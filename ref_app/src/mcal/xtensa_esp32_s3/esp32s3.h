
#ifndef ESP32_S3_H
#define ESP32_S3_H

#ifdef __cplusplus
extern "C" {
#endif

#if 0
/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M3 Specific Interrupt Numbers  ======================================== */
/* ==========================================  ESP32_S3 Specific Interrupt Numbers  ========================================== */
  WIFI_MAC_IRQn             =   0,              /*!< 0  WIFI_MAC                                                               */
  WIFI_NMI_IRQn             =   1,              /*!< 1  WIFI_NMI                                                               */
  WIFI_PWR_IRQn             =   2,              /*!< 2  WIFI_PWR                                                               */
  WIFI_BB_IRQn              =   3,              /*!< 3  WIFI_BB                                                                */
  BT_MAC_IRQn               =   4,              /*!< 4  BT_MAC                                                                 */
  BT_BB_IRQn                =   5,              /*!< 5  BT_BB                                                                  */
  BT_BB_NMI_IRQn            =   6,              /*!< 6  BT_BB_NMI                                                              */
  RWBT_IRQn                 =   7,              /*!< 7  RWBT                                                                   */
  RWBLE_IRQn                =   8,              /*!< 8  RWBLE                                                                  */
  RWBT_NMI_IRQn             =   9,              /*!< 9  RWBT_NMI                                                               */
  RWBLE_NMI_IRQn            =  10,              /*!< 10 RWBLE_NMI                                                              */
  I2C_MASTER_IRQn           =  11,              /*!< 11 I2C_MASTER                                                             */
  SLC0_IRQn                 =  12,              /*!< 12 SLC0                                                                   */
  SLC1_IRQn                 =  13,              /*!< 13 SLC1                                                                   */
  UHCI0_IRQn                =  14,              /*!< 14 UHCI0                                                                  */
  UHCI1_IRQn                =  15,              /*!< 15 UHCI1                                                                  */
  GPIO_IRQn                 =  16,              /*!< 16 GPIO                                                                   */
  GPIO_NMI_IRQn             =  17,              /*!< 17 GPIO_NMI                                                               */
  GPIO_INTR_2_IRQn          =  18,              /*!< 18 GPIO_INTR_2                                                            */
  GPIO_NMI_2_IRQn           =  19,              /*!< 19 GPIO_NMI_2                                                             */
  SPI1_IRQn                 =  20,              /*!< 20 SPI1                                                                   */
  SPI2_IRQn                 =  21,              /*!< 21 SPI2                                                                   */
  SPI3_IRQn                 =  22,              /*!< 22 SPI3                                                                   */
  LCD_CAM_IRQn              =  24,              /*!< 24 LCD_CAM                                                                */
  I2S0_IRQn                 =  25,              /*!< 25 I2S0                                                                   */
  I2S1_IRQn                 =  26,              /*!< 26 I2S1                                                                   */
  UART0_IRQn                =  27,              /*!< 27 UART0                                                                  */
  UART1_IRQn                =  28,              /*!< 28 UART1                                                                  */
  UART2_IRQn                =  29,              /*!< 29 UART2                                                                  */
  SDIO_HOST_IRQn            =  30,              /*!< 30 SDIO_HOST                                                              */
  MCPWM0_IRQn               =  31,              /*!< 31 MCPWM0                                                                 */
  MCPWM1_IRQn               =  32,              /*!< 32 MCPWM1                                                                 */
  LEDC_IRQn                 =  35,              /*!< 35 LEDC                                                                   */
  EFUSE_IRQn                =  36,              /*!< 36 EFUSE                                                                  */
  TWAI0_IRQn                =  37,              /*!< 37 TWAI0                                                                  */
  USB_IRQn                  =  38,              /*!< 38 USB                                                                    */
  RTC_CORE_IRQn             =  39,              /*!< 39 RTC_CORE                                                               */
  RMT_IRQn                  =  40,              /*!< 40 RMT                                                                    */
  PCNT_IRQn                 =  41,              /*!< 41 PCNT                                                                   */
  I2C_EXT0_IRQn             =  42,              /*!< 42 I2C_EXT0                                                               */
  I2C_EXT1_IRQn             =  43,              /*!< 43 I2C_EXT1                                                               */
  SPI2_DMA_IRQn             =  44,              /*!< 44 SPI2_DMA                                                               */
  SPI3_DMA_IRQn             =  45,              /*!< 45 SPI3_DMA                                                               */
  WDT_IRQn                  =  47,              /*!< 47 WDT                                                                    */
  TIMER1_IRQn               =  48,              /*!< 48 TIMER1                                                                 */
  TIMER2_IRQn               =  49,              /*!< 49 TIMER2                                                                 */
  TG0_T0_LEVEL_IRQn         =  50,              /*!< 50 TG0_T0_LEVEL                                                           */
  TG0_T1_LEVEL_IRQn         =  51,              /*!< 51 TG0_T1_LEVEL                                                           */
  TG0_WDT_LEVEL_IRQn        =  52,              /*!< 52 TG0_WDT_LEVEL                                                          */
  TG1_T0_LEVEL_IRQn         =  53,              /*!< 53 TG1_T0_LEVEL                                                           */
  TG1_T1_LEVEL_IRQn         =  54,              /*!< 54 TG1_T1_LEVEL                                                           */
  TG1_WDT_LEVEL_IRQn        =  55,              /*!< 55 TG1_WDT_LEVEL                                                          */
  CACHE_IA_IRQn             =  56,              /*!< 56 CACHE_IA                                                               */
  SYSTIMER_TARGET0_IRQn     =  57,              /*!< 57 SYSTIMER_TARGET0                                                       */
  SYSTIMER_TARGET1_IRQn     =  58,              /*!< 58 SYSTIMER_TARGET1                                                       */
  SYSTIMER_TARGET2_IRQn     =  59,              /*!< 59 SYSTIMER_TARGET2                                                       */
  SPI_MEM_REJECT_CACHE_IRQn =  60,              /*!< 60 SPI_MEM_REJECT_CACHE                                                   */
  DCACHE_PRELOAD0_IRQn      =  61,              /*!< 61 DCACHE_PRELOAD0                                                        */
  ICACHE_PRELOAD0_IRQn      =  62,              /*!< 62 ICACHE_PRELOAD0                                                        */
  DCACHE_SYNC0_IRQn         =  63,              /*!< 63 DCACHE_SYNC0                                                           */
  ICACHE_SYNC0_IRQn         =  64,              /*!< 64 ICACHE_SYNC0                                                           */
  APB_ADC_IRQn              =  65,              /*!< 65 APB_ADC                                                                */
  DMA_IN_CH0_IRQn           =  66,              /*!< 66 DMA_IN_CH0                                                             */
  DMA_IN_CH1_IRQn           =  67,              /*!< 67 DMA_IN_CH1                                                             */
  DMA_IN_CH2_IRQn           =  68,              /*!< 68 DMA_IN_CH2                                                             */
  DMA_IN_CH3_IRQn           =  69,              /*!< 69 DMA_IN_CH3                                                             */
  DMA_IN_CH4_IRQn           =  70,              /*!< 70 DMA_IN_CH4                                                             */
  DMA_OUT_CH0_IRQn          =  71,              /*!< 71 DMA_OUT_CH0                                                            */
  DMA_OUT_CH1_IRQn          =  72,              /*!< 72 DMA_OUT_CH1                                                            */
  DMA_OUT_CH2_IRQn          =  73,              /*!< 73 DMA_OUT_CH2                                                            */
  DMA_OUT_CH3_IRQn          =  74,              /*!< 74 DMA_OUT_CH3                                                            */
  DMA_OUT_CH4_IRQn          =  75,              /*!< 75 DMA_OUT_CH4                                                            */
  RSA_IRQn                  =  76,              /*!< 76 RSA                                                                    */
  SHA_IRQn                  =  77,              /*!< 77 SHA                                                                    */
  FROM_CPU_INTR0_IRQn       =  79,              /*!< 79 FROM_CPU_INTR0                                                         */
  FROM_CPU_INTR1_IRQn       =  80,              /*!< 80 FROM_CPU_INTR1                                                         */
  FROM_CPU_INTR2_IRQn       =  81,              /*!< 81 FROM_CPU_INTR2                                                         */
  FROM_CPU_INTR3_IRQn       =  82,              /*!< 82 FROM_CPU_INTR3                                                         */
  ASSIST_DEBUG_IRQn         =  83,              /*!< 83 ASSIST_DEBUG                                                           */
  DMA_APBPERI_PMS_IRQn      =  84,              /*!< 84 DMA_APBPERI_PMS                                                        */
  CORE0_IRAM0_PMS_IRQn      =  85,              /*!< 85 CORE0_IRAM0_PMS                                                        */
  CORE0_DRAM0_PMS_IRQn      =  86,              /*!< 86 CORE0_DRAM0_PMS                                                        */
  CORE0_PIF_PMS_IRQn        =  87,              /*!< 87 CORE0_PIF_PMS                                                          */
  CORE0_PIF_PMS_SIZE_IRQn   =  88,              /*!< 88 CORE0_PIF_PMS_SIZE                                                     */
  CORE1_IRAM0_PMS_IRQn      =  89,              /*!< 89 CORE1_IRAM0_PMS                                                        */
  CORE1_DRAM0_PMS_IRQn      =  90,              /*!< 90 CORE1_DRAM0_PMS                                                        */
  CORE1_PIF_PMS_IRQn        =  91,              /*!< 91 CORE1_PIF_PMS                                                          */
  CORE1_PIF_PMS_SIZE_IRQn   =  92,              /*!< 92 CORE1_PIF_PMS_SIZE                                                     */
  BACKUP_PMS_VIOLATE_IRQn   =  93,              /*!< 93 BACKUP_PMS_VIOLATE                                                     */
  CACHE_CORE0_ACS_IRQn      =  94,              /*!< 94 CACHE_CORE0_ACS                                                        */
  CACHE_CORE1_ACS_IRQn      =  95,              /*!< 95 CACHE_CORE1_ACS                                                        */
  USB_DEVICE_IRQn           =  96,              /*!< 96 USB_DEVICE                                                             */
  PERI_BACKUP_IRQn          =  97,              /*!< 97 PERI_BACKUP                                                            */
  DMA_EXTMEM_REJECT_IRQn    =  98               /*!< 98 DMA_EXTMEM_REJECT                                                      */
} IRQn_Type;

#endif


#include <stdint.h>

#define     __IM     volatile const
#define     __OM     volatile
#define     __IOM    volatile


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */


/* =========================================================================================================================== */
/* ================                                            AES                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES (Advanced Encryption Standard) Accelerator (AES)
  */

typedef struct {                                /*!< AES Structure                                                             */
  
  union {
    __IOM uint32_t reg[8];                      /*!< AES key register [0..7]                                                   */
    
    struct {
      __IOM uint32_t KEY        : 32;           /*!< Stores AES keys.                                                          */
    } bit[8];
  } KEY;
  
  union {
    __IOM uint32_t reg[4];                      /*!< Source data register [0..3]                                               */
    
    struct {
      __IOM uint32_t TEXT_IN    : 32;           /*!< Stores the source data when the AES accelerator operates in
                                                     the Typical AES working mode.                                             */
    } bit[4];
  } TEXT_IN;
  
  union {
    __IOM uint32_t reg[4];                      /*!< Result data register [0..3]                                               */
    
    struct {
      __IOM uint32_t TEXT_OUT   : 32;           /*!< Stores the result data when the AES accelerator operates in
                                                     the Typical AES working mode.                                             */
    } bit[4];
  } TEXT_OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< AES Mode register                                                         */
    
    struct {
      __IOM uint32_t MODE       : 3;            /*!< Defines the key length and the encryption/decryption of the
                                                     AES accelerator.                                                          */
            uint32_t            : 29;
    } bit;
  } MODE;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< AES trigger register                                                      */
    
    struct {
      __OM  uint32_t TRIGGER    : 1;            /*!< Set this bit to 1 to start AES calculation.                               */
            uint32_t            : 31;
    } bit;
  } TRIGGER;
  
  union {
    __IOM uint32_t reg;                         /*!< AES state register                                                        */
    
    struct {
      __IM  uint32_t STATE      : 2;            /*!< Stores the working status of the AES accelerator. For typical
                                                     AES, 0: idle, 1: busy. For DMA-AES, 0: idle, 1: busy, 2:
                                                     calculation_done.                                                         */
            uint32_t            : 30;
    } bit;
  } STATE;
  __IOM uint32_t  IV_MEM[4];                    /*!< The memory that stores initialization vector                              */
  __IOM uint32_t  H_MEM[4];                     /*!< The memory that stores GCM hash subkey                                    */
  __IOM uint32_t  J0_MEM[4];                    /*!< The memory that stores J0                                                 */
  __IOM uint32_t  T0_MEM[4];                    /*!< The memory that stores T0                                                 */
  
  union {
    __IOM uint32_t reg;                         /*!< AES accelerator working mode register                                     */
    
    struct {
      __IOM uint32_t DMA_ENABLE : 1;            /*!< Defines the working mode of the AES accelerator. 1'b0: typical
                                                     AES working mode, 1'b1: DMA-AES working mode.                             */
            uint32_t            : 31;
    } bit;
  } DMA_ENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< AES cipher block mode register                                            */
    
    struct {
      __IOM uint32_t BLOCK_MODE : 3;            /*!< Defines the block cipher mode of the AES accelerator operating
                                                     under the DMA-AES working mode. 0x0: ECB, 0x1: CBC, 0x2:
                                                     OFB, 0x3: CTR, 0x4: CFB-8, 0x5: CFB-128, 0x6: reserved,
                                                     0x7: reserved.                                                            */
            uint32_t            : 29;
    } bit;
  } BLOCK_MODE;
  
  union {
    __IOM uint32_t reg;                         /*!< AES block number register                                                 */
    
    struct {
      __IOM uint32_t BLOCK_NUM  : 32;           /*!< Stores the Block Number of plaintext or ciphertext when the
                                                     AES accelerator operates under the DMA-AES working mode.                  */
    } bit;
  } BLOCK_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< Standard incrementing function configure register                         */
    
    struct {
      __IOM uint32_t INC_SEL    : 1;            /*!< Defines the Standard Incrementing Function for CTR block operation.
                                                     Set this bit to 0 or 1 to choose INC32 or INC128.                         */
            uint32_t            : 31;
    } bit;
  } INC_SEL;
  
  union {
    __IOM uint32_t reg;                         /*!< Additional Authential Data block number register                          */
    
    struct {
      __IOM uint32_t AAD_BLOCK_NUM : 32;        /*!< Those bits stores the number of AAD block.                                */
    } bit;
  } AAD_BLOCK_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< AES remainder bit number register                                         */
    
    struct {
      __IOM uint32_t REMAINDER_BIT_NUM : 7;     /*!< Those bits stores the number of remainder bit.                            */
            uint32_t            : 25;
    } bit;
  } REMAINDER_BIT_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< AES continue register                                                     */
    
    struct {
      __OM  uint32_t CONTINUE   : 1;            /*!< Set this bit to 1 to continue GCM operation.                              */
            uint32_t            : 31;
    } bit;
  } CONTINUE;
  
  union {
    __IOM uint32_t reg;                         /*!< AES Interrupt clear register                                              */
    
    struct {
      __OM  uint32_t INT_CLEAR  : 1;            /*!< Set this bit to 1 to clear AES interrupt.                                 */
            uint32_t            : 31;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA-AES Interrupt enable register                                         */
    
    struct {
      __IOM uint32_t INT_ENA    : 1;            /*!< Set this bit to 1 to enable AES interrupt and 0 to disable interrupt.
                                                     This field is only effective for DMA-AES operation.                       */
            uint32_t            : 31;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< AES version control register                                              */
    
    struct {
      __IOM uint32_t DATE       : 30;           /*!< This bits stores the version information of AES.                          */
            uint32_t            : 2;
    } bit;
  } DATE;
  
  union {
    __IOM uint32_t reg;                         /*!< AES-DMA exit config                                                       */
    
    struct {
      __OM  uint32_t DMA_EXIT   : 1;            /*!< Set this bit to 1 to exit AES operation. This field is only
                                                     effective for DMA-AES operation.                                          */
            uint32_t            : 31;
    } bit;
  } DMA_EXIT;
} AES_Type;                                     /*!< Size = 188 (0xbc)                                                         */



/* =========================================================================================================================== */
/* ================                                         APB_CTRL                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief APB (Advanced Peripheral Bus) Controller (APB_CTRL)
  */

typedef struct {                                /*!< APB_CTRL Structure                                                        */
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t PRE_DIV_CNT : 10;          /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK_320M_EN : 1;           /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK_EN     : 1;            /*!< ******* Description ***********                                           */
      __IOM uint32_t RST_TICK_CNT : 1;          /*!< ******* Description ***********                                           */
            uint32_t            : 19;
    } bit;
  } SYSCLK_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t XTAL_TICK_NUM : 8;         /*!< ******* Description ***********                                           */
      __IOM uint32_t CK8M_TICK_NUM : 8;         /*!< ******* Description ***********                                           */
      __IOM uint32_t TICK_ENABLE : 1;           /*!< ******* Description ***********                                           */
            uint32_t            : 15;
    } bit;
  } TICK_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CLK20_OEN  : 1;            /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK22_OEN  : 1;            /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK44_OEN  : 1;            /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK_BB_OEN : 1;            /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK80_OEN  : 1;            /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK160_OEN : 1;            /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK_320M_OEN : 1;          /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK_ADC_INF_OEN : 1;       /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK_DAC_CPU_OEN : 1;       /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK40X_BB_OEN : 1;         /*!< ******* Description ***********                                           */
      __IOM uint32_t CLK_XTAL_OEN : 1;          /*!< ******* Description ***********                                           */
            uint32_t            : 21;
    } bit;
  } CLK_OUT_EN;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t WIFI_BB_CFG : 32;          /*!< ******* Description ***********                                           */
    } bit;
  } WIFI_BB_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t WIFI_BB_CFG_2 : 32;        /*!< ******* Description ***********                                           */
    } bit;
  } WIFI_BB_CFG_2;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t WIFI_CLK_EN : 32;          /*!< ******* Description ***********                                           */
    } bit;
  } WIFI_CLK_EN;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t WIFI_RST   : 32;           /*!< ******* Description ***********                                           */
    } bit;
  } WIFI_RST_EN;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t PERI_IO_SWAP : 8;          /*!< ******* Description ***********                                           */
            uint32_t            : 24;
    } bit;
  } HOST_INF_SEL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t EXT_MEM_PMS_LOCK : 1;      /*!< ******* Description ***********                                           */
            uint32_t            : 31;
    } bit;
  } EXT_MEM_PMS_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t WRITEBACK_BYPASS : 1;      /*!< Set 1 to bypass cache writeback request to external memory so
                                                     that spi will not check its attribute.                                    */
            uint32_t            : 31;
    } bit;
  } EXT_MEM_WRITEBACK_BYPASS;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t FLASH_ACE0_ATTR : 9;       /*!< ******* Description ***********                                           */
            uint32_t            : 23;
    } bit;
  } FLASH_ACE0_ATTR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t FLASH_ACE1_ATTR : 9;       /*!< ******* Description ***********                                           */
            uint32_t            : 23;
    } bit;
  } FLASH_ACE1_ATTR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t FLASH_ACE2_ATTR : 9;       /*!< ******* Description ***********                                           */
            uint32_t            : 23;
    } bit;
  } FLASH_ACE2_ATTR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t FLASH_ACE3_ATTR : 9;       /*!< ******* Description ***********                                           */
            uint32_t            : 23;
    } bit;
  } FLASH_ACE3_ATTR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t S          : 32;           /*!< ******* Description ***********                                           */
    } bit;
  } FLASH_ACE0_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t S          : 32;           /*!< ******* Description ***********                                           */
    } bit;
  } FLASH_ACE1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t S          : 32;           /*!< ******* Description ***********                                           */
    } bit;
  } FLASH_ACE2_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t S          : 32;           /*!< ******* Description ***********                                           */
    } bit;
  } FLASH_ACE3_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t FLASH_ACE0_SIZE : 16;      /*!< ******* Description ***********                                           */
            uint32_t            : 16;
    } bit;
  } FLASH_ACE0_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t FLASH_ACE1_SIZE : 16;      /*!< ******* Description ***********                                           */
            uint32_t            : 16;
    } bit;
  } FLASH_ACE1_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t FLASH_ACE2_SIZE : 16;      /*!< ******* Description ***********                                           */
            uint32_t            : 16;
    } bit;
  } FLASH_ACE2_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t FLASH_ACE3_SIZE : 16;      /*!< ******* Description ***********                                           */
            uint32_t            : 16;
    } bit;
  } FLASH_ACE3_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t SRAM_ACE0_ATTR : 9;        /*!< ******* Description ***********                                           */
            uint32_t            : 23;
    } bit;
  } SRAM_ACE0_ATTR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t SRAM_ACE1_ATTR : 9;        /*!< ******* Description ***********                                           */
            uint32_t            : 23;
    } bit;
  } SRAM_ACE1_ATTR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t SRAM_ACE2_ATTR : 9;        /*!< ******* Description ***********                                           */
            uint32_t            : 23;
    } bit;
  } SRAM_ACE2_ATTR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t SRAM_ACE3_ATTR : 9;        /*!< ******* Description ***********                                           */
            uint32_t            : 23;
    } bit;
  } SRAM_ACE3_ATTR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t S          : 32;           /*!< ******* Description ***********                                           */
    } bit;
  } SRAM_ACE0_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t S          : 32;           /*!< ******* Description ***********                                           */
    } bit;
  } SRAM_ACE1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t S          : 32;           /*!< ******* Description ***********                                           */
    } bit;
  } SRAM_ACE2_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t S          : 32;           /*!< ******* Description ***********                                           */
    } bit;
  } SRAM_ACE3_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t SRAM_ACE0_SIZE : 16;       /*!< ******* Description ***********                                           */
            uint32_t            : 16;
    } bit;
  } SRAM_ACE0_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t SRAM_ACE1_SIZE : 16;       /*!< ******* Description ***********                                           */
            uint32_t            : 16;
    } bit;
  } SRAM_ACE1_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t SRAM_ACE2_SIZE : 16;       /*!< ******* Description ***********                                           */
            uint32_t            : 16;
    } bit;
  } SRAM_ACE2_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t SRAM_ACE3_SIZE : 16;       /*!< ******* Description ***********                                           */
            uint32_t            : 16;
    } bit;
  } SRAM_ACE3_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t SPI_MEM_REJECT_INT : 1;    /*!< ******* Description ***********                                           */
      __OM  uint32_t SPI_MEM_REJECT_CLR : 1;    /*!< ******* Description ***********                                           */
      __IM  uint32_t SPI_MEM_REJECT_CDE : 5;    /*!< ******* Description ***********                                           */
            uint32_t            : 25;
    } bit;
  } SPI_MEM_PMS_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t SPI_MEM_REJECT_ADDR : 32;  /*!< ******* Description ***********                                           */
    } bit;
  } SPI_MEM_REJECT_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t SDIO_WIN_ACCESS_EN : 1;    /*!< ******* Description ***********                                           */
            uint32_t            : 31;
    } bit;
  } SDIO_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t REDCY_SIG0 : 31;           /*!< ******* Description ***********                                           */
      __IM  uint32_t REDCY_ANDOR : 1;           /*!< ******* Description ***********                                           */
    } bit;
  } REDCY_SIG0;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t REDCY_SIG1 : 31;           /*!< ******* Description ***********                                           */
      __IM  uint32_t REDCY_NANDOR : 1;          /*!< ******* Description ***********                                           */
    } bit;
  } REDCY_SIG1;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t AGC_MEM_FORCE_PU : 1;      /*!< ******* Description ***********                                           */
      __IOM uint32_t AGC_MEM_FORCE_PD : 1;      /*!< ******* Description ***********                                           */
      __IOM uint32_t PBUS_MEM_FORCE_PU : 1;     /*!< ******* Description ***********                                           */
      __IOM uint32_t PBUS_MEM_FORCE_PD : 1;     /*!< ******* Description ***********                                           */
      __IOM uint32_t DC_MEM_FORCE_PU : 1;       /*!< ******* Description ***********                                           */
      __IOM uint32_t DC_MEM_FORCE_PD : 1;       /*!< ******* Description ***********                                           */
      __IOM uint32_t FREQ_MEM_FORCE_PU : 1;     /*!< ******* Description ***********                                           */
      __IOM uint32_t FREQ_MEM_FORCE_PD : 1;     /*!< ******* Description ***********                                           */
            uint32_t            : 24;
    } bit;
  } FRONT_END_MEM_PD;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
            uint32_t            : 18;
      __IOM uint32_t FLASH_PAGE_SIZE : 2;       /*!< Set the page size of the used MSPI flash. 0: 256 bytes. 1: 512
                                                     bytes. 2: 1024 bytes. 3: 2048 bytes.                                      */
      __IOM uint32_t SRAM_PAGE_SIZE : 2;        /*!< Set the page size of the used MSPI external RAM. 0: 256 bytes.
                                                     1: 512 bytes. 2: 1024 bytes. 3: 2048 bytes.                               */
            uint32_t            : 10;
    } bit;
  } SPI_MEM_ECC_CTRL;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ROM_CLKGATE_FORCE_ON : 3;  /*!< ******* Description ***********                                           */
      __IOM uint32_t SRAM_CLKGATE_FORCE_ON : 11;/*!< ******* Description ***********                                           */
            uint32_t            : 18;
    } bit;
  } CLKGATE_FORCE_ON;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ROM_POWER_DOWN : 3;        /*!< ******* Description ***********                                           */
      __IOM uint32_t SRAM_POWER_DOWN : 11;      /*!< ******* Description ***********                                           */
            uint32_t            : 18;
    } bit;
  } MEM_POWER_DOWN;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ROM_POWER_UP : 3;          /*!< ******* Description ***********                                           */
      __IOM uint32_t SRAM_POWER_UP : 11;        /*!< ******* Description ***********                                           */
            uint32_t            : 18;
    } bit;
  } MEM_POWER_UP;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t RETENTION_CPU_LINK_ADDR : 27;/*!< ******* Description ***********                                         */
      __IOM uint32_t NOBYPASS_CPU_ISO_RST : 1;  /*!< ******* Description ***********                                           */
            uint32_t            : 4;
    } bit;
  } RETENTION_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t RETENTION_TAG_LINK_ADDR : 27;/*!< ******* Description ***********                                         */
            uint32_t            : 5;
    } bit;
  } RETENTION_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t RET_ICACHE_SIZE : 8;       /*!< ******* Description ***********                                           */
            uint32_t            : 1;
      __IOM uint32_t RET_ICACHE_VLD_SIZE : 8;   /*!< ******* Description ***********                                           */
            uint32_t            : 1;
      __IOM uint32_t RET_ICACHE_START_POINT : 8;/*!< ******* Description ***********                                           */
            uint32_t            : 1;
      __IOM uint32_t RET_ICACHE_ENABLE : 1;     /*!< ******* Description ***********                                           */
    } bit;
  } RETENTION_CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t RET_DCACHE_SIZE : 9;       /*!< ******* Description ***********                                           */
      __IOM uint32_t RET_DCACHE_VLD_SIZE : 9;   /*!< ******* Description ***********                                           */
      __IOM uint32_t RET_DCACHE_START_POINT : 9;/*!< ******* Description ***********                                           */
      __IOM uint32_t RET_DCACHE_ENABLE : 1;     /*!< ******* Description ***********                                           */
    } bit;
  } RETENTION_CTRL3;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t RETENTION_INV_CFG : 32;    /*!< ******* Description ***********                                           */
    } bit;
  } RETENTION_CTRL4;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t RETENTION_DISABLE : 1;     /*!< ******* Description ***********                                           */
            uint32_t            : 31;
    } bit;
  } RETENTION_CTRL5;
  __IM  uint32_t  RESERVED1[204];
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DATE       : 32;           /*!< Version control                                                           */
    } bit;
  } DATE;
} APB_CTRL_Type;                                /*!< Size = 1024 (0x400)                                                       */



/* =========================================================================================================================== */
/* ================                                        APB_SARADC                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief SAR (Successive Approximation Register) Analog-to-Digital Converter (APB_SARADC)
  */

typedef struct {                                /*!< APB_SARADC Structure                                                      */
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc controller                                           */
    
    struct {
      __IOM uint32_t SARADC_START_FORCE : 1;    /*!< enable start saradc by sw                                                 */
      __IOM uint32_t SARADC_START : 1;          /*!< start saradc by sw                                                        */
            uint32_t            : 1;
      __IOM uint32_t SARADC_WORK_MODE : 2;      /*!< 0: single mode, 1: double mode, 2: alternate mode                         */
      __IOM uint32_t SARADC_SAR_SEL : 1;        /*!< 0: SAR1, 1: SAR2, only work for single SAR mode                           */
      __IOM uint32_t SARADC_SAR_CLK_GATED : 1;  /*!< enable SAR CLK gate when saradc idle                                      */
      __IOM uint32_t SARADC_SAR_CLK_DIV : 8;    /*!< SAR clock divider                                                         */
      __IOM uint32_t SARADC_SAR1_PATT_LEN : 4;  /*!< 0 ~ 15 means length 1 ~ 16                                                */
      __IOM uint32_t SARADC_SAR2_PATT_LEN : 4;  /*!< 0 ~ 15 means length 1 ~ 16                                                */
      __IOM uint32_t SARADC_SAR1_PATT_P_CLEAR : 1;/*!< clear the pointer of pattern table for DIG ADC1 CTRL                    */
      __IOM uint32_t SARADC_SAR2_PATT_P_CLEAR : 1;/*!< clear the pointer of pattern table for DIG ADC2 CTRL                    */
      __IOM uint32_t SARADC_DATA_SAR_SEL : 1;   /*!< 1: sar_sel will be coded by the MSB of the 16-bit output data,
                                                     in this case the resolution should not be larger than 11
                                                     bits.                                                                     */
      __IOM uint32_t SARADC_DATA_TO_I2S : 1;    /*!< 1: I2S input data is from SAR ADC (for DMA), 0: I2S input data
                                                     is from GPIO matrix                                                       */
      __IOM uint32_t SARADC_XPD_SAR_FORCE : 2;  /*!< force option to xpd sar blocks                                            */
            uint32_t            : 1;
      __IOM uint32_t SARADC_WAIT_ARB_CYCLE : 2; /*!< wait arbit signal stable after sar_done                                   */
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc controller                                           */
    
    struct {
      __IOM uint32_t SARADC_MEAS_NUM_LIMIT : 1; /*!< enable apb saradc limit the sample num                                    */
      __IOM uint32_t SARADC_MAX_MEAS_NUM : 8;   /*!< max conversion number                                                     */
      __IOM uint32_t SARADC_SAR1_INV : 1;       /*!< 1: data to DIG ADC1 CTRL is inverted, otherwise not                       */
      __IOM uint32_t SARADC_SAR2_INV : 1;       /*!< 1: data to DIG ADC2 CTRL is inverted, otherwise not                       */
      __IOM uint32_t SARADC_TIMER_SEL : 1;      /*!< 1: select saradc timer 0: i2s_ws trigger                                  */
      __IOM uint32_t SARADC_TIMER_TARGET : 12;  /*!< to set saradc timer target                                                */
      __IOM uint32_t SARADC_TIMER_EN : 1;       /*!< to enable saradc timer trigger                                            */
            uint32_t            : 7;
    } bit;
  } CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc filter                                                   */
    
    struct {
            uint32_t            : 26;
      __IOM uint32_t FILTER_FACTOR1 : 3;        /*!< apb saradc factor1                                                        */
      __IOM uint32_t FILTER_FACTOR0 : 3;        /*!< apb saradc factor0                                                        */
    } bit;
  } FILTER_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc fsm                                                  */
    
    struct {
      __IOM uint32_t SARADC_XPD_WAIT : 8;       /*!< the cycle which saradc controller in xpd state                            */
      __IOM uint32_t SARADC_RSTB_WAIT : 8;      /*!< the cycle which saradc controller in rst state                            */
      __IOM uint32_t SARADC_STANDBY_WAIT : 8;   /*!< the cycle which saradc controller in standby state                        */
            uint32_t            : 8;
    } bit;
  } FSM_WAIT;
  
  union {
    __IOM uint32_t reg;                         /*!< saradc1 status for debug                                                  */
    
    struct {
      __IM  uint32_t SARADC_SAR1_STATUS : 32;   /*!< saradc1 status                                                            */
    } bit;
  } SAR1_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< saradc2 status for debug                                                  */
    
    struct {
      __IM  uint32_t SARADC_SAR2_STATUS : 32;   /*!< saradc2 status                                                            */
    } bit;
  } SAR2_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc pattern table                                        */
    
    struct {
      __IOM uint32_t SARADC_SAR1_PATT_TAB1 : 24;/*!< item 0 ~ 3 for pattern table 1 (each item 6bit)                           */
            uint32_t            : 8;
    } bit;
  } SAR1_PATT_TAB1;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc pattern table                                        */
    
    struct {
      __IOM uint32_t SARADC_SAR1_PATT_TAB2 : 24;/*!< Item 4 ~ 7 for pattern table 1 (each item 6bit)                           */
            uint32_t            : 8;
    } bit;
  } SAR1_PATT_TAB2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc pattern table                                        */
    
    struct {
      __IOM uint32_t SARADC_SAR1_PATT_TAB3 : 24;/*!< Item 8 ~ 11 for pattern table 1 (each item 6bit)                          */
            uint32_t            : 8;
    } bit;
  } SAR1_PATT_TAB3;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc pattern table                                        */
    
    struct {
      __IOM uint32_t SARADC_SAR1_PATT_TAB4 : 24;/*!< Item 12 ~ 15 for pattern table 1 (each item 6bit)                         */
            uint32_t            : 8;
    } bit;
  } SAR1_PATT_TAB4;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc pattern table                                        */
    
    struct {
      __IOM uint32_t SARADC_SAR2_PATT_TAB1 : 24;/*!< item 0 ~ 3 for pattern table 2 (each item 6bit)                           */
            uint32_t            : 8;
    } bit;
  } SAR2_PATT_TAB1;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc pattern table                                        */
    
    struct {
      __IOM uint32_t SARADC_SAR2_PATT_TAB2 : 24;/*!< Item 4 ~ 7 for pattern table 2 (each item 6bit)                           */
            uint32_t            : 8;
    } bit;
  } SAR2_PATT_TAB2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc pattern table                                        */
    
    struct {
      __IOM uint32_t SARADC_SAR2_PATT_TAB3 : 24;/*!< Item 8 ~ 11 for pattern table 2 (each item 6bit)                          */
            uint32_t            : 8;
    } bit;
  } SAR2_PATT_TAB3;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc pattern table                                        */
    
    struct {
      __IOM uint32_t SARADC_SAR2_PATT_TAB4 : 24;/*!< Item 12 ~ 15 for pattern table 2 (each item 6bit)                         */
            uint32_t            : 8;
    } bit;
  } SAR2_PATT_TAB4;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc arbit                                                */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t ADC_ARB_APB_FORCE : 1;     /*!< adc2 arbiter force to enableapb controller                                */
      __IOM uint32_t ADC_ARB_RTC_FORCE : 1;     /*!< adc2 arbiter force to enable rtc controller                               */
      __IOM uint32_t ADC_ARB_WIFI_FORCE : 1;    /*!< adc2 arbiter force to enable wifi controller                              */
      __IOM uint32_t ADC_ARB_GRANT_FORCE : 1;   /*!< adc2 arbiter force grant                                                  */
      __IOM uint32_t ADC_ARB_APB_PRIORITY : 2;  /*!< Set adc2 arbiterapb priority                                              */
      __IOM uint32_t ADC_ARB_RTC_PRIORITY : 2;  /*!< Set adc2 arbiter rtc priority                                             */
      __IOM uint32_t ADC_ARB_WIFI_PRIORITY : 2; /*!< Set adc2 arbiter wifi priority                                            */
      __IOM uint32_t ADC_ARB_FIX_PRIORITY : 1;  /*!< adc2 arbiter uses fixed priority                                          */
            uint32_t            : 19;
    } bit;
  } ARB_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc arbit                                                */
    
    struct {
            uint32_t            : 14;
      __IOM uint32_t FILTER_CHANNEL1 : 5;       /*!< configure the filter1 channel                                             */
      __IOM uint32_t FILTER_CHANNEL0 : 5;       /*!< configure the filter0 channel                                             */
            uint32_t            : 7;
      __IOM uint32_t FILTER_RESET : 1;          /*!< enable apb_adc1_filter                                                    */
    } bit;
  } FILTER_CTRL0;
  
  union {
    __IOM uint32_t reg;                         /*!< get apb saradc sample data                                                */
    
    struct {
      __IM  uint32_t APB_SARADC1_DATA : 17;     /*!< apbsaradc sample data                                                     */
            uint32_t            : 15;
    } bit;
  } APB_SARADC1_DATA_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc thres monitor                                        */
    
    struct {
      __IOM uint32_t THRES0_CHANNEL : 5;        /*!< configure which channel thres0 monitor                                    */
      __IOM uint32_t THRES0_HIGH : 13;          /*!< thres0 monitor high thres                                                 */
      __IOM uint32_t THRES0_LOW : 13;           /*!< thres0 monitor low thres                                                  */
            uint32_t            : 1;
    } bit;
  } THRES0_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc thres monitor                                        */
    
    struct {
      __IOM uint32_t THRES1_CHANNEL : 5;        /*!< configure which channel thres0 monitor                                    */
      __IOM uint32_t THRES1_HIGH : 13;          /*!< thres1 monitor high thres                                                 */
      __IOM uint32_t THRES1_LOW : 13;           /*!< thres1 monitor low thres                                                  */
            uint32_t            : 1;
    } bit;
  } THRES1_CTRL;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure thres monitor enable                                            */
    
    struct {
            uint32_t            : 27;
      __IOM uint32_t THRES_ALL_EN : 1;          /*!< enable thres0 to monitor all channel                                      */
      __IOM uint32_t THRES3_EN  : 1;            /*!< no public                                                                 */
      __IOM uint32_t THRES2_EN  : 1;            /*!< no public                                                                 */
      __IOM uint32_t THRES1_EN  : 1;            /*!< enable thres1                                                             */
      __IOM uint32_t THRES0_EN  : 1;            /*!< enable thres0                                                             */
    } bit;
  } THRES_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< enable interrupt                                                          */
    
    struct {
            uint32_t            : 26;
      __IOM uint32_t THRES1_LOW_INT_ENA : 1;    /*!< interrupt of thres1 low                                                   */
      __IOM uint32_t THRES0_LOW_INT_ENA : 1;    /*!< interrupt of thres0 low                                                   */
      __IOM uint32_t THRES1_HIGH_INT_ENA : 1;   /*!< interrupt of thres1 high                                                  */
      __IOM uint32_t THRES0_HIGH_INT_ENA : 1;   /*!< interrupt of thres0 high                                                  */
      __IOM uint32_t APB_SARADC2_DONE_INT_ENA : 1;/*!< interrupt of sar2 done                                                  */
      __IOM uint32_t APB_SARADC1_DONE_INT_ENA : 1;/*!< interrupt of sar1 done                                                  */
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< raw of interrupt                                                          */
    
    struct {
            uint32_t            : 26;
      __IM  uint32_t THRES1_LOW_INT_RAW : 1;    /*!< interrupt of thres1 low                                                   */
      __IM  uint32_t THRES0_LOW_INT_RAW : 1;    /*!< interrupt of thres0 low                                                   */
      __IM  uint32_t THRES1_HIGH_INT_RAW : 1;   /*!< interrupt of thres1 high                                                  */
      __IM  uint32_t THRES0_HIGH_INT_RAW : 1;   /*!< interrupt of thres0 high                                                  */
      __IM  uint32_t APB_SARADC2_DONE_INT_RAW : 1;/*!< interrupt of sar2 done                                                  */
      __IM  uint32_t APB_SARADC1_DONE_INT_RAW : 1;/*!< interrupt of sar1 done                                                  */
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< state of interrupt                                                        */
    
    struct {
            uint32_t            : 26;
      __IM  uint32_t THRES1_LOW_INT_ST : 1;     /*!< interrupt of thres1 low                                                   */
      __IM  uint32_t THRES0_LOW_INT_ST : 1;     /*!< interrupt of thres0 low                                                   */
      __IM  uint32_t THRES1_HIGH_INT_ST : 1;    /*!< interrupt of thres1 high                                                  */
      __IM  uint32_t THRES0_HIGH_INT_ST : 1;    /*!< interrupt of thres0 high                                                  */
      __IM  uint32_t APB_SARADC2_DONE_INT_ST : 1;/*!< interrupt of sar2 done                                                   */
      __IM  uint32_t APB_SARADC1_DONE_INT_ST : 1;/*!< interrupt of sar1 done                                                   */
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< clear interrupt                                                           */
    
    struct {
            uint32_t            : 26;
      __OM  uint32_t THRES1_LOW_INT_CLR : 1;    /*!< interrupt of thres1 low                                                   */
      __OM  uint32_t THRES0_LOW_INT_CLR : 1;    /*!< interrupt of thres0 low                                                   */
      __OM  uint32_t THRES1_HIGH_INT_CLR : 1;   /*!< interrupt of thres1 high                                                  */
      __OM  uint32_t THRES0_HIGH_INT_CLR : 1;   /*!< interrupt of thres0 high                                                  */
      __OM  uint32_t APB_SARADC2_DONE_INT_CLR : 1;/*!< interrupt of sar2 done                                                  */
      __OM  uint32_t APB_SARADC1_DONE_INT_CLR : 1;/*!< interrupt of sar1 done                                                  */
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc dma                                                  */
    
    struct {
      __IOM uint32_t APB_ADC_EOF_NUM : 16;      /*!< the dma_in_suc_eof gen when sample cnt = spi_eof_num                      */
            uint32_t            : 14;
      __IOM uint32_t APB_ADC_RESET_FSM : 1;     /*!< reset_apb_adc_state                                                       */
      __IOM uint32_t APB_ADC_TRANS : 1;         /*!< enable apb_adc use spi_dma                                                */
    } bit;
  } DMA_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< configure apb saradc clock                                                */
    
    struct {
      __IOM uint32_t CLKM_DIV_NUM : 8;          /*!< Integral clock divider value                                              */
      __IOM uint32_t CLKM_DIV_B : 6;            /*!< Fractional clock divider numerator value                                  */
      __IOM uint32_t CLKM_DIV_A : 6;            /*!< Fractional clock divider denominator value                                */
      __IOM uint32_t CLK_EN     : 1;            /*!< no public                                                                 */
      __IOM uint32_t CLK_SEL    : 2;            /*!< Set this bit to enable clk_apll                                           */
            uint32_t            : 9;
    } bit;
  } CLKM_CONF;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< get apb saradc2 sample data                                               */
    
    struct {
      __IM  uint32_t APB_SARADC2_DATA : 17;     /*!< apb saradc2 sample data                                                   */
            uint32_t            : 15;
    } bit;
  } APB_SARADC2_DATA_STATUS;
  __IM  uint32_t  RESERVED2[224];
  
  union {
    __IOM uint32_t reg;                         /*!< version                                                                   */
    
    struct {
      __IOM uint32_t APB_CTRL_DATE : 32;        /*!< version                                                                   */
    } bit;
  } APB_CTRL_DATE;
} APB_SARADC_Type;                              /*!< Size = 1024 (0x400)                                                       */



/* =========================================================================================================================== */
/* ================                                            BB                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief BB Peripheral (BB)
  */

typedef struct {                                /*!< BB Structure                                                              */
  __IM  uint32_t  RESERVED[21];
  
  union {
    __IOM uint32_t reg;                         /*!< Baseband control register                                                 */
    
    struct {
      __IOM uint32_t DC_EST_FORCE_PD : 1;       /*!< DC_EST_FORCE_PD                                                           */
      __IOM uint32_t DC_EST_FORCE_PU : 1;       /*!< DC_EST_FORCE_PU                                                           */
      __IOM uint32_t FFT_FORCE_PD : 1;          /*!< FFT_FORCE_PD                                                              */
      __IOM uint32_t FFT_FORCE_PU : 1;          /*!< FFT_FORCE_PU                                                              */
            uint32_t            : 28;
    } bit;
  } BBPD_CTRL;
} BB_Type;                                      /*!< Size = 88 (0x58)                                                          */



/* =========================================================================================================================== */
/* ================                                       ASSIST_DEBUG                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Debug Assist (ASSIST_DEBUG)
  */

typedef struct {                                /*!< ASSIST_DEBUG Structure                                                    */
  
  union {
    __IOM uint32_t reg;                         /*!< core0 monitor enable configuration register                               */
    
    struct {
      __IOM uint32_t CORE_0_AREA_DRAM0_0_RD_ENA : 1;/*!< Core0 dram0 area0 read monitor enable                                 */
      __IOM uint32_t CORE_0_AREA_DRAM0_0_WR_ENA : 1;/*!< Core0 dram0 area0 write monitor enable                                */
      __IOM uint32_t CORE_0_AREA_DRAM0_1_RD_ENA : 1;/*!< Core0 dram0 area1 read monitor enable                                 */
      __IOM uint32_t CORE_0_AREA_DRAM0_1_WR_ENA : 1;/*!< Core0 dram0 area1 write monitor enable                                */
      __IOM uint32_t CORE_0_AREA_PIF_0_RD_ENA : 1;/*!< Core0 PIF area0 read monitor enable                                     */
      __IOM uint32_t CORE_0_AREA_PIF_0_WR_ENA : 1;/*!< Core0 PIF area0 write monitor enable                                    */
      __IOM uint32_t CORE_0_AREA_PIF_1_RD_ENA : 1;/*!< Core0 PIF area1 read monitor enable                                     */
      __IOM uint32_t CORE_0_AREA_PIF_1_WR_ENA : 1;/*!< Core0 PIF area1 write monitor enable                                    */
      __IOM uint32_t CORE_0_SP_SPILL_MIN_ENA : 1;/*!< Core0 stackpoint overflow monitor enable                                 */
      __IOM uint32_t CORE_0_SP_SPILL_MAX_ENA : 1;/*!< Core0 stackpoint underflow monitor enable                                */
      __IOM uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_ENA : 1;/*!< IBUS busy monitor enable                                      */
      __IOM uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_ENA : 1;/*!< DBUS busy monitor enbale                                      */
            uint32_t            : 20;
    } bit;
  } CORE_0_MONTR_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 monitor interrupt status register                                   */
    
    struct {
      __IM  uint32_t CORE_0_AREA_DRAM0_0_RD_RAW : 1;/*!< Core0 dram0 area0 read monitor interrupt status                       */
      __IM  uint32_t CORE_0_AREA_DRAM0_0_WR_RAW : 1;/*!< Core0 dram0 area0 write monitor interrupt status                      */
      __IM  uint32_t CORE_0_AREA_DRAM0_1_RD_RAW : 1;/*!< Core0 dram0 area1 read monitor interrupt status                       */
      __IM  uint32_t CORE_0_AREA_DRAM0_1_WR_RAW : 1;/*!< Core0 dram0 area1 write monitor interrupt status                      */
      __IM  uint32_t CORE_0_AREA_PIF_0_RD_RAW : 1;/*!< Core0 PIF area0 read monitor interrupt status                           */
      __IM  uint32_t CORE_0_AREA_PIF_0_WR_RAW : 1;/*!< Core0 PIF area0 write monitor interrupt status                          */
      __IM  uint32_t CORE_0_AREA_PIF_1_RD_RAW : 1;/*!< Core0 PIF area1 read monitor interrupt status                           */
      __IM  uint32_t CORE_0_AREA_PIF_1_WR_RAW : 1;/*!< Core0 PIF area1 write monitor interrupt status                          */
      __IM  uint32_t CORE_0_SP_SPILL_MIN_RAW : 1;/*!< Core0 stackpoint overflow monitor interrupt status                       */
      __IM  uint32_t CORE_0_SP_SPILL_MAX_RAW : 1;/*!< Core0 stackpoint underflow monitor interrupt status                      */
      __IM  uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_RAW : 1;/*!< IBUS busy monitor interrupt status                            */
      __IM  uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_RAW : 1;/*!< DBUS busy monitor initerrupt status                           */
            uint32_t            : 20;
    } bit;
  } CORE_0_INTR_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 monitor interrupt enable register                                   */
    
    struct {
      __IOM uint32_t CORE_0_AREA_DRAM0_0_RD_INTR_ENA : 1;/*!< Core0 dram0 area0 read monitor interrupt enable                  */
      __IOM uint32_t CORE_0_AREA_DRAM0_0_WR_INTR_ENA : 1;/*!< Core0 dram0 area0 write monitor interrupt enable                 */
      __IOM uint32_t CORE_0_AREA_DRAM0_1_RD_INTR_ENA : 1;/*!< Core0 dram0 area1 read monitor interrupt enable                  */
      __IOM uint32_t CORE_0_AREA_DRAM0_1_WR_INTR_ENA : 1;/*!< Core0 dram0 area1 write monitor interrupt enable                 */
      __IOM uint32_t CORE_0_AREA_PIF_0_RD_INTR_ENA : 1;/*!< Core0 PIF area0 read monitor interrupt enable                      */
      __IOM uint32_t CORE_0_AREA_PIF_0_WR_INTR_ENA : 1;/*!< Core0 PIF area0 write monitor interrupt enable                     */
      __IOM uint32_t CORE_0_AREA_PIF_1_RD_INTR_ENA : 1;/*!< Core0 PIF area1 read monitor interrupt enable                      */
      __IOM uint32_t CORE_0_AREA_PIF_1_WR_INTR_ENA : 1;/*!< Core0 PIF area1 write monitor interrupt enable                     */
      __IOM uint32_t CORE_0_SP_SPILL_MIN_INTR_ENA : 1;/*!< Core0 stackpoint overflow monitor interrupt enable                  */
      __IOM uint32_t CORE_0_SP_SPILL_MAX_INTR_ENA : 1;/*!< Core0 stackpoint underflow monitor interrupt enable                 */
      __IOM uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_INTR_ENA : 1;/*!< IBUS busy monitor interrupt enable                       */
      __IOM uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_INTR_ENA : 1;/*!< DBUS busy monitor interrupt enbale                       */
            uint32_t            : 20;
    } bit;
  } CORE_0_INTR_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 monitor interrupt clr register                                      */
    
    struct {
      __IOM uint32_t CORE_0_AREA_DRAM0_0_RD_CLR : 1;/*!< Core0 dram0 area0 read monitor interrupt clr                          */
      __IOM uint32_t CORE_0_AREA_DRAM0_0_WR_CLR : 1;/*!< Core0 dram0 area0 write monitor interrupt clr                         */
      __IOM uint32_t CORE_0_AREA_DRAM0_1_RD_CLR : 1;/*!< Core0 dram0 area1 read monitor interrupt clr                          */
      __IOM uint32_t CORE_0_AREA_DRAM0_1_WR_CLR : 1;/*!< Core0 dram0 area1 write monitor interrupt clr                         */
      __IOM uint32_t CORE_0_AREA_PIF_0_RD_CLR : 1;/*!< Core0 PIF area0 read monitor interrupt clr                              */
      __IOM uint32_t CORE_0_AREA_PIF_0_WR_CLR : 1;/*!< Core0 PIF area0 write monitor interrupt clr                             */
      __IOM uint32_t CORE_0_AREA_PIF_1_RD_CLR : 1;/*!< Core0 PIF area1 read monitor interrupt clr                              */
      __IOM uint32_t CORE_0_AREA_PIF_1_WR_CLR : 1;/*!< Core0 PIF area1 write monitor interrupt clr                             */
      __IOM uint32_t CORE_0_SP_SPILL_MIN_CLR : 1;/*!< Core0 stackpoint overflow monitor interrupt clr                          */
      __IOM uint32_t CORE_0_SP_SPILL_MAX_CLR : 1;/*!< Core0 stackpoint underflow monitor interrupt clr                         */
      __IOM uint32_t CORE_0_IRAM0_EXCEPTION_MONITOR_CLR : 1;/*!< IBUS busy monitor interrupt clr                               */
      __IOM uint32_t CORE_0_DRAM0_EXCEPTION_MONITOR_CLR : 1;/*!< DBUS busy monitor interrupt clr                               */
            uint32_t            : 20;
    } bit;
  } CORE_0_INTR_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 dram0 region0 addr configuration register                           */
    
    struct {
      __IOM uint32_t CORE_0_AREA_DRAM0_0_MIN : 32;/*!< Core0 dram0 region0 start addr                                          */
    } bit;
  } CORE_0_AREA_DRAM0_0_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 dram0 region0 addr configuration register                           */
    
    struct {
      __IOM uint32_t CORE_0_AREA_DRAM0_0_MAX : 32;/*!< Core0 dram0 region0 end addr                                            */
    } bit;
  } CORE_0_AREA_DRAM0_0_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 dram0 region1 addr configuration register                           */
    
    struct {
      __IOM uint32_t CORE_0_AREA_DRAM0_1_MIN : 32;/*!< Core0 dram0 region1 start addr                                          */
    } bit;
  } CORE_0_AREA_DRAM0_1_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 dram0 region1 addr configuration register                           */
    
    struct {
      __IOM uint32_t CORE_0_AREA_DRAM0_1_MAX : 32;/*!< Core0 dram0 region1 end addr                                            */
    } bit;
  } CORE_0_AREA_DRAM0_1_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 PIF region0 addr configuration register                             */
    
    struct {
      __IOM uint32_t CORE_0_AREA_PIF_0_MIN : 32;/*!< Core0 PIF region0 start addr                                              */
    } bit;
  } CORE_0_AREA_PIF_0_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 PIF region0 addr configuration register                             */
    
    struct {
      __IOM uint32_t CORE_0_AREA_PIF_0_MAX : 32;/*!< Core0 PIF region0 end addr                                                */
    } bit;
  } CORE_0_AREA_PIF_0_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 PIF region1 addr configuration register                             */
    
    struct {
      __IOM uint32_t CORE_0_AREA_PIF_1_MIN : 32;/*!< Core0 PIF region1 start addr                                              */
    } bit;
  } CORE_0_AREA_PIF_1_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 PIF region1 addr configuration register                             */
    
    struct {
      __IOM uint32_t CORE_0_AREA_PIF_1_MAX : 32;/*!< Core0 PIF region1 end addr                                                */
    } bit;
  } CORE_0_AREA_PIF_1_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 area sp status register                                             */
    
    struct {
      __IM  uint32_t CORE_0_AREA_SP : 32;       /*!< the stackpointer when first touch region monitor interrupt                */
    } bit;
  } CORE_0_AREA_SP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 area pc status register                                             */
    
    struct {
      __IM  uint32_t CORE_0_AREA_PC : 32;       /*!< the PC when first touch region monitor interrupt                          */
    } bit;
  } CORE_0_AREA_PC;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 sp unstable configuration register                                  */
    
    struct {
      __IOM uint32_t CORE_0_SP_UNSTABLE : 8;    /*!< unstable period when window change,during this period no check
                                                     stackpointer                                                              */
            uint32_t            : 24;
    } bit;
  } CORE_0_SP_UNSTABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 sp region configuration regsiter                                    */
    
    struct {
      __IOM uint32_t CORE_0_SP_MIN : 32;        /*!< stack min value                                                           */
    } bit;
  } CORE_0_SP_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 sp region configuration regsiter                                    */
    
    struct {
      __IOM uint32_t CORE_0_SP_MAX : 32;        /*!< stack max value                                                           */
    } bit;
  } CORE_0_SP_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 sp pc status register                                               */
    
    struct {
      __IM  uint32_t CORE_0_SP_PC : 32;         /*!< the PC when first touch stack monitor interrupt                           */
    } bit;
  } CORE_0_SP_PC;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug configuration register                                       */
    
    struct {
      __IOM uint32_t CORE_0_RCD_PDEBUGENABLE : 1;/*!< Core0 Pdebugenable,set 1 to open core0 Pdebug interface,then
                                                     can get core0 PC                                                          */
            uint32_t            : 31;
    } bit;
  } CORE_0_RCD_PDEBUGENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug status register                                              */
    
    struct {
      __IOM uint32_t CORE_0_RCD_RECORDING : 1;  /*!< Pdebug record enable,set 1 to record core0 pdebug interface
                                                     signal                                                                    */
            uint32_t            : 31;
    } bit;
  } CORE_0_RCD_RECORDING;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_0_RCD_PDEBUGINST : 32;/*!< core0 pdebuginst                                                          */
    } bit;
  } CORE_0_RCD_PDEBUGINST;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_0_RCD_PDEBUGSTATUS : 8;/*!< core0 pdebugstatus                                                       */
            uint32_t            : 24;
    } bit;
  } CORE_0_RCD_PDEBUGSTATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_0_RCD_PDEBUGDATA : 32;/*!< core0_pdebugdata                                                          */
    } bit;
  } CORE_0_RCD_PDEBUGDATA;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_0_RCD_PDEBUGPC : 32;  /*!< core0_pdebugPC                                                            */
    } bit;
  } CORE_0_RCD_PDEBUGPC;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_0_RCD_PDEBUGLS0STAT : 32;/*!< core0_pdebug_s0stat                                                    */
    } bit;
  } CORE_0_RCD_PDEBUGLS0STAT;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_0_RCD_PDEBUGLS0ADDR : 32;/*!< core0_pdebug_s0addr                                                    */
    } bit;
  } CORE_0_RCD_PDEBUGLS0ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_0_RCD_PDEBUGLS0DATA : 32;/*!< core0_pdebug_s0data                                                    */
    } bit;
  } CORE_0_RCD_PDEBUGLS0DATA;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_0_RCD_SP : 32;        /*!< core0_stack pointer                                                       */
    } bit;
  } CORE_0_RCD_SP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_0_IRAM0_RECORDING_ADDR_0 : 24;/*!< The first iram0's addr[25:2] status when trigger IRAM busy interrupt */
      __IM  uint32_t CORE_0_IRAM0_RECORDING_WR_0 : 1;/*!< The first iram0's wr status when trigger IRAM busy interrupt         */
      __IM  uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_0 : 1;/*!< The first iram0's loadstore status when trigger IRAM busy interrupt */
            uint32_t            : 6;
    } bit;
  } CORE_0_IRAM0_EXCEPTION_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_0_IRAM0_RECORDING_ADDR_1 : 24;/*!< The second iram0's addr[25:2] status when trigger IRAM busy
                                                     interrupt                                                                 */
      __IM  uint32_t CORE_0_IRAM0_RECORDING_WR_1 : 1;/*!< The second iram0's wr status when trigger IRAM busy interrupt        */
      __IM  uint32_t CORE_0_IRAM0_RECORDING_LOADSTORE_1 : 1;/*!< The second iram0's loadstore status when trigger IRAM busy interrupt */
            uint32_t            : 6;
    } bit;
  } CORE_0_IRAM0_EXCEPTION_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_0_DRAM0_RECORDING_ADDR_0 : 22;/*!< The first dram0's addr[25:4] status when trigger DRAM busy interrupt */
      __IM  uint32_t CORE_0_DRAM0_RECORDING_WR_0 : 1;/*!< The first dram0's wr status when trigger DRAM busy interrupt         */
            uint32_t            : 9;
    } bit;
  } CORE_0_DRAM0_EXCEPTION_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_0 : 16;/*!< The first dram0's byteen status when trigger DRAM busy interrupt */
            uint32_t            : 16;
    } bit;
  } CORE_0_DRAM0_EXCEPTION_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_0_DRAM0_RECORDING_PC_0 : 32;/*!< The first dram0's PC status when trigger DRAM busy interrupt        */
    } bit;
  } CORE_0_DRAM0_EXCEPTION_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_0_DRAM0_RECORDING_ADDR_1 : 22;/*!< The second dram0's addr[25:4] status when trigger DRAM busy
                                                     interrupt                                                                 */
      __IM  uint32_t CORE_0_DRAM0_RECORDING_WR_1 : 1;/*!< The second dram0's wr status when trigger DRAM busy interrupt        */
            uint32_t            : 9;
    } bit;
  } CORE_0_DRAM0_EXCEPTION_MONITOR_3;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 bus busy configuration regsiter                                     */
    
    struct {
      __IM  uint32_t CORE_0_DRAM0_RECORDING_BYTEEN_1 : 16;/*!< The second dram0's byteen status when trigger DRAM busy interrupt */
            uint32_t            : 16;
    } bit;
  } CORE_0_DRAM0_EXCEPTION_MONITOR_4;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 bus busy configuration regsiter                                     */
    
    struct {
      __IM  uint32_t CORE_0_DRAM0_RECORDING_PC_1 : 32;/*!< The second dram0's PC status when trigger DRAM busy interrupt       */
    } bit;
  } CORE_0_DRAM0_EXCEPTION_MONITOR_5;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 monitor enable configuration register                               */
    
    struct {
      __IOM uint32_t CORE_1_AREA_DRAM0_0_RD_ENA : 1;/*!< Core1 dram0 area0 read monitor enable                                 */
      __IOM uint32_t CORE_1_AREA_DRAM0_0_WR_ENA : 1;/*!< Core1 dram0 area0 write monitor enable                                */
      __IOM uint32_t CORE_1_AREA_DRAM0_1_RD_ENA : 1;/*!< Core1 dram0 area1 read monitor enable                                 */
      __IOM uint32_t CORE_1_AREA_DRAM0_1_WR_ENA : 1;/*!< Core1 dram0 area1 write monitor enable                                */
      __IOM uint32_t CORE_1_AREA_PIF_0_RD_ENA : 1;/*!< Core1 PIF area0 read monitor enable                                     */
      __IOM uint32_t CORE_1_AREA_PIF_0_WR_ENA : 1;/*!< Core1 PIF area0 write monitor enable                                    */
      __IOM uint32_t CORE_1_AREA_PIF_1_RD_ENA : 1;/*!< Core1 PIF area1 read monitor enable                                     */
      __IOM uint32_t CORE_1_AREA_PIF_1_WR_ENA : 1;/*!< Core1 PIF area1 write monitor enable                                    */
      __IOM uint32_t CORE_1_SP_SPILL_MIN_ENA : 1;/*!< Core1 stackpoint overflow monitor enable                                 */
      __IOM uint32_t CORE_1_SP_SPILL_MAX_ENA : 1;/*!< Core1 stackpoint underflow monitor enable                                */
      __IOM uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_ENA : 1;/*!< IBUS busy monitor enable                                      */
      __IOM uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_ENA : 1;/*!< DBUS busy monitor enbale                                      */
            uint32_t            : 20;
    } bit;
  } CORE_1_MONTR_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 monitor interrupt status register                                   */
    
    struct {
      __IM  uint32_t CORE_1_AREA_DRAM0_0_RD_RAW : 1;/*!< Core1 dram0 area0 read monitor interrupt status                       */
      __IM  uint32_t CORE_1_AREA_DRAM0_0_WR_RAW : 1;/*!< Core1 dram0 area0 write monitor interrupt status                      */
      __IM  uint32_t CORE_1_AREA_DRAM0_1_RD_RAW : 1;/*!< Core1 dram0 area1 read monitor interrupt status                       */
      __IM  uint32_t CORE_1_AREA_DRAM0_1_WR_RAW : 1;/*!< Core1 dram0 area1 write monitor interrupt status                      */
      __IM  uint32_t CORE_1_AREA_PIF_0_RD_RAW : 1;/*!< Core1 PIF area0 read monitor interrupt status                           */
      __IM  uint32_t CORE_1_AREA_PIF_0_WR_RAW : 1;/*!< Core1 PIF area0 write monitor interrupt status                          */
      __IM  uint32_t CORE_1_AREA_PIF_1_RD_RAW : 1;/*!< Core1 PIF area1 read monitor interrupt status                           */
      __IM  uint32_t CORE_1_AREA_PIF_1_WR_RAW : 1;/*!< Core1 PIF area1 write monitor interrupt status                          */
      __IM  uint32_t CORE_1_SP_SPILL_MIN_RAW : 1;/*!< Core1 stackpoint overflow monitor interrupt status                       */
      __IM  uint32_t CORE_1_SP_SPILL_MAX_RAW : 1;/*!< Core1 stackpoint underflow monitor interrupt status                      */
      __IM  uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_RAW : 1;/*!< IBUS busy monitor interrupt status                            */
      __IM  uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_RAW : 1;/*!< DBUS busy monitor initerrupt status                           */
            uint32_t            : 20;
    } bit;
  } CORE_1_INTR_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 monitor interrupt enable register                                   */
    
    struct {
      __IOM uint32_t CORE_1_AREA_DRAM0_0_RD_INTR_ENA : 1;/*!< Core1 dram0 area0 read monitor interrupt enable                  */
      __IOM uint32_t CORE_1_AREA_DRAM0_0_WR_INTR_ENA : 1;/*!< Core1 dram0 area0 write monitor interrupt enable                 */
      __IOM uint32_t CORE_1_AREA_DRAM0_1_RD_INTR_ENA : 1;/*!< Core1 dram0 area1 read monitor interrupt enable                  */
      __IOM uint32_t CORE_1_AREA_DRAM0_1_WR_INTR_ENA : 1;/*!< Core1 dram0 area1 write monitor interrupt enable                 */
      __IOM uint32_t CORE_1_AREA_PIF_0_RD_INTR_ENA : 1;/*!< Core1 PIF area0 read monitor interrupt enable                      */
      __IOM uint32_t CORE_1_AREA_PIF_0_WR_INTR_ENA : 1;/*!< Core1 PIF area0 write monitor interrupt enable                     */
      __IOM uint32_t CORE_1_AREA_PIF_1_RD_INTR_ENA : 1;/*!< Core1 PIF area1 read monitor interrupt enable                      */
      __IOM uint32_t CORE_1_AREA_PIF_1_WR_INTR_ENA : 1;/*!< Core1 PIF area1 write monitor interrupt enable                     */
      __IOM uint32_t CORE_1_SP_SPILL_MIN_INTR_ENA : 1;/*!< Core1 stackpoint overflow monitor interrupt enable                  */
      __IOM uint32_t CORE_1_SP_SPILL_MAX_INTR_ENA : 1;/*!< Core1 stackpoint underflow monitor interrupt enable                 */
      __IOM uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_INTR_ENA : 1;/*!< IBUS busy monitor interrupt enable                       */
      __IOM uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_INTR_ENA : 1;/*!< DBUS busy monitor interrupt enbale                       */
            uint32_t            : 20;
    } bit;
  } CORE_1_INTR_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 monitor interrupt clr register                                      */
    
    struct {
      __IOM uint32_t CORE_1_AREA_DRAM0_0_RD_CLR : 1;/*!< Core1 dram0 area0 read monitor interrupt clr                          */
      __IOM uint32_t CORE_1_AREA_DRAM0_0_WR_CLR : 1;/*!< Core1 dram0 area0 write monitor interrupt clr                         */
      __IOM uint32_t CORE_1_AREA_DRAM0_1_RD_CLR : 1;/*!< Core1 dram0 area1 read monitor interrupt clr                          */
      __IOM uint32_t CORE_1_AREA_DRAM0_1_WR_CLR : 1;/*!< Core1 dram0 area1 write monitor interrupt clr                         */
      __IOM uint32_t CORE_1_AREA_PIF_0_RD_CLR : 1;/*!< Core1 PIF area0 read monitor interrupt clr                              */
      __IOM uint32_t CORE_1_AREA_PIF_0_WR_CLR : 1;/*!< Core1 PIF area0 write monitor interrupt clr                             */
      __IOM uint32_t CORE_1_AREA_PIF_1_RD_CLR : 1;/*!< Core1 PIF area1 read monitor interrupt clr                              */
      __IOM uint32_t CORE_1_AREA_PIF_1_WR_CLR : 1;/*!< Core1 PIF area1 write monitor interrupt clr                             */
      __IOM uint32_t CORE_1_SP_SPILL_MIN_CLR : 1;/*!< Core1 stackpoint overflow monitor interrupt clr                          */
      __IOM uint32_t CORE_1_SP_SPILL_MAX_CLR : 1;/*!< Core1 stackpoint underflow monitor interrupt clr                         */
      __IOM uint32_t CORE_1_IRAM0_EXCEPTION_MONITOR_CLR : 1;/*!< IBUS busy monitor interrupt clr                               */
      __IOM uint32_t CORE_1_DRAM0_EXCEPTION_MONITOR_CLR : 1;/*!< DBUS busy monitor interrupt clr                               */
            uint32_t            : 20;
    } bit;
  } CORE_1_INTR_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 dram0 region0 addr configuration register                           */
    
    struct {
      __IOM uint32_t CORE_1_AREA_DRAM0_0_MIN : 32;/*!< Core1 dram0 region0 start addr                                          */
    } bit;
  } CORE_1_AREA_DRAM0_0_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 dram0 region0 addr configuration register                           */
    
    struct {
      __IOM uint32_t CORE_1_AREA_DRAM0_0_MAX : 32;/*!< Core1 dram0 region0 end addr                                            */
    } bit;
  } CORE_1_AREA_DRAM0_0_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 dram0 region1 addr configuration register                           */
    
    struct {
      __IOM uint32_t CORE_1_AREA_DRAM0_1_MIN : 32;/*!< Core1 dram0 region1 start addr                                          */
    } bit;
  } CORE_1_AREA_DRAM0_1_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 dram0 region1 addr configuration register                           */
    
    struct {
      __IOM uint32_t CORE_1_AREA_DRAM0_1_MAX : 32;/*!< Core1 dram0 region1 end addr                                            */
    } bit;
  } CORE_1_AREA_DRAM0_1_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 PIF region0 addr configuration register                             */
    
    struct {
      __IOM uint32_t CORE_1_AREA_PIF_0_MIN : 32;/*!< Core1 PIF region0 start addr                                              */
    } bit;
  } CORE_1_AREA_PIF_0_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 PIF region0 addr configuration register                             */
    
    struct {
      __IOM uint32_t CORE_1_AREA_PIF_0_MAX : 32;/*!< Core1 PIF region0 end addr                                                */
    } bit;
  } CORE_1_AREA_PIF_0_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 PIF region1 addr configuration register                             */
    
    struct {
      __IOM uint32_t CORE_1_AREA_PIF_1_MIN : 32;/*!< Core1 PIF region1 start addr                                              */
    } bit;
  } CORE_1_AREA_PIF_1_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 PIF region1 addr configuration register                             */
    
    struct {
      __IOM uint32_t CORE_1_AREA_PIF_1_MAX : 32;/*!< Core1 PIF region1 end addr                                                */
    } bit;
  } CORE_1_AREA_PIF_1_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 area sp status register                                             */
    
    struct {
      __IM  uint32_t CORE_1_AREA_PC : 32;       /*!< the stackpointer when first touch region monitor interrupt                */
    } bit;
  } CORE_1_AREA_PC;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 area pc status register                                             */
    
    struct {
      __IM  uint32_t CORE_1_AREA_SP : 32;       /*!< the PC when first touch region monitor interrupt                          */
    } bit;
  } CORE_1_AREA_SP;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 sp unstable configuration register                                  */
    
    struct {
      __IOM uint32_t CORE_1_SP_UNSTABLE : 8;    /*!< unstable period when window change,during this period no check
                                                     stackpointer                                                              */
            uint32_t            : 24;
    } bit;
  } CORE_1_SP_UNSTABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 sp region configuration regsiter                                    */
    
    struct {
      __IOM uint32_t CORE_1_SP_MIN : 32;        /*!< stack min value                                                           */
    } bit;
  } CORE_1_SP_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 sp region configuration regsiter                                    */
    
    struct {
      __IOM uint32_t CORE_1_SP_MAX : 32;        /*!< stack max value                                                           */
    } bit;
  } CORE_1_SP_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 sp pc status register                                               */
    
    struct {
      __IM  uint32_t CORE_1_SP_PC : 32;         /*!< the PC when first touch stack monitor interrupt                           */
    } bit;
  } CORE_1_SP_PC;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug configuration register                                       */
    
    struct {
      __IOM uint32_t CORE_1_RCD_PDEBUGENABLE : 1;/*!< Core1 Pdebugenable,set 1 to open Core1 Pdebug interface, then
                                                     can get Core1 PC                                                          */
            uint32_t            : 31;
    } bit;
  } CORE_1_RCD_PDEBUGENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug status register                                              */
    
    struct {
      __IOM uint32_t CORE_1_RCD_RECORDING : 1;  /*!< Pdebug record enable,set 1 to record Core1 pdebug interface
                                                     signal                                                                    */
            uint32_t            : 31;
    } bit;
  } CORE_1_RCD_RECORDING;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_1_RCD_PDEBUGINST : 32;/*!< Core1 pdebuginst                                                          */
    } bit;
  } CORE_1_RCD_PDEBUGINST;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_1_RCD_PDEBUGSTATUS : 8;/*!< Core1 pdebugstatus                                                       */
            uint32_t            : 24;
    } bit;
  } CORE_1_RCD_PDEBUGSTATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_1_RCD_PDEBUGDATA : 32;/*!< Core1_pdebugdata                                                          */
    } bit;
  } CORE_1_RCD_PDEBUGDATA;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_1_RCD_PDEBUGPC : 32;  /*!< Core1_pdebugPC                                                            */
    } bit;
  } CORE_1_RCD_PDEBUGPC;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_1_RCD_PDEBUGLS0STAT : 32;/*!< Core1_pdebug_s0stat                                                    */
    } bit;
  } CORE_1_RCD_PDEBUGLS0STAT;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_1_RCD_PDEBUGLS0ADDR : 32;/*!< Core1_pdebug_s0addr                                                    */
    } bit;
  } CORE_1_RCD_PDEBUGLS0ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_1_RCD_PDEBUGLS0DATA : 32;/*!< Core1_pdebug_s0data                                                    */
    } bit;
  } CORE_1_RCD_PDEBUGLS0DATA;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 pdebug status register                                              */
    
    struct {
      __IM  uint32_t CORE_1_RCD_SP : 32;        /*!< Core1_stack pointer                                                       */
    } bit;
  } CORE_1_RCD_SP;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_1_IRAM0_RECORDING_ADDR_0 : 24;/*!< The first iram0's addr[25:2] status when trigger IRAM busy interrupt */
      __IM  uint32_t CORE_1_IRAM0_RECORDING_WR_0 : 1;/*!< The first iram0's wr status when trigger IRAM busy interrupt         */
      __IM  uint32_t CORE_1_IRAM0_RECORDING_LOADSTORE_0 : 1;/*!< The first iram0's loadstore status when trigger IRAM busy interrupt */
            uint32_t            : 6;
    } bit;
  } CORE_1_IRAM0_EXCEPTION_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_1_IRAM0_RECORDING_ADDR_1 : 24;/*!< The second iram0's addr[25:2] status when trigger IRAM busy
                                                     interrupt                                                                 */
      __IM  uint32_t CORE_1_IRAM0_RECORDING_WR_1 : 1;/*!< The second iram0's wr status when trigger IRAM busy interrupt        */
      __IM  uint32_t CORE_1_IRAM0_RECORDING_LOADSTORE_1 : 1;/*!< The second iram0's loadstore status when trigger IRAM busy interrupt */
            uint32_t            : 6;
    } bit;
  } CORE_1_IRAM0_EXCEPTION_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_1_DRAM0_RECORDING_ADDR_0 : 22;/*!< The first dram0's addr[25:4] status when trigger DRAM busy interrupt */
      __IM  uint32_t CORE_1_DRAM0_RECORDING_WR_0 : 1;/*!< The first dram0's wr status when trigger DRAM busy interrupt         */
            uint32_t            : 9;
    } bit;
  } CORE_1_DRAM0_EXCEPTION_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_1_DRAM0_RECORDING_BYTEEN_0 : 16;/*!< The first dram0's byteen status when trigger DRAM busy interrupt */
            uint32_t            : 16;
    } bit;
  } CORE_1_DRAM0_EXCEPTION_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_1_DRAM0_RECORDING_PC_0 : 32;/*!< The first dram0's PC status when trigger DRAM busy interrupt        */
    } bit;
  } CORE_1_DRAM0_EXCEPTION_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_1_DRAM0_RECORDING_ADDR_1 : 22;/*!< The second dram0's addr[25:4] status when trigger DRAM busy
                                                     interrupt                                                                 */
      __IM  uint32_t CORE_1_DRAM0_RECORDING_WR_1 : 1;/*!< The second dram0's wr status when trigger DRAM busy interrupt        */
            uint32_t            : 9;
    } bit;
  } CORE_1_DRAM0_EXCEPTION_MONITOR_3;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_1_DRAM0_RECORDING_BYTEEN_1 : 16;/*!< The second dram0's byteen status when trigger DRAM busy interrupt */
            uint32_t            : 16;
    } bit;
  } CORE_1_DRAM0_EXCEPTION_MONITOR_4;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 bus busy status regsiter                                            */
    
    struct {
      __IM  uint32_t CORE_1_DRAM0_RECORDING_PC_1 : 32;/*!< The second dram0's PC status when trigger DRAM busy interrupt       */
    } bit;
  } CORE_1_DRAM0_EXCEPTION_MONITOR_5;
  
  union {
    __IOM uint32_t reg;                         /*!< bus busy configuration register                                           */
    
    struct {
      __IOM uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_0 : 20;/*!< busy monitor window cycle                                      */
            uint32_t            : 12;
    } bit;
  } CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< bus busy configuration register                                           */
    
    struct {
      __IOM uint32_t CORE_X_IRAM0_DRAM0_LIMIT_CYCLE_1 : 20;/*!< non busy cycle,for example: when cycle=100 and cycle=10,it means
                                                     that in 100 cycle, if busy access success time less than
                                                     10, it will trigger interrutpt                                            */
            uint32_t            : 12;
    } bit;
  } CORE_X_IRAM0_DRAM0_EXCEPTION_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< log set register                                                          */
    
    struct {
      __IOM uint32_t LOG_ENA    : 3;            /*!< bus moniter enable: [0]Core1,[1]core1,[2]dma                              */
      __IOM uint32_t LOG_MODE   : 3;            /*!< check_mode:0:write,1:word,2:halword,3:byte,4:doubleword,5:4word           */
      __IOM uint32_t LOG_MEM_LOOP_ENABLE : 1;   /*!< mem_loop enable,1 means that loop write                                   */
            uint32_t            : 25;
    } bit;
  } LOG_SETTING;
  
  union {
    __IOM uint32_t reg;                         /*!< log check data register                                                   */
    
    struct {
      __IOM uint32_t LOG_DATA_0 : 32;           /*!< check data0                                                               */
    } bit;
  } LOG_DATA_0;
  
  union {
    __IOM uint32_t reg;                         /*!< log check data register                                                   */
    
    struct {
      __IOM uint32_t LOG_DATA_1 : 32;           /*!< check data1                                                               */
    } bit;
  } LOG_DATA_1;
  
  union {
    __IOM uint32_t reg;                         /*!< log check data register                                                   */
    
    struct {
      __IOM uint32_t LOG_DATA_2 : 32;           /*!< check data2                                                               */
    } bit;
  } LOG_DATA_2;
  
  union {
    __IOM uint32_t reg;                         /*!< log check data register                                                   */
    
    struct {
      __IOM uint32_t LOG_DATA_3 : 32;           /*!< check data3                                                               */
    } bit;
  } LOG_DATA_3;
  
  union {
    __IOM uint32_t reg;                         /*!< log check data mask register                                              */
    
    struct {
      __IOM uint32_t LOG_DATA_SIZE : 16;        /*!< data mask                                                                 */
            uint32_t            : 16;
    } bit;
  } LOG_DATA_MASK;
  
  union {
    __IOM uint32_t reg;                         /*!< log check region configuration register                                   */
    
    struct {
      __IOM uint32_t LOG_MIN    : 32;           /*!< check region min addr                                                     */
    } bit;
  } LOG_MIN;
  
  union {
    __IOM uint32_t reg;                         /*!< log check region configuration register                                   */
    
    struct {
      __IOM uint32_t LOG_MAX    : 32;           /*!< check region max addr                                                     */
    } bit;
  } LOG_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< log mem region configuration register                                     */
    
    struct {
      __IOM uint32_t LOG_MEM_START : 32;        /*!< mem start addr                                                            */
    } bit;
  } LOG_MEM_START;
  
  union {
    __IOM uint32_t reg;                         /*!< log mem region configuration register                                     */
    
    struct {
      __IOM uint32_t LOG_MEM_END : 32;          /*!< mem end addr                                                              */
    } bit;
  } LOG_MEM_END;
  
  union {
    __IOM uint32_t reg;                         /*!< log mem addr status register                                              */
    
    struct {
      __IM  uint32_t LOG_MEM_WRITING_ADDR : 32; /*!< mem current addr, it means next writing addr                              */
    } bit;
  } LOG_MEM_WRITING_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< log mem status register                                                   */
    
    struct {
      __IOM uint32_t LOG_MEM_FULL_FLAG : 1;     /*!< when it's 1,show that mem write loop morte than one time.                 */
            uint32_t            : 31;
    } bit;
  } LOG_MEM_FULL_FLAG;
  __IM  uint32_t  RESERVED[41];
  
  union {
    __IOM uint32_t reg;                         /*!< version register                                                          */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< version register                                                          */
            uint32_t            : 4;
    } bit;
  } DATE;
} ASSIST_DEBUG_Type;                            /*!< Size = 512 (0x200)                                                        */



/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DMA (Direct Memory Access) Controller (DMA)
  */

typedef struct {                                /*!< DMA Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_RST     : 1;            /*!< This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.       */
      __IOM uint32_t IN_LOOP_TEST : 1;          /*!< reserved                                                                  */
      __IOM uint32_t INDSCR_BURST_EN : 1;       /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t IN_DATA_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 receiving data when accessing internal SRAM.                            */
      __IOM uint32_t MEM_TRANS_EN : 1;          /*!< Set this bit 1 to enable automatic transmitting data from memory
                                                     to memory via DMA.                                                        */
            uint32_t            : 27;
    } bit;
  } IN_CONF0_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t DMA_INFIFO_FULL_THRS : 12; /*!< This register is used to generate the INFIFO_FULL_WM_INT interrupt
                                                     when Rx channel 0 received byte number in Rx FIFO is up
                                                     to the value of the register.                                             */
      __IOM uint32_t IN_CHECK_OWNER : 1;        /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t IN_EXT_MEM_BK_SIZE : 2;    /*!< Block size of Rx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } IN_CONF1_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0.                                                             */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0. For UHCI0, the raw interrupt bit turns to
                                                     high level when the last data pointed by one inlink descriptor
                                                     has been received and no data error is detected for Rx
                                                     channel 0.                                                                */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt bit turns to high level when data error is
                                                     detected only in the case that the peripheral is UHCI0
                                                     for Rx channel 0. For other peripherals, this raw interrupt
                                                     is reserved.                                                              */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt bit turns to high level when detecting inlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of inlink descriptor for Rx channel 0.                   */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt bit turns to high level when Rx buffer pointed
                                                     by inlink is full and receiving data is not completed,
                                                     but there is no more inlink for Rx channel 0.                             */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt bit turns to high level when received data
                                                     byte number is up to threshold configured by REG_DMA_INFIFO_FULL_THRS_CH0
                                                     in Rx FIFO of channel 0.                                                  */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is underflow.                                             */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is underflow.                                             */
            uint32_t            : 22;
    } bit;
  } IN_INT_RAW_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Rx channel 0                                          */
    
    struct {
      __IM  uint32_t IN_DONE    : 1;            /*!< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.            */
      __IM  uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.        */
      __IM  uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt status bit for the INFIFO_FULL_WM_CH_INT interrupt.     */
      __IM  uint32_t INFIFO_OVF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_OVF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L3_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L3_CH_INT interrupt.      */
            uint32_t            : 22;
    } bit;
  } IN_INT_ST_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The interrupt enable bit for the IN_DONE_CH_INT interrupt.                */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.            */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The interrupt enable bit for the INFIFO_FULL_WM_CH_INT interrupt.         */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L3_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L3_CH_INT interrupt.          */
            uint32_t            : 22;
    } bit;
  } IN_INT_ENA_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Rx channel 0                                      */
    
    struct {
      __OM  uint32_t IN_DONE    : 1;            /*!< Set this bit to clear the IN_DONE_CH_INT interrupt.                       */
      __OM  uint32_t IN_SUC_EOF : 1;            /*!< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_ERR_EOF : 1;            /*!< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_DSCR_ERR : 1;           /*!< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.                   */
      __OM  uint32_t IN_DSCR_EMPTY : 1;         /*!< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.                 */
      __OM  uint32_t DMA_INFIFO_FULL_WM : 1;    /*!< Set this bit to clear the INFIFO_FULL_WM_CH_INT interrupt.                */
      __OM  uint32_t INFIFO_OVF_L1 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L1 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_OVF_L3 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L3_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L3 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L3_CH_INT interrupt.                 */
            uint32_t            : 22;
    } bit;
  } IN_INT_CLR_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive FIFO status of Rx channel 0                                       */
    
    struct {
      __IM  uint32_t INFIFO_FULL_L1 : 1;        /*!< L1 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L1 : 1;       /*!< L1 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L2 : 1;        /*!< L2 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L2 : 1;       /*!< L2 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L3 : 1;        /*!< L3 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L3 : 1;       /*!< L3 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_CNT_L1 : 6;         /*!< The register stores the byte number of the data in L1 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L2 : 7;         /*!< The register stores the byte number of the data in L2 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L3 : 5;         /*!< The register stores the byte number of the data in L3 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t IN_REMAIN_UNDER_1B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_2B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_3B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_4B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_BUF_HUNGRY : 1;         /*!< reserved                                                                  */
            uint32_t            : 3;
    } bit;
  } INFIFO_STATUS_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Pop control register of Rx channel 0                                      */
    
    struct {
      __IM  uint32_t INFIFO_RDATA : 12;         /*!< This register stores the data popping from DMA FIFO.                      */
      __IOM uint32_t INFIFO_POP : 1;            /*!< Set this bit to pop data from DMA FIFO.                                   */
            uint32_t            : 19;
    } bit;
  } IN_POP_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Rx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t INLINK_ADDR : 20;          /*!< This register stores the 20 least significant bits of the first
                                                     inlink descriptor's address.                                              */
      __IOM uint32_t INLINK_AUTO_RET : 1;       /*!< Set this bit to return to current inlink descriptor's address,
                                                     when there are some errors in current receiving data.                     */
      __IOM uint32_t INLINK_STOP : 1;           /*!< Set this bit to stop dealing with the inlink descriptors.                 */
      __IOM uint32_t INLINK_START : 1;          /*!< Set this bit to start dealing with the inlink descriptors.                */
      __IOM uint32_t INLINK_RESTART : 1;        /*!< Set this bit to mount a new inlink descriptor.                            */
      __IM  uint32_t INLINK_PARK : 1;           /*!< 1: the inlink descriptor's FSM is in idle state. 0: the inlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 7;
    } bit;
  } IN_LINK_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive status of Rx channel 0                                            */
    
    struct {
      __IM  uint32_t INLINK_DSCR_ADDR : 18;     /*!< This register stores the current inlink descriptor's address.             */
      __IM  uint32_t IN_DSCR_STATE : 2;         /*!< reserved                                                                  */
      __IM  uint32_t IN_STATE   : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } IN_STATE_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when EOF occurs of Rx channel 0                 */
    
    struct {
      __IM  uint32_t IN_SUC_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } IN_SUC_EOF_DES_ADDR_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when errors occur of Rx channel 0               */
    
    struct {
      __IM  uint32_t IN_ERR_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     there are some errors in current receiving data. Only used
                                                     when peripheral is UHCI0.                                                 */
    } bit;
  } IN_ERR_EOF_DES_ADDR_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Rx channel 0                         */
    
    struct {
      __IM  uint32_t INLINK_DSCR : 32;          /*!< The address of the current inlink descriptor x.                           */
    } bit;
  } IN_DSCR_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Rx channel 0                        */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF0 : 32;      /*!< The address of the last inlink descriptor x-1.                            */
    } bit;
  } IN_DSCR_BF0_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Rx channel 0              */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF1 : 32;      /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } IN_DSCR_BF1_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t RX_WEIGHT  : 4;            /*!< The weight of Rx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } IN_WIGHT_CH0;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Rx channel 0                                         */
    
    struct {
      __IOM uint32_t RX_PRI     : 4;            /*!< The priority of Rx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } IN_PRI_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_IN_SEL : 6;           /*!< This register is used to select peripheral for Rx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } IN_PERI_SEL_CH0;
  __IM  uint32_t  RESERVED1[5];
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_RST    : 1;            /*!< This bit is used to reset DMA channel 0 Tx FSM and Tx FIFO pointer.       */
      __IOM uint32_t OUT_LOOP_TEST : 1;         /*!< reserved                                                                  */
      __IOM uint32_t OUT_AUTO_WRBACK : 1;       /*!< Set this bit to enable automatic outlink-writeback when all
                                                     the data in tx buffer has been transmitted.                               */
      __IOM uint32_t OUT_EOF_MODE : 1;          /*!< EOF flag generation mode when transmitting data. 1: EOF flag
                                                     for Tx channel 0 is generated when data need to transmit
                                                     has been popped from FIFO in DMA                                          */
      __IOM uint32_t OUTDSCR_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t OUT_DATA_BURST_EN : 1;     /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 transmitting data when accessing internal SRAM.                         */
            uint32_t            : 26;
    } bit;
  } OUT_CONF0_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Tx channel 0                                      */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t OUT_CHECK_OWNER : 1;       /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t OUT_EXT_MEM_BK_SIZE : 2;   /*!< Block size of Tx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } OUT_CONF1_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been transmitted
                                                     to peripherals for Tx channel 0.                                          */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been read from memory
                                                     for Tx channel 0.                                                         */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt bit turns to high level when detecting outlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of outlink descriptor for Tx channel 0.                  */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt bit turns to high level when data corresponding
                                                     a outlink (includes one link descriptor or few link descriptors)
                                                     is transmitted out for Tx channel 0.                                      */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is underflow.                                             */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is underflow.                                             */
            uint32_t            : 24;
    } bit;
  } OUT_INT_RAW_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Tx channel 0                                          */
    
    struct {
      __IM  uint32_t OUT_DONE   : 1;            /*!< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.           */
      __IM  uint32_t OUT_EOF    : 1;            /*!< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.            */
      __IM  uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.       */
      __IM  uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.      */
      __IM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L3_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L3_CH_INT interrupt.     */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ST_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Tx channel 0                                     */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.               */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.                */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.           */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.          */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L3_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L3_CH_INT interrupt.         */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ENA_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Tx channel 0                                      */
    
    struct {
      __OM  uint32_t OUT_DONE   : 1;            /*!< Set this bit to clear the OUT_DONE_CH_INT interrupt.                      */
      __OM  uint32_t OUT_EOF    : 1;            /*!< Set this bit to clear the OUT_EOF_CH_INT interrupt.                       */
      __OM  uint32_t OUT_DSCR_ERR : 1;          /*!< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.                  */
      __OM  uint32_t OUT_TOTAL_EOF : 1;         /*!< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.                 */
      __OM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L3_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L3_CH_INT interrupt.                */
            uint32_t            : 24;
    } bit;
  } OUT_INT_CLR_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit FIFO status of Tx channel 0                                      */
    
    struct {
      __IM  uint32_t OUTFIFO_FULL_L1 : 1;       /*!< L1 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L1 : 1;      /*!< L1 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L2 : 1;       /*!< L2 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L2 : 1;      /*!< L2 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L3 : 1;       /*!< L3 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L3 : 1;      /*!< L3 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_CNT_L1 : 5;        /*!< The register stores the byte number of the data in L1 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L2 : 7;        /*!< The register stores the byte number of the data in L2 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L3 : 5;        /*!< The register stores the byte number of the data in L3 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUT_REMAIN_UNDER_1B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_2B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_3B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_4B_L3 : 1;/*!< reserved                                                                  */
            uint32_t            : 5;
    } bit;
  } OUTFIFO_STATUS_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Push control register of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t OUTFIFO_WDATA : 9;         /*!< This register stores the data that need to be pushed into DMA
                                                     FIFO.                                                                     */
      __IOM uint32_t OUTFIFO_PUSH : 1;          /*!< Set this bit to push data into DMA FIFO.                                  */
            uint32_t            : 22;
    } bit;
  } OUT_PUSH_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Tx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t OUTLINK_ADDR : 20;         /*!< This register stores the 20 least significant bits of the first
                                                     outlink descriptor's address.                                             */
      __IOM uint32_t OUTLINK_STOP : 1;          /*!< Set this bit to stop dealing with the outlink descriptors.                */
      __IOM uint32_t OUTLINK_START : 1;         /*!< Set this bit to start dealing with the outlink descriptors.               */
      __IOM uint32_t OUTLINK_RESTART : 1;       /*!< Set this bit to restart a new outlink from the last address.              */
      __IM  uint32_t OUTLINK_PARK : 1;          /*!< 1: the outlink descriptor's FSM is in idle state. 0: the outlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 8;
    } bit;
  } OUT_LINK_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit status of Tx channel 0                                           */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_ADDR : 18;    /*!< This register stores the current outlink descriptor's address.            */
      __IM  uint32_t OUT_DSCR_STATE : 2;        /*!< reserved                                                                  */
      __IM  uint32_t OUT_STATE  : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } OUT_STATE_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Outlink descriptor address when EOF occurs of Tx channel 0                */
    
    struct {
      __IM  uint32_t OUT_EOF_DES_ADDR : 32;     /*!< This register stores the address of the outlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } OUT_EOF_DES_ADDR_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< The last outlink descriptor address when EOF occurs of Tx channel
                                                     0                                                                         */
    
    struct {
      __IM  uint32_t OUT_EOF_BFR_DES_ADDR : 32; /*!< This register stores the address of the outlink descriptor before
                                                     the last outlink descriptor.                                              */
    } bit;
  } OUT_EOF_BFR_DES_ADDR_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Tx channel 0                         */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR : 32;         /*!< The address of the current outlink descriptor y.                          */
    } bit;
  } OUT_DSCR_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Tx channel 0                        */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF0 : 32;     /*!< The address of the last outlink descriptor y-1.                           */
    } bit;
  } OUT_DSCR_BF0_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Tx channel 0              */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF1 : 32;     /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } OUT_DSCR_BF1_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t TX_WEIGHT  : 4;            /*!< The weight of Tx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } OUT_WIGHT_CH0;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Tx channel 0.                                        */
    
    struct {
      __IOM uint32_t TX_PRI     : 4;            /*!< The priority of Tx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } OUT_PRI_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_OUT_SEL : 6;          /*!< This register is used to select peripheral for Tx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } OUT_PERI_SEL_CH0;
  __IM  uint32_t  RESERVED3[149];
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_RST     : 1;            /*!< This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.       */
      __IOM uint32_t IN_LOOP_TEST : 1;          /*!< reserved                                                                  */
      __IOM uint32_t INDSCR_BURST_EN : 1;       /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t IN_DATA_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 receiving data when accessing internal SRAM.                            */
      __IOM uint32_t MEM_TRANS_EN : 1;          /*!< Set this bit 1 to enable automatic transmitting data from memory
                                                     to memory via DMA.                                                        */
            uint32_t            : 27;
    } bit;
  } IN_CONF0_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t DMA_INFIFO_FULL_THRS : 12; /*!< This register is used to generate the INFIFO_FULL_WM_INT interrupt
                                                     when Rx channel 0 received byte number in Rx FIFO is up
                                                     to the value of the register.                                             */
      __IOM uint32_t IN_CHECK_OWNER : 1;        /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t IN_EXT_MEM_BK_SIZE : 2;    /*!< Block size of Rx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } IN_CONF1_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0.                                                             */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0. For UHCI0, the raw interrupt bit turns to
                                                     high level when the last data pointed by one inlink descriptor
                                                     has been received and no data error is detected for Rx
                                                     channel 0.                                                                */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt bit turns to high level when data error is
                                                     detected only in the case that the peripheral is UHCI0
                                                     for Rx channel 0. For other peripherals, this raw interrupt
                                                     is reserved.                                                              */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt bit turns to high level when detecting inlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of inlink descriptor for Rx channel 0.                   */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt bit turns to high level when Rx buffer pointed
                                                     by inlink is full and receiving data is not completed,
                                                     but there is no more inlink for Rx channel 0.                             */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt bit turns to high level when received data
                                                     byte number is up to threshold configured by REG_DMA_INFIFO_FULL_THRS_CH0
                                                     in Rx FIFO of channel 0.                                                  */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is underflow.                                             */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is underflow.                                             */
            uint32_t            : 22;
    } bit;
  } IN_INT_RAW_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Rx channel 0                                          */
    
    struct {
      __IM  uint32_t IN_DONE    : 1;            /*!< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.            */
      __IM  uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.        */
      __IM  uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt status bit for the INFIFO_FULL_WM_CH_INT interrupt.     */
      __IM  uint32_t INFIFO_OVF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_OVF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L3_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L3_CH_INT interrupt.      */
            uint32_t            : 22;
    } bit;
  } IN_INT_ST_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The interrupt enable bit for the IN_DONE_CH_INT interrupt.                */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.            */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The interrupt enable bit for the INFIFO_FULL_WM_CH_INT interrupt.         */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L3_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L3_CH_INT interrupt.          */
            uint32_t            : 22;
    } bit;
  } IN_INT_ENA_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Rx channel 0                                      */
    
    struct {
      __OM  uint32_t IN_DONE    : 1;            /*!< Set this bit to clear the IN_DONE_CH_INT interrupt.                       */
      __OM  uint32_t IN_SUC_EOF : 1;            /*!< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_ERR_EOF : 1;            /*!< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_DSCR_ERR : 1;           /*!< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.                   */
      __OM  uint32_t IN_DSCR_EMPTY : 1;         /*!< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.                 */
      __OM  uint32_t DMA_INFIFO_FULL_WM : 1;    /*!< Set this bit to clear the INFIFO_FULL_WM_CH_INT interrupt.                */
      __OM  uint32_t INFIFO_OVF_L1 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L1 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_OVF_L3 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L3_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L3 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L3_CH_INT interrupt.                 */
            uint32_t            : 22;
    } bit;
  } IN_INT_CLR_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive FIFO status of Rx channel 0                                       */
    
    struct {
      __IM  uint32_t INFIFO_FULL_L1 : 1;        /*!< L1 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L1 : 1;       /*!< L1 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L2 : 1;        /*!< L2 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L2 : 1;       /*!< L2 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L3 : 1;        /*!< L3 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L3 : 1;       /*!< L3 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_CNT_L1 : 6;         /*!< The register stores the byte number of the data in L1 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L2 : 7;         /*!< The register stores the byte number of the data in L2 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L3 : 5;         /*!< The register stores the byte number of the data in L3 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t IN_REMAIN_UNDER_1B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_2B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_3B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_4B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_BUF_HUNGRY : 1;         /*!< reserved                                                                  */
            uint32_t            : 3;
    } bit;
  } INFIFO_STATUS_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Pop control register of Rx channel 0                                      */
    
    struct {
      __IM  uint32_t INFIFO_RDATA : 12;         /*!< This register stores the data popping from DMA FIFO.                      */
      __IOM uint32_t INFIFO_POP : 1;            /*!< Set this bit to pop data from DMA FIFO.                                   */
            uint32_t            : 19;
    } bit;
  } IN_POP_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Rx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t INLINK_ADDR : 20;          /*!< This register stores the 20 least significant bits of the first
                                                     inlink descriptor's address.                                              */
      __IOM uint32_t INLINK_AUTO_RET : 1;       /*!< Set this bit to return to current inlink descriptor's address,
                                                     when there are some errors in current receiving data.                     */
      __IOM uint32_t INLINK_STOP : 1;           /*!< Set this bit to stop dealing with the inlink descriptors.                 */
      __IOM uint32_t INLINK_START : 1;          /*!< Set this bit to start dealing with the inlink descriptors.                */
      __IOM uint32_t INLINK_RESTART : 1;        /*!< Set this bit to mount a new inlink descriptor.                            */
      __IM  uint32_t INLINK_PARK : 1;           /*!< 1: the inlink descriptor's FSM is in idle state. 0: the inlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 7;
    } bit;
  } IN_LINK_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive status of Rx channel 0                                            */
    
    struct {
      __IM  uint32_t INLINK_DSCR_ADDR : 18;     /*!< This register stores the current inlink descriptor's address.             */
      __IM  uint32_t IN_DSCR_STATE : 2;         /*!< reserved                                                                  */
      __IM  uint32_t IN_STATE   : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } IN_STATE_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when EOF occurs of Rx channel 0                 */
    
    struct {
      __IM  uint32_t IN_SUC_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } IN_SUC_EOF_DES_ADDR_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when errors occur of Rx channel 0               */
    
    struct {
      __IM  uint32_t IN_ERR_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     there are some errors in current receiving data. Only used
                                                     when peripheral is UHCI0.                                                 */
    } bit;
  } IN_ERR_EOF_DES_ADDR_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Rx channel 0                         */
    
    struct {
      __IM  uint32_t INLINK_DSCR : 32;          /*!< The address of the current inlink descriptor x.                           */
    } bit;
  } IN_DSCR_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Rx channel 0                        */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF0 : 32;      /*!< The address of the last inlink descriptor x-1.                            */
    } bit;
  } IN_DSCR_BF0_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Rx channel 0              */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF1 : 32;      /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } IN_DSCR_BF1_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t RX_WEIGHT  : 4;            /*!< The weight of Rx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } IN_WIGHT_CH1;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Rx channel 0                                         */
    
    struct {
      __IOM uint32_t RX_PRI     : 4;            /*!< The priority of Rx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } IN_PRI_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_IN_SEL : 6;           /*!< This register is used to select peripheral for Rx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } IN_PERI_SEL_CH1;
  __IM  uint32_t  RESERVED5[5];
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_RST    : 1;            /*!< This bit is used to reset DMA channel 0 Tx FSM and Tx FIFO pointer.       */
      __IOM uint32_t OUT_LOOP_TEST : 1;         /*!< reserved                                                                  */
      __IOM uint32_t OUT_AUTO_WRBACK : 1;       /*!< Set this bit to enable automatic outlink-writeback when all
                                                     the data in tx buffer has been transmitted.                               */
      __IOM uint32_t OUT_EOF_MODE : 1;          /*!< EOF flag generation mode when transmitting data. 1: EOF flag
                                                     for Tx channel 0 is generated when data need to transmit
                                                     has been popped from FIFO in DMA                                          */
      __IOM uint32_t OUTDSCR_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t OUT_DATA_BURST_EN : 1;     /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 transmitting data when accessing internal SRAM.                         */
            uint32_t            : 26;
    } bit;
  } OUT_CONF0_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Tx channel 0                                      */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t OUT_CHECK_OWNER : 1;       /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t OUT_EXT_MEM_BK_SIZE : 2;   /*!< Block size of Tx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } OUT_CONF1_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been transmitted
                                                     to peripherals for Tx channel 0.                                          */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been read from memory
                                                     for Tx channel 0.                                                         */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt bit turns to high level when detecting outlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of outlink descriptor for Tx channel 0.                  */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt bit turns to high level when data corresponding
                                                     a outlink (includes one link descriptor or few link descriptors)
                                                     is transmitted out for Tx channel 0.                                      */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is underflow.                                             */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is underflow.                                             */
            uint32_t            : 24;
    } bit;
  } OUT_INT_RAW_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Tx channel 0                                          */
    
    struct {
      __IM  uint32_t OUT_DONE   : 1;            /*!< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.           */
      __IM  uint32_t OUT_EOF    : 1;            /*!< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.            */
      __IM  uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.       */
      __IM  uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.      */
      __IM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L3_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L3_CH_INT interrupt.     */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ST_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Tx channel 0                                     */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.               */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.                */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.           */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.          */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L3_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L3_CH_INT interrupt.         */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ENA_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Tx channel 0                                      */
    
    struct {
      __OM  uint32_t OUT_DONE   : 1;            /*!< Set this bit to clear the OUT_DONE_CH_INT interrupt.                      */
      __OM  uint32_t OUT_EOF    : 1;            /*!< Set this bit to clear the OUT_EOF_CH_INT interrupt.                       */
      __OM  uint32_t OUT_DSCR_ERR : 1;          /*!< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.                  */
      __OM  uint32_t OUT_TOTAL_EOF : 1;         /*!< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.                 */
      __OM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L3_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L3_CH_INT interrupt.                */
            uint32_t            : 24;
    } bit;
  } OUT_INT_CLR_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit FIFO status of Tx channel 0                                      */
    
    struct {
      __IM  uint32_t OUTFIFO_FULL_L1 : 1;       /*!< L1 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L1 : 1;      /*!< L1 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L2 : 1;       /*!< L2 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L2 : 1;      /*!< L2 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L3 : 1;       /*!< L3 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L3 : 1;      /*!< L3 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_CNT_L1 : 5;        /*!< The register stores the byte number of the data in L1 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L2 : 7;        /*!< The register stores the byte number of the data in L2 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L3 : 5;        /*!< The register stores the byte number of the data in L3 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUT_REMAIN_UNDER_1B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_2B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_3B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_4B_L3 : 1;/*!< reserved                                                                  */
            uint32_t            : 5;
    } bit;
  } OUTFIFO_STATUS_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Push control register of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t OUTFIFO_WDATA : 9;         /*!< This register stores the data that need to be pushed into DMA
                                                     FIFO.                                                                     */
      __IOM uint32_t OUTFIFO_PUSH : 1;          /*!< Set this bit to push data into DMA FIFO.                                  */
            uint32_t            : 22;
    } bit;
  } OUT_PUSH_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Tx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t OUTLINK_ADDR : 20;         /*!< This register stores the 20 least significant bits of the first
                                                     outlink descriptor's address.                                             */
      __IOM uint32_t OUTLINK_STOP : 1;          /*!< Set this bit to stop dealing with the outlink descriptors.                */
      __IOM uint32_t OUTLINK_START : 1;         /*!< Set this bit to start dealing with the outlink descriptors.               */
      __IOM uint32_t OUTLINK_RESTART : 1;       /*!< Set this bit to restart a new outlink from the last address.              */
      __IM  uint32_t OUTLINK_PARK : 1;          /*!< 1: the outlink descriptor's FSM is in idle state. 0: the outlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 8;
    } bit;
  } OUT_LINK_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit status of Tx channel 0                                           */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_ADDR : 18;    /*!< This register stores the current outlink descriptor's address.            */
      __IM  uint32_t OUT_DSCR_STATE : 2;        /*!< reserved                                                                  */
      __IM  uint32_t OUT_STATE  : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } OUT_STATE_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Outlink descriptor address when EOF occurs of Tx channel 0                */
    
    struct {
      __IM  uint32_t OUT_EOF_DES_ADDR : 32;     /*!< This register stores the address of the outlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } OUT_EOF_DES_ADDR_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< The last outlink descriptor address when EOF occurs of Tx channel
                                                     0                                                                         */
    
    struct {
      __IM  uint32_t OUT_EOF_BFR_DES_ADDR : 32; /*!< This register stores the address of the outlink descriptor before
                                                     the last outlink descriptor.                                              */
    } bit;
  } OUT_EOF_BFR_DES_ADDR_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Tx channel 0                         */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR : 32;         /*!< The address of the current outlink descriptor y.                          */
    } bit;
  } OUT_DSCR_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Tx channel 0                        */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF0 : 32;     /*!< The address of the last outlink descriptor y-1.                           */
    } bit;
  } OUT_DSCR_BF0_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Tx channel 0              */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF1 : 32;     /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } OUT_DSCR_BF1_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t TX_WEIGHT  : 4;            /*!< The weight of Tx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } OUT_WIGHT_CH1;
  __IM  uint32_t  RESERVED6;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Tx channel 0.                                        */
    
    struct {
      __IOM uint32_t TX_PRI     : 4;            /*!< The priority of Tx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } OUT_PRI_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_OUT_SEL : 6;          /*!< This register is used to select peripheral for Tx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } OUT_PERI_SEL_CH1;
  __IM  uint32_t  RESERVED7[5];
  
  union {
    __IOM uint32_t reg;                         /*!< reserved                                                                  */
    
    struct {
      __IOM uint32_t AHB_TESTMODE : 3;          /*!< reserved                                                                  */
            uint32_t            : 1;
      __IOM uint32_t AHB_TESTADDR : 2;          /*!< reserved                                                                  */
            uint32_t            : 26;
    } bit;
  } AHB_TEST;
  
  union {
    __IOM uint32_t reg;                         /*!< reserved                                                                  */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t DMA_RAM_FORCE_PD : 1;      /*!< Set this bit to force power down DMA internal memory.                     */
      __IOM uint32_t DMA_RAM_FORCE_PU : 1;      /*!< Set this bit to force power up DMA internal memory                        */
      __IOM uint32_t DMA_RAM_CLK_FO : 1;        /*!< 1: Force to open the clock and bypass the gate-clock when accessing
                                                     the RAM in DMA. 0: A gate-clock will be used when accessing
                                                     the RAM in DMA.                                                           */
            uint32_t            : 25;
    } bit;
  } PD_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< MISC register                                                             */
    
    struct {
      __IOM uint32_t AHBM_RST_INTER : 1;        /*!< Set this bit, then clear this bit to reset the internal ahb
                                                     FSM.                                                                      */
      __IOM uint32_t AHBM_RST_EXTER : 1;        /*!< Set this bit, then clear this bit to reset the external ahb
                                                     FSM.                                                                      */
      __IOM uint32_t ARB_PRI_DIS : 1;           /*!< Set this bit to disable priority arbitration function.                    */
            uint32_t            : 1;
      __IOM uint32_t CLK_EN     : 1;            /*!< 1'h1: Force clock on for register. 1'h0: Support clock only
                                                     when application writes registers.                                        */
            uint32_t            : 27;
    } bit;
  } MISC_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive L2 FIFO depth of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t IN_SIZE    : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Rx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
            uint32_t            : 25;
    } bit;
  } IN_SRAM_SIZE_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit L2 FIFO depth of Tx channel 0                                    */
    
    struct {
      __IOM uint32_t OUT_SIZE   : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Tx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
            uint32_t            : 25;
    } bit;
  } OUT_SRAM_SIZE_CH0;
  __IM  uint32_t  RESERVED8[6];
  
  union {
    __IOM uint32_t reg;                         /*!< Receive L2 FIFO depth of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t IN_SIZE    : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Rx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
            uint32_t            : 25;
    } bit;
  } IN_SRAM_SIZE_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit L2 FIFO depth of Tx channel 0                                    */
    
    struct {
      __IOM uint32_t OUT_SIZE   : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Tx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
            uint32_t            : 25;
    } bit;
  } OUT_SRAM_SIZE_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Reject address accessing external RAM                                     */
    
    struct {
      __IM  uint32_t EXTMEM_REJECT_ADDR : 32;   /*!< This register store the first address rejected by permission
                                                     control when accessing external RAM.                                      */
    } bit;
  } EXTMEM_REJECT_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Reject status accessing external RAM                                      */
    
    struct {
      __IM  uint32_t EXTMEM_REJECT_ATRR : 2;    /*!< The reject accessing. Bit 0: if this bit is 1, the rejected
                                                     accessing is READ. Bit 1: if this bit is 1, the rejected
                                                     accessing is WRITE.                                                       */
      __IM  uint32_t EXTMEM_REJECT_CHANNEL_NUM : 4;/*!< The register indicate the reject accessing from which channel.         */
      __IM  uint32_t EXTMEM_REJECT_PERI_NUM : 6;/*!< This register indicate reject accessing from which peripheral.            */
            uint32_t            : 20;
    } bit;
  } EXTMEM_REJECT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw interrupt status of external RAM permission                           */
    
    struct {
      __IOM uint32_t EXTMEM_REJECT_INT_RAW : 1; /*!< The raw interrupt bit turns to high level when accessing external
                                                     RAM is rejected by permission control.                                    */
            uint32_t            : 31;
    } bit;
  } EXTMEM_REJECT_INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt status of external RAM permission                        */
    
    struct {
      __IM  uint32_t EXTMEM_REJECT_INT_ST : 1;  /*!< The raw interrupt status bit for the EXTMEM_REJECT_INT interrupt.         */
            uint32_t            : 31;
    } bit;
  } EXTMEM_REJECT_INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of external RAM permission                          */
    
    struct {
      __IOM uint32_t EXTMEM_REJECT_INT_ENA : 1; /*!< The interrupt enable bit for the EXTMEM_REJECT_INT interrupt.             */
            uint32_t            : 31;
    } bit;
  } EXTMEM_REJECT_INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of external RAM permission                           */
    
    struct {
      __OM  uint32_t EXTMEM_REJECT_INT_CLR : 1; /*!< Set this bit to clear the EXTMEM_REJECT_INT interrupt.                    */
            uint32_t            : 31;
    } bit;
  } EXTMEM_REJECT_INT_CLR;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Receive L2 FIFO depth of Rx channel 0                                     */
      
      struct {
        __IOM uint32_t IN_SIZE  : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Rx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
              uint32_t          : 25;
      } bit;
    } IN_SRAM_SIZE_CH2;
    
    union {
      __IOM uint32_t reg;                       /*!< Version control register                                                  */
      
      struct {
        __IOM uint32_t DATE     : 32;           /*!< register version.                                                         */
      } bit;
    } DATE;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit L2 FIFO depth of Tx channel 0                                    */
    
    struct {
      __IOM uint32_t OUT_SIZE   : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Tx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
            uint32_t            : 25;
    } bit;
  } OUT_SRAM_SIZE_CH2;
  __IM  uint32_t  RESERVED9[6];
  
  union {
    __IOM uint32_t reg;                         /*!< Receive L2 FIFO depth of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t IN_SIZE    : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Rx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
            uint32_t            : 25;
    } bit;
  } IN_SRAM_SIZE_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit L2 FIFO depth of Tx channel 0                                    */
    
    struct {
      __IOM uint32_t OUT_SIZE   : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Tx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
            uint32_t            : 25;
    } bit;
  } OUT_SRAM_SIZE_CH3;
  __IM  uint32_t  RESERVED10[6];
  
  union {
    __IOM uint32_t reg;                         /*!< Receive L2 FIFO depth of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t IN_SIZE    : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Rx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
            uint32_t            : 25;
    } bit;
  } IN_SRAM_SIZE_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit L2 FIFO depth of Tx channel 0                                    */
    
    struct {
      __IOM uint32_t OUT_SIZE   : 7;            /*!< This register is used to configure the size of L2 Tx FIFO for
                                                     Tx channel 0. 0:16 bytes. 1:24 bytes. 2:32 bytes. 3: 40
                                                     bytes. 4: 48 bytes. 5:56 bytes. 6: 64 bytes. 7: 72 bytes.
                                                     8: 80 bytes.                                                              */
            uint32_t            : 25;
    } bit;
  } OUT_SRAM_SIZE_CH4;
  __IM  uint32_t  RESERVED11[107];
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_RST     : 1;            /*!< This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.       */
      __IOM uint32_t IN_LOOP_TEST : 1;          /*!< reserved                                                                  */
      __IOM uint32_t INDSCR_BURST_EN : 1;       /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t IN_DATA_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 receiving data when accessing internal SRAM.                            */
      __IOM uint32_t MEM_TRANS_EN : 1;          /*!< Set this bit 1 to enable automatic transmitting data from memory
                                                     to memory via DMA.                                                        */
            uint32_t            : 27;
    } bit;
  } IN_CONF0_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t DMA_INFIFO_FULL_THRS : 12; /*!< This register is used to generate the INFIFO_FULL_WM_INT interrupt
                                                     when Rx channel 0 received byte number in Rx FIFO is up
                                                     to the value of the register.                                             */
      __IOM uint32_t IN_CHECK_OWNER : 1;        /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t IN_EXT_MEM_BK_SIZE : 2;    /*!< Block size of Rx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } IN_CONF1_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0.                                                             */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0. For UHCI0, the raw interrupt bit turns to
                                                     high level when the last data pointed by one inlink descriptor
                                                     has been received and no data error is detected for Rx
                                                     channel 0.                                                                */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt bit turns to high level when data error is
                                                     detected only in the case that the peripheral is UHCI0
                                                     for Rx channel 0. For other peripherals, this raw interrupt
                                                     is reserved.                                                              */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt bit turns to high level when detecting inlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of inlink descriptor for Rx channel 0.                   */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt bit turns to high level when Rx buffer pointed
                                                     by inlink is full and receiving data is not completed,
                                                     but there is no more inlink for Rx channel 0.                             */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt bit turns to high level when received data
                                                     byte number is up to threshold configured by REG_DMA_INFIFO_FULL_THRS_CH0
                                                     in Rx FIFO of channel 0.                                                  */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is underflow.                                             */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is underflow.                                             */
            uint32_t            : 22;
    } bit;
  } IN_INT_RAW_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Rx channel 0                                          */
    
    struct {
      __IM  uint32_t IN_DONE    : 1;            /*!< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.            */
      __IM  uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.        */
      __IM  uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt status bit for the INFIFO_FULL_WM_CH_INT interrupt.     */
      __IM  uint32_t INFIFO_OVF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_OVF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L3_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L3_CH_INT interrupt.      */
            uint32_t            : 22;
    } bit;
  } IN_INT_ST_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The interrupt enable bit for the IN_DONE_CH_INT interrupt.                */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.            */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The interrupt enable bit for the INFIFO_FULL_WM_CH_INT interrupt.         */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L3_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L3_CH_INT interrupt.          */
            uint32_t            : 22;
    } bit;
  } IN_INT_ENA_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Rx channel 0                                      */
    
    struct {
      __OM  uint32_t IN_DONE    : 1;            /*!< Set this bit to clear the IN_DONE_CH_INT interrupt.                       */
      __OM  uint32_t IN_SUC_EOF : 1;            /*!< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_ERR_EOF : 1;            /*!< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_DSCR_ERR : 1;           /*!< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.                   */
      __OM  uint32_t IN_DSCR_EMPTY : 1;         /*!< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.                 */
      __OM  uint32_t DMA_INFIFO_FULL_WM : 1;    /*!< Set this bit to clear the INFIFO_FULL_WM_CH_INT interrupt.                */
      __OM  uint32_t INFIFO_OVF_L1 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L1 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_OVF_L3 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L3_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L3 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L3_CH_INT interrupt.                 */
            uint32_t            : 22;
    } bit;
  } IN_INT_CLR_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive FIFO status of Rx channel 0                                       */
    
    struct {
      __IM  uint32_t INFIFO_FULL_L1 : 1;        /*!< L1 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L1 : 1;       /*!< L1 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L2 : 1;        /*!< L2 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L2 : 1;       /*!< L2 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L3 : 1;        /*!< L3 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L3 : 1;       /*!< L3 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_CNT_L1 : 6;         /*!< The register stores the byte number of the data in L1 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L2 : 7;         /*!< The register stores the byte number of the data in L2 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L3 : 5;         /*!< The register stores the byte number of the data in L3 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t IN_REMAIN_UNDER_1B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_2B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_3B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_4B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_BUF_HUNGRY : 1;         /*!< reserved                                                                  */
            uint32_t            : 3;
    } bit;
  } INFIFO_STATUS_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Pop control register of Rx channel 0                                      */
    
    struct {
      __IM  uint32_t INFIFO_RDATA : 12;         /*!< This register stores the data popping from DMA FIFO.                      */
      __IOM uint32_t INFIFO_POP : 1;            /*!< Set this bit to pop data from DMA FIFO.                                   */
            uint32_t            : 19;
    } bit;
  } IN_POP_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Rx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t INLINK_ADDR : 20;          /*!< This register stores the 20 least significant bits of the first
                                                     inlink descriptor's address.                                              */
      __IOM uint32_t INLINK_AUTO_RET : 1;       /*!< Set this bit to return to current inlink descriptor's address,
                                                     when there are some errors in current receiving data.                     */
      __IOM uint32_t INLINK_STOP : 1;           /*!< Set this bit to stop dealing with the inlink descriptors.                 */
      __IOM uint32_t INLINK_START : 1;          /*!< Set this bit to start dealing with the inlink descriptors.                */
      __IOM uint32_t INLINK_RESTART : 1;        /*!< Set this bit to mount a new inlink descriptor.                            */
      __IM  uint32_t INLINK_PARK : 1;           /*!< 1: the inlink descriptor's FSM is in idle state. 0: the inlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 7;
    } bit;
  } IN_LINK_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive status of Rx channel 0                                            */
    
    struct {
      __IM  uint32_t INLINK_DSCR_ADDR : 18;     /*!< This register stores the current inlink descriptor's address.             */
      __IM  uint32_t IN_DSCR_STATE : 2;         /*!< reserved                                                                  */
      __IM  uint32_t IN_STATE   : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } IN_STATE_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when EOF occurs of Rx channel 0                 */
    
    struct {
      __IM  uint32_t IN_SUC_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } IN_SUC_EOF_DES_ADDR_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when errors occur of Rx channel 0               */
    
    struct {
      __IM  uint32_t IN_ERR_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     there are some errors in current receiving data. Only used
                                                     when peripheral is UHCI0.                                                 */
    } bit;
  } IN_ERR_EOF_DES_ADDR_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Rx channel 0                         */
    
    struct {
      __IM  uint32_t INLINK_DSCR : 32;          /*!< The address of the current inlink descriptor x.                           */
    } bit;
  } IN_DSCR_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Rx channel 0                        */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF0 : 32;      /*!< The address of the last inlink descriptor x-1.                            */
    } bit;
  } IN_DSCR_BF0_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Rx channel 0              */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF1 : 32;      /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } IN_DSCR_BF1_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t RX_WEIGHT  : 4;            /*!< The weight of Rx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } IN_WIGHT_CH2;
  __IM  uint32_t  RESERVED12;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Rx channel 0                                         */
    
    struct {
      __IOM uint32_t RX_PRI     : 4;            /*!< The priority of Rx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } IN_PRI_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_IN_SEL : 6;           /*!< This register is used to select peripheral for Rx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } IN_PERI_SEL_CH2;
  __IM  uint32_t  RESERVED13[5];
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_RST    : 1;            /*!< This bit is used to reset DMA channel 0 Tx FSM and Tx FIFO pointer.       */
      __IOM uint32_t OUT_LOOP_TEST : 1;         /*!< reserved                                                                  */
      __IOM uint32_t OUT_AUTO_WRBACK : 1;       /*!< Set this bit to enable automatic outlink-writeback when all
                                                     the data in tx buffer has been transmitted.                               */
      __IOM uint32_t OUT_EOF_MODE : 1;          /*!< EOF flag generation mode when transmitting data. 1: EOF flag
                                                     for Tx channel 0 is generated when data need to transmit
                                                     has been popped from FIFO in DMA                                          */
      __IOM uint32_t OUTDSCR_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t OUT_DATA_BURST_EN : 1;     /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 transmitting data when accessing internal SRAM.                         */
            uint32_t            : 26;
    } bit;
  } OUT_CONF0_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Tx channel 0                                      */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t OUT_CHECK_OWNER : 1;       /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t OUT_EXT_MEM_BK_SIZE : 2;   /*!< Block size of Tx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } OUT_CONF1_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been transmitted
                                                     to peripherals for Tx channel 0.                                          */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been read from memory
                                                     for Tx channel 0.                                                         */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt bit turns to high level when detecting outlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of outlink descriptor for Tx channel 0.                  */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt bit turns to high level when data corresponding
                                                     a outlink (includes one link descriptor or few link descriptors)
                                                     is transmitted out for Tx channel 0.                                      */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is underflow.                                             */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is underflow.                                             */
            uint32_t            : 24;
    } bit;
  } OUT_INT_RAW_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Tx channel 0                                          */
    
    struct {
      __IM  uint32_t OUT_DONE   : 1;            /*!< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.           */
      __IM  uint32_t OUT_EOF    : 1;            /*!< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.            */
      __IM  uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.       */
      __IM  uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.      */
      __IM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L3_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L3_CH_INT interrupt.     */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ST_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Tx channel 0                                     */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.               */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.                */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.           */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.          */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L3_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L3_CH_INT interrupt.         */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ENA_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Tx channel 0                                      */
    
    struct {
      __OM  uint32_t OUT_DONE   : 1;            /*!< Set this bit to clear the OUT_DONE_CH_INT interrupt.                      */
      __OM  uint32_t OUT_EOF    : 1;            /*!< Set this bit to clear the OUT_EOF_CH_INT interrupt.                       */
      __OM  uint32_t OUT_DSCR_ERR : 1;          /*!< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.                  */
      __OM  uint32_t OUT_TOTAL_EOF : 1;         /*!< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.                 */
      __OM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L3_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L3_CH_INT interrupt.                */
            uint32_t            : 24;
    } bit;
  } OUT_INT_CLR_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit FIFO status of Tx channel 0                                      */
    
    struct {
      __IM  uint32_t OUTFIFO_FULL_L1 : 1;       /*!< L1 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L1 : 1;      /*!< L1 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L2 : 1;       /*!< L2 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L2 : 1;      /*!< L2 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L3 : 1;       /*!< L3 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L3 : 1;      /*!< L3 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_CNT_L1 : 5;        /*!< The register stores the byte number of the data in L1 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L2 : 7;        /*!< The register stores the byte number of the data in L2 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L3 : 5;        /*!< The register stores the byte number of the data in L3 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUT_REMAIN_UNDER_1B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_2B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_3B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_4B_L3 : 1;/*!< reserved                                                                  */
            uint32_t            : 5;
    } bit;
  } OUTFIFO_STATUS_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Push control register of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t OUTFIFO_WDATA : 9;         /*!< This register stores the data that need to be pushed into DMA
                                                     FIFO.                                                                     */
      __IOM uint32_t OUTFIFO_PUSH : 1;          /*!< Set this bit to push data into DMA FIFO.                                  */
            uint32_t            : 22;
    } bit;
  } OUT_PUSH_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Tx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t OUTLINK_ADDR : 20;         /*!< This register stores the 20 least significant bits of the first
                                                     outlink descriptor's address.                                             */
      __IOM uint32_t OUTLINK_STOP : 1;          /*!< Set this bit to stop dealing with the outlink descriptors.                */
      __IOM uint32_t OUTLINK_START : 1;         /*!< Set this bit to start dealing with the outlink descriptors.               */
      __IOM uint32_t OUTLINK_RESTART : 1;       /*!< Set this bit to restart a new outlink from the last address.              */
      __IM  uint32_t OUTLINK_PARK : 1;          /*!< 1: the outlink descriptor's FSM is in idle state. 0: the outlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 8;
    } bit;
  } OUT_LINK_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit status of Tx channel 0                                           */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_ADDR : 18;    /*!< This register stores the current outlink descriptor's address.            */
      __IM  uint32_t OUT_DSCR_STATE : 2;        /*!< reserved                                                                  */
      __IM  uint32_t OUT_STATE  : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } OUT_STATE_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Outlink descriptor address when EOF occurs of Tx channel 0                */
    
    struct {
      __IM  uint32_t OUT_EOF_DES_ADDR : 32;     /*!< This register stores the address of the outlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } OUT_EOF_DES_ADDR_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< The last outlink descriptor address when EOF occurs of Tx channel
                                                     0                                                                         */
    
    struct {
      __IM  uint32_t OUT_EOF_BFR_DES_ADDR : 32; /*!< This register stores the address of the outlink descriptor before
                                                     the last outlink descriptor.                                              */
    } bit;
  } OUT_EOF_BFR_DES_ADDR_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Tx channel 0                         */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR : 32;         /*!< The address of the current outlink descriptor y.                          */
    } bit;
  } OUT_DSCR_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Tx channel 0                        */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF0 : 32;     /*!< The address of the last outlink descriptor y-1.                           */
    } bit;
  } OUT_DSCR_BF0_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Tx channel 0              */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF1 : 32;     /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } OUT_DSCR_BF1_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t TX_WEIGHT  : 4;            /*!< The weight of Tx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } OUT_WIGHT_CH2;
  __IM  uint32_t  RESERVED14;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Tx channel 0.                                        */
    
    struct {
      __IOM uint32_t TX_PRI     : 4;            /*!< The priority of Tx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } OUT_PRI_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_OUT_SEL : 6;          /*!< This register is used to select peripheral for Tx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } OUT_PERI_SEL_CH2;
  __IM  uint32_t  RESERVED15[149];
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_RST     : 1;            /*!< This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.       */
      __IOM uint32_t IN_LOOP_TEST : 1;          /*!< reserved                                                                  */
      __IOM uint32_t INDSCR_BURST_EN : 1;       /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t IN_DATA_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 receiving data when accessing internal SRAM.                            */
      __IOM uint32_t MEM_TRANS_EN : 1;          /*!< Set this bit 1 to enable automatic transmitting data from memory
                                                     to memory via DMA.                                                        */
            uint32_t            : 27;
    } bit;
  } IN_CONF0_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t DMA_INFIFO_FULL_THRS : 12; /*!< This register is used to generate the INFIFO_FULL_WM_INT interrupt
                                                     when Rx channel 0 received byte number in Rx FIFO is up
                                                     to the value of the register.                                             */
      __IOM uint32_t IN_CHECK_OWNER : 1;        /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t IN_EXT_MEM_BK_SIZE : 2;    /*!< Block size of Rx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } IN_CONF1_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0.                                                             */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0. For UHCI0, the raw interrupt bit turns to
                                                     high level when the last data pointed by one inlink descriptor
                                                     has been received and no data error is detected for Rx
                                                     channel 0.                                                                */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt bit turns to high level when data error is
                                                     detected only in the case that the peripheral is UHCI0
                                                     for Rx channel 0. For other peripherals, this raw interrupt
                                                     is reserved.                                                              */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt bit turns to high level when detecting inlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of inlink descriptor for Rx channel 0.                   */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt bit turns to high level when Rx buffer pointed
                                                     by inlink is full and receiving data is not completed,
                                                     but there is no more inlink for Rx channel 0.                             */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt bit turns to high level when received data
                                                     byte number is up to threshold configured by REG_DMA_INFIFO_FULL_THRS_CH0
                                                     in Rx FIFO of channel 0.                                                  */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is underflow.                                             */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is underflow.                                             */
            uint32_t            : 22;
    } bit;
  } IN_INT_RAW_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Rx channel 0                                          */
    
    struct {
      __IM  uint32_t IN_DONE    : 1;            /*!< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.            */
      __IM  uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.        */
      __IM  uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt status bit for the INFIFO_FULL_WM_CH_INT interrupt.     */
      __IM  uint32_t INFIFO_OVF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_OVF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L3_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L3_CH_INT interrupt.      */
            uint32_t            : 22;
    } bit;
  } IN_INT_ST_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The interrupt enable bit for the IN_DONE_CH_INT interrupt.                */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.            */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The interrupt enable bit for the INFIFO_FULL_WM_CH_INT interrupt.         */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L3_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L3_CH_INT interrupt.          */
            uint32_t            : 22;
    } bit;
  } IN_INT_ENA_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Rx channel 0                                      */
    
    struct {
      __OM  uint32_t IN_DONE    : 1;            /*!< Set this bit to clear the IN_DONE_CH_INT interrupt.                       */
      __OM  uint32_t IN_SUC_EOF : 1;            /*!< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_ERR_EOF : 1;            /*!< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_DSCR_ERR : 1;           /*!< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.                   */
      __OM  uint32_t IN_DSCR_EMPTY : 1;         /*!< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.                 */
      __OM  uint32_t DMA_INFIFO_FULL_WM : 1;    /*!< Set this bit to clear the INFIFO_FULL_WM_CH_INT interrupt.                */
      __OM  uint32_t INFIFO_OVF_L1 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L1 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_OVF_L3 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L3_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L3 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L3_CH_INT interrupt.                 */
            uint32_t            : 22;
    } bit;
  } IN_INT_CLR_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive FIFO status of Rx channel 0                                       */
    
    struct {
      __IM  uint32_t INFIFO_FULL_L1 : 1;        /*!< L1 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L1 : 1;       /*!< L1 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L2 : 1;        /*!< L2 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L2 : 1;       /*!< L2 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L3 : 1;        /*!< L3 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L3 : 1;       /*!< L3 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_CNT_L1 : 6;         /*!< The register stores the byte number of the data in L1 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L2 : 7;         /*!< The register stores the byte number of the data in L2 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L3 : 5;         /*!< The register stores the byte number of the data in L3 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t IN_REMAIN_UNDER_1B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_2B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_3B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_4B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_BUF_HUNGRY : 1;         /*!< reserved                                                                  */
            uint32_t            : 3;
    } bit;
  } INFIFO_STATUS_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Pop control register of Rx channel 0                                      */
    
    struct {
      __IM  uint32_t INFIFO_RDATA : 12;         /*!< This register stores the data popping from DMA FIFO.                      */
      __IOM uint32_t INFIFO_POP : 1;            /*!< Set this bit to pop data from DMA FIFO.                                   */
            uint32_t            : 19;
    } bit;
  } IN_POP_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Rx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t INLINK_ADDR : 20;          /*!< This register stores the 20 least significant bits of the first
                                                     inlink descriptor's address.                                              */
      __IOM uint32_t INLINK_AUTO_RET : 1;       /*!< Set this bit to return to current inlink descriptor's address,
                                                     when there are some errors in current receiving data.                     */
      __IOM uint32_t INLINK_STOP : 1;           /*!< Set this bit to stop dealing with the inlink descriptors.                 */
      __IOM uint32_t INLINK_START : 1;          /*!< Set this bit to start dealing with the inlink descriptors.                */
      __IOM uint32_t INLINK_RESTART : 1;        /*!< Set this bit to mount a new inlink descriptor.                            */
      __IM  uint32_t INLINK_PARK : 1;           /*!< 1: the inlink descriptor's FSM is in idle state. 0: the inlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 7;
    } bit;
  } IN_LINK_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive status of Rx channel 0                                            */
    
    struct {
      __IM  uint32_t INLINK_DSCR_ADDR : 18;     /*!< This register stores the current inlink descriptor's address.             */
      __IM  uint32_t IN_DSCR_STATE : 2;         /*!< reserved                                                                  */
      __IM  uint32_t IN_STATE   : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } IN_STATE_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when EOF occurs of Rx channel 0                 */
    
    struct {
      __IM  uint32_t IN_SUC_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } IN_SUC_EOF_DES_ADDR_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when errors occur of Rx channel 0               */
    
    struct {
      __IM  uint32_t IN_ERR_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     there are some errors in current receiving data. Only used
                                                     when peripheral is UHCI0.                                                 */
    } bit;
  } IN_ERR_EOF_DES_ADDR_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Rx channel 0                         */
    
    struct {
      __IM  uint32_t INLINK_DSCR : 32;          /*!< The address of the current inlink descriptor x.                           */
    } bit;
  } IN_DSCR_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Rx channel 0                        */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF0 : 32;      /*!< The address of the last inlink descriptor x-1.                            */
    } bit;
  } IN_DSCR_BF0_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Rx channel 0              */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF1 : 32;      /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } IN_DSCR_BF1_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t RX_WEIGHT  : 4;            /*!< The weight of Rx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } IN_WIGHT_CH3;
  __IM  uint32_t  RESERVED16;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Rx channel 0                                         */
    
    struct {
      __IOM uint32_t RX_PRI     : 4;            /*!< The priority of Rx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } IN_PRI_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_IN_SEL : 6;           /*!< This register is used to select peripheral for Rx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } IN_PERI_SEL_CH3;
  __IM  uint32_t  RESERVED17[5];
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_RST    : 1;            /*!< This bit is used to reset DMA channel 0 Tx FSM and Tx FIFO pointer.       */
      __IOM uint32_t OUT_LOOP_TEST : 1;         /*!< reserved                                                                  */
      __IOM uint32_t OUT_AUTO_WRBACK : 1;       /*!< Set this bit to enable automatic outlink-writeback when all
                                                     the data in tx buffer has been transmitted.                               */
      __IOM uint32_t OUT_EOF_MODE : 1;          /*!< EOF flag generation mode when transmitting data. 1: EOF flag
                                                     for Tx channel 0 is generated when data need to transmit
                                                     has been popped from FIFO in DMA                                          */
      __IOM uint32_t OUTDSCR_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t OUT_DATA_BURST_EN : 1;     /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 transmitting data when accessing internal SRAM.                         */
            uint32_t            : 26;
    } bit;
  } OUT_CONF0_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Tx channel 0                                      */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t OUT_CHECK_OWNER : 1;       /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t OUT_EXT_MEM_BK_SIZE : 2;   /*!< Block size of Tx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } OUT_CONF1_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been transmitted
                                                     to peripherals for Tx channel 0.                                          */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been read from memory
                                                     for Tx channel 0.                                                         */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt bit turns to high level when detecting outlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of outlink descriptor for Tx channel 0.                  */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt bit turns to high level when data corresponding
                                                     a outlink (includes one link descriptor or few link descriptors)
                                                     is transmitted out for Tx channel 0.                                      */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is underflow.                                             */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is underflow.                                             */
            uint32_t            : 24;
    } bit;
  } OUT_INT_RAW_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Tx channel 0                                          */
    
    struct {
      __IM  uint32_t OUT_DONE   : 1;            /*!< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.           */
      __IM  uint32_t OUT_EOF    : 1;            /*!< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.            */
      __IM  uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.       */
      __IM  uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.      */
      __IM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L3_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L3_CH_INT interrupt.     */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ST_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Tx channel 0                                     */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.               */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.                */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.           */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.          */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L3_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L3_CH_INT interrupt.         */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ENA_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Tx channel 0                                      */
    
    struct {
      __OM  uint32_t OUT_DONE   : 1;            /*!< Set this bit to clear the OUT_DONE_CH_INT interrupt.                      */
      __OM  uint32_t OUT_EOF    : 1;            /*!< Set this bit to clear the OUT_EOF_CH_INT interrupt.                       */
      __OM  uint32_t OUT_DSCR_ERR : 1;          /*!< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.                  */
      __OM  uint32_t OUT_TOTAL_EOF : 1;         /*!< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.                 */
      __OM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L3_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L3_CH_INT interrupt.                */
            uint32_t            : 24;
    } bit;
  } OUT_INT_CLR_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit FIFO status of Tx channel 0                                      */
    
    struct {
      __IM  uint32_t OUTFIFO_FULL_L1 : 1;       /*!< L1 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L1 : 1;      /*!< L1 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L2 : 1;       /*!< L2 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L2 : 1;      /*!< L2 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L3 : 1;       /*!< L3 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L3 : 1;      /*!< L3 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_CNT_L1 : 5;        /*!< The register stores the byte number of the data in L1 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L2 : 7;        /*!< The register stores the byte number of the data in L2 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L3 : 5;        /*!< The register stores the byte number of the data in L3 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUT_REMAIN_UNDER_1B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_2B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_3B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_4B_L3 : 1;/*!< reserved                                                                  */
            uint32_t            : 5;
    } bit;
  } OUTFIFO_STATUS_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Push control register of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t OUTFIFO_WDATA : 9;         /*!< This register stores the data that need to be pushed into DMA
                                                     FIFO.                                                                     */
      __IOM uint32_t OUTFIFO_PUSH : 1;          /*!< Set this bit to push data into DMA FIFO.                                  */
            uint32_t            : 22;
    } bit;
  } OUT_PUSH_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Tx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t OUTLINK_ADDR : 20;         /*!< This register stores the 20 least significant bits of the first
                                                     outlink descriptor's address.                                             */
      __IOM uint32_t OUTLINK_STOP : 1;          /*!< Set this bit to stop dealing with the outlink descriptors.                */
      __IOM uint32_t OUTLINK_START : 1;         /*!< Set this bit to start dealing with the outlink descriptors.               */
      __IOM uint32_t OUTLINK_RESTART : 1;       /*!< Set this bit to restart a new outlink from the last address.              */
      __IM  uint32_t OUTLINK_PARK : 1;          /*!< 1: the outlink descriptor's FSM is in idle state. 0: the outlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 8;
    } bit;
  } OUT_LINK_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit status of Tx channel 0                                           */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_ADDR : 18;    /*!< This register stores the current outlink descriptor's address.            */
      __IM  uint32_t OUT_DSCR_STATE : 2;        /*!< reserved                                                                  */
      __IM  uint32_t OUT_STATE  : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } OUT_STATE_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Outlink descriptor address when EOF occurs of Tx channel 0                */
    
    struct {
      __IM  uint32_t OUT_EOF_DES_ADDR : 32;     /*!< This register stores the address of the outlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } OUT_EOF_DES_ADDR_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< The last outlink descriptor address when EOF occurs of Tx channel
                                                     0                                                                         */
    
    struct {
      __IM  uint32_t OUT_EOF_BFR_DES_ADDR : 32; /*!< This register stores the address of the outlink descriptor before
                                                     the last outlink descriptor.                                              */
    } bit;
  } OUT_EOF_BFR_DES_ADDR_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Tx channel 0                         */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR : 32;         /*!< The address of the current outlink descriptor y.                          */
    } bit;
  } OUT_DSCR_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Tx channel 0                        */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF0 : 32;     /*!< The address of the last outlink descriptor y-1.                           */
    } bit;
  } OUT_DSCR_BF0_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Tx channel 0              */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF1 : 32;     /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } OUT_DSCR_BF1_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t TX_WEIGHT  : 4;            /*!< The weight of Tx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } OUT_WIGHT_CH3;
  __IM  uint32_t  RESERVED18;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Tx channel 0.                                        */
    
    struct {
      __IOM uint32_t TX_PRI     : 4;            /*!< The priority of Tx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } OUT_PRI_CH3;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_OUT_SEL : 6;          /*!< This register is used to select peripheral for Tx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } OUT_PERI_SEL_CH3;
  __IM  uint32_t  RESERVED19[149];
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_RST     : 1;            /*!< This bit is used to reset DMA channel 0 Rx FSM and Rx FIFO pointer.       */
      __IOM uint32_t IN_LOOP_TEST : 1;          /*!< reserved                                                                  */
      __IOM uint32_t INDSCR_BURST_EN : 1;       /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t IN_DATA_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Rx channel
                                                     0 receiving data when accessing internal SRAM.                            */
      __IOM uint32_t MEM_TRANS_EN : 1;          /*!< Set this bit 1 to enable automatic transmitting data from memory
                                                     to memory via DMA.                                                        */
            uint32_t            : 27;
    } bit;
  } IN_CONF0_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t DMA_INFIFO_FULL_THRS : 12; /*!< This register is used to generate the INFIFO_FULL_WM_INT interrupt
                                                     when Rx channel 0 received byte number in Rx FIFO is up
                                                     to the value of the register.                                             */
      __IOM uint32_t IN_CHECK_OWNER : 1;        /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t IN_EXT_MEM_BK_SIZE : 2;    /*!< Block size of Rx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } IN_CONF1_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0.                                                             */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one inlink descriptor has been received for
                                                     Rx channel 0. For UHCI0, the raw interrupt bit turns to
                                                     high level when the last data pointed by one inlink descriptor
                                                     has been received and no data error is detected for Rx
                                                     channel 0.                                                                */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt bit turns to high level when data error is
                                                     detected only in the case that the peripheral is UHCI0
                                                     for Rx channel 0. For other peripherals, this raw interrupt
                                                     is reserved.                                                              */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt bit turns to high level when detecting inlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of inlink descriptor for Rx channel 0.                   */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt bit turns to high level when Rx buffer pointed
                                                     by inlink is full and receiving data is not completed,
                                                     but there is no more inlink for Rx channel 0.                             */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt bit turns to high level when received data
                                                     byte number is up to threshold configured by REG_DMA_INFIFO_FULL_THRS_CH0
                                                     in Rx FIFO of channel 0.                                                  */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Rx channel 0 is underflow.                                             */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is overflow.                                              */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Rx channel 0 is underflow.                                             */
            uint32_t            : 22;
    } bit;
  } IN_INT_RAW_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Rx channel 0                                          */
    
    struct {
      __IM  uint32_t IN_DONE    : 1;            /*!< The raw interrupt status bit for the IN_DONE_CH_INT interrupt.            */
      __IM  uint32_t IN_SUC_EOF : 1;            /*!< The raw interrupt status bit for the IN_SUC_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_ERR_EOF : 1;            /*!< The raw interrupt status bit for the IN_ERR_EOF_CH_INT interrupt.         */
      __IM  uint32_t IN_DSCR_ERR : 1;           /*!< The raw interrupt status bit for the IN_DSCR_ERR_CH_INT interrupt.        */
      __IM  uint32_t IN_DSCR_EMPTY : 1;         /*!< The raw interrupt status bit for the IN_DSCR_EMPTY_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_FULL_WM : 1;        /*!< The raw interrupt status bit for the INFIFO_FULL_WM_CH_INT interrupt.     */
      __IM  uint32_t INFIFO_OVF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L1 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L1_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_OVF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_OVF_L3_CH_INT interrupt.      */
      __IM  uint32_t INFIFO_UDF_L3 : 1;         /*!< The raw interrupt status bit for the INFIFO_UDF_L3_CH_INT interrupt.      */
            uint32_t            : 22;
    } bit;
  } IN_INT_ST_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t IN_DONE    : 1;            /*!< The interrupt enable bit for the IN_DONE_CH_INT interrupt.                */
      __IOM uint32_t IN_SUC_EOF : 1;            /*!< The interrupt enable bit for the IN_SUC_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_ERR_EOF : 1;            /*!< The interrupt enable bit for the IN_ERR_EOF_CH_INT interrupt.             */
      __IOM uint32_t IN_DSCR_ERR : 1;           /*!< The interrupt enable bit for the IN_DSCR_ERR_CH_INT interrupt.            */
      __IOM uint32_t IN_DSCR_EMPTY : 1;         /*!< The interrupt enable bit for the IN_DSCR_EMPTY_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_FULL_WM : 1;        /*!< The interrupt enable bit for the INFIFO_FULL_WM_CH_INT interrupt.         */
      __IOM uint32_t INFIFO_OVF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L1 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L1_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_OVF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_OVF_L3_CH_INT interrupt.          */
      __IOM uint32_t INFIFO_UDF_L3 : 1;         /*!< The interrupt enable bit for the INFIFO_UDF_L3_CH_INT interrupt.          */
            uint32_t            : 22;
    } bit;
  } IN_INT_ENA_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Rx channel 0                                      */
    
    struct {
      __OM  uint32_t IN_DONE    : 1;            /*!< Set this bit to clear the IN_DONE_CH_INT interrupt.                       */
      __OM  uint32_t IN_SUC_EOF : 1;            /*!< Set this bit to clear the IN_SUC_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_ERR_EOF : 1;            /*!< Set this bit to clear the IN_ERR_EOF_CH_INT interrupt.                    */
      __OM  uint32_t IN_DSCR_ERR : 1;           /*!< Set this bit to clear the IN_DSCR_ERR_CH_INT interrupt.                   */
      __OM  uint32_t IN_DSCR_EMPTY : 1;         /*!< Set this bit to clear the IN_DSCR_EMPTY_CH_INT interrupt.                 */
      __OM  uint32_t DMA_INFIFO_FULL_WM : 1;    /*!< Set this bit to clear the INFIFO_FULL_WM_CH_INT interrupt.                */
      __OM  uint32_t INFIFO_OVF_L1 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L1 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L1_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_OVF_L3 : 1;         /*!< Set this bit to clear the INFIFO_OVF_L3_CH_INT interrupt.                 */
      __OM  uint32_t INFIFO_UDF_L3 : 1;         /*!< Set this bit to clear the INFIFO_UDF_L3_CH_INT interrupt.                 */
            uint32_t            : 22;
    } bit;
  } IN_INT_CLR_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive FIFO status of Rx channel 0                                       */
    
    struct {
      __IM  uint32_t INFIFO_FULL_L1 : 1;        /*!< L1 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L1 : 1;       /*!< L1 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L2 : 1;        /*!< L2 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L2 : 1;       /*!< L2 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_FULL_L3 : 1;        /*!< L3 Rx FIFO full signal for Rx channel 0.                                  */
      __IM  uint32_t INFIFO_EMPTY_L3 : 1;       /*!< L3 Rx FIFO empty signal for Rx channel 0.                                 */
      __IM  uint32_t INFIFO_CNT_L1 : 6;         /*!< The register stores the byte number of the data in L1 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L2 : 7;         /*!< The register stores the byte number of the data in L2 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t INFIFO_CNT_L3 : 5;         /*!< The register stores the byte number of the data in L3 Rx FIFO
                                                     for Rx channel 0.                                                         */
      __IM  uint32_t IN_REMAIN_UNDER_1B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_2B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_3B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_REMAIN_UNDER_4B_L3 : 1; /*!< reserved                                                                  */
      __IM  uint32_t IN_BUF_HUNGRY : 1;         /*!< reserved                                                                  */
            uint32_t            : 3;
    } bit;
  } INFIFO_STATUS_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Pop control register of Rx channel 0                                      */
    
    struct {
      __IM  uint32_t INFIFO_RDATA : 12;         /*!< This register stores the data popping from DMA FIFO.                      */
      __IOM uint32_t INFIFO_POP : 1;            /*!< Set this bit to pop data from DMA FIFO.                                   */
            uint32_t            : 19;
    } bit;
  } IN_POP_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Rx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t INLINK_ADDR : 20;          /*!< This register stores the 20 least significant bits of the first
                                                     inlink descriptor's address.                                              */
      __IOM uint32_t INLINK_AUTO_RET : 1;       /*!< Set this bit to return to current inlink descriptor's address,
                                                     when there are some errors in current receiving data.                     */
      __IOM uint32_t INLINK_STOP : 1;           /*!< Set this bit to stop dealing with the inlink descriptors.                 */
      __IOM uint32_t INLINK_START : 1;          /*!< Set this bit to start dealing with the inlink descriptors.                */
      __IOM uint32_t INLINK_RESTART : 1;        /*!< Set this bit to mount a new inlink descriptor.                            */
      __IM  uint32_t INLINK_PARK : 1;           /*!< 1: the inlink descriptor's FSM is in idle state. 0: the inlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 7;
    } bit;
  } IN_LINK_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive status of Rx channel 0                                            */
    
    struct {
      __IM  uint32_t INLINK_DSCR_ADDR : 18;     /*!< This register stores the current inlink descriptor's address.             */
      __IM  uint32_t IN_DSCR_STATE : 2;         /*!< reserved                                                                  */
      __IM  uint32_t IN_STATE   : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } IN_STATE_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when EOF occurs of Rx channel 0                 */
    
    struct {
      __IM  uint32_t IN_SUC_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } IN_SUC_EOF_DES_ADDR_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Inlink descriptor address when errors occur of Rx channel 0               */
    
    struct {
      __IM  uint32_t IN_ERR_EOF_DES_ADDR : 32;  /*!< This register stores the address of the inlink descriptor when
                                                     there are some errors in current receiving data. Only used
                                                     when peripheral is UHCI0.                                                 */
    } bit;
  } IN_ERR_EOF_DES_ADDR_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Rx channel 0                         */
    
    struct {
      __IM  uint32_t INLINK_DSCR : 32;          /*!< The address of the current inlink descriptor x.                           */
    } bit;
  } IN_DSCR_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Rx channel 0                        */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF0 : 32;      /*!< The address of the last inlink descriptor x-1.                            */
    } bit;
  } IN_DSCR_BF0_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Rx channel 0              */
    
    struct {
      __IM  uint32_t INLINK_DSCR_BF1 : 32;      /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } IN_DSCR_BF1_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t RX_WEIGHT  : 4;            /*!< The weight of Rx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } IN_WIGHT_CH4;
  __IM  uint32_t  RESERVED20;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Rx channel 0                                         */
    
    struct {
      __IOM uint32_t RX_PRI     : 4;            /*!< The priority of Rx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } IN_PRI_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Rx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_IN_SEL : 6;           /*!< This register is used to select peripheral for Rx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } IN_PERI_SEL_CH4;
  __IM  uint32_t  RESERVED21[5];
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_RST    : 1;            /*!< This bit is used to reset DMA channel 0 Tx FSM and Tx FIFO pointer.       */
      __IOM uint32_t OUT_LOOP_TEST : 1;         /*!< reserved                                                                  */
      __IOM uint32_t OUT_AUTO_WRBACK : 1;       /*!< Set this bit to enable automatic outlink-writeback when all
                                                     the data in tx buffer has been transmitted.                               */
      __IOM uint32_t OUT_EOF_MODE : 1;          /*!< EOF flag generation mode when transmitting data. 1: EOF flag
                                                     for Tx channel 0 is generated when data need to transmit
                                                     has been popped from FIFO in DMA                                          */
      __IOM uint32_t OUTDSCR_BURST_EN : 1;      /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 reading link descriptor when accessing internal SRAM.                   */
      __IOM uint32_t OUT_DATA_BURST_EN : 1;     /*!< Set this bit to 1 to enable INCR burst transfer for Tx channel
                                                     0 transmitting data when accessing internal SRAM.                         */
            uint32_t            : 26;
    } bit;
  } OUT_CONF0_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 1 register of Tx channel 0                                      */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t OUT_CHECK_OWNER : 1;       /*!< Set this bit to enable checking the owner attribute of the link
                                                     descriptor.                                                               */
      __IOM uint32_t OUT_EXT_MEM_BK_SIZE : 2;   /*!< Block size of Tx channel 0 when DMA access external SRAM. 0:
                                                     16 bytes 1: 32 bytes 2/3:reserved                                         */
            uint32_t            : 17;
    } bit;
  } OUT_CONF1_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been transmitted
                                                     to peripherals for Tx channel 0.                                          */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The raw interrupt bit turns to high level when the last data
                                                     pointed by one outlink descriptor has been read from memory
                                                     for Tx channel 0.                                                         */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt bit turns to high level when detecting outlink
                                                     descriptor error, including owner error, the second and
                                                     third word error of outlink descriptor for Tx channel 0.                  */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt bit turns to high level when data corresponding
                                                     a outlink (includes one link descriptor or few link descriptors)
                                                     is transmitted out for Tx channel 0.                                      */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< This raw interrupt bit turns to high level when level 1 fifo
                                                     of Tx channel 0 is underflow.                                             */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is overflow.                                              */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< This raw interrupt bit turns to high level when level 3 fifo
                                                     of Tx channel 0 is underflow.                                             */
            uint32_t            : 24;
    } bit;
  } OUT_INT_RAW_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt of Tx channel 0                                          */
    
    struct {
      __IM  uint32_t OUT_DONE   : 1;            /*!< The raw interrupt status bit for the OUT_DONE_CH_INT interrupt.           */
      __IM  uint32_t OUT_EOF    : 1;            /*!< The raw interrupt status bit for the OUT_EOF_CH_INT interrupt.            */
      __IM  uint32_t OUT_DSCR_ERR : 1;          /*!< The raw interrupt status bit for the OUT_DSCR_ERR_CH_INT interrupt.       */
      __IM  uint32_t OUT_TOTAL_EOF : 1;         /*!< The raw interrupt status bit for the OUT_TOTAL_EOF_CH_INT interrupt.      */
      __IM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L1_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_OVF_L3_CH_INT interrupt.     */
      __IM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The raw interrupt status bit for the OUTFIFO_UDF_L3_CH_INT interrupt.     */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ST_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits of Tx channel 0                                     */
    
    struct {
      __IOM uint32_t OUT_DONE   : 1;            /*!< The interrupt enable bit for the OUT_DONE_CH_INT interrupt.               */
      __IOM uint32_t OUT_EOF    : 1;            /*!< The interrupt enable bit for the OUT_EOF_CH_INT interrupt.                */
      __IOM uint32_t OUT_DSCR_ERR : 1;          /*!< The interrupt enable bit for the OUT_DSCR_ERR_CH_INT interrupt.           */
      __IOM uint32_t OUT_TOTAL_EOF : 1;         /*!< The interrupt enable bit for the OUT_TOTAL_EOF_CH_INT interrupt.          */
      __IOM uint32_t OUTFIFO_OVF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L1 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L1_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_OVF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_OVF_L3_CH_INT interrupt.         */
      __IOM uint32_t OUTFIFO_UDF_L3 : 1;        /*!< The interrupt enable bit for the OUTFIFO_UDF_L3_CH_INT interrupt.         */
            uint32_t            : 24;
    } bit;
  } OUT_INT_ENA_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits of Tx channel 0                                      */
    
    struct {
      __OM  uint32_t OUT_DONE   : 1;            /*!< Set this bit to clear the OUT_DONE_CH_INT interrupt.                      */
      __OM  uint32_t OUT_EOF    : 1;            /*!< Set this bit to clear the OUT_EOF_CH_INT interrupt.                       */
      __OM  uint32_t OUT_DSCR_ERR : 1;          /*!< Set this bit to clear the OUT_DSCR_ERR_CH_INT interrupt.                  */
      __OM  uint32_t OUT_TOTAL_EOF : 1;         /*!< Set this bit to clear the OUT_TOTAL_EOF_CH_INT interrupt.                 */
      __OM  uint32_t OUTFIFO_OVF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L1 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L1_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_OVF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_OVF_L3_CH_INT interrupt.                */
      __OM  uint32_t OUTFIFO_UDF_L3 : 1;        /*!< Set this bit to clear the OUTFIFO_UDF_L3_CH_INT interrupt.                */
            uint32_t            : 24;
    } bit;
  } OUT_INT_CLR_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit FIFO status of Tx channel 0                                      */
    
    struct {
      __IM  uint32_t OUTFIFO_FULL_L1 : 1;       /*!< L1 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L1 : 1;      /*!< L1 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L2 : 1;       /*!< L2 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L2 : 1;      /*!< L2 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_FULL_L3 : 1;       /*!< L3 Tx FIFO full signal for Tx channel 0.                                  */
      __IM  uint32_t OUTFIFO_EMPTY_L3 : 1;      /*!< L3 Tx FIFO empty signal for Tx channel 0.                                 */
      __IM  uint32_t OUTFIFO_CNT_L1 : 5;        /*!< The register stores the byte number of the data in L1 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L2 : 7;        /*!< The register stores the byte number of the data in L2 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUTFIFO_CNT_L3 : 5;        /*!< The register stores the byte number of the data in L3 Tx FIFO
                                                     for Tx channel 0.                                                         */
      __IM  uint32_t OUT_REMAIN_UNDER_1B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_2B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_3B_L3 : 1;/*!< reserved                                                                  */
      __IM  uint32_t OUT_REMAIN_UNDER_4B_L3 : 1;/*!< reserved                                                                  */
            uint32_t            : 5;
    } bit;
  } OUTFIFO_STATUS_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Push control register of Rx channel 0                                     */
    
    struct {
      __IOM uint32_t OUTFIFO_WDATA : 9;         /*!< This register stores the data that need to be pushed into DMA
                                                     FIFO.                                                                     */
      __IOM uint32_t OUTFIFO_PUSH : 1;          /*!< Set this bit to push data into DMA FIFO.                                  */
            uint32_t            : 22;
    } bit;
  } OUT_PUSH_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Link descriptor configure and control register of Tx channel
                                                     0                                                                         */
    
    struct {
      __IOM uint32_t OUTLINK_ADDR : 20;         /*!< This register stores the 20 least significant bits of the first
                                                     outlink descriptor's address.                                             */
      __IOM uint32_t OUTLINK_STOP : 1;          /*!< Set this bit to stop dealing with the outlink descriptors.                */
      __IOM uint32_t OUTLINK_START : 1;         /*!< Set this bit to start dealing with the outlink descriptors.               */
      __IOM uint32_t OUTLINK_RESTART : 1;       /*!< Set this bit to restart a new outlink from the last address.              */
      __IM  uint32_t OUTLINK_PARK : 1;          /*!< 1: the outlink descriptor's FSM is in idle state. 0: the outlink
                                                     descriptor's FSM is working.                                              */
            uint32_t            : 8;
    } bit;
  } OUT_LINK_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit status of Tx channel 0                                           */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_ADDR : 18;    /*!< This register stores the current outlink descriptor's address.            */
      __IM  uint32_t OUT_DSCR_STATE : 2;        /*!< reserved                                                                  */
      __IM  uint32_t OUT_STATE  : 3;            /*!< reserved                                                                  */
            uint32_t            : 9;
    } bit;
  } OUT_STATE_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Outlink descriptor address when EOF occurs of Tx channel 0                */
    
    struct {
      __IM  uint32_t OUT_EOF_DES_ADDR : 32;     /*!< This register stores the address of the outlink descriptor when
                                                     the EOF bit in this descriptor is 1.                                      */
    } bit;
  } OUT_EOF_DES_ADDR_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< The last outlink descriptor address when EOF occurs of Tx channel
                                                     0                                                                         */
    
    struct {
      __IM  uint32_t OUT_EOF_BFR_DES_ADDR : 32; /*!< This register stores the address of the outlink descriptor before
                                                     the last outlink descriptor.                                              */
    } bit;
  } OUT_EOF_BFR_DES_ADDR_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Current inlink descriptor address of Tx channel 0                         */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR : 32;         /*!< The address of the current outlink descriptor y.                          */
    } bit;
  } OUT_DSCR_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< The last inlink descriptor address of Tx channel 0                        */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF0 : 32;     /*!< The address of the last outlink descriptor y-1.                           */
    } bit;
  } OUT_DSCR_BF0_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< The second-to-last inlink descriptor address of Tx channel 0              */
    
    struct {
      __IM  uint32_t OUTLINK_DSCR_BF1 : 32;     /*!< The address of the second-to-last inlink descriptor x-2.                  */
    } bit;
  } OUT_DSCR_BF1_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Weight register of Rx channel 0                                           */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t TX_WEIGHT  : 4;            /*!< The weight of Tx channel 0.                                               */
            uint32_t            : 20;
    } bit;
  } OUT_WIGHT_CH4;
  __IM  uint32_t  RESERVED22;
  
  union {
    __IOM uint32_t reg;                         /*!< Priority register of Tx channel 0.                                        */
    
    struct {
      __IOM uint32_t TX_PRI     : 4;            /*!< The priority of Tx channel 0. The larger of the value, the higher
                                                     of the priority.                                                          */
            uint32_t            : 28;
    } bit;
  } OUT_PRI_CH4;
  
  union {
    __IOM uint32_t reg;                         /*!< Peripheral selection of Tx channel 0                                      */
    
    struct {
      __IOM uint32_t PERI_OUT_SEL : 6;          /*!< This register is used to select peripheral for Tx channel 0.
                                                     0:SPI2. 1: SPI3. 2: UHCI0. 3: I2S0. 4: I2S1. 5: LCD_CAM.
                                                     6: AES. 7: SHA. 8: ADC_DAC. 9: RMT.                                       */
            uint32_t            : 26;
    } bit;
  } OUT_PERI_SEL_CH4;
} DMA_Type;                                     /*!< Size = 3244 (0xcac)                                                       */



/* =========================================================================================================================== */
/* ================                                            DS                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief Digital Signature (DS)
  */

typedef struct {                                /*!< DS Structure                                                              */
  __IOM uint32_t  C_MEM[396];                   /*!< Memory C                                                                  */
  
  union {
    __IOM uint32_t reg;                         /*!< IV block data                                                             */
    
    struct {
      __IOM uint32_t IV         : 32;           /*!< Stores IV block data                                                      */
    } bit;
  } IV_0;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IV block data                                                             */
    
    struct {
      __IOM uint32_t IV         : 32;           /*!< Stores IV block data                                                      */
    } bit;
  } IV_1;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IV block data                                                             */
    
    struct {
      __IOM uint32_t IV         : 32;           /*!< Stores IV block data                                                      */
    } bit;
  } IV_2;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IV block data                                                             */
    
    struct {
      __IOM uint32_t IV         : 32;           /*!< Stores IV block data                                                      */
    } bit;
  } IV_3;
  __IM  uint32_t  RESERVED3[103];
  __IOM uint32_t  X_MEM[128];                   /*!< Memory X                                                                  */
  __IOM uint32_t  Z_MEM[128];                   /*!< Memory Z                                                                  */
  __IM  uint32_t  RESERVED4[128];
  
  union {
    __IOM uint32_t reg;                         /*!< Activates the DS peripheral                                               */
    
    struct {
      __OM  uint32_t SET_START  : 1;            /*!< Write 1 to this register to active the DS peripheral                      */
            uint32_t            : 31;
    } bit;
  } SET_START;
  
  union {
    __IOM uint32_t reg;                         /*!< Starts DS operation                                                       */
    
    struct {
      __OM  uint32_t SET_ME     : 1;            /*!< Write 1 to this register to start DS operation.                           */
            uint32_t            : 31;
    } bit;
  } SET_ME;
  
  union {
    __IOM uint32_t reg;                         /*!< Ends DS operation                                                         */
    
    struct {
      __OM  uint32_t SET_FINISH : 1;            /*!< Write 1 to this register to end DS operation.                             */
            uint32_t            : 31;
    } bit;
  } SET_FINISH;
  
  union {
    __IOM uint32_t reg;                         /*!< Status of the DS perihperal                                               */
    
    struct {
      __IM  uint32_t QUERY_BUSY : 1;            /*!< Stores the status of the DS peripheral. 1: The DS peripheral
                                                     is busy. 0: The DS peripheral is idle.                                    */
            uint32_t            : 31;
    } bit;
  } QUERY_BUSY;
  
  union {
    __IOM uint32_t reg;                         /*!< Checks the reason why DS_KEY is not ready                                 */
    
    struct {
      __IM  uint32_t QUERY_KEY_WRONG : 4;       /*!< 1-15: HMAC was activated, but the DS peripheral did not successfully
                                                     receive the DS_KEY from the HMAC peripheral. (The biggest
                                                     value is 15). 0: HMAC is not activated.                                   */
            uint32_t            : 28;
    } bit;
  } QUERY_KEY_WRONG;
  
  union {
    __IOM uint32_t reg;                         /*!< Queries DS check result                                                   */
    
    struct {
      __IM  uint32_t MD_ERROR   : 1;            /*!< MD checkout result. 1: The MD check fails. 0: The MD check passes.        */
      __IM  uint32_t PADDING_BAD : 1;           /*!< padding checkout result. 1: The padding check fails. 0: The
                                                     padding check passes.                                                     */
            uint32_t            : 30;
    } bit;
  } QUERY_CHECK;
  __IM  uint32_t  RESERVED5[2];
  
  union {
    __IOM uint32_t reg;                         /*!< DS version control register                                               */
    
    struct {
      __IOM uint32_t DATE       : 30;           /*!< ds version information                                                    */
            uint32_t            : 2;
    } bit;
  } DATE;
} DS_Type;                                      /*!< Size = 3620 (0xe24)                                                       */



/* =========================================================================================================================== */
/* ================                                           EFUSE                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief eFuse Controller (EFUSE)
  */

typedef struct {                                /*!< EFUSE Structure                                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 that stores data to be programmed.                             */
    
    struct {
      __IOM uint32_t PGM_DATA_0 : 32;           /*!< The content of the 0th 32-bit data to be programmed.                      */
    } bit;
  } PGM_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 that stores data to be programmed.                             */
    
    struct {
      __IOM uint32_t PGM_DATA_1 : 32;           /*!< The content of the 1st 32-bit data to be programmed.                      */
    } bit;
  } PGM_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 that stores data to be programmed.                             */
    
    struct {
      __IOM uint32_t PGM_DATA_2 : 32;           /*!< The content of the 2nd 32-bit data to be programmed.                      */
    } bit;
  } PGM_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 that stores data to be programmed.                             */
    
    struct {
      __IOM uint32_t PGM_DATA_3 : 32;           /*!< The content of the 3rd 32-bit data to be programmed.                      */
    } bit;
  } PGM_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 that stores data to be programmed.                             */
    
    struct {
      __IOM uint32_t PGM_DATA_4 : 32;           /*!< The content of the 4th 32-bit data to be programmed.                      */
    } bit;
  } PGM_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 that stores data to be programmed.                             */
    
    struct {
      __IOM uint32_t PGM_DATA_5 : 32;           /*!< The content of the 5th 32-bit data to be programmed.                      */
    } bit;
  } PGM_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 that stores data to be programmed.                             */
    
    struct {
      __IOM uint32_t PGM_DATA_6 : 32;           /*!< The content of the 6th 32-bit data to be programmed.                      */
    } bit;
  } PGM_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 that stores data to be programmed.                             */
    
    struct {
      __IOM uint32_t PGM_DATA_7 : 32;           /*!< The content of the 7th 32-bit data to be programmed.                      */
    } bit;
  } PGM_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 that stores the RS code to be programmed.                      */
    
    struct {
      __IOM uint32_t PGM_RS_DATA_0 : 32;        /*!< The content of the 0th 32-bit RS code to be programmed.                   */
    } bit;
  } PGM_CHECK_VALUE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 that stores the RS code to be programmed.                      */
    
    struct {
      __IOM uint32_t PGM_RS_DATA_1 : 32;        /*!< The content of the 1st 32-bit RS code to be programmed.                   */
    } bit;
  } PGM_CHECK_VALUE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 that stores the RS code to be programmed.                      */
    
    struct {
      __IOM uint32_t PGM_RS_DATA_2 : 32;        /*!< The content of the 2nd 32-bit RS code to be programmed.                   */
    } bit;
  } PGM_CHECK_VALUE2;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK0 data register 0.                                                   */
    
    struct {
      __IM  uint32_t WR_DIS     : 32;           /*!< Disable programming of individual eFuses.                                 */
    } bit;
  } RD_WR_DIS;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK0 data register 1.                                                   */
    
    struct {
      __IM  uint32_t RD_DIS     : 7;            /*!< Set this bit to disable reading from BlOCK4-10.                           */
      __IM  uint32_t DIS_RTC_RAM_BOOT : 1;      /*!< Set this bit to disable boot from RTC RAM.                                */
      __IM  uint32_t DIS_ICACHE : 1;            /*!< Set this bit to disable Icache.                                           */
      __IM  uint32_t DIS_DCACHE : 1;            /*!< Set this bit to disable Dcache.                                           */
      __IM  uint32_t DIS_DOWNLOAD_ICACHE : 1;   /*!< Set this bit to disable Icache in download mode (boot_mode[3:0]
                                                     is 0, 1, 2, 3, 6, 7).                                                     */
      __IM  uint32_t DIS_DOWNLOAD_DCACHE : 1;   /*!< Set this bit to disable Dcache in download mode ( boot_mode[3:0]
                                                     is 0, 1, 2, 3, 6, 7).                                                     */
      __IM  uint32_t DIS_FORCE_DOWNLOAD : 1;    /*!< Set this bit to disable the function that forces chip into download
                                                     mode.                                                                     */
      __IM  uint32_t DIS_USB    : 1;            /*!< Set this bit to disable USB function.                                     */
      __IM  uint32_t DIS_CAN    : 1;            /*!< Set this bit to disable CAN function.                                     */
      __IM  uint32_t DIS_APP_CPU : 1;           /*!< Disable app cpu.                                                          */
      __IM  uint32_t SOFT_DIS_JTAG : 3;         /*!< Set these bits to disable JTAG in the soft way (odd number 1
                                                     means disable ). JTAG can be enabled in HMAC module.                      */
      __IM  uint32_t DIS_PAD_JTAG : 1;          /*!< Set this bit to disable JTAG in the hard way. JTAG is disabled
                                                     permanently.                                                              */
      __IM  uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT : 1;/*!< Set this bit to disable flash encryption when in download boot
                                                     modes.                                                                    */
      __IM  uint32_t USB_DREFH  : 2;            /*!< Controls single-end input threshold vrefh, 1.76 V to 2 V with
                                                     step of 80 mV, stored in eFuse.                                           */
      __IM  uint32_t USB_DREFL  : 2;            /*!< Controls single-end input threshold vrefl, 0.8 V to 1.04 V with
                                                     step of 80 mV, stored in eFuse.                                           */
      __IM  uint32_t USB_EXCHG_PINS : 1;        /*!< Set this bit to exchange USB D+ and D- pins.                              */
      __IM  uint32_t EXT_PHY_ENABLE : 1;        /*!< Set this bit to enable external PHY.                                      */
      __IM  uint32_t BTLC_GPIO_ENABLE : 2;      /*!< Bluetooth GPIO signal output security level control.                      */
      __IM  uint32_t VDD_SPI_MODECURLIM : 1;    /*!< SPI regulator switches current limit mode.                                */
      __IM  uint32_t VDD_SPI_DREFH : 2;         /*!< SPI regulator high voltage reference.                                     */
    } bit;
  } RD_REPEAT_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK0 data register 2.                                                   */
    
    struct {
      __IM  uint32_t VDD_SPI_DREFM : 2;         /*!< SPI regulator medium voltage reference.                                   */
      __IM  uint32_t VDD_SPI_DREFL : 2;         /*!< SPI regulator low voltage reference.                                      */
      __IM  uint32_t VDD_SPI_XPD : 1;           /*!< SPI regulator power up signal.                                            */
      __IM  uint32_t VDD_SPI_TIEH : 1;          /*!< SPI regulator output is short connected to VDD3P3_RTC_IO.                 */
      __IM  uint32_t VDD_SPI_FORCE : 1;         /*!< Set this bit and force to use the configuration of eFuse to
                                                     configure VDD_SPI.                                                        */
      __IM  uint32_t VDD_SPI_EN_INIT : 1;       /*!< Set SPI regulator to 0 to configure init[1:0]=0.                          */
      __IM  uint32_t VDD_SPI_ENCURLIM : 1;      /*!< Set SPI regulator to 1 to enable output current limit.                    */
      __IM  uint32_t VDD_SPI_DCURLIM : 3;       /*!< Tunes the current limit threshold of SPI regulator when tieh=0,
                                                     about 800 mA/(8+d).                                                       */
      __IM  uint32_t VDD_SPI_INIT : 2;          /*!< Adds resistor from LDO output to ground. 0: no resistance 1:
                                                     6 K 2: 4 K 3: 2 K.                                                        */
      __IM  uint32_t VDD_SPI_DCAP : 2;          /*!< Prevents SPI regulator from overshoot.                                    */
      __IM  uint32_t WDT_DELAY_SEL : 2;         /*!< Selects RTC watchdog timeout threshold, in unit of slow clock
                                                     cycle. 0: 40000. 1: 80000. 2: 160000. 3:320000.                           */
      __IM  uint32_t SPI_BOOT_CRYPT_CNT : 3;    /*!< Set this bit to enable SPI boot encrypt/decrypt. Odd number
                                                     of 1: enable. even number of 1: disable.                                  */
      __IM  uint32_t SECURE_BOOT_KEY_REVOKE0 : 1;/*!< Set this bit to enable revoking first secure boot key.                   */
      __IM  uint32_t SECURE_BOOT_KEY_REVOKE1 : 1;/*!< Set this bit to enable revoking second secure boot key.                  */
      __IM  uint32_t SECURE_BOOT_KEY_REVOKE2 : 1;/*!< Set this bit to enable revoking third secure boot key.                   */
      __IM  uint32_t KEY_PURPOSE_0 : 4;         /*!< Purpose of Key0.                                                          */
      __IM  uint32_t KEY_PURPOSE_1 : 4;         /*!< Purpose of Key1.                                                          */
    } bit;
  } RD_REPEAT_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK0 data register 3.                                                   */
    
    struct {
      __IM  uint32_t KEY_PURPOSE_2 : 4;         /*!< Purpose of Key2.                                                          */
      __IM  uint32_t KEY_PURPOSE_3 : 4;         /*!< Purpose of Key3.                                                          */
      __IM  uint32_t KEY_PURPOSE_4 : 4;         /*!< Purpose of Key4.                                                          */
      __IM  uint32_t KEY_PURPOSE_5 : 4;         /*!< Purpose of Key5.                                                          */
      __IM  uint32_t RPT4_RESERVED0 : 4;        /*!< Reserved (used for four backups method).                                  */
      __IM  uint32_t SECURE_BOOT_EN : 1;        /*!< Set this bit to enable secure boot.                                       */
      __IM  uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE : 1;/*!< Set this bit to enable revoking aggressive secure boot.            */
      __IM  uint32_t DIS_USB_JTAG : 1;          /*!< Set this bit to disable function of usb switch to jtag in module
                                                     of usb device.                                                            */
      __IM  uint32_t DIS_USB_DEVICE : 1;        /*!< Set this bit to disable usb device.                                       */
      __IM  uint32_t STRAP_JTAG_SEL : 1;        /*!< Set this bit to enable selection between usb_to_jtag and pad_to_jtag
                                                     through strapping gpio10 when both reg_dis_usb_jtag and
                                                     reg_dis_pad_jtag are equal to 0.                                          */
      __IM  uint32_t USB_PHY_SEL : 1;           /*!< This bit is used to switch internal PHY and external PHY for
                                                     USB OTG and USB Device. 0: internal PHY is assigned to
                                                     USB Device while external PHY is assigned to USB OTG. 1:
                                                     internal PHY is assigned to USB OTG while external PHY
                                                     is assigned to USB Device.                                                */
      __IM  uint32_t POWER_GLITCH_DSENSE : 2;   /*!< Sample delay configuration of power glitch.                               */
      __IM  uint32_t FLASH_TPUW : 4;            /*!< Configures flash waiting time after power-up, in unit of ms.
                                                     If the value is less than 15, the waiting time is the configurable
                                                     value. Otherwise, the waiting time is twice the configurable
                                                     value.                                                                    */
    } bit;
  } RD_REPEAT_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK0 data register 4.                                                   */
    
    struct {
      __IM  uint32_t DIS_DOWNLOAD_MODE : 1;     /*!< Set this bit to disable download mode (boot_mode[3:0] = 0, 1,
                                                     2, 3, 6, 7).                                                              */
      __IM  uint32_t DIS_LEGACY_SPI_BOOT : 1;   /*!< Set this bit to disable Legacy SPI boot mode (boot_mode[3:0]
                                                     = 4).                                                                     */
      __IM  uint32_t UART_PRINT_CHANNEL : 1;    /*!< Selectes the default UART print channel. 0: UART0. 1: UART1.              */
      __IM  uint32_t FLASH_ECC_MODE : 1;        /*!< Set ECC mode in ROM, 0: ROM would Enable Flash ECC 16to18 byte
                                                     mode. 1:ROM would use 16to17 byte mode.                                   */
      __IM  uint32_t DIS_USB_DOWNLOAD_MODE : 1; /*!< Set this bit to disable UART download mode through USB.                   */
      __IM  uint32_t ENABLE_SECURITY_DOWNLOAD : 1;/*!< Set this bit to enable secure UART download mode.                       */
      __IM  uint32_t UART_PRINT_CONTROL : 2;    /*!< Set the default UARTboot message output mode. 00: Enabled. 01:
                                                     Enabled when GPIO8 is low at reset. 10: Enabled when GPIO8
                                                     is high at reset. 11:disabled.                                            */
      __IM  uint32_t PIN_POWER_SELECTION : 1;   /*!< GPIO33-GPIO37 power supply selection in ROM code. 0: VDD3P3_CPU.
                                                     1: VDD_SPI.                                                               */
      __IM  uint32_t FLASH_TYPE : 1;            /*!< Set the maximum lines of SPI flash. 0: four lines. 1: eight
                                                     lines.                                                                    */
      __IM  uint32_t FLASH_PAGE_SIZE : 2;       /*!< Set Flash page size.                                                      */
      __IM  uint32_t FLASH_ECC_EN : 1;          /*!< Set 1 to enable ECC for flash boot.                                       */
      __IM  uint32_t FORCE_SEND_RESUME : 1;     /*!< Set this bit to force ROM code to send a resume command during
                                                     SPI boot.                                                                 */
      __IM  uint32_t SECURE_VERSION : 16;       /*!< Secure version (used by ESP-IDF anti-rollback feature).                   */
      __IM  uint32_t POWERGLITCH_EN : 1;        /*!< Set this bit to enable power glitch function.                             */
      __IM  uint32_t RPT4_RESERVED1 : 1;        /*!< Reserved (used for four backups method).                                  */
    } bit;
  } RD_REPEAT_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK0 data register 5.                                                   */
    
    struct {
      __IM  uint32_t RPT4_RESERVED2 : 24;       /*!< Reserved (used for four backups method).                                  */
            uint32_t            : 8;
    } bit;
  } RD_REPEAT_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK1 data register 0.                                                   */
    
    struct {
      __IM  uint32_t MAC_0      : 32;           /*!< Stores the low 32 bits of MAC address.                                    */
    } bit;
  } RD_MAC_SPI_SYS_0;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK1 data register 1.                                                   */
    
    struct {
      __IM  uint32_t MAC_1      : 16;           /*!< Stores the high 16 bits of MAC address.                                   */
      __IM  uint32_t SPI_PAD_CONF_0 : 16;       /*!< Stores the zeroth part of SPI_PAD_CONF.                                   */
    } bit;
  } RD_MAC_SPI_SYS_1;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK1 data register 2.                                                   */
    
    struct {
      __IM  uint32_t SPI_PAD_CONF_1 : 32;       /*!< Stores the first part of SPI_PAD_CONF.                                    */
    } bit;
  } RD_MAC_SPI_SYS_2;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK1 data register 3.                                                   */
    
    struct {
      __IM  uint32_t SPI_PAD_CONF_2 : 18;       /*!< Stores the second part of SPI_PAD_CONF.                                   */
      __IM  uint32_t SYS_DATA_PART0_0 : 14;     /*!< Stores the fist 14 bits of the zeroth part of system data.                */
    } bit;
  } RD_MAC_SPI_SYS_3;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK1 data register 4.                                                   */
    
    struct {
      __IM  uint32_t SYS_DATA_PART0_1 : 32;     /*!< Stores the fist 32 bits of the zeroth part of system data.                */
    } bit;
  } RD_MAC_SPI_SYS_4;
  
  union {
    __IOM uint32_t reg;                         /*!< BLOCK1 data register 5.                                                   */
    
    struct {
      __IM  uint32_t SYS_DATA_PART0_2 : 32;     /*!< Stores the second 32 bits of the zeroth part of system data.              */
    } bit;
  } RD_MAC_SPI_SYS_5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 of BLOCK2 (system).                                            */
    
    struct {
      __IM  uint32_t SYS_DATA_PART1_0 : 32;     /*!< Stores the zeroth 32 bits of the first part of system data.               */
    } bit;
  } RD_SYS_PART1_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 of BLOCK2 (system).                                            */
    
    struct {
      __IM  uint32_t SYS_DATA_PART1_1 : 32;     /*!< Stores the first 32 bits of the first part of system data.                */
    } bit;
  } RD_SYS_PART1_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 of BLOCK2 (system).                                            */
    
    struct {
      __IM  uint32_t SYS_DATA_PART1_2 : 32;     /*!< Stores the second 32 bits of the first part of system data.               */
    } bit;
  } RD_SYS_PART1_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 of BLOCK2 (system).                                            */
    
    struct {
      __IM  uint32_t SYS_DATA_PART1_3 : 32;     /*!< Stores the third 32 bits of the first part of system data.                */
    } bit;
  } RD_SYS_PART1_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 of BLOCK2 (system).                                            */
    
    struct {
      __IM  uint32_t SYS_DATA_PART1_4 : 32;     /*!< Stores the fourth 32 bits of the first part of system data.               */
    } bit;
  } RD_SYS_PART1_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 of BLOCK2 (system).                                            */
    
    struct {
      __IM  uint32_t SYS_DATA_PART1_5 : 32;     /*!< Stores the fifth 32 bits of the first part of system data.                */
    } bit;
  } RD_SYS_PART1_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 of BLOCK2 (system).                                            */
    
    struct {
      __IM  uint32_t SYS_DATA_PART1_6 : 32;     /*!< Stores the sixth 32 bits of the first part of system data.                */
    } bit;
  } RD_SYS_PART1_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 of BLOCK2 (system).                                            */
    
    struct {
      __IM  uint32_t SYS_DATA_PART1_7 : 32;     /*!< Stores the seventh 32 bits of the first part of system data.              */
    } bit;
  } RD_SYS_PART1_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 of BLOCK3 (user).                                              */
    
    struct {
      __IM  uint32_t USR_DATA0  : 32;           /*!< Stores the zeroth 32 bits of BLOCK3 (user).                               */
    } bit;
  } RD_USR_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 of BLOCK3 (user).                                              */
    
    struct {
      __IM  uint32_t USR_DATA1  : 32;           /*!< Stores the first 32 bits of BLOCK3 (user).                                */
    } bit;
  } RD_USR_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 of BLOCK3 (user).                                              */
    
    struct {
      __IM  uint32_t USR_DATA2  : 32;           /*!< Stores the second 32 bits of BLOCK3 (user).                               */
    } bit;
  } RD_USR_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 of BLOCK3 (user).                                              */
    
    struct {
      __IM  uint32_t USR_DATA3  : 32;           /*!< Stores the third 32 bits of BLOCK3 (user).                                */
    } bit;
  } RD_USR_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 of BLOCK3 (user).                                              */
    
    struct {
      __IM  uint32_t USR_DATA4  : 32;           /*!< Stores the fourth 32 bits of BLOCK3 (user).                               */
    } bit;
  } RD_USR_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 of BLOCK3 (user).                                              */
    
    struct {
      __IM  uint32_t USR_DATA5  : 32;           /*!< Stores the fifth 32 bits of BLOCK3 (user).                                */
    } bit;
  } RD_USR_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 of BLOCK3 (user).                                              */
    
    struct {
      __IM  uint32_t USR_DATA6  : 32;           /*!< Stores the sixth 32 bits of BLOCK3 (user).                                */
    } bit;
  } RD_USR_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 of BLOCK3 (user).                                              */
    
    struct {
      __IM  uint32_t USR_DATA7  : 32;           /*!< Stores the seventh 32 bits of BLOCK3 (user).                              */
    } bit;
  } RD_USR_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 of BLOCK4 (KEY0).                                              */
    
    struct {
      __IM  uint32_t KEY0_DATA0 : 32;           /*!< Stores the zeroth 32 bits of KEY0.                                        */
    } bit;
  } RD_KEY0_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 of BLOCK4 (KEY0).                                              */
    
    struct {
      __IM  uint32_t KEY0_DATA1 : 32;           /*!< Stores the first 32 bits of KEY0.                                         */
    } bit;
  } RD_KEY0_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 of BLOCK4 (KEY0).                                              */
    
    struct {
      __IM  uint32_t KEY0_DATA2 : 32;           /*!< Stores the second 32 bits of KEY0.                                        */
    } bit;
  } RD_KEY0_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 of BLOCK4 (KEY0).                                              */
    
    struct {
      __IM  uint32_t KEY0_DATA3 : 32;           /*!< Stores the third 32 bits of KEY0.                                         */
    } bit;
  } RD_KEY0_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 of BLOCK4 (KEY0).                                              */
    
    struct {
      __IM  uint32_t KEY0_DATA4 : 32;           /*!< Stores the fourth 32 bits of KEY0.                                        */
    } bit;
  } RD_KEY0_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 of BLOCK4 (KEY0).                                              */
    
    struct {
      __IM  uint32_t KEY0_DATA5 : 32;           /*!< Stores the fifth 32 bits of KEY0.                                         */
    } bit;
  } RD_KEY0_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 of BLOCK4 (KEY0).                                              */
    
    struct {
      __IM  uint32_t KEY0_DATA6 : 32;           /*!< Stores the sixth 32 bits of KEY0.                                         */
    } bit;
  } RD_KEY0_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 of BLOCK4 (KEY0).                                              */
    
    struct {
      __IM  uint32_t KEY0_DATA7 : 32;           /*!< Stores the seventh 32 bits of KEY0.                                       */
    } bit;
  } RD_KEY0_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 of BLOCK5 (KEY1).                                              */
    
    struct {
      __IM  uint32_t KEY1_DATA0 : 32;           /*!< Stores the zeroth 32 bits of KEY1.                                        */
    } bit;
  } RD_KEY1_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 of BLOCK5 (KEY1).                                              */
    
    struct {
      __IM  uint32_t KEY1_DATA1 : 32;           /*!< Stores the first 32 bits of KEY1.                                         */
    } bit;
  } RD_KEY1_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 of BLOCK5 (KEY1).                                              */
    
    struct {
      __IM  uint32_t KEY1_DATA2 : 32;           /*!< Stores the second 32 bits of KEY1.                                        */
    } bit;
  } RD_KEY1_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 of BLOCK5 (KEY1).                                              */
    
    struct {
      __IM  uint32_t KEY1_DATA3 : 32;           /*!< Stores the third 32 bits of KEY1.                                         */
    } bit;
  } RD_KEY1_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 of BLOCK5 (KEY1).                                              */
    
    struct {
      __IM  uint32_t KEY1_DATA4 : 32;           /*!< Stores the fourth 32 bits of KEY1.                                        */
    } bit;
  } RD_KEY1_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 of BLOCK5 (KEY1).                                              */
    
    struct {
      __IM  uint32_t KEY1_DATA5 : 32;           /*!< Stores the fifth 32 bits of KEY1.                                         */
    } bit;
  } RD_KEY1_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 of BLOCK5 (KEY1).                                              */
    
    struct {
      __IM  uint32_t KEY1_DATA6 : 32;           /*!< Stores the sixth 32 bits of KEY1.                                         */
    } bit;
  } RD_KEY1_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 of BLOCK5 (KEY1).                                              */
    
    struct {
      __IM  uint32_t KEY1_DATA7 : 32;           /*!< Stores the seventh 32 bits of KEY1.                                       */
    } bit;
  } RD_KEY1_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 of BLOCK6 (KEY2).                                              */
    
    struct {
      __IM  uint32_t KEY2_DATA0 : 32;           /*!< Stores the zeroth 32 bits of KEY2.                                        */
    } bit;
  } RD_KEY2_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 of BLOCK6 (KEY2).                                              */
    
    struct {
      __IM  uint32_t KEY2_DATA1 : 32;           /*!< Stores the first 32 bits of KEY2.                                         */
    } bit;
  } RD_KEY2_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 of BLOCK6 (KEY2).                                              */
    
    struct {
      __IM  uint32_t KEY2_DATA2 : 32;           /*!< Stores the second 32 bits of KEY2.                                        */
    } bit;
  } RD_KEY2_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 of BLOCK6 (KEY2).                                              */
    
    struct {
      __IM  uint32_t KEY2_DATA3 : 32;           /*!< Stores the third 32 bits of KEY2.                                         */
    } bit;
  } RD_KEY2_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 of BLOCK6 (KEY2).                                              */
    
    struct {
      __IM  uint32_t KEY2_DATA4 : 32;           /*!< Stores the fourth 32 bits of KEY2.                                        */
    } bit;
  } RD_KEY2_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 of BLOCK6 (KEY2).                                              */
    
    struct {
      __IM  uint32_t KEY2_DATA5 : 32;           /*!< Stores the fifth 32 bits of KEY2.                                         */
    } bit;
  } RD_KEY2_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 of BLOCK6 (KEY2).                                              */
    
    struct {
      __IM  uint32_t KEY2_DATA6 : 32;           /*!< Stores the sixth 32 bits of KEY2.                                         */
    } bit;
  } RD_KEY2_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 of BLOCK6 (KEY2).                                              */
    
    struct {
      __IM  uint32_t KEY2_DATA7 : 32;           /*!< Stores the seventh 32 bits of KEY2.                                       */
    } bit;
  } RD_KEY2_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 of BLOCK7 (KEY3).                                              */
    
    struct {
      __IM  uint32_t KEY3_DATA0 : 32;           /*!< Stores the zeroth 32 bits of KEY3.                                        */
    } bit;
  } RD_KEY3_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 of BLOCK7 (KEY3).                                              */
    
    struct {
      __IM  uint32_t KEY3_DATA1 : 32;           /*!< Stores the first 32 bits of KEY3.                                         */
    } bit;
  } RD_KEY3_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 of BLOCK7 (KEY3).                                              */
    
    struct {
      __IM  uint32_t KEY3_DATA2 : 32;           /*!< Stores the second 32 bits of KEY3.                                        */
    } bit;
  } RD_KEY3_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 of BLOCK7 (KEY3).                                              */
    
    struct {
      __IM  uint32_t KEY3_DATA3 : 32;           /*!< Stores the third 32 bits of KEY3.                                         */
    } bit;
  } RD_KEY3_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 of BLOCK7 (KEY3).                                              */
    
    struct {
      __IM  uint32_t KEY3_DATA4 : 32;           /*!< Stores the fourth 32 bits of KEY3.                                        */
    } bit;
  } RD_KEY3_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 of BLOCK7 (KEY3).                                              */
    
    struct {
      __IM  uint32_t KEY3_DATA5 : 32;           /*!< Stores the fifth 32 bits of KEY3.                                         */
    } bit;
  } RD_KEY3_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 of BLOCK7 (KEY3).                                              */
    
    struct {
      __IM  uint32_t KEY3_DATA6 : 32;           /*!< Stores the sixth 32 bits of KEY3.                                         */
    } bit;
  } RD_KEY3_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 of BLOCK7 (KEY3).                                              */
    
    struct {
      __IM  uint32_t KEY3_DATA7 : 32;           /*!< Stores the seventh 32 bits of KEY3.                                       */
    } bit;
  } RD_KEY3_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 of BLOCK8 (KEY4).                                              */
    
    struct {
      __IM  uint32_t KEY4_DATA0 : 32;           /*!< Stores the zeroth 32 bits of KEY4.                                        */
    } bit;
  } RD_KEY4_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 of BLOCK8 (KEY4).                                              */
    
    struct {
      __IM  uint32_t KEY4_DATA1 : 32;           /*!< Stores the first 32 bits of KEY4.                                         */
    } bit;
  } RD_KEY4_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 of BLOCK8 (KEY4).                                              */
    
    struct {
      __IM  uint32_t KEY4_DATA2 : 32;           /*!< Stores the second 32 bits of KEY4.                                        */
    } bit;
  } RD_KEY4_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 of BLOCK8 (KEY4).                                              */
    
    struct {
      __IM  uint32_t KEY4_DATA3 : 32;           /*!< Stores the third 32 bits of KEY4.                                         */
    } bit;
  } RD_KEY4_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 of BLOCK8 (KEY4).                                              */
    
    struct {
      __IM  uint32_t KEY4_DATA4 : 32;           /*!< Stores the fourth 32 bits of KEY4.                                        */
    } bit;
  } RD_KEY4_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 of BLOCK8 (KEY4).                                              */
    
    struct {
      __IM  uint32_t KEY4_DATA5 : 32;           /*!< Stores the fifth 32 bits of KEY4.                                         */
    } bit;
  } RD_KEY4_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 of BLOCK8 (KEY4).                                              */
    
    struct {
      __IM  uint32_t KEY4_DATA6 : 32;           /*!< Stores the sixth 32 bits of KEY4.                                         */
    } bit;
  } RD_KEY4_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 of BLOCK8 (KEY4).                                              */
    
    struct {
      __IM  uint32_t KEY4_DATA7 : 32;           /*!< Stores the seventh 32 bits of KEY4.                                       */
    } bit;
  } RD_KEY4_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 of BLOCK9 (KEY5).                                              */
    
    struct {
      __IM  uint32_t KEY5_DATA0 : 32;           /*!< Stores the zeroth 32 bits of KEY5.                                        */
    } bit;
  } RD_KEY5_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 of BLOCK9 (KEY5).                                              */
    
    struct {
      __IM  uint32_t KEY5_DATA1 : 32;           /*!< Stores the first 32 bits of KEY5.                                         */
    } bit;
  } RD_KEY5_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 of BLOCK9 (KEY5).                                              */
    
    struct {
      __IM  uint32_t KEY5_DATA2 : 32;           /*!< Stores the second 32 bits of KEY5.                                        */
    } bit;
  } RD_KEY5_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 of BLOCK9 (KEY5).                                              */
    
    struct {
      __IM  uint32_t KEY5_DATA3 : 32;           /*!< Stores the third 32 bits of KEY5.                                         */
    } bit;
  } RD_KEY5_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 of BLOCK9 (KEY5).                                              */
    
    struct {
      __IM  uint32_t KEY5_DATA4 : 32;           /*!< Stores the fourth 32 bits of KEY5.                                        */
    } bit;
  } RD_KEY5_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 of BLOCK9 (KEY5).                                              */
    
    struct {
      __IM  uint32_t KEY5_DATA5 : 32;           /*!< Stores the fifth 32 bits of KEY5.                                         */
    } bit;
  } RD_KEY5_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 of BLOCK9 (KEY5).                                              */
    
    struct {
      __IM  uint32_t KEY5_DATA6 : 32;           /*!< Stores the sixth 32 bits of KEY5.                                         */
    } bit;
  } RD_KEY5_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 of BLOCK9 (KEY5).                                              */
    
    struct {
      __IM  uint32_t KEY5_DATA7 : 32;           /*!< Stores the seventh 32 bits of KEY5.                                       */
    } bit;
  } RD_KEY5_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 0 of BLOCK10 (system).                                           */
    
    struct {
      __IM  uint32_t SYS_DATA_PART2_0 : 32;     /*!< Stores the 0th 32 bits of the 2nd part of system data.                    */
    } bit;
  } RD_SYS_PART2_DATA0;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 1 of BLOCK9 (KEY5).                                              */
    
    struct {
      __IM  uint32_t SYS_DATA_PART2_1 : 32;     /*!< Stores the 1st 32 bits of the 2nd part of system data.                    */
    } bit;
  } RD_SYS_PART2_DATA1;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 2 of BLOCK10 (system).                                           */
    
    struct {
      __IM  uint32_t SYS_DATA_PART2_2 : 32;     /*!< Stores the 2nd 32 bits of the 2nd part of system data.                    */
    } bit;
  } RD_SYS_PART2_DATA2;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 3 of BLOCK10 (system).                                           */
    
    struct {
      __IM  uint32_t SYS_DATA_PART2_3 : 32;     /*!< Stores the 3rd 32 bits of the 2nd part of system data.                    */
    } bit;
  } RD_SYS_PART2_DATA3;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 4 of BLOCK10 (system).                                           */
    
    struct {
      __IM  uint32_t SYS_DATA_PART2_4 : 32;     /*!< Stores the 4th 32 bits of the 2nd part of system data.                    */
    } bit;
  } RD_SYS_PART2_DATA4;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 5 of BLOCK10 (system).                                           */
    
    struct {
      __IM  uint32_t SYS_DATA_PART2_5 : 32;     /*!< Stores the 5th 32 bits of the 2nd part of system data.                    */
    } bit;
  } RD_SYS_PART2_DATA5;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 6 of BLOCK10 (system).                                           */
    
    struct {
      __IM  uint32_t SYS_DATA_PART2_6 : 32;     /*!< Stores the 6th 32 bits of the 2nd part of system data.                    */
    } bit;
  } RD_SYS_PART2_DATA6;
  
  union {
    __IOM uint32_t reg;                         /*!< Register 7 of BLOCK10 (system).                                           */
    
    struct {
      __IM  uint32_t SYS_DATA_PART2_7 : 32;     /*!< Stores the 7th 32 bits of the 2nd part of system data.                    */
    } bit;
  } RD_SYS_PART2_DATA7;
  
  union {
    __IOM uint32_t reg;                         /*!< Programming error record register 0 of BLOCK0.                            */
    
    struct {
      __IM  uint32_t RD_DIS_ERR : 7;            /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_RTC_RAM_BOOT_ERR : 1;  /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_ICACHE_ERR : 1;        /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_DCACHE_ERR : 1;        /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_DOWNLOAD_ICACHE_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_DOWNLOAD_DCACHE_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_FORCE_DOWNLOAD_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_USB_ERR : 1;           /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_CAN_ERR : 1;           /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_APP_CPU_ERR : 1;       /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t SOFT_DIS_JTAG_ERR : 3;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_PAD_JTAG_ERR : 1;      /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_DOWNLOAD_MANUAL_ENCRYPT_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t USB_DREFH_ERR : 2;         /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t USB_DREFL_ERR : 2;         /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t USB_EXCHG_PINS_ERR : 1;    /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t EXT_PHY_ENABLE_ERR : 1;    /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t BTLC_GPIO_ENABLE_ERR : 2;  /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_MODECURLIM_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_DREFH_ERR : 2;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
    } bit;
  } RD_REPEAT_ERR0;
  
  union {
    __IOM uint32_t reg;                         /*!< Programming error record register 1 of BLOCK0.                            */
    
    struct {
      __IM  uint32_t VDD_SPI_DREFM_ERR : 2;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_DREFL_ERR : 2;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_XPD_ERR : 1;       /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_TIEH_ERR : 1;      /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_FORCE_ERR : 1;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_EN_INIT_ERR : 1;   /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_ENCURLIM_ERR : 1;  /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_DCURLIM_ERR : 3;   /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_INIT_ERR : 2;      /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t VDD_SPI_DCAP_ERR : 2;      /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t WDT_DELAY_SEL_ERR : 2;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t SPI_BOOT_CRYPT_CNT_ERR : 3;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t SECURE_BOOT_KEY_REVOKE0_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t SECURE_BOOT_KEY_REVOKE1_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t SECURE_BOOT_KEY_REVOKE2_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t KEY_PURPOSE_0_ERR : 4;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t KEY_PURPOSE_1_ERR : 4;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
    } bit;
  } RD_REPEAT_ERR1;
  
  union {
    __IOM uint32_t reg;                         /*!< Programming error record register 2 of BLOCK0.                            */
    
    struct {
      __IM  uint32_t KEY_PURPOSE_2_ERR : 4;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t KEY_PURPOSE_3_ERR : 4;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t KEY_PURPOSE_4_ERR : 4;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t KEY_PURPOSE_5_ERR : 4;     /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t RPT4_RESERVED0_ERR : 4;    /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t SECURE_BOOT_EN_ERR : 1;    /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t SECURE_BOOT_AGGRESSIVE_REVOKE_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_USB_JTAG_ERR : 1;      /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_USB_DEVICE_ERR : 1;    /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t STRAP_JTAG_SEL_ERR : 1;    /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t USB_PHY_SEL_ERR : 1;       /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t POWER_GLITCH_DSENSE_ERR : 2;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t FLASH_TPUW_ERR : 4;        /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
    } bit;
  } RD_REPEAT_ERR2;
  
  union {
    __IOM uint32_t reg;                         /*!< Programming error record register 3 of BLOCK0.                            */
    
    struct {
      __IM  uint32_t DIS_DOWNLOAD_MODE_ERR : 1; /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_LEGACY_SPI_BOOT_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t UART_PRINT_CHANNEL_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t FLASH_ECC_MODE_ERR : 1;    /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t DIS_USB_DOWNLOAD_MODE_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t ENABLE_SECURITY_DOWNLOAD_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t UART_PRINT_CONTROL_ERR : 2;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t PIN_POWER_SELECTION_ERR : 1;/*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t FLASH_TYPE_ERR : 1;        /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t FLASH_PAGE_SIZE_ERR : 2;   /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t FLASH_ECC_EN_ERR : 1;      /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t FORCE_SEND_RESUME_ERR : 1; /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t SECURE_VERSION_ERR : 16;   /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t POWERGLITCH_EN_ERR : 1;    /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
      __IM  uint32_t RPT4_RESERVED1_ERR : 1;    /*!< Reserved.                                                                 */
    } bit;
  } RD_REPEAT_ERR3;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< Programming error record register 4 of BLOCK0.                            */
    
    struct {
      __IM  uint32_t RPT4_RESERVED2_ERR : 24;   /*!< If any bits in this filed are 1, then it indicates a programming
                                                     error.                                                                    */
            uint32_t            : 8;
    } bit;
  } RD_REPEAT_ERR4;
  __IM  uint32_t  RESERVED1[11];
  
  union {
    __IOM uint32_t reg;                         /*!< Programming error record register 0 of BLOCK1-10.                         */
    
    struct {
      __IM  uint32_t MAC_SPI_8M_ERR_NUM : 3;    /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t MAC_SPI_8M_FAIL : 1;       /*!< 0: Means no failure and that the data of MAC_SPI_8M is reliable
                                                     1: Means that programming user data failed and the number
                                                     of error bytes is over 6.                                                 */
      __IM  uint32_t SYS_PART1_NUM : 3;         /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t SYS_PART1_FAIL : 1;        /*!< 0: Means no failure and that the data of system part1 is reliable
                                                     1: Means that programming user data failed and the number
                                                     of error bytes is over 6.                                                 */
      __IM  uint32_t USR_DATA_ERR_NUM : 3;      /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t USR_DATA_FAIL : 1;         /*!< 0: Means no failure and that the user data is reliable 1: Means
                                                     that programming user data failed and the number of error
                                                     bytes is over 6.                                                          */
      __IM  uint32_t KEY0_ERR_NUM : 3;          /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t KEY0_FAIL  : 1;            /*!< 0: Means no failure and that the data of key0 is reliable 1:
                                                     Means that programming key0 failed and the number of error
                                                     bytes is over 6.                                                          */
      __IM  uint32_t KEY1_ERR_NUM : 3;          /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t KEY1_FAIL  : 1;            /*!< 0: Means no failure and that the data of key1 is reliable 1:
                                                     Means that programming key1 failed and the number of error
                                                     bytes is over 6.                                                          */
      __IM  uint32_t KEY2_ERR_NUM : 3;          /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t KEY2_FAIL  : 1;            /*!< 0: Means no failure and that the data of key2 is reliable 1:
                                                     Means that programming key2 failed and the number of error
                                                     bytes is over 6.                                                          */
      __IM  uint32_t KEY3_ERR_NUM : 3;          /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t KEY3_FAIL  : 1;            /*!< 0: Means no failure and that the data of key3 is reliable 1:
                                                     Means that programming key3 failed and the number of error
                                                     bytes is over 6.                                                          */
      __IM  uint32_t KEY4_ERR_NUM : 3;          /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t KEY4_FAIL  : 1;            /*!< 0: Means no failure and that the data of key4 is reliable 1:
                                                     Means that programming key4 failed and the number of error
                                                     bytes is over 6.                                                          */
    } bit;
  } RD_RS_ERR0;
  
  union {
    __IOM uint32_t reg;                         /*!< Programming error record register 1 of BLOCK1-10.                         */
    
    struct {
      __IM  uint32_t KEY5_ERR_NUM : 3;          /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t KEY5_FAIL  : 1;            /*!< 0: Means no failure and that the data of KEY5 is reliable 1:
                                                     Means that programming user data failed and the number
                                                     of error bytes is over 6.                                                 */
      __IM  uint32_t SYS_PART2_ERR_NUM : 3;     /*!< The value of this signal means the number of error bytes.                 */
      __IM  uint32_t SYS_PART2_FAIL : 1;        /*!< 0: Means no failure and that the data of system part2 is reliable
                                                     1: Means that programming user data failed and the number
                                                     of error bytes is over 6.                                                 */
            uint32_t            : 24;
    } bit;
  } RD_RS_ERR1;
  
  union {
    __IOM uint32_t reg;                         /*!< eFuse clcok configuration register.                                       */
    
    struct {
      __IOM uint32_t EFUSE_MEM_FORCE_PD : 1;    /*!< Set this bit to force eFuse SRAM into power-saving mode.                  */
      __IOM uint32_t MEM_CLK_FORCE_ON : 1;      /*!< Set this bit and force to activate clock signal of eFuse SRAM.            */
      __IOM uint32_t EFUSE_MEM_FORCE_PU : 1;    /*!< Set this bit to force eFuse SRAM into working mode.                       */
            uint32_t            : 13;
      __IOM uint32_t EN         : 1;            /*!< Set this bit and force to enable clock signal of eFuse memory.            */
            uint32_t            : 15;
    } bit;
  } CLK;
  
  union {
    __IOM uint32_t reg;                         /*!< eFuse operation mode configuraiton register                               */
    
    struct {
      __IOM uint32_t OP_CODE    : 16;           /*!< 0x5A5A: Operate programming command 0x5AA5: Operate read command.         */
            uint32_t            : 16;
    } bit;
  } CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< eFuse status register.                                                    */
    
    struct {
      __IM  uint32_t STATE      : 4;            /*!< Indicates the state of the eFuse state machine.                           */
      __IM  uint32_t OTP_LOAD_SW : 1;           /*!< The value of OTP_LOAD_SW.                                                 */
      __IM  uint32_t OTP_VDDQ_C_SYNC2 : 1;      /*!< The value of OTP_VDDQ_C_SYNC2.                                            */
      __IM  uint32_t OTP_STROBE_SW : 1;         /*!< The value of OTP_STROBE_SW.                                               */
      __IM  uint32_t OTP_CSB_SW : 1;            /*!< The value of OTP_CSB_SW.                                                  */
      __IM  uint32_t OTP_PGENB_SW : 1;          /*!< The value of OTP_PGENB_SW.                                                */
      __IM  uint32_t OTP_VDDQ_IS_SW : 1;        /*!< The value of OTP_VDDQ_IS_SW.                                              */
      __IM  uint32_t REPEAT_ERR_CNT : 8;        /*!< Indicates the number of error bits during programming BLOCK0.             */
            uint32_t            : 14;
    } bit;
  } STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< eFuse command register.                                                   */
    
    struct {
      __IOM uint32_t READ_CMD   : 1;            /*!< Set this bit to send read command.                                        */
      __IOM uint32_t PGM_CMD    : 1;            /*!< Set this bit to send programming command.                                 */
      __IOM uint32_t BLK_NUM    : 4;            /*!< The serial number of the block to be programmed. Value 0-10
                                                     corresponds to block number 0-10, respectively.                           */
            uint32_t            : 26;
    } bit;
  } CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< eFuse raw interrupt register.                                             */
    
    struct {
      __IOM uint32_t READ_DONE_INT_RAW : 1;     /*!< The raw bit signal for read_done interrupt.                               */
      __IOM uint32_t PGM_DONE_INT_RAW : 1;      /*!< The raw bit signal for pgm_done interrupt.                                */
            uint32_t            : 30;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< eFuse interrupt status register.                                          */
    
    struct {
      __IM  uint32_t READ_DONE_INT_ST : 1;      /*!< The status signal for read_done interrupt.                                */
      __IM  uint32_t PGM_DONE_INT_ST : 1;       /*!< The status signal for pgm_done interrupt.                                 */
            uint32_t            : 30;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< eFuse interrupt enable register.                                          */
    
    struct {
      __IOM uint32_t READ_DONE_INT_ENA : 1;     /*!< The enable signal for read_done interrupt.                                */
      __IOM uint32_t PGM_DONE_INT_ENA : 1;      /*!< The enable signal for pgm_done interrupt.                                 */
            uint32_t            : 30;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< eFuse interrupt clear register.                                           */
    
    struct {
      __OM  uint32_t READ_DONE_INT_CLR : 1;     /*!< The clear signal for read_done interrupt.                                 */
      __OM  uint32_t PGM_DONE_INT_CLR : 1;      /*!< The clear signal for pgm_done interrupt.                                  */
            uint32_t            : 30;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Controls the eFuse programming voltage.                                   */
    
    struct {
      __IOM uint32_t DAC_CLK_DIV : 8;           /*!< Controls the division factor of the rising clock of the programming
                                                     voltage.                                                                  */
      __IOM uint32_t DAC_CLK_PAD_SEL : 1;       /*!< Don't care.                                                               */
      __IOM uint32_t DAC_NUM    : 8;            /*!< Controls the rising period of the programming voltage.                    */
      __IOM uint32_t OE_CLR     : 1;            /*!< Reduces the power supply of the programming voltage.                      */
            uint32_t            : 14;
    } bit;
  } DAC_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Configures read timing parameters.                                        */
    
    struct {
            uint32_t            : 24;
      __IOM uint32_t READ_INIT_NUM : 8;         /*!< Configures the initial read time of eFuse.                                */
    } bit;
  } RD_TIM_CONF;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< Configurarion register 1 of eFuse programming timing parameters.          */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t PWR_ON_NUM : 16;           /*!< Configures the power up time for VDDQ.                                    */
            uint32_t            : 8;
    } bit;
  } WR_TIM_CONF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Configurarion register 2 of eFuse programming timing parameters.          */
    
    struct {
      __IOM uint32_t PWR_OFF_NUM : 16;          /*!< Configures the power outage time for VDDQ.                                */
            uint32_t            : 16;
    } bit;
  } WR_TIM_CONF2;
  
  union {
    __IOM uint32_t reg;                         /*!< eFuse version register.                                                   */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< Stores eFuse version.                                                     */
            uint32_t            : 4;
    } bit;
  } DATE;
} EFUSE_Type;                                   /*!< Size = 512 (0x200)                                                        */



/* =========================================================================================================================== */
/* ================                                          EXTMEM                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief External Memory (EXTMEM)
  */

typedef struct {                                /*!< EXTMEM Structure                                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_ENABLE : 1;         /*!< The bit is used to activate the data cache. 0: disable, 1: enable         */
            uint32_t            : 1;
      __IOM uint32_t DCACHE_SIZE_MODE : 1;      /*!< The bit is used to configure cache memory size.0: 32KB, 1: 64KB           */
      __IOM uint32_t DCACHE_BLOCKSIZE_MODE : 2; /*!< The bit is used to configure cache block size.0: 16 bytes, 1:
                                                     32 bytes,2: 64 bytes                                                      */
            uint32_t            : 27;
    } bit;
  } DCACHE_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_SHUT_CORE0_BUS : 1; /*!< The bit is used to disable core0 dbus, 0: enable, 1: disable              */
      __IOM uint32_t DCACHE_SHUT_CORE1_BUS : 1; /*!< The bit is used to disable core1 dbus, 0: enable, 1: disable              */
            uint32_t            : 30;
    } bit;
  } DCACHE_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_TAG_MEM_FORCE_ON : 1;/*!< The bit is used to close clock gating of dcache tag memory.
                                                     1: close gating, 0: open clock gating.                                    */
      __IOM uint32_t DCACHE_TAG_MEM_FORCE_PD : 1;/*!< The bit is used to power dcache tag memory down, 0: follow rtc_lslp_pd,
                                                     1: power down                                                             */
      __IOM uint32_t DCACHE_TAG_MEM_FORCE_PU : 1;/*!< The bit is used to power dcache tag memory up, 0: follow rtc_lslp_pd,
                                                     1: power up                                                               */
            uint32_t            : 29;
    } bit;
  } DCACHE_TAG_POWER_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_PRELOCK_SCT0_EN : 1;/*!< The bit is used to enable the first section of prelock function.          */
      __IOM uint32_t DCACHE_PRELOCK_SCT1_EN : 1;/*!< The bit is used to enable the second section of prelock function.         */
            uint32_t            : 30;
    } bit;
  } DCACHE_PRELOCK_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_PRELOCK_SCT0_ADDR : 32;/*!< The bits are used to configure the first start virtual address
                                                     of data prelock, which is combined with DCACHE_PRELOCK_SCT0_SIZE_REG      */
    } bit;
  } DCACHE_PRELOCK_SCT0_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_PRELOCK_SCT1_ADDR : 32;/*!< The bits are used to configure the second start virtual address
                                                     of data prelock, which is combined with DCACHE_PRELOCK_SCT1_SIZE_REG      */
    } bit;
  } DCACHE_PRELOCK_SCT1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_PRELOCK_SCT1_SIZE : 16;/*!< The bits are used to configure the second length of data locking,
                                                     which is combined with DCACHE_PRELOCK_SCT1_ADDR_REG                       */
      __IOM uint32_t DCACHE_PRELOCK_SCT0_SIZE : 16;/*!< The bits are used to configure the first length of data locking,
                                                     which is combined with DCACHE_PRELOCK_SCT0_ADDR_REG                       */
    } bit;
  } DCACHE_PRELOCK_SCT_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_LOCK_ENA : 1;       /*!< The bit is used to enable lock operation. It will be cleared
                                                     by hardware after lock operation done.                                    */
      __IOM uint32_t DCACHE_UNLOCK_ENA : 1;     /*!< The bit is used to enable unlock operation. It will be cleared
                                                     by hardware after unlock operation done.                                  */
      __IM  uint32_t DCACHE_LOCK_DONE : 1;      /*!< The bit is used to indicate unlock/lock operation is finished.            */
            uint32_t            : 29;
    } bit;
  } DCACHE_LOCK_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_LOCK_ADDR : 32;     /*!< The bits are used to configure the start virtual address for
                                                     lock operations. It should be combined with DCACHE_LOCK_SIZE_REG.         */
    } bit;
  } DCACHE_LOCK_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_LOCK_SIZE : 16;     /*!< The bits are used to configure the length for lock operations.
                                                     The bits are the counts of cache block. It should be combined
                                                     with DCACHE_LOCK_ADDR_REG.                                                */
            uint32_t            : 16;
    } bit;
  } DCACHE_LOCK_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_INVALIDATE_ENA : 1; /*!< The bit is used to enable invalidate operation. It will be cleared
                                                     by hardware after invalidate operation done.                              */
      __IOM uint32_t DCACHE_WRITEBACK_ENA : 1;  /*!< The bit is used to enable writeback operation. It will be cleared
                                                     by hardware after writeback operation done.                               */
      __IOM uint32_t DCACHE_CLEAN_ENA : 1;      /*!< The bit is used to enable clean operation. It will be cleared
                                                     by hardware after clean operation done.                                   */
      __IM  uint32_t DCACHE_SYNC_DONE : 1;      /*!< The bit is used to indicate clean/writeback/invalidate operation
                                                     is finished.                                                              */
            uint32_t            : 28;
    } bit;
  } DCACHE_SYNC_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_SYNC_ADDR : 32;     /*!< The bits are used to configure the start virtual address for
                                                     clean operations. It should be combined with DCACHE_SYNC_SIZE_REG.        */
    } bit;
  } DCACHE_SYNC_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_SYNC_SIZE : 23;     /*!< The bits are used to configure the length for sync operations.
                                                     The bits are the counts of cache block. It should be combined
                                                     with DCACHE_SYNC_ADDR_REG.                                                */
            uint32_t            : 9;
    } bit;
  } DCACHE_SYNC_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_OCCUPY_ENA : 1;     /*!< The bit is used to enable occupy operation. It will be cleared
                                                     by hardware after issuing Auot-Invalidate Operation.                      */
      __IM  uint32_t DCACHE_OCCUPY_DONE : 1;    /*!< The bit is used to indicate occupy operation is finished.                 */
            uint32_t            : 30;
    } bit;
  } DCACHE_OCCUPY_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_OCCUPY_ADDR : 32;   /*!< The bits are used to configure the start virtual address for
                                                     occupy operation. It should be combined with DCACHE_OCCUPY_SIZE_REG.      */
    } bit;
  } DCACHE_OCCUPY_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_OCCUPY_SIZE : 16;   /*!< The bits are used to configure the length for occupy operation.
                                                     The bits are the counts of cache block. It should be combined
                                                     with DCACHE_OCCUPY_ADDR_REG.                                              */
            uint32_t            : 16;
    } bit;
  } DCACHE_OCCUPY_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_PRELOAD_ENA : 1;    /*!< The bit is used to enable preload operation. It will be cleared
                                                     by hardware after preload operation done.                                 */
      __IM  uint32_t DCACHE_PRELOAD_DONE : 1;   /*!< The bit is used to indicate preload operation is finished.                */
      __IOM uint32_t DCACHE_PRELOAD_ORDER : 1;  /*!< The bit is used to configure the direction of preload operation.
                                                     1: descending, 0: ascending.                                              */
            uint32_t            : 29;
    } bit;
  } DCACHE_PRELOAD_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_PRELOAD_ADDR : 32;  /*!< The bits are used to configure the start virtual address for
                                                     preload operation. It should be combined with DCACHE_PRELOAD_SIZE_REG.    */
    } bit;
  } DCACHE_PRELOAD_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_PRELOAD_SIZE : 16;  /*!< The bits are used to configure the length for preload operation.
                                                     The bits are the counts of cache block. It should be combined
                                                     with DCACHE_PRELOAD_ADDR_REG..                                            */
            uint32_t            : 16;
    } bit;
  } DCACHE_PRELOAD_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_AUTOLOAD_SCT0_ENA : 1;/*!< The bits are used to enable the first section for autoload operation.   */
      __IOM uint32_t DCACHE_AUTOLOAD_SCT1_ENA : 1;/*!< The bits are used to enable the second section for autoload
                                                     operation.                                                                */
      __IOM uint32_t DCACHE_AUTOLOAD_ENA : 1;   /*!< The bit is used to enable and disable autoload operation. It
                                                     is combined with dcache_autoload_done. 1: enable, 0: disable.             */
      __IM  uint32_t DCACHE_AUTOLOAD_DONE : 1;  /*!< The bit is used to indicate autoload operation is finished.               */
      __IOM uint32_t DCACHE_AUTOLOAD_ORDER : 1; /*!< The bits are used to configure the direction of autoload. 1:
                                                     descending, 0: ascending.                                                 */
      __IOM uint32_t DCACHE_AUTOLOAD_RQST : 2;  /*!< The bits are used to configure trigger conditions for autoload.
                                                     0/3: cache miss, 1: cache hit, 2: both cache miss and hit.                */
      __IOM uint32_t DCACHE_AUTOLOAD_SIZE : 2;  /*!< The bits are used to configure the numbers of the cache block
                                                     for the issuing autoload operation.                                       */
      __IOM uint32_t DCACHE_AUTOLOAD_BUFFER_CLEAR : 1;/*!< The bit is used to clear autoload buffer in dcache.                 */
            uint32_t            : 22;
    } bit;
  } DCACHE_AUTOLOAD_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_AUTOLOAD_SCT0_ADDR : 32;/*!< The bits are used to configure the start virtual address of
                                                     the first section for autoload operation. It should be
                                                     combined with dcache_autoload_sct0_ena.                                   */
    } bit;
  } DCACHE_AUTOLOAD_SCT0_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_AUTOLOAD_SCT0_SIZE : 27;/*!< The bits are used to configure the length of the first section
                                                     for autoload operation. It should be combined with dcache_autoload_sct0_e
                                                     a.                                                                        */
            uint32_t            : 5;
    } bit;
  } DCACHE_AUTOLOAD_SCT0_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_AUTOLOAD_SCT1_ADDR : 32;/*!< The bits are used to configure the start virtual address of
                                                     the second section for autoload operation. It should be
                                                     combined with dcache_autoload_sct1_ena.                                   */
    } bit;
  } DCACHE_AUTOLOAD_SCT1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_AUTOLOAD_SCT1_SIZE : 27;/*!< The bits are used to configure the length of the second section
                                                     for autoload operation. It should be combined with dcache_autoload_sct1_e
                                                     a.                                                                        */
            uint32_t            : 5;
    } bit;
  } DCACHE_AUTOLOAD_SCT1_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_ENABLE : 1;         /*!< The bit is used to activate the data cache. 0: disable, 1: enable         */
      __IOM uint32_t ICACHE_WAY_MODE : 1;       /*!< The bit is used to configure cache way mode.0: 4-way, 1: 8-way            */
      __IOM uint32_t ICACHE_SIZE_MODE : 1;      /*!< The bit is used to configure cache memory size.0: 16KB, 1: 32KB           */
      __IOM uint32_t ICACHE_BLOCKSIZE_MODE : 1; /*!< The bit is used to configure cache block size.0: 16 bytes, 1:
                                                     32 bytes                                                                  */
            uint32_t            : 28;
    } bit;
  } ICACHE_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_SHUT_CORE0_BUS : 1; /*!< The bit is used to disable core0 ibus, 0: enable, 1: disable              */
      __IOM uint32_t ICACHE_SHUT_CORE1_BUS : 1; /*!< The bit is used to disable core1 ibus, 0: enable, 1: disable              */
            uint32_t            : 30;
    } bit;
  } ICACHE_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_TAG_MEM_FORCE_ON : 1;/*!< The bit is used to close clock gating of icache tag memory.
                                                     1: close gating, 0: open clock gating.                                    */
      __IOM uint32_t ICACHE_TAG_MEM_FORCE_PD : 1;/*!< The bit is used to power icache tag memory down, 0: follow rtc_lslp,
                                                     1: power down                                                             */
      __IOM uint32_t ICACHE_TAG_MEM_FORCE_PU : 1;/*!< The bit is used to power icache tag memory up, 0: follow rtc_lslp,
                                                     1: power up                                                               */
            uint32_t            : 29;
    } bit;
  } ICACHE_TAG_POWER_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_PRELOCK_SCT0_EN : 1;/*!< The bit is used to enable the first section of prelock function.          */
      __IOM uint32_t ICACHE_PRELOCK_SCT1_EN : 1;/*!< The bit is used to enable the second section of prelock function.         */
            uint32_t            : 30;
    } bit;
  } ICACHE_PRELOCK_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_PRELOCK_SCT0_ADDR : 32;/*!< The bits are used to configure the first start virtual address
                                                     of data prelock, which is combined with ICACHE_PRELOCK_SCT0_SIZE_REG      */
    } bit;
  } ICACHE_PRELOCK_SCT0_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_PRELOCK_SCT1_ADDR : 32;/*!< The bits are used to configure the second start virtual address
                                                     of data prelock, which is combined with ICACHE_PRELOCK_SCT1_SIZE_REG      */
    } bit;
  } ICACHE_PRELOCK_SCT1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_PRELOCK_SCT1_SIZE : 16;/*!< The bits are used to configure the second length of data locking,
                                                     which is combined with ICACHE_PRELOCK_SCT1_ADDR_REG                       */
      __IOM uint32_t ICACHE_PRELOCK_SCT0_SIZE : 16;/*!< The bits are used to configure the first length of data locking,
                                                     which is combined with ICACHE_PRELOCK_SCT0_ADDR_REG                       */
    } bit;
  } ICACHE_PRELOCK_SCT_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_LOCK_ENA : 1;       /*!< The bit is used to enable lock operation. It will be cleared
                                                     by hardware after lock operation done.                                    */
      __IOM uint32_t ICACHE_UNLOCK_ENA : 1;     /*!< The bit is used to enable unlock operation. It will be cleared
                                                     by hardware after unlock operation done.                                  */
      __IM  uint32_t ICACHE_LOCK_DONE : 1;      /*!< The bit is used to indicate unlock/lock operation is finished.            */
            uint32_t            : 29;
    } bit;
  } ICACHE_LOCK_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_LOCK_ADDR : 32;     /*!< The bits are used to configure the start virtual address for
                                                     lock operations. It should be combined with ICACHE_LOCK_SIZE_REG.         */
    } bit;
  } ICACHE_LOCK_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_LOCK_SIZE : 16;     /*!< The bits are used to configure the length for lock operations.
                                                     The bits are the counts of cache block. It should be combined
                                                     with ICACHE_LOCK_ADDR_REG.                                                */
            uint32_t            : 16;
    } bit;
  } ICACHE_LOCK_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_INVALIDATE_ENA : 1; /*!< The bit is used to enable invalidate operation. It will be cleared
                                                     by hardware after invalidate operation done.                              */
      __IM  uint32_t ICACHE_SYNC_DONE : 1;      /*!< The bit is used to indicate invalidate operation is finished.             */
            uint32_t            : 30;
    } bit;
  } ICACHE_SYNC_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_SYNC_ADDR : 32;     /*!< The bits are used to configure the start virtual address for
                                                     clean operations. It should be combined with ICACHE_SYNC_SIZE_REG.        */
    } bit;
  } ICACHE_SYNC_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_SYNC_SIZE : 23;     /*!< The bits are used to configure the length for sync operations.
                                                     The bits are the counts of cache block. It should be combined
                                                     with ICACHE_SYNC_ADDR_REG.                                                */
            uint32_t            : 9;
    } bit;
  } ICACHE_SYNC_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_PRELOAD_ENA : 1;    /*!< The bit is used to enable preload operation. It will be cleared
                                                     by hardware after preload operation done.                                 */
      __IM  uint32_t ICACHE_PRELOAD_DONE : 1;   /*!< The bit is used to indicate preload operation is finished.                */
      __IOM uint32_t ICACHE_PRELOAD_ORDER : 1;  /*!< The bit is used to configure the direction of preload operation.
                                                     1: descending, 0: ascending.                                              */
            uint32_t            : 29;
    } bit;
  } ICACHE_PRELOAD_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_PRELOAD_ADDR : 32;  /*!< The bits are used to configure the start virtual address for
                                                     preload operation. It should be combined with ICACHE_PRELOAD_SIZE_REG.    */
    } bit;
  } ICACHE_PRELOAD_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_PRELOAD_SIZE : 16;  /*!< The bits are used to configure the length for preload operation.
                                                     The bits are the counts of cache block. It should be combined
                                                     with ICACHE_PRELOAD_ADDR_REG..                                            */
            uint32_t            : 16;
    } bit;
  } ICACHE_PRELOAD_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_AUTOLOAD_SCT0_ENA : 1;/*!< The bits are used to enable the first section for autoload operation.   */
      __IOM uint32_t ICACHE_AUTOLOAD_SCT1_ENA : 1;/*!< The bits are used to enable the second section for autoload
                                                     operation.                                                                */
      __IOM uint32_t ICACHE_AUTOLOAD_ENA : 1;   /*!< The bit is used to enable and disable autoload operation. It
                                                     is combined with icache_autoload_done. 1: enable, 0: disable.             */
      __IM  uint32_t ICACHE_AUTOLOAD_DONE : 1;  /*!< The bit is used to indicate autoload operation is finished.               */
      __IOM uint32_t ICACHE_AUTOLOAD_ORDER : 1; /*!< The bits are used to configure the direction of autoload. 1:
                                                     descending, 0: ascending.                                                 */
      __IOM uint32_t ICACHE_AUTOLOAD_RQST : 2;  /*!< The bits are used to configure trigger conditions for autoload.
                                                     0/3: cache miss, 1: cache hit, 2: both cache miss and hit.                */
      __IOM uint32_t ICACHE_AUTOLOAD_SIZE : 2;  /*!< The bits are used to configure the numbers of the cache block
                                                     for the issuing autoload operation.                                       */
      __IOM uint32_t ICACHE_AUTOLOAD_BUFFER_CLEAR : 1;/*!< The bit is used to clear autoload buffer in icache.                 */
            uint32_t            : 22;
    } bit;
  } ICACHE_AUTOLOAD_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_AUTOLOAD_SCT0_ADDR : 32;/*!< The bits are used to configure the start virtual address of
                                                     the first section for autoload operation. It should be
                                                     combined with icache_autoload_sct0_ena.                                   */
    } bit;
  } ICACHE_AUTOLOAD_SCT0_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_AUTOLOAD_SCT0_SIZE : 27;/*!< The bits are used to configure the length of the first section
                                                     for autoload operation. It should be combined with icache_autoload_sct0_e
                                                     a.                                                                        */
            uint32_t            : 5;
    } bit;
  } ICACHE_AUTOLOAD_SCT0_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_AUTOLOAD_SCT1_ADDR : 32;/*!< The bits are used to configure the start virtual address of
                                                     the second section for autoload operation. It should be
                                                     combined with icache_autoload_sct1_ena.                                   */
    } bit;
  } ICACHE_AUTOLOAD_SCT1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_AUTOLOAD_SCT1_SIZE : 27;/*!< The bits are used to configure the length of the second section
                                                     for autoload operation. It should be combined with icache_autoload_sct1_e
                                                     a.                                                                        */
            uint32_t            : 5;
    } bit;
  } ICACHE_AUTOLOAD_SCT1_SIZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t IBUS_TO_FLASH_START_VADDR : 32;/*!< The bits are used to configure the start virtual address of
                                                     ibus to access flash. The register is used to give constraints
                                                     to ibus access counter.                                                   */
    } bit;
  } IBUS_TO_FLASH_START_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t IBUS_TO_FLASH_END_VADDR : 32;/*!< The bits are used to configure the end virtual address of ibus
                                                     to access flash. The register is used to give constraints
                                                     to ibus access counter.                                                   */
    } bit;
  } IBUS_TO_FLASH_END_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DBUS_TO_FLASH_START_VADDR : 32;/*!< The bits are used to configure the start virtual address of
                                                     dbus to access flash. The register is used to give constraints
                                                     to dbus access counter.                                                   */
    } bit;
  } DBUS_TO_FLASH_START_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DBUS_TO_FLASH_END_VADDR : 32;/*!< The bits are used to configure the end virtual address of dbus
                                                     to access flash. The register is used to give constraints
                                                     to dbus access counter.                                                   */
    } bit;
  } DBUS_TO_FLASH_END_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __OM  uint32_t DCACHE_ACS_CNT_CLR : 1;    /*!< The bit is used to clear dcache counter.                                  */
      __OM  uint32_t ICACHE_ACS_CNT_CLR : 1;    /*!< The bit is used to clear icache counter.                                  */
            uint32_t            : 30;
    } bit;
  } CACHE_ACS_CNT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t IBUS_ACS_MISS_CNT : 32;    /*!< The bits are used to count the number of the cache miss caused
                                                     by ibus access flash/spiram.                                              */
    } bit;
  } IBUS_ACS_MISS_CNT;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t IBUS_ACS_CNT : 32;         /*!< The bits are used to count the number of ibus access flash/spiram
                                                     through icache.                                                           */
    } bit;
  } IBUS_ACS_CNT;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t DBUS_ACS_FLASH_MISS_CNT : 32;/*!< The bits are used to count the number of the cache miss caused
                                                     by dbus access flash.                                                     */
    } bit;
  } DBUS_ACS_FLASH_MISS_CNT;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t DBUS_ACS_SPIRAM_MISS_CNT : 32;/*!< The bits are used to count the number of the cache miss caused
                                                     by dbus access spiram.                                                    */
    } bit;
  } DBUS_ACS_SPIRAM_MISS_CNT;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t DBUS_ACS_CNT : 32;         /*!< The bits are used to count the number of dbus access flash/spiram
                                                     through dcache.                                                           */
    } bit;
  } DBUS_ACS_CNT;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_SYNC_OP_FAULT_INT_ENA : 1;/*!< The bit is used to enable interrupt by sync configurations fault.   */
      __IOM uint32_t ICACHE_PRELOAD_OP_FAULT_INT_ENA : 1;/*!< The bit is used to enable interrupt by preload configurations
                                                     fault.                                                                    */
      __IOM uint32_t DCACHE_SYNC_OP_FAULT_INT_ENA : 1;/*!< The bit is used to enable interrupt by sync configurations fault.   */
      __IOM uint32_t DCACHE_PRELOAD_OP_FAULT_INT_ENA : 1;/*!< The bit is used to enable interrupt by preload configurations
                                                     fault.                                                                    */
      __IOM uint32_t DCACHE_WRITE_FLASH_INT_ENA : 1;/*!< The bit is used to enable interrupt by dcache trying to write
                                                     flash.                                                                    */
      __IOM uint32_t MMU_ENTRY_FAULT_INT_ENA : 1;/*!< The bit is used to enable interrupt by mmu entry fault.                  */
      __IOM uint32_t DCACHE_OCCUPY_EXC_INT_ENA : 1;/*!< The bit is used to enable interrupt by dcache trying to replace
                                                     a line whose blocks all have been occupied by occupy-mode.                */
      __IOM uint32_t IBUS_CNT_OVF_INT_ENA : 1;  /*!< The bit is used to enable interrupt by ibus counter overflow.             */
      __IOM uint32_t DBUS_CNT_OVF_INT_ENA : 1;  /*!< The bit is used to enable interrupt by dbus counter overflow.             */
            uint32_t            : 23;
    } bit;
  } CACHE_ILG_INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __OM  uint32_t ICACHE_SYNC_OP_FAULT_INT_CLR : 1;/*!< The bit is used to clear interrupt by sync configurations fault.    */
      __OM  uint32_t ICACHE_PRELOAD_OP_FAULT_INT_CLR : 1;/*!< The bit is used to clear interrupt by preload configurations
                                                     fault.                                                                    */
      __OM  uint32_t DCACHE_SYNC_OP_FAULT_INT_CLR : 1;/*!< The bit is used to clear interrupt by sync configurations fault.    */
      __OM  uint32_t DCACHE_PRELOAD_OP_FAULT_INT_CLR : 1;/*!< The bit is used to clear interrupt by preload configurations
                                                     fault.                                                                    */
      __OM  uint32_t DCACHE_WRITE_FLASH_INT_CLR : 1;/*!< The bit is used to clear interrupt by dcache trying to write
                                                     flash.                                                                    */
      __OM  uint32_t MMU_ENTRY_FAULT_INT_CLR : 1;/*!< The bit is used to clear interrupt by mmu entry fault.                   */
      __OM  uint32_t DCACHE_OCCUPY_EXC_INT_CLR : 1;/*!< The bit is used to clear interrupt by dcache trying to replace
                                                     a line whose blocks all have been occupied by occupy-mode.                */
      __OM  uint32_t IBUS_CNT_OVF_INT_CLR : 1;  /*!< The bit is used to clear interrupt by ibus counter overflow.              */
      __OM  uint32_t DBUS_CNT_OVF_INT_CLR : 1;  /*!< The bit is used to clear interrupt by dbus counter overflow.              */
            uint32_t            : 23;
    } bit;
  } CACHE_ILG_INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t ICACHE_SYNC_OP_FAULT_ST : 1;/*!< The bit is used to indicate interrupt by sync configurations
                                                     fault.                                                                    */
      __IM  uint32_t ICACHE_PRELOAD_OP_FAULT_ST : 1;/*!< The bit is used to indicate interrupt by preload configurations
                                                     fault.                                                                    */
      __IM  uint32_t DCACHE_SYNC_OP_FAULT_ST : 1;/*!< The bit is used to indicate interrupt by sync configurations
                                                     fault.                                                                    */
      __IM  uint32_t DCACHE_PRELOAD_OP_FAULT_ST : 1;/*!< The bit is used to indicate interrupt by preload configurations
                                                     fault.                                                                    */
      __IM  uint32_t DCACHE_WRITE_FLASH_ST : 1; /*!< The bit is used to indicate interrupt by dcache trying to write
                                                     flash.                                                                    */
      __IM  uint32_t MMU_ENTRY_FAULT_ST : 1;    /*!< The bit is used to indicate interrupt by mmu entry fault.                 */
      __IM  uint32_t DCACHE_OCCUPY_EXC_ST : 1;  /*!< The bit is used to indicate interrupt by dcache trying to replace
                                                     a line whose blocks all have been occupied by occupy-mode.                */
      __IM  uint32_t IBUS_ACS_CNT_OVF_ST : 1;   /*!< The bit is used to indicate interrupt by ibus access flash/spiram
                                                     counter overflow.                                                         */
      __IM  uint32_t IBUS_ACS_MISS_CNT_OVF_ST : 1;/*!< The bit is used to indicate interrupt by ibus access flash/spiram
                                                     miss counter overflow.                                                    */
      __IM  uint32_t DBUS_ACS_CNT_OVF_ST : 1;   /*!< The bit is used to indicate interrupt by dbus access flash/spiram
                                                     counter overflow.                                                         */
      __IM  uint32_t DBUS_ACS_FLASH_MISS_CNT_OVF_ST : 1;/*!< The bit is used to indicate interrupt by dbus access flash miss
                                                     counter overflow.                                                         */
      __IM  uint32_t DBUS_ACS_SPIRAM_MISS_CNT_OVF_ST : 1;/*!< The bit is used to indicate interrupt by dbus access spiram
                                                     miss counter overflow.                                                    */
            uint32_t            : 20;
    } bit;
  } CACHE_ILG_INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CORE0_IBUS_ACS_MSK_IC_INT_ENA : 1;/*!< The bit is used to enable interrupt by cpu access icache while
                                                     the corresponding ibus is disabled which include speculative
                                                     access.                                                                   */
      __IOM uint32_t CORE0_IBUS_WR_IC_INT_ENA : 1;/*!< The bit is used to enable interrupt by ibus trying to write
                                                     icache                                                                    */
      __IOM uint32_t CORE0_IBUS_REJECT_INT_ENA : 1;/*!< The bit is used to enable interrupt by authentication fail.            */
      __IOM uint32_t CORE0_DBUS_ACS_MSK_DC_INT_ENA : 1;/*!< The bit is used to enable interrupt by cpu access dcache while
                                                     the corresponding dbus is disabled which include speculative
                                                     access.                                                                   */
      __IOM uint32_t CORE0_DBUS_REJECT_INT_ENA : 1;/*!< The bit is used to enable interrupt by authentication fail.            */
            uint32_t            : 27;
    } bit;
  } CORE0_ACS_CACHE_INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __OM  uint32_t CORE0_IBUS_ACS_MSK_IC_INT_CLR : 1;/*!< The bit is used to clear interrupt by cpu access icache while
                                                     the corresponding ibus is disabled or icache is disabled
                                                     which include speculative access.                                         */
      __OM  uint32_t CORE0_IBUS_WR_IC_INT_CLR : 1;/*!< The bit is used to clear interrupt by ibus trying to write icache       */
      __OM  uint32_t CORE0_IBUS_REJECT_INT_CLR : 1;/*!< The bit is used to clear interrupt by authentication fail.             */
      __OM  uint32_t CORE0_DBUS_ACS_MSK_DC_INT_CLR : 1;/*!< The bit is used to clear interrupt by cpu access dcache while
                                                     the corresponding dbus is disabled or dcache is disabled
                                                     which include speculative access.                                         */
      __OM  uint32_t CORE0_DBUS_REJECT_INT_CLR : 1;/*!< The bit is used to clear interrupt by authentication fail.             */
            uint32_t            : 27;
    } bit;
  } CORE0_ACS_CACHE_INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE0_IBUS_ACS_MSK_ICACHE_ST : 1;/*!< The bit is used to indicate interrupt by cpu access icache while
                                                     the core0_ibus is disabled or icache is disabled which
                                                     include speculative access.                                               */
      __IM  uint32_t CORE0_IBUS_WR_ICACHE_ST : 1;/*!< The bit is used to indicate interrupt by ibus trying to write
                                                     icache                                                                    */
      __IM  uint32_t CORE0_IBUS_REJECT_ST : 1;  /*!< The bit is used to indicate interrupt by authentication fail.             */
      __IM  uint32_t CORE0_DBUS_ACS_MSK_DCACHE_ST : 1;/*!< The bit is used to indicate interrupt by cpu access dcache while
                                                     the core0_dbus is disabled or dcache is disabled which
                                                     include speculative access.                                               */
      __IM  uint32_t CORE0_DBUS_REJECT_ST : 1;  /*!< The bit is used to indicate interrupt by authentication fail.             */
            uint32_t            : 27;
    } bit;
  } CORE0_ACS_CACHE_INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CORE1_IBUS_ACS_MSK_IC_INT_ENA : 1;/*!< The bit is used to enable interrupt by cpu access icache while
                                                     the corresponding ibus is disabled which include speculative
                                                     access.                                                                   */
      __IOM uint32_t CORE1_IBUS_WR_IC_INT_ENA : 1;/*!< The bit is used to enable interrupt by ibus trying to write
                                                     icache                                                                    */
      __IOM uint32_t CORE1_IBUS_REJECT_INT_ENA : 1;/*!< The bit is used to enable interrupt by authentication fail.            */
      __IOM uint32_t CORE1_DBUS_ACS_MSK_DC_INT_ENA : 1;/*!< The bit is used to enable interrupt by cpu access dcache while
                                                     the corresponding dbus is disabled which include speculative
                                                     access.                                                                   */
      __IOM uint32_t CORE1_DBUS_REJECT_INT_ENA : 1;/*!< The bit is used to enable interrupt by authentication fail.            */
            uint32_t            : 27;
    } bit;
  } CORE1_ACS_CACHE_INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __OM  uint32_t CORE1_IBUS_ACS_MSK_IC_INT_CLR : 1;/*!< The bit is used to clear interrupt by cpu access icache while
                                                     the corresponding ibus is disabled or icache is disabled
                                                     which include speculative access.                                         */
      __OM  uint32_t CORE1_IBUS_WR_IC_INT_CLR : 1;/*!< The bit is used to clear interrupt by ibus trying to write icache       */
      __OM  uint32_t CORE1_IBUS_REJECT_INT_CLR : 1;/*!< The bit is used to clear interrupt by authentication fail.             */
      __OM  uint32_t CORE1_DBUS_ACS_MSK_DC_INT_CLR : 1;/*!< The bit is used to clear interrupt by cpu access dcache while
                                                     the corresponding dbus is disabled or dcache is disabled
                                                     which include speculative access.                                         */
      __OM  uint32_t CORE1_DBUS_REJECT_INT_CLR : 1;/*!< The bit is used to clear interrupt by authentication fail.             */
            uint32_t            : 27;
    } bit;
  } CORE1_ACS_CACHE_INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE1_IBUS_ACS_MSK_ICACHE_ST : 1;/*!< The bit is used to indicate interrupt by cpu access icache while
                                                     the core1_ibus is disabled or icache is disabled which
                                                     include speculative access.                                               */
      __IM  uint32_t CORE1_IBUS_WR_ICACHE_ST : 1;/*!< The bit is used to indicate interrupt by ibus trying to write
                                                     icache                                                                    */
      __IM  uint32_t CORE1_IBUS_REJECT_ST : 1;  /*!< The bit is used to indicate interrupt by authentication fail.             */
      __IM  uint32_t CORE1_DBUS_ACS_MSK_DCACHE_ST : 1;/*!< The bit is used to indicate interrupt by cpu access dcache while
                                                     the core1_dbus is disabled or dcache is disabled which
                                                     include speculative access.                                               */
      __IM  uint32_t CORE1_DBUS_REJECT_ST : 1;  /*!< The bit is used to indicate interrupt by authentication fail.             */
            uint32_t            : 27;
    } bit;
  } CORE1_ACS_CACHE_INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE0_DBUS_TAG_ATTR : 3;   /*!< The bits are used to indicate the attribute of data from external
                                                     memory when authentication fail. 0: invalidate, 1: execute-able,
                                                     2: read-able, 4: write-able.                                              */
      __IM  uint32_t CORE0_DBUS_ATTR : 3;       /*!< The bits are used to indicate the attribute of CPU access dbus
                                                     when authentication fail. 0: invalidate, 1: execute-able,
                                                     2: read-able, 4: write-able.                                              */
      __IM  uint32_t CORE0_DBUS_WORLD : 1;      /*!< The bit is used to indicate the world of CPU access dbus when
                                                     authentication fail. 0: WORLD0, 1: WORLD1                                 */
            uint32_t            : 25;
    } bit;
  } CORE0_DBUS_REJECT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE0_DBUS_VADDR : 32;     /*!< The bits are used to indicate the virtual address of CPU access
                                                     dbus when authentication fail.                                            */
    } bit;
  } CORE0_DBUS_REJECT_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE0_IBUS_TAG_ATTR : 3;   /*!< The bits are used to indicate the attribute of data from external
                                                     memory when authentication fail. 0: invalidate, 1: execute-able,
                                                     2: read-able, 4: write-able.                                              */
      __IM  uint32_t CORE0_IBUS_ATTR : 3;       /*!< The bits are used to indicate the attribute of CPU access ibus
                                                     when authentication fail. 0: invalidate, 1: execute-able,
                                                     2: read-able                                                              */
      __IM  uint32_t CORE0_IBUS_WORLD : 1;      /*!< The bit is used to indicate the world of CPU access ibus when
                                                     authentication fail. 0: WORLD0, 1: WORLD1                                 */
            uint32_t            : 25;
    } bit;
  } CORE0_IBUS_REJECT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE0_IBUS_VADDR : 32;     /*!< The bits are used to indicate the virtual address of CPU access
                                                     ibus when authentication fail.                                            */
    } bit;
  } CORE0_IBUS_REJECT_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE1_DBUS_TAG_ATTR : 3;   /*!< The bits are used to indicate the attribute of data from external
                                                     memory when authentication fail. 0: invalidate, 1: execute-able,
                                                     2: read-able, 4: write-able.                                              */
      __IM  uint32_t CORE1_DBUS_ATTR : 3;       /*!< The bits are used to indicate the attribute of CPU access dbus
                                                     when authentication fail. 0: invalidate, 1: execute-able,
                                                     2: read-able, 4: write-able.                                              */
      __IM  uint32_t CORE1_DBUS_WORLD : 1;      /*!< The bit is used to indicate the world of CPU access dbus when
                                                     authentication fail. 0: WORLD0, 1: WORLD1                                 */
            uint32_t            : 25;
    } bit;
  } CORE1_DBUS_REJECT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE1_DBUS_VADDR : 32;     /*!< The bits are used to indicate the virtual address of CPU access
                                                     dbus when authentication fail.                                            */
    } bit;
  } CORE1_DBUS_REJECT_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE1_IBUS_TAG_ATTR : 3;   /*!< The bits are used to indicate the attribute of data from external
                                                     memory when authentication fail. 0: invalidate, 1: execute-able,
                                                     2: read-able, 4: write-able.                                              */
      __IM  uint32_t CORE1_IBUS_ATTR : 3;       /*!< The bits are used to indicate the attribute of CPU access ibus
                                                     when authentication fail. 0: invalidate, 1: execute-able,
                                                     2: read-able                                                              */
      __IM  uint32_t CORE1_IBUS_WORLD : 1;      /*!< The bit is used to indicate the world of CPU access ibus when
                                                     authentication fail. 0: WORLD0, 1: WORLD1                                 */
            uint32_t            : 25;
    } bit;
  } CORE1_IBUS_REJECT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CORE1_IBUS_VADDR : 32;     /*!< The bits are used to indicate the virtual address of CPU access
                                                     ibus when authentication fail.                                            */
    } bit;
  } CORE1_IBUS_REJECT_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CACHE_MMU_FAULT_CONTENT : 16;/*!< The bits are used to indicate the content of mmu entry which
                                                     cause mmu fault..                                                         */
      __IM  uint32_t CACHE_MMU_FAULT_CODE : 4;  /*!< The right-most 3 bits are used to indicate the operations which
                                                     cause mmu fault occurrence. 0: default, 1: cpu miss, 2:
                                                     preload miss, 3: writeback, 4: cpu miss evict recovery
                                                     address, 5: load miss evict recovery address, 6: external
                                                     dma tx, 7: external dma rx. The most significant bit is
                                                     used to indicate this operation occurs in which one icache.               */
            uint32_t            : 12;
    } bit;
  } CACHE_MMU_FAULT_CONTENT;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t CACHE_MMU_FAULT_VADDR : 32;/*!< The bits are used to indicate the virtual address which cause
                                                     mmu fault..                                                               */
    } bit;
  } CACHE_MMU_FAULT_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CACHE_FLASH_WRAP_AROUND : 1;/*!< The bit is used to enable wrap around mode when read data from
                                                     flash.                                                                    */
      __IOM uint32_t CACHE_SRAM_RD_WRAP_AROUND : 1;/*!< The bit is used to enable wrap around mode when read data from
                                                     spiram.                                                                   */
            uint32_t            : 30;
    } bit;
  } CACHE_WRAP_AROUND_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CACHE_MMU_MEM_FORCE_ON : 1;/*!< The bit is used to enable clock gating to save power when access
                                                     mmu memory, 0: enable, 1: disable                                         */
      __IOM uint32_t CACHE_MMU_MEM_FORCE_PD : 1;/*!< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd,
                                                     1: power down                                                             */
      __IOM uint32_t CACHE_MMU_MEM_FORCE_PU : 1;/*!< The bit is used to power mmu memory down, 0: follow_rtc_lslp_pd,
                                                     1: power up                                                               */
            uint32_t            : 29;
    } bit;
  } CACHE_MMU_POWER_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t ICACHE_STATE : 12;         /*!< The bit is used to indicate whether icache main fsm is in idle
                                                     state or not. 1: in idle state, 0: not in idle state                      */
      __IM  uint32_t DCACHE_STATE : 12;         /*!< The bit is used to indicate whether dcache main fsm is in idle
                                                     state or not. 1: in idle state, 0: not in idle state                      */
            uint32_t            : 8;
    } bit;
  } CACHE_STATE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t RECORD_DISABLE_DB_ENCRYPT : 1;/*!< Reserved                                                               */
      __IOM uint32_t RECORD_DISABLE_G0CB_DECRYPT : 1;/*!< Reserved                                                             */
            uint32_t            : 30;
    } bit;
  } CACHE_ENCRYPT_DECRYPT_RECORD_DISABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CLK_FORCE_ON_MANUAL_CRYPT : 1;/*!< The bit is used to close clock gating of manual crypt clock.
                                                     1: close gating, 0: open clock gating.                                    */
      __IOM uint32_t CLK_FORCE_ON_AUTO_CRYPT : 1;/*!< The bit is used to close clock gating of automatic crypt clock.
                                                     1: close gating, 0: open clock gating.                                    */
      __IOM uint32_t CLK_FORCE_ON_CRYPT : 1;    /*!< The bit is used to close clock gating of external memory encrypt
                                                     and decrypt clock. 1: close gating, 0: open clock gating.                 */
            uint32_t            : 29;
    } bit;
  } CACHE_ENCRYPT_DECRYPT_CLK_FORCE_ON;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ALLOC_WB_HOLD_ARBITER : 1; /*!< Reserved                                                                  */
            uint32_t            : 31;
    } bit;
  } CACHE_BRIDGE_ARBITER_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t ICACHE_PRELOAD_INT_ST : 1; /*!< The bit is used to indicate the interrupt by icache pre-load
                                                     done.                                                                     */
      __IOM uint32_t ICACHE_PRELOAD_INT_ENA : 1;/*!< The bit is used to enable the interrupt by icache pre-load done.          */
      __OM  uint32_t ICACHE_PRELOAD_INT_CLR : 1;/*!< The bit is used to clear the interrupt by icache pre-load done.           */
      __IM  uint32_t DCACHE_PRELOAD_INT_ST : 1; /*!< The bit is used to indicate the interrupt by dcache pre-load
                                                     done.                                                                     */
      __IOM uint32_t DCACHE_PRELOAD_INT_ENA : 1;/*!< The bit is used to enable the interrupt by dcache pre-load done.          */
      __OM  uint32_t DCACHE_PRELOAD_INT_CLR : 1;/*!< The bit is used to clear the interrupt by dcache pre-load done.           */
            uint32_t            : 26;
    } bit;
  } CACHE_PRELOAD_INT_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t ICACHE_SYNC_INT_ST : 1;    /*!< The bit is used to indicate the interrupt by icache sync done.            */
      __IOM uint32_t ICACHE_SYNC_INT_ENA : 1;   /*!< The bit is used to enable the interrupt by icache sync done.              */
      __OM  uint32_t ICACHE_SYNC_INT_CLR : 1;   /*!< The bit is used to clear the interrupt by icache sync done.               */
      __IM  uint32_t DCACHE_SYNC_INT_ST : 1;    /*!< The bit is used to indicate the interrupt by dcache sync done.            */
      __IOM uint32_t DCACHE_SYNC_INT_ENA : 1;   /*!< The bit is used to enable the interrupt by dcache sync done.              */
      __OM  uint32_t DCACHE_SYNC_INT_CLR : 1;   /*!< The bit is used to clear the interrupt by dcache sync done.               */
            uint32_t            : 26;
    } bit;
  } CACHE_SYNC_INT_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CACHE_MMU_OWNER : 24;      /*!< The bits are used to specify the owner of MMU.bit0: icache,
                                                     bit1: dcache, bit2: dma, bit3: reserved.                                  */
            uint32_t            : 8;
    } bit;
  } CACHE_MMU_OWNER;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CACHE_IGNORE_PRELOAD_MMU_ENTRY_FAULT : 1;/*!< The bit is used to disable checking mmu entry fault by preload
                                                     operation.                                                                */
      __IOM uint32_t CACHE_IGNORE_SYNC_MMU_ENTRY_FAULT : 1;/*!< The bit is used to disable checking mmu entry fault by sync
                                                     operation.                                                                */
      __IOM uint32_t CACHE_TRACE_ENA : 1;       /*!< The bit is used to enable cache trace function.                           */
            uint32_t            : 29;
    } bit;
  } CACHE_CONF_MISC;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ENA        : 1;            /*!< The bit is used to enable dcache freeze mode                              */
      __IOM uint32_t MODE       : 1;            /*!< The bit is used to configure freeze mode, 0: assert busy if
                                                     CPU miss 1: assert hit if CPU miss                                        */
      __IM  uint32_t DONE       : 1;            /*!< The bit is used to indicate dcache freeze success                         */
            uint32_t            : 29;
    } bit;
  } DCACHE_FREEZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ENA        : 1;            /*!< The bit is used to enable icache freeze mode                              */
      __IOM uint32_t MODE       : 1;            /*!< The bit is used to configure freeze mode, 0: assert busy if
                                                     CPU miss 1: assert hit if CPU miss                                        */
      __IM  uint32_t DONE       : 1;            /*!< The bit is used to indicate icache freeze success                         */
            uint32_t            : 29;
    } bit;
  } ICACHE_FREEZE;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_ATOMIC_OPERATE_ENA : 1;/*!< The bit is used to activate icache atomic operation protection.
                                                     In this case, sync/lock operation can not interrupt miss-work.
                                                     This feature does not work during invalidateAll operation.                */
            uint32_t            : 31;
    } bit;
  } ICACHE_ATOMIC_OPERATE_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DCACHE_ATOMIC_OPERATE_ENA : 1;/*!< The bit is used to activate dcache atomic operation protection.
                                                     In this case, sync/lock/occupy operation can not interrupt
                                                     miss-work. This feature does not work during invalidateAll
                                                     operation.                                                                */
            uint32_t            : 31;
    } bit;
  } DCACHE_ATOMIC_OPERATE_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t BYPASS     : 1;            /*!< The bit is used to disable request recording which could cause
                                                     performance issue                                                         */
            uint32_t            : 31;
    } bit;
  } CACHE_REQUEST;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CLK_EN     : 1;            /*!< Reserved                                                                  */
            uint32_t            : 31;
    } bit;
  } CLOCK_GATE;
  __IM  uint32_t  RESERVED[6];
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t ICACHE_TAG_OBJECT : 1;     /*!< Set this bit to set icache tag memory as object. This bit should
                                                     be onehot with the others fields inside this register.                    */
      __IOM uint32_t DCACHE_TAG_OBJECT : 1;     /*!< Set this bit to set dcache tag memory as object. This bit should
                                                     be onehot with the others fields inside this register.                    */
            uint32_t            : 30;
    } bit;
  } CACHE_TAG_OBJECT_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CACHE_TAG_WAY_OBJECT : 3;  /*!< Set this bits to select which way of the tag-object will be
                                                     accessed. 0: way0, 1: way1, 2: way2, 3: way3, .., 7: way7.                */
            uint32_t            : 29;
    } bit;
  } CACHE_TAG_WAY_OBJECT;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CACHE_VADDR : 32;          /*!< Those bits stores the virtual address which will decide where
                                                     inside the specified tag memory object will be accessed.                  */
    } bit;
  } CACHE_VADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CACHE_TAG_CONTENT : 32;    /*!< This is a constant place where we can write data to or read
                                                     data from the tag memory on the specified cache.                          */
    } bit;
  } CACHE_TAG_CONTENT;
  __IM  uint32_t  RESERVED1[155];
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< version information.                                                      */
            uint32_t            : 4;
    } bit;
  } DATE;
} EXTMEM_Type;                                  /*!< Size = 1024 (0x400)                                                       */



/* =========================================================================================================================== */
/* ================                                           GPIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Input/Output (GPIO)
  */

typedef struct {                                /*!< GPIO Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO bit select register                                                  */
    
    struct {
      __IOM uint32_t BT_SEL     : 32;           /*!< GPIO bit select register                                                  */
    } bit;
  } BT_SELECT;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output register for GPIO0-31                                         */
    
    struct {
      __IOM uint32_t DATA_ORIG  : 32;           /*!< GPIO output register for GPIO0-31                                         */
    } bit;
  } OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output set register for GPIO0-31                                     */
    
    struct {
      __OM  uint32_t OUT_W1TS   : 32;           /*!< GPIO output set register for GPIO0-31                                     */
    } bit;
  } OUT_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output clear register for GPIO0-31                                   */
    
    struct {
      __OM  uint32_t OUT_W1TC   : 32;           /*!< GPIO output clear register for GPIO0-31                                   */
    } bit;
  } OUT_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output register for GPIO32-53                                        */
    
    struct {
      __IOM uint32_t DATA_ORIG  : 22;           /*!< GPIO output register for GPIO32-53                                        */
            uint32_t            : 10;
    } bit;
  } OUT1;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output set register for GPIO32-53                                    */
    
    struct {
      __OM  uint32_t OUT1_W1TS  : 22;           /*!< GPIO output set register for GPIO32-53                                    */
            uint32_t            : 10;
    } bit;
  } OUT1_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output clear register for GPIO32-53                                  */
    
    struct {
      __OM  uint32_t OUT1_W1TC  : 22;           /*!< GPIO output clear register for GPIO32-53                                  */
            uint32_t            : 10;
    } bit;
  } OUT1_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO sdio select register                                                 */
    
    struct {
      __IOM uint32_t SDIO_SEL   : 8;            /*!< GPIO sdio select register                                                 */
            uint32_t            : 24;
    } bit;
  } SDIO_SELECT;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable register for GPIO0-31                                  */
    
    struct {
      __IOM uint32_t DATA       : 32;           /*!< GPIO output enable register for GPIO0-31                                  */
    } bit;
  } ENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable set register for GPIO0-31                              */
    
    struct {
      __OM  uint32_t ENABLE_W1TS : 32;          /*!< GPIO output enable set register for GPIO0-31                              */
    } bit;
  } ENABLE_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable clear register for GPIO0-31                            */
    
    struct {
      __OM  uint32_t ENABLE_W1TC : 32;          /*!< GPIO output enable clear register for GPIO0-31                            */
    } bit;
  } ENABLE_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable register for GPIO32-53                                 */
    
    struct {
      __IOM uint32_t DATA       : 22;           /*!< GPIO output enable register for GPIO32-53                                 */
            uint32_t            : 10;
    } bit;
  } ENABLE1;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable set register for GPIO32-53                             */
    
    struct {
      __OM  uint32_t ENABLE1_W1TS : 22;         /*!< GPIO output enable set register for GPIO32-53                             */
            uint32_t            : 10;
    } bit;
  } ENABLE1_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO output enable clear register for GPIO32-53                           */
    
    struct {
      __OM  uint32_t ENABLE1_W1TC : 22;         /*!< GPIO output enable clear register for GPIO32-53                           */
            uint32_t            : 10;
    } bit;
  } ENABLE1_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< pad strapping register                                                    */
    
    struct {
      __IM  uint32_t STRAPPING  : 16;           /*!< pad strapping register                                                    */
            uint32_t            : 16;
    } bit;
  } STRAP;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input register for GPIO0-31                                          */
    
    struct {
      __IOM uint32_t DATA_NEXT  : 32;           /*!< GPIO input register for GPIO0-31                                          */
    } bit;
  } IN;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input register for GPIO32-53                                         */
    
    struct {
      __IOM uint32_t DATA_NEXT  : 22;           /*!< GPIO input register for GPIO32-53                                         */
            uint32_t            : 10;
    } bit;
  } IN1;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO interrupt status register for GPIO0-31                               */
    
    struct {
      __IOM uint32_t INTERRUPT  : 32;           /*!< GPIO interrupt status register for GPIO0-31                               */
    } bit;
  } STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO interrupt status set register for GPIO0-31                           */
    
    struct {
      __OM  uint32_t STATUS_W1TS : 32;          /*!< GPIO interrupt status set register for GPIO0-31                           */
    } bit;
  } STATUS_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO interrupt status clear register for GPIO0-31                         */
    
    struct {
      __OM  uint32_t STATUS_W1TC : 32;          /*!< GPIO interrupt status clear register for GPIO0-31                         */
    } bit;
  } STATUS_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO interrupt status register for GPIO32-53                              */
    
    struct {
      __IOM uint32_t INTERRUPT  : 22;           /*!< GPIO interrupt status register for GPIO32-53                              */
            uint32_t            : 10;
    } bit;
  } STATUS1;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO interrupt status set register for GPIO32-53                          */
    
    struct {
      __OM  uint32_t STATUS1_W1TS : 22;         /*!< GPIO interrupt status set register for GPIO32-53                          */
            uint32_t            : 10;
    } bit;
  } STATUS1_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO interrupt status clear register for GPIO32-53                        */
    
    struct {
      __OM  uint32_t STATUS1_W1TC : 22;         /*!< GPIO interrupt status clear register for GPIO32-53                        */
            uint32_t            : 10;
    } bit;
  } STATUS1_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO PRO_CPU interrupt status register for GPIO0-31                       */
    
    struct {
      __IM  uint32_t PROCPU_INT : 32;           /*!< GPIO PRO_CPU interrupt status register for GPIO0-31                       */
    } bit;
  } PCPU_INT;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31         */
    
    struct {
      __IM  uint32_t PROCPU_NMI_INT : 32;       /*!< GPIO PRO_CPU(not shielded) interrupt status register for GPIO0-31         */
    } bit;
  } PCPU_NMI_INT;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO CPUSDIO interrupt status register for GPIO0-31                       */
    
    struct {
      __IM  uint32_t SDIO_INT   : 32;           /*!< GPIO CPUSDIO interrupt status register for GPIO0-31                       */
    } bit;
  } CPUSDIO_INT;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO PRO_CPU interrupt status register for GPIO32-53                      */
    
    struct {
      __IM  uint32_t PROCPU_INT1 : 22;          /*!< GPIO PRO_CPU interrupt status register for GPIO32-53                      */
            uint32_t            : 10;
    } bit;
  } PCPU_INT1;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO PRO_CPU(not shielded) interrupt status register for GPIO32-53        */
    
    struct {
      __IM  uint32_t PROCPU_NMI_INT1 : 22;      /*!< GPIO PRO_CPU(not shielded) interrupt status register for GPIO32-53        */
            uint32_t            : 10;
    } bit;
  } PCPU_NMI_INT1;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO CPUSDIO interrupt status register for GPIO32-53                      */
    
    struct {
      __IM  uint32_t SDIO_INT1  : 22;           /*!< GPIO CPUSDIO interrupt status register for GPIO32-53                      */
            uint32_t            : 10;
    } bit;
  } CPUSDIO_INT1;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN0;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN1;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN2;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN3;
  __IM  uint32_t  RESERVED3[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN4;
  __IM  uint32_t  RESERVED4[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN5;
  __IM  uint32_t  RESERVED5[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN6;
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN7;
  __IM  uint32_t  RESERVED7[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN8;
  __IM  uint32_t  RESERVED8[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN9;
  __IM  uint32_t  RESERVED9[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN10;
  __IM  uint32_t  RESERVED10[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN11;
  __IM  uint32_t  RESERVED11[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN12;
  __IM  uint32_t  RESERVED12[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO pin configuration register                                           */
    
    struct {
      __IOM uint32_t SYNC2_BYPASS : 2;          /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
      __IOM uint32_t PAD_DRIVER : 1;            /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
      __IOM uint32_t SYNC1_BYPASS : 2;          /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
            uint32_t            : 2;
      __IOM uint32_t INT_TYPE   : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
      __IOM uint32_t CONFIG     : 2;            /*!< reserved                                                                  */
      __IOM uint32_t INT_ENA    : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
            uint32_t            : 14;
    } bit;
  } PIN13;
  __IM  uint32_t  RESERVED13;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO interrupt source register for GPIO0-31                               */
    
    struct {
      __IM  uint32_t STATUS_INTERRUPT_NEXT : 32;/*!< GPIO interrupt source register for GPIO0-31                               */
    } bit;
  } STATUS_NEXT;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO interrupt source register for GPIO32-53                              */
    
    struct {
      __IM  uint32_t STATUS_INTERRUPT_NEXT1 : 22;/*!< GPIO interrupt source register for GPIO32-53                             */
            uint32_t            : 10;
    } bit;
  } STATUS_NEXT1;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN14;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC0_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED14[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN15;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC1_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED15[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN16;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC2_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED16[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN17;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC3_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED17[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN18;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC4_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED18[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN19;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC5_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED19[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN20;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC6_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED20[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN21;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC7_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED21[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN22;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC8_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED22[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN23;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC9_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED23[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN24;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC10_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED24[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN25;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC11_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED25[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN26;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC12_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED26[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN27;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC13_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED27[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN28;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC14_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED28[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN29;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC15_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED29[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN30;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC16_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED30[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN31;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC17_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED31[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN32;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC18_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED32[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN33;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC19_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED33[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN34;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC20_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED34[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN35;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC21_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED35[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN36;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC22_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED36[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN37;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC23_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED37[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN38;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC24_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED38[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN39;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC25_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED39[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN40;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC26_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED40[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN41;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC27_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED41[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN42;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC28_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED42[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN43;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC29_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED43[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN44;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC30_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED44[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN45;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC31_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED45[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN46;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC32_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED46[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN47;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC33_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED47[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN48;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC34_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED48[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN49;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC35_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED49[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN50;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC36_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED50[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN51;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC37_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED51[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN52;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC38_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED52[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO pin configuration register                                           */
      
      struct {
        __IOM uint32_t SYNC2_BYPASS : 2;        /*!< set GPIO input_sync2 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
        __IOM uint32_t PAD_DRIVER : 1;          /*!< set this bit to select pad driver. 1:open-drain. 0:normal.                */
        __IOM uint32_t SYNC1_BYPASS : 2;        /*!< set GPIO input_sync1 signal mode. 0:disable. 1:trigger at negedge.
                                                     2or3:trigger at posedge.                                                  */
              uint32_t          : 2;
        __IOM uint32_t INT_TYPE : 3;            /*!< set this value to choose interrupt mode. 0:disable GPIO interrupt.
                                                     1:trigger at posedge. 2:trigger at negedge. 3:trigger at
                                                     any edge. 4:valid at low level. 5:valid at high level                     */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< set this bit to enable GPIO wakeup.(can only wakeup CPU from
                                                     Light-sleep Mode)                                                         */
        __IOM uint32_t CONFIG   : 2;            /*!< reserved                                                                  */
        __IOM uint32_t INT_ENA  : 5;            /*!< set bit 13 to enable CPU interrupt. set bit 14 to enable CPU(not
                                                     shielded) interrupt.                                                      */
              uint32_t          : 14;
      } bit;
    } PIN53;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC39_IN_SEL_CFG;
  };
  __IM  uint32_t  RESERVED53[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC40_IN_SEL_CFG;
  __IM  uint32_t  RESERVED54[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC41_IN_SEL_CFG;
  __IM  uint32_t  RESERVED55[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC42_IN_SEL_CFG;
  __IM  uint32_t  RESERVED56[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC43_IN_SEL_CFG;
  __IM  uint32_t  RESERVED57[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC44_IN_SEL_CFG;
  __IM  uint32_t  RESERVED58[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC45_IN_SEL_CFG;
  __IM  uint32_t  RESERVED59[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC46_IN_SEL_CFG;
  __IM  uint32_t  RESERVED60[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC47_IN_SEL_CFG;
  __IM  uint32_t  RESERVED61[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC48_IN_SEL_CFG;
  __IM  uint32_t  RESERVED62[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC49_IN_SEL_CFG;
  __IM  uint32_t  RESERVED63[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC50_IN_SEL_CFG;
  __IM  uint32_t  RESERVED64[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC51_IN_SEL_CFG;
  __IM  uint32_t  RESERVED65[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC52_IN_SEL_CFG;
  __IM  uint32_t  RESERVED66[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC53_IN_SEL_CFG;
  __IM  uint32_t  RESERVED67[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC54_IN_SEL_CFG;
  __IM  uint32_t  RESERVED68[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC55_IN_SEL_CFG;
  __IM  uint32_t  RESERVED69[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC56_IN_SEL_CFG;
  __IM  uint32_t  RESERVED70[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC57_IN_SEL_CFG;
  __IM  uint32_t  RESERVED71[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC58_IN_SEL_CFG;
  __IM  uint32_t  RESERVED72[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC59_IN_SEL_CFG;
  __IM  uint32_t  RESERVED73[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC60_IN_SEL_CFG;
  __IM  uint32_t  RESERVED74[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC61_IN_SEL_CFG;
  __IM  uint32_t  RESERVED75[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC62_IN_SEL_CFG;
  __IM  uint32_t  RESERVED76[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC63_IN_SEL_CFG;
  __IM  uint32_t  RESERVED77[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC64_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC0_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED78[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC65_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC1_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED79[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC66_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC2_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED80[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC67_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC3_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED81[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC68_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC4_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED82[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC69_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC5_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED83[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC70_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC6_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED84[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC71_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC7_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED85[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC72_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC8_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED86[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC73_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC9_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED87[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC74_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC10_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED88[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC75_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC11_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED89[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC76_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC12_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED90[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC77_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC13_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED91;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO clock gate register                                                  */
    
    struct {
      __IOM uint32_t CLK_EN     : 1;            /*!< set this bit to enable GPIO clock gate                                    */
            uint32_t            : 31;
    } bit;
  } CLOCK_GATE;
  __IM  uint32_t  RESERVED92;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC78_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC14_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED93[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC79_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC15_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED94[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC80_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC16_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED95[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC81_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC17_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED96[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC82_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC18_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED97[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC83_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC19_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED98[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC84_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC20_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED99[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC85_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC21_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED100[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC86_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC22_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED101[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC87_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC23_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED102[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC88_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC24_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED103[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC89_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC25_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED104[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC90_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC26_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED105;
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO version register                                                     */
    
    struct {
      __IOM uint32_t REG_DATE   : 28;           /*!< version register                                                          */
            uint32_t            : 4;
    } bit;
  } REG_DATE;
  __IM  uint32_t  RESERVED106;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC91_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC27_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED107[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC92_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC28_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED108[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC93_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC29_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED109[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC94_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC30_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED110[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC95_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC31_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED111[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC96_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC32_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED112[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC97_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC33_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED113[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC98_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC34_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED114[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC99_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC35_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED115[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC100_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC36_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED116[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC101_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC37_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED117[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC102_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC38_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED118[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC103_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC39_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED119[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC104_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC40_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED120[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC105_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC41_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED121[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC106_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC42_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED122[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC107_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC43_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED123[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC108_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC44_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED124[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC109_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC45_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED125[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC110_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC46_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED126[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC111_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC47_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED127[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC112_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC48_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED128[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC113_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC49_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED129[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC114_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC50_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED130[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC115_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC51_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED131[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC116_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC52_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED132[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< GPIO input function configuration register                                */
      
      struct {
        __IOM uint32_t IN_SEL   : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
        __IOM uint32_t IN_INV_SEL : 1;          /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
        __IOM uint32_t SEL      : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
              uint32_t          : 24;
      } bit;
    } FUNC117_IN_SEL_CFG;
    
    union {
      __IOM uint32_t reg;                       /*!< GPIO output function select register                                      */
      
      struct {
        __IOM uint32_t OUT_SEL  : 9;            /*!< The value of the bits: 0<=s<=256. Set the value to select output
                                                     signal. s=0-255: output of GPIO[n] equals input of peripheral[s].
                                                     s=256: output of GPIO[n] equals GPIO_OUT_REG[n].                          */
        __IOM uint32_t INV_SEL  : 1;            /*!< set this bit to invert output signal.1:invert.0:not invert.               */
        __IOM uint32_t OEN_SEL  : 1;            /*!< set this bit to select output enable signal.1:use GPIO_ENABLE_REG[n]
                                                     as output enable signal.0:use peripheral output enable
                                                     signal.                                                                   */
        __IOM uint32_t OEN_INV_SEL : 1;         /*!< set this bit to invert output enable signal.1:invert.0:not invert.        */
              uint32_t          : 20;
      } bit;
    } FUNC53_OUT_SEL_CFG;
  };
  __IM  uint32_t  RESERVED133[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC118_IN_SEL_CFG;
  __IM  uint32_t  RESERVED134[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC119_IN_SEL_CFG;
  __IM  uint32_t  RESERVED135[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC120_IN_SEL_CFG;
  __IM  uint32_t  RESERVED136[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC121_IN_SEL_CFG;
  __IM  uint32_t  RESERVED137[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC122_IN_SEL_CFG;
  __IM  uint32_t  RESERVED138[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC123_IN_SEL_CFG;
  __IM  uint32_t  RESERVED139[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC124_IN_SEL_CFG;
  __IM  uint32_t  RESERVED140[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC125_IN_SEL_CFG;
  __IM  uint32_t  RESERVED141[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC126_IN_SEL_CFG;
  __IM  uint32_t  RESERVED142[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC127_IN_SEL_CFG;
  __IM  uint32_t  RESERVED143[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC128_IN_SEL_CFG;
  __IM  uint32_t  RESERVED144[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC129_IN_SEL_CFG;
  __IM  uint32_t  RESERVED145[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC130_IN_SEL_CFG;
  __IM  uint32_t  RESERVED146[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC131_IN_SEL_CFG;
  __IM  uint32_t  RESERVED147[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC132_IN_SEL_CFG;
  __IM  uint32_t  RESERVED148[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC133_IN_SEL_CFG;
  __IM  uint32_t  RESERVED149[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC134_IN_SEL_CFG;
  __IM  uint32_t  RESERVED150[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC135_IN_SEL_CFG;
  __IM  uint32_t  RESERVED151[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC136_IN_SEL_CFG;
  __IM  uint32_t  RESERVED152[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC137_IN_SEL_CFG;
  __IM  uint32_t  RESERVED153[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC138_IN_SEL_CFG;
  __IM  uint32_t  RESERVED154[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC139_IN_SEL_CFG;
  __IM  uint32_t  RESERVED155[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC140_IN_SEL_CFG;
  __IM  uint32_t  RESERVED156[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC141_IN_SEL_CFG;
  __IM  uint32_t  RESERVED157[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC142_IN_SEL_CFG;
  __IM  uint32_t  RESERVED158[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC143_IN_SEL_CFG;
  __IM  uint32_t  RESERVED159[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC144_IN_SEL_CFG;
  __IM  uint32_t  RESERVED160[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC145_IN_SEL_CFG;
  __IM  uint32_t  RESERVED161[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC146_IN_SEL_CFG;
  __IM  uint32_t  RESERVED162[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC147_IN_SEL_CFG;
  __IM  uint32_t  RESERVED163[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC148_IN_SEL_CFG;
  __IM  uint32_t  RESERVED164[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC149_IN_SEL_CFG;
  __IM  uint32_t  RESERVED165[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC150_IN_SEL_CFG;
  __IM  uint32_t  RESERVED166[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC151_IN_SEL_CFG;
  __IM  uint32_t  RESERVED167[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC152_IN_SEL_CFG;
  __IM  uint32_t  RESERVED168[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC153_IN_SEL_CFG;
  __IM  uint32_t  RESERVED169[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC154_IN_SEL_CFG;
  __IM  uint32_t  RESERVED170[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC155_IN_SEL_CFG;
  __IM  uint32_t  RESERVED171[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC156_IN_SEL_CFG;
  __IM  uint32_t  RESERVED172[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC157_IN_SEL_CFG;
  __IM  uint32_t  RESERVED173[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC158_IN_SEL_CFG;
  __IM  uint32_t  RESERVED174[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC159_IN_SEL_CFG;
  __IM  uint32_t  RESERVED175[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC160_IN_SEL_CFG;
  __IM  uint32_t  RESERVED176[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC161_IN_SEL_CFG;
  __IM  uint32_t  RESERVED177[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC162_IN_SEL_CFG;
  __IM  uint32_t  RESERVED178[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC163_IN_SEL_CFG;
  __IM  uint32_t  RESERVED179[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC164_IN_SEL_CFG;
  __IM  uint32_t  RESERVED180[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC165_IN_SEL_CFG;
  __IM  uint32_t  RESERVED181[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC166_IN_SEL_CFG;
  __IM  uint32_t  RESERVED182[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC167_IN_SEL_CFG;
  __IM  uint32_t  RESERVED183[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC168_IN_SEL_CFG;
  __IM  uint32_t  RESERVED184[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC169_IN_SEL_CFG;
  __IM  uint32_t  RESERVED185[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC170_IN_SEL_CFG;
  __IM  uint32_t  RESERVED186[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC171_IN_SEL_CFG;
  __IM  uint32_t  RESERVED187[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC172_IN_SEL_CFG;
  __IM  uint32_t  RESERVED188[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC173_IN_SEL_CFG;
  __IM  uint32_t  RESERVED189[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC174_IN_SEL_CFG;
  __IM  uint32_t  RESERVED190[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC175_IN_SEL_CFG;
  __IM  uint32_t  RESERVED191[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC176_IN_SEL_CFG;
  __IM  uint32_t  RESERVED192[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC177_IN_SEL_CFG;
  __IM  uint32_t  RESERVED193[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC178_IN_SEL_CFG;
  __IM  uint32_t  RESERVED194[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC179_IN_SEL_CFG;
  __IM  uint32_t  RESERVED195[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC180_IN_SEL_CFG;
  __IM  uint32_t  RESERVED196[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC181_IN_SEL_CFG;
  __IM  uint32_t  RESERVED197[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC182_IN_SEL_CFG;
  __IM  uint32_t  RESERVED198[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC183_IN_SEL_CFG;
  __IM  uint32_t  RESERVED199[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC184_IN_SEL_CFG;
  __IM  uint32_t  RESERVED200[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC185_IN_SEL_CFG;
  __IM  uint32_t  RESERVED201[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC186_IN_SEL_CFG;
  __IM  uint32_t  RESERVED202[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC187_IN_SEL_CFG;
  __IM  uint32_t  RESERVED203[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC188_IN_SEL_CFG;
  __IM  uint32_t  RESERVED204[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC189_IN_SEL_CFG;
  __IM  uint32_t  RESERVED205[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC190_IN_SEL_CFG;
  __IM  uint32_t  RESERVED206[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC191_IN_SEL_CFG;
  __IM  uint32_t  RESERVED207[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC192_IN_SEL_CFG;
  __IM  uint32_t  RESERVED208[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC193_IN_SEL_CFG;
  __IM  uint32_t  RESERVED209[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC194_IN_SEL_CFG;
  __IM  uint32_t  RESERVED210[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC195_IN_SEL_CFG;
  __IM  uint32_t  RESERVED211[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC196_IN_SEL_CFG;
  __IM  uint32_t  RESERVED212[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC197_IN_SEL_CFG;
  __IM  uint32_t  RESERVED213[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC198_IN_SEL_CFG;
  __IM  uint32_t  RESERVED214[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC199_IN_SEL_CFG;
  __IM  uint32_t  RESERVED215[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC200_IN_SEL_CFG;
  __IM  uint32_t  RESERVED216[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC201_IN_SEL_CFG;
  __IM  uint32_t  RESERVED217[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC202_IN_SEL_CFG;
  __IM  uint32_t  RESERVED218[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC203_IN_SEL_CFG;
  __IM  uint32_t  RESERVED219[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC204_IN_SEL_CFG;
  __IM  uint32_t  RESERVED220[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC205_IN_SEL_CFG;
  __IM  uint32_t  RESERVED221[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC206_IN_SEL_CFG;
  __IM  uint32_t  RESERVED222[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC207_IN_SEL_CFG;
  __IM  uint32_t  RESERVED223[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC208_IN_SEL_CFG;
  __IM  uint32_t  RESERVED224[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC209_IN_SEL_CFG;
  __IM  uint32_t  RESERVED225[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC210_IN_SEL_CFG;
  __IM  uint32_t  RESERVED226[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC211_IN_SEL_CFG;
  __IM  uint32_t  RESERVED227[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC212_IN_SEL_CFG;
  __IM  uint32_t  RESERVED228[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC213_IN_SEL_CFG;
  __IM  uint32_t  RESERVED229[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC214_IN_SEL_CFG;
  __IM  uint32_t  RESERVED230[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC215_IN_SEL_CFG;
  __IM  uint32_t  RESERVED231[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC216_IN_SEL_CFG;
  __IM  uint32_t  RESERVED232[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC217_IN_SEL_CFG;
  __IM  uint32_t  RESERVED233[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC218_IN_SEL_CFG;
  __IM  uint32_t  RESERVED234[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC219_IN_SEL_CFG;
  __IM  uint32_t  RESERVED235[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC220_IN_SEL_CFG;
  __IM  uint32_t  RESERVED236[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC221_IN_SEL_CFG;
  __IM  uint32_t  RESERVED237[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC222_IN_SEL_CFG;
  __IM  uint32_t  RESERVED238[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC223_IN_SEL_CFG;
  __IM  uint32_t  RESERVED239[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC224_IN_SEL_CFG;
  __IM  uint32_t  RESERVED240[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC225_IN_SEL_CFG;
  __IM  uint32_t  RESERVED241[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC226_IN_SEL_CFG;
  __IM  uint32_t  RESERVED242[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC227_IN_SEL_CFG;
  __IM  uint32_t  RESERVED243[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC228_IN_SEL_CFG;
  __IM  uint32_t  RESERVED244[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC229_IN_SEL_CFG;
  __IM  uint32_t  RESERVED245[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC230_IN_SEL_CFG;
  __IM  uint32_t  RESERVED246[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC231_IN_SEL_CFG;
  __IM  uint32_t  RESERVED247[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC232_IN_SEL_CFG;
  __IM  uint32_t  RESERVED248[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC233_IN_SEL_CFG;
  __IM  uint32_t  RESERVED249[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC234_IN_SEL_CFG;
  __IM  uint32_t  RESERVED250[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC235_IN_SEL_CFG;
  __IM  uint32_t  RESERVED251[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC236_IN_SEL_CFG;
  __IM  uint32_t  RESERVED252[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC237_IN_SEL_CFG;
  __IM  uint32_t  RESERVED253[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC238_IN_SEL_CFG;
  __IM  uint32_t  RESERVED254[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC239_IN_SEL_CFG;
  __IM  uint32_t  RESERVED255[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC240_IN_SEL_CFG;
  __IM  uint32_t  RESERVED256[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC241_IN_SEL_CFG;
  __IM  uint32_t  RESERVED257[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC242_IN_SEL_CFG;
  __IM  uint32_t  RESERVED258[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC243_IN_SEL_CFG;
  __IM  uint32_t  RESERVED259[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC244_IN_SEL_CFG;
  __IM  uint32_t  RESERVED260[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC245_IN_SEL_CFG;
  __IM  uint32_t  RESERVED261[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC246_IN_SEL_CFG;
  __IM  uint32_t  RESERVED262[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC247_IN_SEL_CFG;
  __IM  uint32_t  RESERVED263[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC248_IN_SEL_CFG;
  __IM  uint32_t  RESERVED264[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC249_IN_SEL_CFG;
  __IM  uint32_t  RESERVED265[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC250_IN_SEL_CFG;
  __IM  uint32_t  RESERVED266[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC251_IN_SEL_CFG;
  __IM  uint32_t  RESERVED267[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC252_IN_SEL_CFG;
  __IM  uint32_t  RESERVED268[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC253_IN_SEL_CFG;
  __IM  uint32_t  RESERVED269[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC254_IN_SEL_CFG;
  __IM  uint32_t  RESERVED270[3];
  
  union {
    __IOM uint32_t reg;                         /*!< GPIO input function configuration register                                */
    
    struct {
      __IOM uint32_t IN_SEL     : 6;            /*!< set this value: s=0-53: connect GPIO[s] to this port. s=0x38:
                                                     set this port always high level. s=0x3C: set this port
                                                     always low level.                                                         */
      __IOM uint32_t IN_INV_SEL : 1;            /*!< set this bit to invert input signal. 1:invert. 0:not invert.              */
      __IOM uint32_t SEL        : 1;            /*!< set this bit to bypass GPIO. 1:do not bypass GPIO. 0:bypass
                                                     GPIO.                                                                     */
            uint32_t            : 24;
    } bit;
  } FUNC255_IN_SEL_CFG;
} GPIO_Type;                                    /*!< Size = 4424 (0x1148)                                                      */



/* =========================================================================================================================== */
/* ================                                          GPIO_SD                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Sigma-Delta Modulation (GPIO_SD)
  */

typedef struct {                                /*!< GPIO_SD Structure                                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< Duty Cycle Configure Register of SDM0                                     */
    
    struct {
      __IOM uint32_t SD_IN      : 8;            /*!< This field is used to configure the duty cycle of sigma delta
                                                     modulation output.                                                        */
      __IOM uint32_t SD_PRESCALE : 8;           /*!< This field is used to set a divider value to divide APB clock.            */
            uint32_t            : 16;
    } bit;
  } SIGMADELTA0;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Duty Cycle Configure Register of SDM1                                     */
    
    struct {
      __IOM uint32_t SD_IN      : 8;            /*!< This field is used to configure the duty cycle of sigma delta
                                                     modulation output.                                                        */
      __IOM uint32_t SD_PRESCALE : 8;           /*!< This field is used to set a divider value to divide APB clock.            */
            uint32_t            : 16;
    } bit;
  } SIGMADELTA1;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Duty Cycle Configure Register of SDM2                                     */
      
      struct {
        __IOM uint32_t SD_IN    : 8;            /*!< This field is used to configure the duty cycle of sigma delta
                                                     modulation output.                                                        */
        __IOM uint32_t SD_PRESCALE : 8;         /*!< This field is used to set a divider value to divide APB clock.            */
              uint32_t          : 16;
      } bit;
    } SIGMADELTA2;
    
    union {
      __IOM uint32_t reg;                       /*!< Clock Gating Configure Register                                           */
      
      struct {
              uint32_t          : 31;
        __IOM uint32_t CLK_EN   : 1;            /*!< Clock enable bit of configuration registers for sigma delta
                                                     modulation.                                                               */
      } bit;
    } SIGMADELTA_CG;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< MISC Register                                                             */
    
    struct {
            uint32_t            : 30;
      __IOM uint32_t FUNCTION_CLK_EN : 1;       /*!< Clock enable bit of sigma delta modulation.                               */
      __IOM uint32_t SPI_SWAP   : 1;            /*!< Reserved.                                                                 */
    } bit;
  } SIGMADELTA_MISC;
  
  union {
    __IOM uint32_t reg;                         /*!< Version Control Register                                                  */
    
    struct {
      __IOM uint32_t GPIO_SD_DATE : 28;         /*!< Version control register.                                                 */
            uint32_t            : 4;
    } bit;
  } SIGMADELTA_VERSION;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< Duty Cycle Configure Register of SDM3                                     */
    
    struct {
      __IOM uint32_t SD_IN      : 8;            /*!< This field is used to configure the duty cycle of sigma delta
                                                     modulation output.                                                        */
      __IOM uint32_t SD_PRESCALE : 8;           /*!< This field is used to set a divider value to divide APB clock.            */
            uint32_t            : 16;
    } bit;
  } SIGMADELTA3;
  __IM  uint32_t  RESERVED3[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Duty Cycle Configure Register of SDM4                                     */
    
    struct {
      __IOM uint32_t SD_IN      : 8;            /*!< This field is used to configure the duty cycle of sigma delta
                                                     modulation output.                                                        */
      __IOM uint32_t SD_PRESCALE : 8;           /*!< This field is used to set a divider value to divide APB clock.            */
            uint32_t            : 16;
    } bit;
  } SIGMADELTA4;
  __IM  uint32_t  RESERVED4[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Duty Cycle Configure Register of SDM5                                     */
    
    struct {
      __IOM uint32_t SD_IN      : 8;            /*!< This field is used to configure the duty cycle of sigma delta
                                                     modulation output.                                                        */
      __IOM uint32_t SD_PRESCALE : 8;           /*!< This field is used to set a divider value to divide APB clock.            */
            uint32_t            : 16;
    } bit;
  } SIGMADELTA5;
  __IM  uint32_t  RESERVED5[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Duty Cycle Configure Register of SDM6                                     */
    
    struct {
      __IOM uint32_t SD_IN      : 8;            /*!< This field is used to configure the duty cycle of sigma delta
                                                     modulation output.                                                        */
      __IOM uint32_t SD_PRESCALE : 8;           /*!< This field is used to set a divider value to divide APB clock.            */
            uint32_t            : 16;
    } bit;
  } SIGMADELTA6;
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Duty Cycle Configure Register of SDM7                                     */
    
    struct {
      __IOM uint32_t SD_IN      : 8;            /*!< This field is used to configure the duty cycle of sigma delta
                                                     modulation output.                                                        */
      __IOM uint32_t SD_PRESCALE : 8;           /*!< This field is used to set a divider value to divide APB clock.            */
            uint32_t            : 16;
    } bit;
  } SIGMADELTA7;
} GPIO_SD_Type;                                 /*!< Size = 116 (0x74)                                                         */



/* =========================================================================================================================== */
/* ================                                           HMAC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief HMAC (Hash-based Message Authentication Code) Accelerator (HMAC)
  */

typedef struct {                                /*!< HMAC Structure                                                            */
  __IM  uint32_t  RESERVED[16];
  
  union {
    __IOM uint32_t reg;                         /*!< Process control register 0.                                               */
    
    struct {
      __OM  uint32_t SET_START  : 1;            /*!< Start hmac operation.                                                     */
            uint32_t            : 31;
    } bit;
  } SET_START;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure purpose.                                                        */
    
    struct {
      __OM  uint32_t PURPOSE_SET : 4;           /*!< Set hmac parameter purpose.                                               */
            uint32_t            : 28;
    } bit;
  } SET_PARA_PURPOSE;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure key.                                                            */
    
    struct {
      __OM  uint32_t KEY_SET    : 3;            /*!< Set hmac parameter key.                                                   */
            uint32_t            : 29;
    } bit;
  } SET_PARA_KEY;
  
  union {
    __IOM uint32_t reg;                         /*!< Finish initial configuration.                                             */
    
    struct {
      __OM  uint32_t SET_PARA_END : 1;          /*!< Finish hmac configuration.                                                */
            uint32_t            : 31;
    } bit;
  } SET_PARA_FINISH;
  
  union {
    __IOM uint32_t reg;                         /*!< Process control register 1.                                               */
    
    struct {
      __OM  uint32_t SET_TEXT_ONE : 1;          /*!< Call SHA to calculate one message block.                                  */
            uint32_t            : 31;
    } bit;
  } SET_MESSAGE_ONE;
  
  union {
    __IOM uint32_t reg;                         /*!< Process control register 2.                                               */
    
    struct {
      __OM  uint32_t SET_TEXT_ING : 1;          /*!< Continue typical hmac.                                                    */
            uint32_t            : 31;
    } bit;
  } SET_MESSAGE_ING;
  
  union {
    __IOM uint32_t reg;                         /*!< Process control register 3.                                               */
    
    struct {
      __OM  uint32_t SET_TEXT_END : 1;          /*!< Start hardware padding.                                                   */
            uint32_t            : 31;
    } bit;
  } SET_MESSAGE_END;
  
  union {
    __IOM uint32_t reg;                         /*!< Process control register 4.                                               */
    
    struct {
      __OM  uint32_t SET_RESULT_END : 1;        /*!< After read result from upstream, then let hmac back to idle.              */
            uint32_t            : 31;
    } bit;
  } SET_RESULT_FINISH;
  
  union {
    __IOM uint32_t reg;                         /*!< Invalidate register 0.                                                    */
    
    struct {
      __OM  uint32_t SET_INVALIDATE_JTAG : 1;   /*!< Clear result from hmac downstream JTAG.                                   */
            uint32_t            : 31;
    } bit;
  } SET_INVALIDATE_JTAG;
  
  union {
    __IOM uint32_t reg;                         /*!< Invalidate register 1.                                                    */
    
    struct {
      __OM  uint32_t SET_INVALIDATE_DS : 1;     /*!< Clear result from hmac downstream DS.                                     */
            uint32_t            : 31;
    } bit;
  } SET_INVALIDATE_DS;
  
  union {
    __IOM uint32_t reg;                         /*!< Error register.                                                           */
    
    struct {
      __IM  uint32_t QUERY_CHECK : 1;           /*!< Hmac configuration state. 0: key are agree with purpose. 1:
                                                     error                                                                     */
            uint32_t            : 31;
    } bit;
  } QUERY_ERROR;
  
  union {
    __IOM uint32_t reg;                         /*!< Busy register.                                                            */
    
    struct {
      __IM  uint32_t BUSY_STATE : 1;            /*!< Hmac state. 1'b0: idle. 1'b1: busy                                        */
            uint32_t            : 31;
    } bit;
  } QUERY_BUSY;
  __IM  uint32_t  RESERVED1[4];
  __IOM uint32_t  WR_MESSAGE_MEM[16];           /*!< Message block memory.                                                     */
  __IOM uint32_t  RD_RESULT_MEM[8];             /*!< Result from upstream.                                                     */
  __IM  uint32_t  RESERVED2[4];
  
  union {
    __IOM uint32_t reg;                         /*!< Process control register 5.                                               */
    
    struct {
      __OM  uint32_t SET_TEXT_PAD : 1;          /*!< Start software padding.                                                   */
            uint32_t            : 31;
    } bit;
  } SET_MESSAGE_PAD;
  
  union {
    __IOM uint32_t reg;                         /*!< Process control register 6.                                               */
    
    struct {
      __OM  uint32_t SET_ONE_BLOCK : 1;         /*!< Don't have to do padding.                                                 */
            uint32_t            : 31;
    } bit;
  } ONE_BLOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< Jtag register 0.                                                          */
    
    struct {
      __OM  uint32_t SOFT_JTAG_CTRL : 1;        /*!< Turn on JTAG verification.                                                */
            uint32_t            : 31;
    } bit;
  } SOFT_JTAG_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Jtag register 1.                                                          */
    
    struct {
      __OM  uint32_t WR_JTAG    : 32;           /*!< 32-bit of key to be compared.                                             */
    } bit;
  } WR_JTAG;
  __IM  uint32_t  RESERVED3[63];
  
  union {
    __IOM uint32_t reg;                         /*!< Date register.                                                            */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< Hmac date information/ hmac version information.                          */
            uint32_t            : 4;
    } bit;
  } DATE;
} HMAC_Type;                                    /*!< Size = 512 (0x200)                                                        */



/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C (Inter-Integrated Circuit) Controller 0 (I2C0)
  */

typedef struct {                                /*!< I2C0 Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< Configures the low level width of the SCLClock                            */
    
    struct {
      __IOM uint32_t SCL_LOW_PERIOD : 9;        /*!< This register is used to configure for how long SCL remains
                                                     low in master mode, in I2C module clock cycles.                           */
            uint32_t            : 23;
    } bit;
  } SCL_LOW_PERIOD;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmission setting                                                      */
    
    struct {
      __IOM uint32_t SDA_FORCE_OUT : 1;         /*!< 0: direct output; 1: open drain output.                                   */
      __IOM uint32_t SCL_FORCE_OUT : 1;         /*!< 0: direct output; 1: open drain output.                                   */
      __IOM uint32_t SAMPLE_SCL_LEVEL : 1;      /*!< This register is used to select the sample mode.1: sample SDA
                                                     data on the SCL low level.0: sample SDA data on the SCL
                                                     high level.                                                               */
      __IOM uint32_t RX_FULL_ACK_LEVEL : 1;     /*!< This register is used to configure the ACK value that need to
                                                     sent by master when the rx_fifo_cnt has reached the threshold.            */
      __IOM uint32_t MS_MODE    : 1;            /*!< Set this bit to configure the module as an I2C Master. Clear
                                                     this bit to configure themodule as an I2C Slave.                          */
      __OM  uint32_t TRANS_START : 1;           /*!< Set this bit to start sending the data in txfifo.                         */
      __IOM uint32_t TX_LSB_FIRST : 1;          /*!< This bit is used to control the sending mode for data needing
                                                     to be sent. 1: send data from the least significant bit;0:
                                                     send data from the most significant bit.                                  */
      __IOM uint32_t RX_LSB_FIRST : 1;          /*!< This bit is used to control the storage mode for received data.1:
                                                     receive data from the least significant bit;0: receive
                                                     data from the most significant bit.                                       */
      __IOM uint32_t CLK_EN     : 1;            /*!< Reserved                                                                  */
      __IOM uint32_t ARBITRATION_EN : 1;        /*!< This is the enable bit for arbitration_lost.                              */
      __OM  uint32_t FSM_RST    : 1;            /*!< This register is used to reset the scl FMS.                               */
      __OM  uint32_t CONF_UPGATE : 1;           /*!< synchronization bit                                                       */
      __IOM uint32_t SLV_TX_AUTO_START_EN : 1;  /*!< This is the enable bit for slave to send data automatically               */
      __IOM uint32_t ADDR_10BIT_RW_CHECK_EN : 1;/*!< This is the enable bit to check if the r/w bit of 10bit addressing
                                                     consists with I2C protocol                                                */
      __IOM uint32_t ADDR_BROADCASTING_EN : 1;  /*!< This is the enable bit to support the 7bit general call function.         */
            uint32_t            : 17;
    } bit;
  } CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< Describe I2C work status.                                                 */
    
    struct {
      __IM  uint32_t RESP_REC   : 1;            /*!< The received ACK value in master mode or slave mode. 0: ACK,
                                                     1: NACK.                                                                  */
      __IM  uint32_t SLAVE_RW   : 1;            /*!< When in slave mode, 1: master reads from slave; 0: master writes
                                                     to slave.                                                                 */
            uint32_t            : 1;
      __IM  uint32_t ARB_LOST   : 1;            /*!< When the I2C controller loses control of SCL line, this register
                                                     changes to 1.                                                             */
      __IM  uint32_t BUS_BUSY   : 1;            /*!< 1: the I2C bus is busy transferring data; 0: the I2C bus is
                                                     in idle state.                                                            */
      __IM  uint32_t SLAVE_ADDRESSED : 1;       /*!< When configured as an I2C Slave, and the address sent by the
                                                     master isequal to the address of the slave, then this bit
                                                     will be of high level.                                                    */
            uint32_t            : 2;
      __IM  uint32_t RXFIFO_CNT : 6;            /*!< This field represents the amount of data needed to be sent.               */
      __IM  uint32_t STRETCH_CAUSE : 2;         /*!< The cause of stretching SCL low in slave mode. 0: stretching
                                                     SCL low at the beginning of I2C read data state. 1: stretching
                                                     SCL low when I2C Tx FIFO is empty in slave mode. 2: stretching
                                                     SCL low when I2C Rx FIFO is full in slave mode.                           */
            uint32_t            : 2;
      __IM  uint32_t TXFIFO_CNT : 6;            /*!< This field stores the amount of received data in RAM.                     */
      __IM  uint32_t SCL_MAIN_STATE_LAST : 3;   /*!< This field indicates the states of the I2C module state machine.
                                                     0: Idle; 1: Address shift; 2: ACK address; 3: Rx data;
                                                     4: Tx data; 5: Send ACK; 6: Wait ACK                                      */
            uint32_t            : 1;
      __IM  uint32_t SCL_STATE_LAST : 3;        /*!< This field indicates the states of the state machine used to
                                                     produce SCL.0: Idle; 1: Start; 2: Negative edge; 3: Low;
                                                     4: Positive edge; 5: High; 6: Stop                                        */
            uint32_t            : 1;
    } bit;
  } SR;
  
  union {
    __IOM uint32_t reg;                         /*!< Setting time out control for receiving data.                              */
    
    struct {
      __IOM uint32_t TIME_OUT_VALUE : 5;        /*!< This register is used to configure the timeout for receiving
                                                     a data bit in APBclock cycles.                                            */
      __IOM uint32_t TIME_OUT_EN : 1;           /*!< This is the enable bit for time out control.                              */
            uint32_t            : 26;
    } bit;
  } TO;
  
  union {
    __IOM uint32_t reg;                         /*!< Local slave address setting                                               */
    
    struct {
      __IOM uint32_t SLAVE_ADDR : 15;           /*!< When configured as an I2C Slave, this field is used to configure
                                                     the slave address.                                                        */
            uint32_t            : 16;
      __IOM uint32_t ADDR_10BIT_EN : 1;         /*!< This field is used to enable the slave 10-bit addressing mode
                                                     in master mode.                                                           */
    } bit;
  } SLAVE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO status register.                                                     */
    
    struct {
      __IM  uint32_t RXFIFO_RADDR : 5;          /*!< This is the offset address of the APB reading from rxfifo                 */
      __IM  uint32_t RXFIFO_WADDR : 5;          /*!< This is the offset address of i2c module receiving data and
                                                     writing to rxfifo.                                                        */
      __IM  uint32_t TXFIFO_RADDR : 5;          /*!< This is the offset address of i2c module reading from txfifo.             */
      __IM  uint32_t TXFIFO_WADDR : 5;          /*!< This is the offset address of APB bus writing to txfifo.                  */
            uint32_t            : 2;
      __IM  uint32_t SLAVE_RW_POINT : 8;        /*!< The received data in I2C slave mode.                                      */
            uint32_t            : 2;
    } bit;
  } FIFO_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO configuration register.                                              */
    
    struct {
      __IOM uint32_t RXFIFO_WM_THRHD : 5;       /*!< The water mark threshold of rx FIFO in nonfifo access mode.
                                                     When reg_reg_fifo_prt_en is 1 and rx FIFO counter is bigger
                                                     than reg_rxfifo_wm_thrhd[4:0], reg_rxfifo_wm_int_raw bit
                                                     will be valid.                                                            */
      __IOM uint32_t TXFIFO_WM_THRHD : 5;       /*!< The water mark threshold of tx FIFO in nonfifo access mode.
                                                     When reg_reg_fifo_prt_en is 1 and tx FIFO counter is smaller
                                                     than reg_txfifo_wm_thrhd[4:0], reg_txfifo_wm_int_raw bit
                                                     will be valid.                                                            */
      __IOM uint32_t NONFIFO_EN : 1;            /*!< Set this bit to enable APB nonfifo access.                                */
      __IOM uint32_t FIFO_ADDR_CFG_EN : 1;      /*!< When this bit is set to 1, the byte received after the I2C address
                                                     byte represents the offset address in the I2C Slave RAM.                  */
      __IOM uint32_t RX_FIFO_RST : 1;           /*!< Set this bit to reset rx-fifo.                                            */
      __IOM uint32_t TX_FIFO_RST : 1;           /*!< Set this bit to reset tx-fifo.                                            */
      __IOM uint32_t FIFO_PRT_EN : 1;           /*!< The control enable bit of FIFO pointer in non-fifo access mode.
                                                     This bit controls the valid bits and the interrupts of
                                                     tx/rx_fifo overflow, underflow, full and empty.                           */
            uint32_t            : 17;
    } bit;
  } FIFO_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Rx FIFO read data.                                                        */
    
    struct {
      __IOM uint32_t FIFO_RDATA : 8;            /*!< The value of rx FIFO read data.                                           */
            uint32_t            : 24;
    } bit;
  } DATA;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw interrupt status                                                      */
    
    struct {
      __IM  uint32_t RXFIFO_WM_INT_RAW : 1;     /*!< The raw interrupt bit for I2C_RXFIFO_WM_INT interrupt.                    */
      __IM  uint32_t TXFIFO_WM_INT_RAW : 1;     /*!< The raw interrupt bit for I2C_TXFIFO_WM_INT interrupt.                    */
      __IM  uint32_t RXFIFO_OVF_INT_RAW : 1;    /*!< The raw interrupt bit for I2C_RXFIFO_OVF_INT interrupt.                   */
      __IM  uint32_t END_DETECT_INT_RAW : 1;    /*!< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.               */
      __IM  uint32_t BYTE_TRANS_DONE_INT_RAW : 1;/*!< The raw interrupt bit for the I2C_END_DETECT_INT interrupt.              */
      __IM  uint32_t ARBITRATION_LOST_INT_RAW : 1;/*!< The raw interrupt bit for the I2C_ARBITRATION_LOST_INT interrupt.       */
      __IM  uint32_t MST_TXFIFO_UDF_INT_RAW : 1;/*!< The raw interrupt bit for I2C_TRANS_COMPLETE_INT interrupt.               */
      __IM  uint32_t TRANS_COMPLETE_INT_RAW : 1;/*!< The raw interrupt bit for the I2C_TRANS_COMPLETE_INT interrupt.           */
      __IM  uint32_t TIME_OUT_INT_RAW : 1;      /*!< The raw interrupt bit for the I2C_TIME_OUT_INT interrupt.                 */
      __IM  uint32_t TRANS_START_INT_RAW : 1;   /*!< The raw interrupt bit for the I2C_TRANS_START_INT interrupt.              */
      __IM  uint32_t NACK_INT_RAW : 1;          /*!< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.                */
      __IM  uint32_t TXFIFO_OVF_INT_RAW : 1;    /*!< The raw interrupt bit for I2C_TXFIFO_OVF_INT interrupt.                   */
      __IM  uint32_t RXFIFO_UDF_INT_RAW : 1;    /*!< The raw interrupt bit for I2C_RXFIFO_UDF_INT interrupt.                   */
      __IM  uint32_t SCL_ST_TO_INT_RAW : 1;     /*!< The raw interrupt bit for I2C_SCL_ST_TO_INT interrupt.                    */
      __IM  uint32_t SCL_MAIN_ST_TO_INT_RAW : 1;/*!< The raw interrupt bit for I2C_SCL_MAIN_ST_TO_INT interrupt.               */
      __IM  uint32_t DET_START_INT_RAW : 1;     /*!< The raw interrupt bit for I2C_DET_START_INT interrupt.                    */
      __IM  uint32_t SLAVE_STRETCH_INT_RAW : 1; /*!< The raw interrupt bit for I2C_SLAVE_STRETCH_INT interrupt.                */
      __IM  uint32_t GENERAL_CALL_INT_RAW : 1;  /*!< The raw interrupt bit for I2C_GENARAL_CALL_INT interrupt.                 */
            uint32_t            : 14;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits                                                      */
    
    struct {
      __OM  uint32_t RXFIFO_WM_INT_CLR : 1;     /*!< Set this bit to clear I2C_RXFIFO_WM_INT interrupt.                        */
      __OM  uint32_t TXFIFO_WM_INT_CLR : 1;     /*!< Set this bit to clear I2C_TXFIFO_WM_INT interrupt.                        */
      __OM  uint32_t RXFIFO_OVF_INT_CLR : 1;    /*!< Set this bit to clear I2C_RXFIFO_OVF_INT interrupt.                       */
      __OM  uint32_t END_DETECT_INT_CLR : 1;    /*!< Set this bit to clear the I2C_END_DETECT_INT interrupt.                   */
      __OM  uint32_t BYTE_TRANS_DONE_INT_CLR : 1;/*!< Set this bit to clear the I2C_END_DETECT_INT interrupt.                  */
      __OM  uint32_t ARBITRATION_LOST_INT_CLR : 1;/*!< Set this bit to clear the I2C_ARBITRATION_LOST_INT interrupt.           */
      __OM  uint32_t MST_TXFIFO_UDF_INT_CLR : 1;/*!< Set this bit to clear I2C_TRANS_COMPLETE_INT interrupt.                   */
      __OM  uint32_t TRANS_COMPLETE_INT_CLR : 1;/*!< Set this bit to clear the I2C_TRANS_COMPLETE_INT interrupt.               */
      __OM  uint32_t TIME_OUT_INT_CLR : 1;      /*!< Set this bit to clear the I2C_TIME_OUT_INT interrupt.                     */
      __OM  uint32_t TRANS_START_INT_CLR : 1;   /*!< Set this bit to clear the I2C_TRANS_START_INT interrupt.                  */
      __OM  uint32_t NACK_INT_CLR : 1;          /*!< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.                    */
      __OM  uint32_t TXFIFO_OVF_INT_CLR : 1;    /*!< Set this bit to clear I2C_TXFIFO_OVF_INT interrupt.                       */
      __OM  uint32_t RXFIFO_UDF_INT_CLR : 1;    /*!< Set this bit to clear I2C_RXFIFO_UDF_INT interrupt.                       */
      __OM  uint32_t SCL_ST_TO_INT_CLR : 1;     /*!< Set this bit to clear I2C_SCL_ST_TO_INT interrupt.                        */
      __OM  uint32_t SCL_MAIN_ST_TO_INT_CLR : 1;/*!< Set this bit to clear I2C_SCL_MAIN_ST_TO_INT interrupt.                   */
      __OM  uint32_t DET_START_INT_CLR : 1;     /*!< Set this bit to clear I2C_DET_START_INT interrupt.                        */
      __OM  uint32_t SLAVE_STRETCH_INT_CLR : 1; /*!< Set this bit to clear I2C_SLAVE_STRETCH_INT interrupt.                    */
      __OM  uint32_t GENERAL_CALL_INT_CLR : 1;  /*!< Set this bit for I2C_GENARAL_CALL_INT interrupt.                          */
            uint32_t            : 14;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits                                                     */
    
    struct {
      __IOM uint32_t RXFIFO_WM_INT_ENA : 1;     /*!< The interrupt enable bit for I2C_RXFIFO_WM_INT interrupt.                 */
      __IOM uint32_t TXFIFO_WM_INT_ENA : 1;     /*!< The interrupt enable bit for I2C_TXFIFO_WM_INT interrupt.                 */
      __IOM uint32_t RXFIFO_OVF_INT_ENA : 1;    /*!< The interrupt enable bit for I2C_RXFIFO_OVF_INT interrupt.                */
      __IOM uint32_t END_DETECT_INT_ENA : 1;    /*!< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.            */
      __IOM uint32_t BYTE_TRANS_DONE_INT_ENA : 1;/*!< The interrupt enable bit for the I2C_END_DETECT_INT interrupt.           */
      __IOM uint32_t ARBITRATION_LOST_INT_ENA : 1;/*!< The interrupt enable bit for the I2C_ARBITRATION_LOST_INT interrupt.    */
      __IOM uint32_t MST_TXFIFO_UDF_INT_ENA : 1;/*!< The interrupt enable bit for I2C_TRANS_COMPLETE_INT interrupt.            */
      __IOM uint32_t TRANS_COMPLETE_INT_ENA : 1;/*!< The interrupt enable bit for the I2C_TRANS_COMPLETE_INT interrupt.        */
      __IOM uint32_t TIME_OUT_INT_ENA : 1;      /*!< The interrupt enable bit for the I2C_TIME_OUT_INT interrupt.              */
      __IOM uint32_t TRANS_START_INT_ENA : 1;   /*!< The interrupt enable bit for the I2C_TRANS_START_INT interrupt.           */
      __IOM uint32_t NACK_INT_ENA : 1;          /*!< The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.             */
      __IOM uint32_t TXFIFO_OVF_INT_ENA : 1;    /*!< The interrupt enable bit for I2C_TXFIFO_OVF_INT interrupt.                */
      __IOM uint32_t RXFIFO_UDF_INT_ENA : 1;    /*!< The interrupt enable bit for I2C_RXFIFO_UDF_INT interrupt.                */
      __IOM uint32_t SCL_ST_TO_INT_ENA : 1;     /*!< The interrupt enable bit for I2C_SCL_ST_TO_INT interrupt.                 */
      __IOM uint32_t SCL_MAIN_ST_TO_INT_ENA : 1;/*!< The interrupt enable bit for I2C_SCL_MAIN_ST_TO_INT interrupt.            */
      __IOM uint32_t DET_START_INT_ENA : 1;     /*!< The interrupt enable bit for I2C_DET_START_INT interrupt.                 */
      __IOM uint32_t SLAVE_STRETCH_INT_ENA : 1; /*!< The interrupt enable bit for I2C_SLAVE_STRETCH_INT interrupt.             */
      __IOM uint32_t GENERAL_CALL_INT_ENA : 1;  /*!< The interrupt enable bit for I2C_GENARAL_CALL_INT interrupt.              */
            uint32_t            : 14;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Status of captured I2C communication events                               */
    
    struct {
      __IM  uint32_t RXFIFO_WM_INT_ST : 1;      /*!< The masked interrupt status bit for I2C_RXFIFO_WM_INT interrupt.          */
      __IM  uint32_t TXFIFO_WM_INT_ST : 1;      /*!< The masked interrupt status bit for I2C_TXFIFO_WM_INT interrupt.          */
      __IM  uint32_t RXFIFO_OVF_INT_ST : 1;     /*!< The masked interrupt status bit for I2C_RXFIFO_OVF_INT interrupt.         */
      __IM  uint32_t END_DETECT_INT_ST : 1;     /*!< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.     */
      __IM  uint32_t BYTE_TRANS_DONE_INT_ST : 1;/*!< The masked interrupt status bit for the I2C_END_DETECT_INT interrupt.     */
      __IM  uint32_t ARBITRATION_LOST_INT_ST : 1;/*!< The masked interrupt status bit for the I2C_ARBITRATION_LOST_INT
                                                     interrupt.                                                                */
      __IM  uint32_t MST_TXFIFO_UDF_INT_ST : 1; /*!< The masked interrupt status bit for I2C_TRANS_COMPLETE_INT interrupt.     */
      __IM  uint32_t TRANS_COMPLETE_INT_ST : 1; /*!< The masked interrupt status bit for the I2C_TRANS_COMPLETE_INT
                                                     interrupt.                                                                */
      __IM  uint32_t TIME_OUT_INT_ST : 1;       /*!< The masked interrupt status bit for the I2C_TIME_OUT_INT interrupt.       */
      __IM  uint32_t TRANS_START_INT_ST : 1;    /*!< The masked interrupt status bit for the I2C_TRANS_START_INT
                                                     interrupt.                                                                */
      __IM  uint32_t NACK_INT_ST : 1;           /*!< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.      */
      __IM  uint32_t TXFIFO_OVF_INT_ST : 1;     /*!< The masked interrupt status bit for I2C_TXFIFO_OVF_INT interrupt.         */
      __IM  uint32_t RXFIFO_UDF_INT_ST : 1;     /*!< The masked interrupt status bit for I2C_RXFIFO_UDF_INT interrupt.         */
      __IM  uint32_t SCL_ST_TO_INT_ST : 1;      /*!< The masked interrupt status bit for I2C_SCL_ST_TO_INT interrupt.          */
      __IM  uint32_t SCL_MAIN_ST_TO_INT_ST : 1; /*!< The masked interrupt status bit for I2C_SCL_MAIN_ST_TO_INT interrupt.     */
      __IM  uint32_t DET_START_INT_ST : 1;      /*!< The masked interrupt status bit for I2C_DET_START_INT interrupt.          */
      __IM  uint32_t SLAVE_STRETCH_INT_ST : 1;  /*!< The masked interrupt status bit for I2C_SLAVE_STRETCH_INT interrupt.      */
      __IM  uint32_t GENERAL_CALL_INT_ST : 1;   /*!< The masked interrupt status bit for I2C_GENARAL_CALL_INT interrupt.       */
            uint32_t            : 14;
    } bit;
  } INT_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Configures the hold time after a negative SCL edge.                       */
    
    struct {
      __IOM uint32_t TIME       : 9;            /*!< This register is used to configure the time to hold the data
                                                     after the negativeedge of SCL, in I2C module clock cycles.                */
            uint32_t            : 23;
    } bit;
  } SDA_HOLD;
  
  union {
    __IOM uint32_t reg;                         /*!< Configures the sample time after a positive SCL edge.                     */
    
    struct {
      __IOM uint32_t TIME       : 9;            /*!< This register is used to configure for how long SDA is sampled,
                                                     in I2C module clock cycles.                                               */
            uint32_t            : 23;
    } bit;
  } SDA_SAMPLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Configures the high level width of SCL                                    */
    
    struct {
      __IOM uint32_t SCL_HIGH_PERIOD : 9;       /*!< This register is used to configure for how long SCL remains
                                                     high in master mode, in I2C module clock cycles.                          */
      __IOM uint32_t SCL_WAIT_HIGH_PERIOD : 7;  /*!< This register is used to configure for the SCL_FSM's waiting
                                                     period for SCL high level in master mode, in I2C module
                                                     clock cycles.                                                             */
            uint32_t            : 16;
    } bit;
  } SCL_HIGH_PERIOD;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< Configures the delay between the SDA and SCL negative edge for
                                                     a start condition                                                         */
    
    struct {
      __IOM uint32_t TIME       : 9;            /*!< This register is used to configure the time between the negative
                                                     edgeof SDA and the negative edge of SCL for a START condition,
                                                     in I2C module clock cycles.                                               */
            uint32_t            : 23;
    } bit;
  } SCL_START_HOLD;
  
  union {
    __IOM uint32_t reg;                         /*!< Configures the delay between the positiveedge of SCL and the
                                                     negative edge of SDA                                                      */
    
    struct {
      __IOM uint32_t TIME       : 9;            /*!< This register is used to configure the time between the positiveedge
                                                     of SCL and the negative edge of SDA for a RESTART condition,
                                                     in I2C module clock cycles.                                               */
            uint32_t            : 23;
    } bit;
  } SCL_RSTART_SETUP;
  
  union {
    __IOM uint32_t reg;                         /*!< Configures the delay after the SCL clockedge for a stop condition         */
    
    struct {
      __IOM uint32_t TIME       : 9;            /*!< This register is used to configure the delay after the STOP
                                                     condition,in I2C module clock cycles.                                     */
            uint32_t            : 23;
    } bit;
  } SCL_STOP_HOLD;
  
  union {
    __IOM uint32_t reg;                         /*!< Configures the delay between the SDA andSCL positive edge for
                                                     a stop condition                                                          */
    
    struct {
      __IOM uint32_t TIME       : 9;            /*!< This register is used to configure the time between the positive
                                                     edgeof SCL and the positive edge of SDA, in I2C module
                                                     clock cycles.                                                             */
            uint32_t            : 23;
    } bit;
  } SCL_STOP_SETUP;
  
  union {
    __IOM uint32_t reg;                         /*!< SCL and SDA filter configuration register                                 */
    
    struct {
      __IOM uint32_t SCL_FILTER_THRES : 4;      /*!< When a pulse on the SCL input has smaller width than this register
                                                     valuein I2C module clock cycles, the I2C controller will
                                                     ignore that pulse.                                                        */
      __IOM uint32_t SDA_FILTER_THRES : 4;      /*!< When a pulse on the SDA input has smaller width than this register
                                                     valuein I2C module clock cycles, the I2C controller will
                                                     ignore that pulse.                                                        */
      __IOM uint32_t SCL_FILTER_EN : 1;         /*!< This is the filter enable bit for SCL.                                    */
      __IOM uint32_t SDA_FILTER_EN : 1;         /*!< This is the filter enable bit for SDA.                                    */
            uint32_t            : 22;
    } bit;
  } FILTER_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C CLK configuration register                                            */
    
    struct {
      __IOM uint32_t SCLK_DIV_NUM : 8;          /*!< the integral part of the fractional divisor for i2c module                */
      __IOM uint32_t SCLK_DIV_A : 6;            /*!< the numerator of the fractional part of the fractional divisor
                                                     for i2c module                                                            */
      __IOM uint32_t SCLK_DIV_B : 6;            /*!< the denominator of the fractional part of the fractional divisor
                                                     for i2c module                                                            */
      __IOM uint32_t SCLK_SEL   : 1;            /*!< The clock selection for i2c module:0-XTAL;1-CLK_8MHz.                     */
      __IOM uint32_t SCLK_ACTIVE : 1;           /*!< The clock switch for i2c module                                           */
            uint32_t            : 10;
    } bit;
  } CLK_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C command register 0                                                    */
    
    struct {
      __IOM uint32_t COMMAND    : 14;           /*!< This is the content of command 0. It consists of three parts:
                                                     op_code is the command, 0: RSTART; 1: WRITE; 2: READ; 3:
                                                     STOP; 4: END.Byte_num represents the number of bytes that
                                                     need to be sent or received.ack_check_en, ack_exp and ack
                                                     are used to control the ACK bit. See I2C cmd structure
                                                     for moreInformation.                                                      */
            uint32_t            : 17;
      __IOM uint32_t COMMAND_DONE : 1;          /*!< When command 0 is done in I2C Master mode, this bit changes
                                                     to highlevel.                                                             */
    } bit;
  } COMD0;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t reg;                         /*!< I2C command register 1                                                    */
    
    struct {
      __IOM uint32_t COMMAND    : 14;           /*!< This is the content of command 0. It consists of three parts:
                                                     op_code is the command, 0: RSTART; 1: WRITE; 2: READ; 3:
                                                     STOP; 4: END.Byte_num represents the number of bytes that
                                                     need to be sent or received.ack_check_en, ack_exp and ack
                                                     are used to control the ACK bit. See I2C cmd structure
                                                     for moreInformation.                                                      */
            uint32_t            : 17;
      __IOM uint32_t COMMAND_DONE : 1;          /*!< When command 0 is done in I2C Master mode, this bit changes
                                                     to highlevel.                                                             */
    } bit;
  } COMD1;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< I2C command register 2                                                    */
      
      struct {
        __IOM uint32_t COMMAND  : 14;           /*!< This is the content of command 0. It consists of three parts:
                                                     op_code is the command, 0: RSTART; 1: WRITE; 2: READ; 3:
                                                     STOP; 4: END.Byte_num represents the number of bytes that
                                                     need to be sent or received.ack_check_en, ack_exp and ack
                                                     are used to control the ACK bit. See I2C cmd structure
                                                     for moreInformation.                                                      */
              uint32_t          : 17;
        __IOM uint32_t COMMAND_DONE : 1;        /*!< When command 0 is done in I2C Master mode, this bit changes
                                                     to highlevel.                                                             */
      } bit;
    } COMD2;
    
    union {
      __IOM uint32_t reg;                       /*!< SCL status time out register                                              */
      
      struct {
        __IOM uint32_t SCL_ST_TO_I2C : 5;       /*!< The threshold value of SCL_FSM state unchanged period. It should
                                                     be o more than 23                                                         */
              uint32_t          : 27;
      } bit;
    } SCL_ST_TIME_OUT;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< SCL main status time out register                                         */
    
    struct {
      __IOM uint32_t SCL_MAIN_ST_TO_I2C : 5;    /*!< The threshold value of SCL_MAIN_FSM state unchanged period.nIt
                                                     should be o more than 23                                                  */
            uint32_t            : 27;
    } bit;
  } SCL_MAIN_ST_TIME_OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< Power configuration register                                              */
    
    struct {
      __IOM uint32_t SCL_RST_SLV_EN : 1;        /*!< When I2C master is IDLE, set this bit to send out SCL pulses.
                                                     The number of pulses equals to reg_scl_rst_slv_num[4:0].                  */
      __IOM uint32_t SCL_RST_SLV_NUM : 5;       /*!< Configure the pulses of SCL generated in I2C master mode. Valid
                                                     when reg_scl_rst_slv_en is 1.                                             */
      __IOM uint32_t SCL_PD_EN  : 1;            /*!< The power down enable bit for the I2C output SCL line. 1: Power
                                                     down. 0: Not power down. Set reg_scl_force_out and reg_scl_pd_en
                                                     to 1 to stretch SCL low.                                                  */
      __IOM uint32_t SDA_PD_EN  : 1;            /*!< The power down enable bit for the I2C output SDA line. 1: Power
                                                     down. 0: Not power down. Set reg_sda_force_out and reg_sda_pd_en
                                                     to 1 to stretch SDA low.                                                  */
            uint32_t            : 24;
    } bit;
  } SCL_SP_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Set SCL stretch of I2C slave                                              */
    
    struct {
      __IOM uint32_t STRETCH_PROTECT_NUM : 10;  /*!< Configure the period of I2C slave stretching SCL line.                    */
      __IOM uint32_t SLAVE_SCL_STRETCH_EN : 1;  /*!< The enable bit for slave SCL stretch function. 1: Enable. 0:
                                                     Disable. The SCL output line will be stretched low when
                                                     reg_slave_scl_stretch_en is 1 and stretch event happens.
                                                     The stretch cause can be seen in reg_stretch_cause.                       */
      __OM  uint32_t SLAVE_SCL_STRETCH_CLR : 1; /*!< Set this bit to clear the I2C slave SCL stretch function.                 */
      __IOM uint32_t SLAVE_BYTE_ACK_CTL_EN : 1; /*!< The enable bit for slave to control ACK level function.                   */
      __IOM uint32_t SLAVE_BYTE_ACK_LVL : 1;    /*!< Set the ACK level when slave controlling ACK level function
                                                     enables.                                                                  */
            uint32_t            : 18;
    } bit;
  } SCL_STRETCH_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C command register 3                                                    */
    
    struct {
      __IOM uint32_t COMMAND    : 14;           /*!< This is the content of command 0. It consists of three parts:
                                                     op_code is the command, 0: RSTART; 1: WRITE; 2: READ; 3:
                                                     STOP; 4: END.Byte_num represents the number of bytes that
                                                     need to be sent or received.ack_check_en, ack_exp and ack
                                                     are used to control the ACK bit. See I2C cmd structure
                                                     for moreInformation.                                                      */
            uint32_t            : 17;
      __IOM uint32_t COMMAND_DONE : 1;          /*!< When command 0 is done in I2C Master mode, this bit changes
                                                     to highlevel.                                                             */
    } bit;
  } COMD3;
  __IM  uint32_t  RESERVED3[3];
  
  union {
    __IOM uint32_t reg;                         /*!< I2C command register 4                                                    */
    
    struct {
      __IOM uint32_t COMMAND    : 14;           /*!< This is the content of command 0. It consists of three parts:
                                                     op_code is the command, 0: RSTART; 1: WRITE; 2: READ; 3:
                                                     STOP; 4: END.Byte_num represents the number of bytes that
                                                     need to be sent or received.ack_check_en, ack_exp and ack
                                                     are used to control the ACK bit. See I2C cmd structure
                                                     for moreInformation.                                                      */
            uint32_t            : 17;
      __IOM uint32_t COMMAND_DONE : 1;          /*!< When command 0 is done in I2C Master mode, this bit changes
                                                     to highlevel.                                                             */
    } bit;
  } COMD4;
  __IM  uint32_t  RESERVED4[3];
  
  union {
    __IOM uint32_t reg;                         /*!< I2C command register 5                                                    */
    
    struct {
      __IOM uint32_t COMMAND    : 14;           /*!< This is the content of command 0. It consists of three parts:
                                                     op_code is the command, 0: RSTART; 1: WRITE; 2: READ; 3:
                                                     STOP; 4: END.Byte_num represents the number of bytes that
                                                     need to be sent or received.ack_check_en, ack_exp and ack
                                                     are used to control the ACK bit. See I2C cmd structure
                                                     for moreInformation.                                                      */
            uint32_t            : 17;
      __IOM uint32_t COMMAND_DONE : 1;          /*!< When command 0 is done in I2C Master mode, this bit changes
                                                     to highlevel.                                                             */
    } bit;
  } COMD5;
  __IM  uint32_t  RESERVED5[3];
  
  union {
    __IOM uint32_t reg;                         /*!< I2C command register 6                                                    */
    
    struct {
      __IOM uint32_t COMMAND    : 14;           /*!< This is the content of command 0. It consists of three parts:
                                                     op_code is the command, 0: RSTART; 1: WRITE; 2: READ; 3:
                                                     STOP; 4: END.Byte_num represents the number of bytes that
                                                     need to be sent or received.ack_check_en, ack_exp and ack
                                                     are used to control the ACK bit. See I2C cmd structure
                                                     for moreInformation.                                                      */
            uint32_t            : 17;
      __IOM uint32_t COMMAND_DONE : 1;          /*!< When command 0 is done in I2C Master mode, this bit changes
                                                     to highlevel.                                                             */
    } bit;
  } COMD6;
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t reg;                         /*!< I2C command register 7                                                    */
    
    struct {
      __IOM uint32_t COMMAND    : 14;           /*!< This is the content of command 0. It consists of three parts:
                                                     op_code is the command, 0: RSTART; 1: WRITE; 2: READ; 3:
                                                     STOP; 4: END.Byte_num represents the number of bytes that
                                                     need to be sent or received.ack_check_en, ack_exp and ack
                                                     are used to control the ACK bit. See I2C cmd structure
                                                     for moreInformation.                                                      */
            uint32_t            : 17;
      __IOM uint32_t COMMAND_DONE : 1;          /*!< When command 0 is done in I2C Master mode, this bit changes
                                                     to highlevel.                                                             */
    } bit;
  } COMD7;
  __IM  uint32_t  RESERVED7[11];
  
  union {
    __IOM uint32_t reg;                         /*!< Version register                                                          */
    
    struct {
      __IOM uint32_t DATE       : 32;           /*!< This is the the version register.                                         */
    } bit;
  } DATE;
  __IM  uint32_t  RESERVED8;
  
  union {
    __IOM uint32_t reg;                         /*!< I2C TXFIFO base address register                                          */
    
    struct {
      __IM  uint32_t TXFIFO_START_ADDR : 32;    /*!< This is the I2C txfifo first address.                                     */
    } bit;
  } TXFIFO_START_ADDR;
  __IM  uint32_t  RESERVED9[31];
  
  union {
    __IOM uint32_t reg;                         /*!< I2C RXFIFO base address register                                          */
    
    struct {
      __IM  uint32_t RXFIFO_START_ADDR : 32;    /*!< This is the I2C rxfifo first address.                                     */
    } bit;
  } RXFIFO_START_ADDR;
} I2C0_Type;                                    /*!< Size = 388 (0x184)                                                        */



/* =========================================================================================================================== */
/* ================                                           I2S0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2S (Inter-IC Sound) Controller 0 (I2S0)
  */

typedef struct {                                /*!< I2S0 Structure                                                            */
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< I2S interrupt raw register, valid in level.                               */
    
    struct {
      __IM  uint32_t RX_DONE_INT_RAW : 1;       /*!< The raw interrupt status bit for the i2s_rx_done_int interrupt            */
      __IM  uint32_t TX_DONE_INT_RAW : 1;       /*!< The raw interrupt status bit for the i2s_tx_done_int interrupt            */
      __IM  uint32_t RX_HUNG_INT_RAW : 1;       /*!< The raw interrupt status bit for the i2s_rx_hung_int interrupt            */
      __IM  uint32_t TX_HUNG_INT_RAW : 1;       /*!< The raw interrupt status bit for the i2s_tx_hung_int interrupt            */
            uint32_t            : 28;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S interrupt status register.                                            */
    
    struct {
      __IM  uint32_t RX_DONE_INT_ST : 1;        /*!< The masked interrupt status bit for the i2s_rx_done_int interrupt         */
      __IM  uint32_t TX_DONE_INT_ST : 1;        /*!< The masked interrupt status bit for the i2s_tx_done_int interrupt         */
      __IM  uint32_t RX_HUNG_INT_ST : 1;        /*!< The masked interrupt status bit for the i2s_rx_hung_int interrupt         */
      __IM  uint32_t TX_HUNG_INT_ST : 1;        /*!< The masked interrupt status bit for the i2s_tx_hung_int interrupt         */
            uint32_t            : 28;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S interrupt enable register.                                            */
    
    struct {
      __IOM uint32_t RX_DONE_INT_ENA : 1;       /*!< The interrupt enable bit for the i2s_rx_done_int interrupt                */
      __IOM uint32_t TX_DONE_INT_ENA : 1;       /*!< The interrupt enable bit for the i2s_tx_done_int interrupt                */
      __IOM uint32_t RX_HUNG_INT_ENA : 1;       /*!< The interrupt enable bit for the i2s_rx_hung_int interrupt                */
      __IOM uint32_t TX_HUNG_INT_ENA : 1;       /*!< The interrupt enable bit for the i2s_tx_hung_int interrupt                */
            uint32_t            : 28;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S interrupt clear register.                                             */
    
    struct {
      __OM  uint32_t RX_DONE_INT_CLR : 1;       /*!< Set this bit to clear the i2s_rx_done_int interrupt                       */
      __OM  uint32_t TX_DONE_INT_CLR : 1;       /*!< Set this bit to clear the i2s_tx_done_int interrupt                       */
      __OM  uint32_t RX_HUNG_INT_CLR : 1;       /*!< Set this bit to clear the i2s_rx_hung_int interrupt                       */
      __OM  uint32_t TX_HUNG_INT_CLR : 1;       /*!< Set this bit to clear the i2s_tx_hung_int interrupt                       */
            uint32_t            : 28;
    } bit;
  } INT_CLR;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX configure register                                                 */
    
    struct {
      __OM  uint32_t RX_RESET   : 1;            /*!< Set this bit to reset receiver                                            */
      __OM  uint32_t RX_FIFO_RESET : 1;         /*!< Set this bit to reset Rx AFIFO                                            */
      __IOM uint32_t RX_START   : 1;            /*!< Set this bit to start receiving data                                      */
      __IOM uint32_t RX_SLAVE_MOD : 1;          /*!< Set this bit to enable slave receiver mode                                */
            uint32_t            : 1;
      __IOM uint32_t RX_MONO    : 1;            /*!< Set this bit to enable receiver in mono mode                              */
            uint32_t            : 1;
      __IOM uint32_t RX_BIG_ENDIAN : 1;         /*!< I2S Rx byte endian, 1: low addr value to high addr. 0: low addr
                                                     with low addr value.                                                      */
      __IOM uint32_t RX_UPDATE  : 1;            /*!< Set 1 to update I2S RX registers from APB clock domain to I2S
                                                     RX clock domain. This bit will be cleared by hardware after
                                                     update register done.                                                     */
      __IOM uint32_t RX_MONO_FST_VLD : 1;       /*!< 1: The first channel data value is valid in I2S RX mono mode.
                                                     0: The second channel data value is valid in I2S RX mono
                                                     mode.                                                                     */
      __IOM uint32_t RX_PCM_CONF : 2;           /*!< I2S RX compress/decompress configuration bit. & 0 (atol): A-Law
                                                     decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law
                                                     decompress, 3 (ltou) : u-Law compress. &                                  */
      __IOM uint32_t RX_PCM_BYPASS : 1;         /*!< Set this bit to bypass Compress/Decompress module for received
                                                     data.                                                                     */
      __IOM uint32_t RX_STOP_MODE : 2;          /*!< 0 : I2S Rx only stop when reg_rx_start is cleared. 1: Stop when
                                                     reg_rx_start is 0 or in_suc_eof is 1. 2: Stop I2S RX when
                                                     reg_rx_start is 0 or RX FIFO is full.                                     */
      __IOM uint32_t RX_LEFT_ALIGN : 1;         /*!< 1: I2S RX left alignment mode. 0: I2S RX right alignment mode.            */
      __IOM uint32_t RX_24_FILL_EN : 1;         /*!< 1: store 24 channel bits to 32 bits. 0:store 24 channel bits
                                                     to 24 bits.                                                               */
      __IOM uint32_t RX_WS_IDLE_POL : 1;        /*!< 0: WS should be 0 when receiving left channel data, and WS is
                                                     1in right channel. 1: WS should be 1 when receiving left
                                                     channel data, and WS is 0in right channel.                                */
      __IOM uint32_t RX_BIT_ORDER : 1;          /*!< I2S Rx bit endian. 1:small endian, the LSB is received first.
                                                     0:big endian, the MSB is received first.                                  */
      __IOM uint32_t RX_TDM_EN  : 1;            /*!< 1: Enable I2S TDM Rx mode . 0: Disable.                                   */
      __IOM uint32_t RX_PDM_EN  : 1;            /*!< 1: Enable I2S PDM Rx mode . 0: Disable.                                   */
      __IOM uint32_t RX_PDM2PCM_EN : 1;         /*!< 1: Enable PDM2PCM RX mode. 0: DIsable.                                    */
      __IOM uint32_t RX_PDM_SINC_DSR_16_EN : 1; /*!< Configure the down sampling rate of PDM RX filter group1 module.
                                                     1: The down sampling rate is 128. 0: down sampling rate
                                                     is 64.                                                                    */
            uint32_t            : 9;
    } bit;
  } RX_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX configure register                                                 */
    
    struct {
      __OM  uint32_t TX_RESET   : 1;            /*!< Set this bit to reset transmitter                                         */
      __OM  uint32_t TX_FIFO_RESET : 1;         /*!< Set this bit to reset Tx AFIFO                                            */
      __IOM uint32_t TX_START   : 1;            /*!< Set this bit to start transmitting data                                   */
      __IOM uint32_t TX_SLAVE_MOD : 1;          /*!< Set this bit to enable slave transmitter mode                             */
            uint32_t            : 1;
      __IOM uint32_t TX_MONO    : 1;            /*!< Set this bit to enable transmitter in mono mode                           */
      __IOM uint32_t TX_CHAN_EQUAL : 1;         /*!< 1: The value of Left channel data is equal to the value of right
                                                     channel data in I2S TX mono mode or TDM channel select
                                                     mode. 0: The invalid channel data is reg_i2s_single_data
                                                     in I2S TX mono mode or TDM channel select mode.                           */
      __IOM uint32_t TX_BIG_ENDIAN : 1;         /*!< I2S Tx byte endian, 1: low addr value to high addr. 0: low addr
                                                     with low addr value.                                                      */
      __IOM uint32_t TX_UPDATE  : 1;            /*!< Set 1 to update I2S TX registers from APB clock domain to I2S
                                                     TX clock domain. This bit will be cleared by hardware after
                                                     update register done.                                                     */
      __IOM uint32_t TX_MONO_FST_VLD : 1;       /*!< 1: The first channel data value is valid in I2S TX mono mode.
                                                     0: The second channel data value is valid in I2S TX mono
                                                     mode.                                                                     */
      __IOM uint32_t TX_PCM_CONF : 2;           /*!< I2S TX compress/decompress configuration bit. & 0 (atol): A-Law
                                                     decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law
                                                     decompress, 3 (ltou) : u-Law compress. &                                  */
      __IOM uint32_t TX_PCM_BYPASS : 1;         /*!< Set this bit to bypass Compress/Decompress module for transmitted
                                                     data.                                                                     */
      __IOM uint32_t TX_STOP_EN : 1;            /*!< Set this bit to stop disable output BCK signal and WS signal
                                                     when tx FIFO is emtpy                                                     */
            uint32_t            : 1;
      __IOM uint32_t TX_LEFT_ALIGN : 1;         /*!< 1: I2S TX left alignment mode. 0: I2S TX right alignment mode.            */
      __IOM uint32_t TX_24_FILL_EN : 1;         /*!< 1: Sent 32 bits in 24 channel bits mode. 0: Sent 24 bits in
                                                     24 channel bits mode                                                      */
      __IOM uint32_t TX_WS_IDLE_POL : 1;        /*!< 0: WS should be 0 when sending left channel data, and WS is
                                                     1in right channel. 1: WS should be 1 when sending left
                                                     channel data, and WS is 0in right channel.                                */
      __IOM uint32_t TX_BIT_ORDER : 1;          /*!< I2S Tx bit endian. 1:small endian, the LSB is sent first. 0:big
                                                     endian, the MSB is sent first.                                            */
      __IOM uint32_t TX_TDM_EN  : 1;            /*!< 1: Enable I2S TDM Tx mode . 0: Disable.                                   */
      __IOM uint32_t TX_PDM_EN  : 1;            /*!< 1: Enable I2S PDM Tx mode . 0: Disable.                                   */
            uint32_t            : 3;
      __IOM uint32_t TX_CHAN_MOD : 3;           /*!< I2S transmitter channel mode configuration bits.                          */
      __IOM uint32_t SIG_LOOPBACK : 1;          /*!< Enable signal loop back mode with transmitter module and receiver
                                                     module sharing the same WS and BCK signals.                               */
            uint32_t            : 4;
    } bit;
  } TX_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX configure register 1                                               */
    
    struct {
      __IOM uint32_t RX_TDM_WS_WIDTH : 7;       /*!< The width of rx_ws_out in TDM mode is (I2S_RX_TDM_WS_WIDTH[6:0]
                                                     +1) * T_bck                                                               */
      __IOM uint32_t RX_BCK_DIV_NUM : 6;        /*!< Bit clock configuration bits in receiver mode.                            */
      __IOM uint32_t RX_BITS_MOD : 5;           /*!< Set the bits to configure the valid data bit length of I2S receiver
                                                     channel. 7: all the valid channel data is in 8-bit-mode.
                                                     15: all the valid channel data is in 16-bit-mode. 23: all
                                                     the valid channel data is in 24-bit-mode. 31:all the valid
                                                     channel data is in 32-bit-mode.                                           */
      __IOM uint32_t RX_HALF_SAMPLE_BITS : 6;   /*!< I2S Rx half sample bits -1.                                               */
      __IOM uint32_t RX_TDM_CHAN_BITS : 5;      /*!< The Rx bit number for each channel minus 1in TDM mode.                    */
      __IOM uint32_t RX_MSB_SHIFT : 1;          /*!< Set this bit to enable receiver in Phillips standard mode                 */
            uint32_t            : 2;
    } bit;
  } RX_CONF1;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX configure register 1                                               */
    
    struct {
      __IOM uint32_t TX_TDM_WS_WIDTH : 7;       /*!< The width of tx_ws_out in TDM mode is (I2S_TX_TDM_WS_WIDTH[6:0]
                                                     +1) * T_bck                                                               */
      __IOM uint32_t TX_BCK_DIV_NUM : 6;        /*!< Bit clock configuration bits in transmitter mode.                         */
      __IOM uint32_t TX_BITS_MOD : 5;           /*!< Set the bits to configure the valid data bit length of I2S transmitter
                                                     channel. 7: all the valid channel data is in 8-bit-mode.
                                                     15: all the valid channel data is in 16-bit-mode. 23: all
                                                     the valid channel data is in 24-bit-mode. 31:all the valid
                                                     channel data is in 32-bit-mode.                                           */
      __IOM uint32_t TX_HALF_SAMPLE_BITS : 6;   /*!< I2S Tx half sample bits -1.                                               */
      __IOM uint32_t TX_TDM_CHAN_BITS : 5;      /*!< The Tx bit number for each channel minus 1in TDM mode.                    */
      __IOM uint32_t TX_MSB_SHIFT : 1;          /*!< Set this bit to enable transmitter in Phillips standard mode              */
      __IOM uint32_t TX_BCK_NO_DLY : 1;         /*!< 1: BCK is not delayed to generate pos/neg edge in master mode.
                                                     0: BCK is delayed to generate pos/neg edge in master mode.                */
            uint32_t            : 1;
    } bit;
  } TX_CONF1;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX clock configure register                                           */
    
    struct {
      __IOM uint32_t RX_CLKM_DIV_NUM : 8;       /*!< Integral I2S clock divider value                                          */
            uint32_t            : 18;
      __IOM uint32_t RX_CLK_ACTIVE : 1;         /*!< I2S Rx module clock enable signal.                                        */
      __IOM uint32_t RX_CLK_SEL : 2;            /*!< Select I2S Rx module source clock. 0: no clock. 1: APLL. 2:
                                                     CLK160. 3: I2S_MCLK_in.                                                   */
      __IOM uint32_t MCLK_SEL   : 1;            /*!< 0: UseI2S Tx module clock as I2S_MCLK_OUT. 1: UseI2S Rx module
                                                     clock as I2S_MCLK_OUT.                                                    */
            uint32_t            : 2;
    } bit;
  } RX_CLKM_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX clock configure register                                           */
    
    struct {
      __IOM uint32_t TX_CLKM_DIV_NUM : 8;       /*!< Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a).
                                                     There will be (a-b) * n-div and b * (n+1)-div. So the average
                                                     combination will be: for b <= a/2, z * [x * n-div + (n+1)-div]
                                                     + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] +
                                                     y * (n+1)-div.                                                            */
            uint32_t            : 18;
      __IOM uint32_t TX_CLK_ACTIVE : 1;         /*!< I2S Tx module clock enable signal.                                        */
      __IOM uint32_t TX_CLK_SEL : 2;            /*!< Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2:
                                                     CLK160. 3: I2S_MCLK_in.                                                   */
      __IOM uint32_t CLK_EN     : 1;            /*!< Set this bit to enable clk gate                                           */
            uint32_t            : 2;
    } bit;
  } TX_CLKM_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX module clock divider configure register                            */
    
    struct {
      __IOM uint32_t RX_CLKM_DIV_Z : 9;         /*!< For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2,
                                                     the value of I2S_RX_CLKM_DIV_Z is (a-b).                                  */
      __IOM uint32_t RX_CLKM_DIV_Y : 9;         /*!< For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For
                                                     b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).                     */
      __IOM uint32_t RX_CLKM_DIV_X : 9;         /*!< For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For
                                                     b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) -
                                                     1.                                                                        */
      __IOM uint32_t RX_CLKM_DIV_YN1 : 1;       /*!< For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b
                                                     > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.                             */
            uint32_t            : 4;
    } bit;
  } RX_CLKM_DIV_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX module clock divider configure register                            */
    
    struct {
      __IOM uint32_t TX_CLKM_DIV_Z : 9;         /*!< For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2,
                                                     the value of I2S_TX_CLKM_DIV_Z is (a-b).                                  */
      __IOM uint32_t TX_CLKM_DIV_Y : 9;         /*!< For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For
                                                     b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).                     */
      __IOM uint32_t TX_CLKM_DIV_X : 9;         /*!< For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For
                                                     b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) -
                                                     1.                                                                        */
      __IOM uint32_t TX_CLKM_DIV_YN1 : 1;       /*!< For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b
                                                     > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.                             */
            uint32_t            : 4;
    } bit;
  } TX_CLKM_DIV_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX PCM2PDM configuration register                                     */
    
    struct {
      __IOM uint32_t TX_PDM_HP_BYPASS : 1;      /*!< I2S TX PDM bypass hp filter or not. The option has been removed.          */
      __IOM uint32_t TX_PDM_SINC_OSR2 : 4;      /*!< I2S TX PDM OSR2 value                                                     */
      __IOM uint32_t TX_PDM_PRESCALE : 8;       /*!< I2S TX PDM prescale for sigmadelta                                        */
      __IOM uint32_t TX_PDM_HP_IN_SHIFT : 2;    /*!< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2
                                                     , 3: x4                                                                   */
      __IOM uint32_t TX_PDM_LP_IN_SHIFT : 2;    /*!< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2
                                                     , 3: x4                                                                   */
      __IOM uint32_t TX_PDM_SINC_IN_SHIFT : 2;  /*!< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2
                                                     , 3: x4                                                                   */
      __IOM uint32_t TX_PDM_SIGMADELTA_IN_SHIFT : 2;/*!< I2S TX PDM sigmadelta scale shift number: 0:/2 , 1:x1 , 2:x2
                                                     , 3: x4                                                                   */
      __IOM uint32_t TX_PDM_SIGMADELTA_DITHER2 : 1;/*!< I2S TX PDM sigmadelta dither2 value                                    */
      __IOM uint32_t TX_PDM_SIGMADELTA_DITHER : 1;/*!< I2S TX PDM sigmadelta dither value                                      */
      __IOM uint32_t TX_PDM_DAC_2OUT_EN : 1;    /*!< I2S TX PDM dac mode enable                                                */
      __IOM uint32_t TX_PDM_DAC_MODE_EN : 1;    /*!< I2S TX PDM dac 2channel enable                                            */
      __IOM uint32_t PCM2PDM_CONV_EN : 1;       /*!< I2S TX PDM Converter enable                                               */
            uint32_t            : 6;
    } bit;
  } TX_PCM2PDM_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX PCM2PDM configuration register                                     */
    
    struct {
      __IOM uint32_t TX_PDM_FP  : 10;           /*!< I2S TX PDM Fp                                                             */
      __IOM uint32_t TX_PDM_FS  : 10;           /*!< I2S TX PDM Fs                                                             */
      __IOM uint32_t TX_IIR_HP_MULT12_5 : 3;    /*!< The fourth parameter of PDM TX IIR_HP filter stage 2 is (504
                                                     + I2S_TX_IIR_HP_MULT12_5[2:0])                                            */
      __IOM uint32_t TX_IIR_HP_MULT12_0 : 3;    /*!< The fourth parameter of PDM TX IIR_HP filter stage 1 is (504
                                                     + I2S_TX_IIR_HP_MULT12_0[2:0])                                            */
            uint32_t            : 6;
    } bit;
  } TX_PCM2PDM_CONF1;
  __IM  uint32_t  RESERVED2[2];
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX TDM mode control register                                          */
    
    struct {
      __IOM uint32_t RX_TDM_PDM_CHAN0_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     0. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN1_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     1. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN2_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     2. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN3_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     3. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN4_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     4. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN5_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     5. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN6_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     6. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN7_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     7. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_CHAN8_EN : 1;       /*!< 1: Enable the valid data input of I2S RX TDM channel 8. 0: Disable,
                                                     just input 0 in this channel.                                             */
      __IOM uint32_t RX_TDM_CHAN9_EN : 1;       /*!< 1: Enable the valid data input of I2S RX TDM channel 9. 0: Disable,
                                                     just input 0 in this channel.                                             */
      __IOM uint32_t RX_TDM_CHAN10_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 10. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN11_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 11. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN12_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 12. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN13_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 13. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN14_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 14. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN15_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 15. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_TOT_CHAN_NUM : 4;   /*!< The total channel number of I2S TX TDM mode.                              */
            uint32_t            : 12;
    } bit;
  } RX_TDM_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX TDM mode control register                                          */
    
    struct {
      __IOM uint32_t TX_TDM_CHAN0_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 0. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN1_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 1. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN2_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 2. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN3_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 3. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN4_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 4. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN5_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 5. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN6_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 6. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN7_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 7. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN8_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 8. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN9_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 9. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN10_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 10. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN11_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 11. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN12_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 12. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN13_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 13. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN14_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 14. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN15_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 15. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_TOT_CHAN_NUM : 4;   /*!< The total channel number of I2S TX TDM mode.                              */
      __IOM uint32_t TX_TDM_SKIP_MSK_EN : 1;    /*!< When DMA TX buffer stores the data of (REG_TX_TDM_TOT_CHAN_NUM
                                                     + 1) channels, and only the data of the enabled channels
                                                     is sent, then this bit should be set. Clear it when all
                                                     the data stored in DMA TX buffer is for enabled channels.                 */
            uint32_t            : 11;
    } bit;
  } TX_TDM_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX timing control register                                            */
    
    struct {
      __IOM uint32_t RX_SD_IN_DM : 2;           /*!< The delay mode of I2S Rx SD input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_SD1_IN_DM : 2;          /*!< The delay mode of I2S Rx SD1 input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_SD2_IN_DM : 2;          /*!< The delay mode of I2S Rx SD2 input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_SD3_IN_DM : 2;          /*!< The delay mode of I2S Rx SD3 input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_WS_OUT_DM : 2;          /*!< The delay mode of I2S Rx WS output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_BCK_OUT_DM : 2;         /*!< The delay mode of I2S Rx BCK output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_WS_IN_DM : 2;           /*!< The delay mode of I2S Rx WS input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_BCK_IN_DM : 2;          /*!< The delay mode of I2S Rx BCK input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
    } bit;
  } RX_TIMING;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX timing control register                                            */
    
    struct {
      __IOM uint32_t TX_SD_OUT_DM : 2;          /*!< The delay mode of I2S TX SD output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t TX_SD1_OUT_DM : 2;         /*!< The delay mode of I2S TX SD1 output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 10;
      __IOM uint32_t TX_WS_OUT_DM : 2;          /*!< The delay mode of I2S TX WS output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t TX_BCK_OUT_DM : 2;         /*!< The delay mode of I2S TX BCK output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t TX_WS_IN_DM : 2;           /*!< The delay mode of I2S TX WS input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t TX_BCK_IN_DM : 2;          /*!< The delay mode of I2S TX BCK input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
    } bit;
  } TX_TIMING;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S HUNG configure register.                                              */
    
    struct {
      __IOM uint32_t LC_FIFO_TIMEOUT : 8;       /*!< the i2s_tx_hung_int interrupt or the i2s_rx_hung_int interrupt
                                                     will be triggered when fifo hung counter is equal to this
                                                     value                                                                     */
      __IOM uint32_t LC_FIFO_TIMEOUT_SHIFT : 3; /*!< The bits are used to scale tick counter threshold. The tick
                                                     counter is reset when counter value >= 88000/2^i2s_lc_fifo_timeout_shift  */
      __IOM uint32_t LC_FIFO_TIMEOUT_ENA : 1;   /*!< The enable bit for FIFO timeout                                           */
            uint32_t            : 20;
    } bit;
  } LC_HUNG_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX data number control register.                                      */
    
    struct {
      __IOM uint32_t RX_EOF_NUM : 12;           /*!< The receive data bit length is (I2S_RX_BITS_MOD[4:0] + 1) *
                                                     (REG_RX_EOF_NUM[11:0] + 1) . It will trigger in_suc_eof
                                                     interrupt in the configured DMA RX channel.                               */
            uint32_t            : 20;
    } bit;
  } RXEOF_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S signal data register                                                  */
    
    struct {
      __IOM uint32_t SINGLE_DATA : 32;          /*!< The configured constant channel data to be sent out.                      */
    } bit;
  } CONF_SIGLE_DATA;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX status register                                                    */
    
    struct {
      __IM  uint32_t TX_IDLE    : 1;            /*!< 1: i2s_tx is idle state. 0: i2s_tx is working.                            */
            uint32_t            : 31;
    } bit;
  } STATE;
  __IM  uint32_t  RESERVED3[4];
  
  union {
    __IOM uint32_t reg;                         /*!< Version control register                                                  */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< I2S version control register                                              */
            uint32_t            : 4;
    } bit;
  } DATE;
} I2S0_Type;                                    /*!< Size = 132 (0x84)                                                         */



/* =========================================================================================================================== */
/* ================                                           I2S1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2S (Inter-IC Sound) Controller 1 (I2S1)
  */

typedef struct {                                /*!< I2S1 Structure                                                            */
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< I2S interrupt raw register, valid in level.                               */
    
    struct {
      __IM  uint32_t RX_DONE_INT_RAW : 1;       /*!< The raw interrupt status bit for the i2s_rx_done_int interrupt            */
      __IM  uint32_t TX_DONE_INT_RAW : 1;       /*!< The raw interrupt status bit for the i2s_tx_done_int interrupt            */
      __IM  uint32_t RX_HUNG_INT_RAW : 1;       /*!< The raw interrupt status bit for the i2s_rx_hung_int interrupt            */
      __IM  uint32_t TX_HUNG_INT_RAW : 1;       /*!< The raw interrupt status bit for the i2s_tx_hung_int interrupt            */
            uint32_t            : 28;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S interrupt status register.                                            */
    
    struct {
      __IM  uint32_t RX_DONE_INT_ST : 1;        /*!< The masked interrupt status bit for the i2s_rx_done_int interrupt         */
      __IM  uint32_t TX_DONE_INT_ST : 1;        /*!< The masked interrupt status bit for the i2s_tx_done_int interrupt         */
      __IM  uint32_t RX_HUNG_INT_ST : 1;        /*!< The masked interrupt status bit for the i2s_rx_hung_int interrupt         */
      __IM  uint32_t TX_HUNG_INT_ST : 1;        /*!< The masked interrupt status bit for the i2s_tx_hung_int interrupt         */
            uint32_t            : 28;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S interrupt enable register.                                            */
    
    struct {
      __IOM uint32_t RX_DONE_INT_ENA : 1;       /*!< The interrupt enable bit for the i2s_rx_done_int interrupt                */
      __IOM uint32_t TX_DONE_INT_ENA : 1;       /*!< The interrupt enable bit for the i2s_tx_done_int interrupt                */
      __IOM uint32_t RX_HUNG_INT_ENA : 1;       /*!< The interrupt enable bit for the i2s_rx_hung_int interrupt                */
      __IOM uint32_t TX_HUNG_INT_ENA : 1;       /*!< The interrupt enable bit for the i2s_tx_hung_int interrupt                */
            uint32_t            : 28;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S interrupt clear register.                                             */
    
    struct {
      __OM  uint32_t RX_DONE_INT_CLR : 1;       /*!< Set this bit to clear the i2s_rx_done_int interrupt                       */
      __OM  uint32_t TX_DONE_INT_CLR : 1;       /*!< Set this bit to clear the i2s_tx_done_int interrupt                       */
      __OM  uint32_t RX_HUNG_INT_CLR : 1;       /*!< Set this bit to clear the i2s_rx_hung_int interrupt                       */
      __OM  uint32_t TX_HUNG_INT_CLR : 1;       /*!< Set this bit to clear the i2s_tx_hung_int interrupt                       */
            uint32_t            : 28;
    } bit;
  } INT_CLR;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX configure register                                                 */
    
    struct {
      __OM  uint32_t RX_RESET   : 1;            /*!< Set this bit to reset receiver                                            */
      __OM  uint32_t RX_FIFO_RESET : 1;         /*!< Set this bit to reset Rx AFIFO                                            */
      __IOM uint32_t RX_START   : 1;            /*!< Set this bit to start receiving data                                      */
      __IOM uint32_t RX_SLAVE_MOD : 1;          /*!< Set this bit to enable slave receiver mode                                */
            uint32_t            : 1;
      __IOM uint32_t RX_MONO    : 1;            /*!< Set this bit to enable receiver in mono mode                              */
            uint32_t            : 1;
      __IOM uint32_t RX_BIG_ENDIAN : 1;         /*!< I2S Rx byte endian, 1: low addr value to high addr. 0: low addr
                                                     with low addr value.                                                      */
      __IOM uint32_t RX_UPDATE  : 1;            /*!< Set 1 to update I2S RX registers from APB clock domain to I2S
                                                     RX clock domain. This bit will be cleared by hardware after
                                                     update register done.                                                     */
      __IOM uint32_t RX_MONO_FST_VLD : 1;       /*!< 1: The first channel data value is valid in I2S RX mono mode.
                                                     0: The second channel data value is valid in I2S RX mono
                                                     mode.                                                                     */
      __IOM uint32_t RX_PCM_CONF : 2;           /*!< I2S RX compress/decompress configuration bit. & 0 (atol): A-Law
                                                     decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law
                                                     decompress, 3 (ltou) : u-Law compress. &                                  */
      __IOM uint32_t RX_PCM_BYPASS : 1;         /*!< Set this bit to bypass Compress/Decompress module for received
                                                     data.                                                                     */
      __IOM uint32_t RX_STOP_MODE : 2;          /*!< 0 : I2S Rx only stop when reg_rx_start is cleared. 1: Stop when
                                                     reg_rx_start is 0 or in_suc_eof is 1. 2: Stop I2S RX when
                                                     reg_rx_start is 0 or RX FIFO is full.                                     */
      __IOM uint32_t RX_LEFT_ALIGN : 1;         /*!< 1: I2S RX left alignment mode. 0: I2S RX right alignment mode.            */
      __IOM uint32_t RX_24_FILL_EN : 1;         /*!< 1: store 24 channel bits to 32 bits. 0:store 24 channel bits
                                                     to 24 bits.                                                               */
      __IOM uint32_t RX_WS_IDLE_POL : 1;        /*!< 0: WS should be 0 when receiving left channel data, and WS is
                                                     1in right channel. 1: WS should be 1 when receiving left
                                                     channel data, and WS is 0in right channel.                                */
      __IOM uint32_t RX_BIT_ORDER : 1;          /*!< I2S Rx bit endian. 1:small endian, the LSB is received first.
                                                     0:big endian, the MSB is received first.                                  */
      __IOM uint32_t RX_TDM_EN  : 1;            /*!< 1: Enable I2S TDM Rx mode . 0: Disable.                                   */
      __IOM uint32_t RX_PDM_EN  : 1;            /*!< 1: Enable I2S PDM Rx mode . 0: Disable.                                   */
            uint32_t            : 11;
    } bit;
  } RX_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX configure register                                                 */
    
    struct {
      __OM  uint32_t TX_RESET   : 1;            /*!< Set this bit to reset transmitter                                         */
      __OM  uint32_t TX_FIFO_RESET : 1;         /*!< Set this bit to reset Tx AFIFO                                            */
      __IOM uint32_t TX_START   : 1;            /*!< Set this bit to start transmitting data                                   */
      __IOM uint32_t TX_SLAVE_MOD : 1;          /*!< Set this bit to enable slave transmitter mode                             */
            uint32_t            : 1;
      __IOM uint32_t TX_MONO    : 1;            /*!< Set this bit to enable transmitter in mono mode                           */
      __IOM uint32_t TX_CHAN_EQUAL : 1;         /*!< 1: The value of Left channel data is equal to the value of right
                                                     channel data in I2S TX mono mode or TDM channel select
                                                     mode. 0: The invalid channel data is reg_i2s_single_data
                                                     in I2S TX mono mode or TDM channel select mode.                           */
      __IOM uint32_t TX_BIG_ENDIAN : 1;         /*!< I2S Tx byte endian, 1: low addr value to high addr. 0: low addr
                                                     with low addr value.                                                      */
      __IOM uint32_t TX_UPDATE  : 1;            /*!< Set 1 to update I2S TX registers from APB clock domain to I2S
                                                     TX clock domain. This bit will be cleared by hardware after
                                                     update register done.                                                     */
      __IOM uint32_t TX_MONO_FST_VLD : 1;       /*!< 1: The first channel data value is valid in I2S TX mono mode.
                                                     0: The second channel data value is valid in I2S TX mono
                                                     mode.                                                                     */
      __IOM uint32_t TX_PCM_CONF : 2;           /*!< I2S TX compress/decompress configuration bit. & 0 (atol): A-Law
                                                     decompress, 1 (ltoa) : A-Law compress, 2 (utol) : u-Law
                                                     decompress, 3 (ltou) : u-Law compress. &                                  */
      __IOM uint32_t TX_PCM_BYPASS : 1;         /*!< Set this bit to bypass Compress/Decompress module for transmitted
                                                     data.                                                                     */
      __IOM uint32_t TX_STOP_EN : 1;            /*!< Set this bit to stop disable output BCK signal and WS signal
                                                     when tx FIFO is emtpy                                                     */
            uint32_t            : 1;
      __IOM uint32_t TX_LEFT_ALIGN : 1;         /*!< 1: I2S TX left alignment mode. 0: I2S TX right alignment mode.            */
      __IOM uint32_t TX_24_FILL_EN : 1;         /*!< 1: Sent 32 bits in 24 channel bits mode. 0: Sent 24 bits in
                                                     24 channel bits mode                                                      */
      __IOM uint32_t TX_WS_IDLE_POL : 1;        /*!< 0: WS should be 0 when sending left channel data, and WS is
                                                     1in right channel. 1: WS should be 1 when sending left
                                                     channel data, and WS is 0in right channel.                                */
      __IOM uint32_t TX_BIT_ORDER : 1;          /*!< I2S Tx bit endian. 1:small endian, the LSB is sent first. 0:big
                                                     endian, the MSB is sent first.                                            */
      __IOM uint32_t TX_TDM_EN  : 1;            /*!< 1: Enable I2S TDM Tx mode . 0: Disable.                                   */
      __IOM uint32_t TX_PDM_EN  : 1;            /*!< 1: Enable I2S PDM Tx mode . 0: Disable.                                   */
            uint32_t            : 3;
      __IOM uint32_t TX_CHAN_MOD : 3;           /*!< I2S transmitter channel mode configuration bits.                          */
      __IOM uint32_t SIG_LOOPBACK : 1;          /*!< Enable signal loop back mode with transmitter module and receiver
                                                     module sharing the same WS and BCK signals.                               */
            uint32_t            : 4;
    } bit;
  } TX_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX configure register 1                                               */
    
    struct {
      __IOM uint32_t RX_TDM_WS_WIDTH : 7;       /*!< The width of rx_ws_out in TDM mode is (I2S_RX_TDM_WS_WIDTH[6:0]
                                                     +1) * T_bck                                                               */
      __IOM uint32_t RX_BCK_DIV_NUM : 6;        /*!< Bit clock configuration bits in receiver mode.                            */
      __IOM uint32_t RX_BITS_MOD : 5;           /*!< Set the bits to configure the valid data bit length of I2S receiver
                                                     channel. 7: all the valid channel data is in 8-bit-mode.
                                                     15: all the valid channel data is in 16-bit-mode. 23: all
                                                     the valid channel data is in 24-bit-mode. 31:all the valid
                                                     channel data is in 32-bit-mode.                                           */
      __IOM uint32_t RX_HALF_SAMPLE_BITS : 6;   /*!< I2S Rx half sample bits -1.                                               */
      __IOM uint32_t RX_TDM_CHAN_BITS : 5;      /*!< The Rx bit number for each channel minus 1in TDM mode.                    */
      __IOM uint32_t RX_MSB_SHIFT : 1;          /*!< Set this bit to enable receiver in Phillips standard mode                 */
            uint32_t            : 2;
    } bit;
  } RX_CONF1;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX configure register 1                                               */
    
    struct {
      __IOM uint32_t TX_TDM_WS_WIDTH : 7;       /*!< The width of tx_ws_out in TDM mode is (I2S_TX_TDM_WS_WIDTH[6:0]
                                                     +1) * T_bck                                                               */
      __IOM uint32_t TX_BCK_DIV_NUM : 6;        /*!< Bit clock configuration bits in transmitter mode.                         */
      __IOM uint32_t TX_BITS_MOD : 5;           /*!< Set the bits to configure the valid data bit length of I2S transmitter
                                                     channel. 7: all the valid channel data is in 8-bit-mode.
                                                     15: all the valid channel data is in 16-bit-mode. 23: all
                                                     the valid channel data is in 24-bit-mode. 31:all the valid
                                                     channel data is in 32-bit-mode.                                           */
      __IOM uint32_t TX_HALF_SAMPLE_BITS : 6;   /*!< I2S Tx half sample bits -1.                                               */
      __IOM uint32_t TX_TDM_CHAN_BITS : 5;      /*!< The Tx bit number for each channel minus 1in TDM mode.                    */
      __IOM uint32_t TX_MSB_SHIFT : 1;          /*!< Set this bit to enable transmitter in Phillips standard mode              */
      __IOM uint32_t TX_BCK_NO_DLY : 1;         /*!< 1: BCK is not delayed to generate pos/neg edge in master mode.
                                                     0: BCK is delayed to generate pos/neg edge in master mode.                */
            uint32_t            : 1;
    } bit;
  } TX_CONF1;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX clock configure register                                           */
    
    struct {
      __IOM uint32_t RX_CLKM_DIV_NUM : 8;       /*!< Integral I2S clock divider value                                          */
            uint32_t            : 18;
      __IOM uint32_t RX_CLK_ACTIVE : 1;         /*!< I2S Rx module clock enable signal.                                        */
      __IOM uint32_t RX_CLK_SEL : 2;            /*!< Select I2S Rx module source clock. 0: no clock. 1: APLL. 2:
                                                     CLK160. 3: I2S_MCLK_in.                                                   */
      __IOM uint32_t MCLK_SEL   : 1;            /*!< 0: UseI2S Tx module clock as I2S_MCLK_OUT. 1: UseI2S Rx module
                                                     clock as I2S_MCLK_OUT.                                                    */
            uint32_t            : 2;
    } bit;
  } RX_CLKM_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX clock configure register                                           */
    
    struct {
      __IOM uint32_t TX_CLKM_DIV_NUM : 8;       /*!< Integral I2S TX clock divider value. f_I2S_CLK = f_I2S_CLK_S/(N+b/a).
                                                     There will be (a-b) * n-div and b * (n+1)-div. So the average
                                                     combination will be: for b <= a/2, z * [x * n-div + (n+1)-div]
                                                     + y * n-div. For b > a/2, z * [n-div + x * (n+1)-div] +
                                                     y * (n+1)-div.                                                            */
            uint32_t            : 18;
      __IOM uint32_t TX_CLK_ACTIVE : 1;         /*!< I2S Tx module clock enable signal.                                        */
      __IOM uint32_t TX_CLK_SEL : 2;            /*!< Select I2S Tx module source clock. 0: XTAL clock. 1: APLL. 2:
                                                     CLK160. 3: I2S_MCLK_in.                                                   */
      __IOM uint32_t CLK_EN     : 1;            /*!< Set this bit to enable clk gate                                           */
            uint32_t            : 2;
    } bit;
  } TX_CLKM_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX module clock divider configure register                            */
    
    struct {
      __IOM uint32_t RX_CLKM_DIV_Z : 9;         /*!< For b <= a/2, the value of I2S_RX_CLKM_DIV_Z is b. For b > a/2,
                                                     the value of I2S_RX_CLKM_DIV_Z is (a-b).                                  */
      __IOM uint32_t RX_CLKM_DIV_Y : 9;         /*!< For b <= a/2, the value of I2S_RX_CLKM_DIV_Y is (a%b) . For
                                                     b > a/2, the value of I2S_RX_CLKM_DIV_Y is (a%(a-b)).                     */
      __IOM uint32_t RX_CLKM_DIV_X : 9;         /*!< For b <= a/2, the value of I2S_RX_CLKM_DIV_X is (a/b) - 1. For
                                                     b > a/2, the value of I2S_RX_CLKM_DIV_X is (a/(a-b)) -
                                                     1.                                                                        */
      __IOM uint32_t RX_CLKM_DIV_YN1 : 1;       /*!< For b <= a/2, the value of I2S_RX_CLKM_DIV_YN1 is 0 . For b
                                                     > a/2, the value of I2S_RX_CLKM_DIV_YN1 is 1.                             */
            uint32_t            : 4;
    } bit;
  } RX_CLKM_DIV_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX module clock divider configure register                            */
    
    struct {
      __IOM uint32_t TX_CLKM_DIV_Z : 9;         /*!< For b <= a/2, the value of I2S_TX_CLKM_DIV_Z is b. For b > a/2,
                                                     the value of I2S_TX_CLKM_DIV_Z is (a-b).                                  */
      __IOM uint32_t TX_CLKM_DIV_Y : 9;         /*!< For b <= a/2, the value of I2S_TX_CLKM_DIV_Y is (a%b) . For
                                                     b > a/2, the value of I2S_TX_CLKM_DIV_Y is (a%(a-b)).                     */
      __IOM uint32_t TX_CLKM_DIV_X : 9;         /*!< For b <= a/2, the value of I2S_TX_CLKM_DIV_X is (a/b) - 1. For
                                                     b > a/2, the value of I2S_TX_CLKM_DIV_X is (a/(a-b)) -
                                                     1.                                                                        */
      __IOM uint32_t TX_CLKM_DIV_YN1 : 1;       /*!< For b <= a/2, the value of I2S_TX_CLKM_DIV_YN1 is 0 . For b
                                                     > a/2, the value of I2S_TX_CLKM_DIV_YN1 is 1.                             */
            uint32_t            : 4;
    } bit;
  } TX_CLKM_DIV_CONF;
  __IM  uint32_t  RESERVED2[4];
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX TDM mode control register                                          */
    
    struct {
      __IOM uint32_t RX_TDM_PDM_CHAN0_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     0. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN1_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     1. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN2_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     2. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN3_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     3. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN4_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     4. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN5_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     5. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN6_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     6. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_PDM_CHAN7_EN : 1;   /*!< 1: Enable the valid data input of I2S RX TDM or PDM channel
                                                     7. 0: Disable, just input 0 in this channel.                              */
      __IOM uint32_t RX_TDM_CHAN8_EN : 1;       /*!< 1: Enable the valid data input of I2S RX TDM channel 8. 0: Disable,
                                                     just input 0 in this channel.                                             */
      __IOM uint32_t RX_TDM_CHAN9_EN : 1;       /*!< 1: Enable the valid data input of I2S RX TDM channel 9. 0: Disable,
                                                     just input 0 in this channel.                                             */
      __IOM uint32_t RX_TDM_CHAN10_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 10. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN11_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 11. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN12_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 12. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN13_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 13. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN14_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 14. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_CHAN15_EN : 1;      /*!< 1: Enable the valid data input of I2S RX TDM channel 15. 0:
                                                     Disable, just input 0 in this channel.                                    */
      __IOM uint32_t RX_TDM_TOT_CHAN_NUM : 4;   /*!< The total channel number of I2S TX TDM mode.                              */
            uint32_t            : 12;
    } bit;
  } RX_TDM_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX TDM mode control register                                          */
    
    struct {
      __IOM uint32_t TX_TDM_CHAN0_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 0. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN1_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 1. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN2_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 2. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN3_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 3. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN4_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 4. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN5_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 5. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN6_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 6. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN7_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 7. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN8_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 8. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN9_EN : 1;       /*!< 1: Enable the valid data output of I2S TX TDM channel 9. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN10_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 10. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN11_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 11. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN12_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 12. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN13_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 13. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN14_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 14. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_CHAN15_EN : 1;      /*!< 1: Enable the valid data output of I2S TX TDM channel 15. 0:
                                                     Disable, just output 0 in this channel.                                   */
      __IOM uint32_t TX_TDM_TOT_CHAN_NUM : 4;   /*!< The total channel number of I2S TX TDM mode.                              */
      __IOM uint32_t TX_TDM_SKIP_MSK_EN : 1;    /*!< When DMA TX buffer stores the data of (REG_TX_TDM_TOT_CHAN_NUM
                                                     + 1) channels, and only the data of the enabled channels
                                                     is sent, then this bit should be set. Clear it when all
                                                     the data stored in DMA TX buffer is for enabled channels.                 */
            uint32_t            : 11;
    } bit;
  } TX_TDM_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX timing control register                                            */
    
    struct {
      __IOM uint32_t RX_SD_IN_DM : 2;           /*!< The delay mode of I2S Rx SD input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 14;
      __IOM uint32_t RX_WS_OUT_DM : 2;          /*!< The delay mode of I2S Rx WS output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_BCK_OUT_DM : 2;         /*!< The delay mode of I2S Rx BCK output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_WS_IN_DM : 2;           /*!< The delay mode of I2S Rx WS input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t RX_BCK_IN_DM : 2;          /*!< The delay mode of I2S Rx BCK input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
    } bit;
  } RX_TIMING;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX timing control register                                            */
    
    struct {
      __IOM uint32_t TX_SD_OUT_DM : 2;          /*!< The delay mode of I2S TX SD output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t TX_SD1_OUT_DM : 2;         /*!< The delay mode of I2S TX SD1 output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 10;
      __IOM uint32_t TX_WS_OUT_DM : 2;          /*!< The delay mode of I2S TX WS output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t TX_BCK_OUT_DM : 2;         /*!< The delay mode of I2S TX BCK output signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t TX_WS_IN_DM : 2;           /*!< The delay mode of I2S TX WS input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
      __IOM uint32_t TX_BCK_IN_DM : 2;          /*!< The delay mode of I2S TX BCK input signal. 0: bypass. 1: delay
                                                     by pos edge. 2: delay by neg edge. 3: not used.                           */
            uint32_t            : 2;
    } bit;
  } TX_TIMING;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S HUNG configure register.                                              */
    
    struct {
      __IOM uint32_t LC_FIFO_TIMEOUT : 8;       /*!< the i2s_tx_hung_int interrupt or the i2s_rx_hung_int interrupt
                                                     will be triggered when fifo hung counter is equal to this
                                                     value                                                                     */
      __IOM uint32_t LC_FIFO_TIMEOUT_SHIFT : 3; /*!< The bits are used to scale tick counter threshold. The tick
                                                     counter is reset when counter value >= 88000/2^i2s_lc_fifo_timeout_shift  */
      __IOM uint32_t LC_FIFO_TIMEOUT_ENA : 1;   /*!< The enable bit for FIFO timeout                                           */
            uint32_t            : 20;
    } bit;
  } LC_HUNG_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S RX data number control register.                                      */
    
    struct {
      __IOM uint32_t RX_EOF_NUM : 12;           /*!< The receive data bit length is (I2S_RX_BITS_MOD[4:0] + 1) *
                                                     (REG_RX_EOF_NUM[11:0] + 1) . It will trigger in_suc_eof
                                                     interrupt in the configured DMA RX channel.                               */
            uint32_t            : 20;
    } bit;
  } RXEOF_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S signal data register                                                  */
    
    struct {
      __IOM uint32_t SINGLE_DATA : 32;          /*!< The configured constant channel data to be sent out.                      */
    } bit;
  } CONF_SIGLE_DATA;
  
  union {
    __IOM uint32_t reg;                         /*!< I2S TX status register                                                    */
    
    struct {
      __IM  uint32_t TX_IDLE    : 1;            /*!< 1: i2s_tx is idle state. 0: i2s_tx is working.                            */
            uint32_t            : 31;
    } bit;
  } STATE;
  __IM  uint32_t  RESERVED3[4];
  
  union {
    __IOM uint32_t reg;                         /*!< Version control register                                                  */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< I2S version control register                                              */
            uint32_t            : 4;
    } bit;
  } DATE;
} I2S1_Type;                                    /*!< Size = 132 (0x84)                                                         */



/* =========================================================================================================================== */
/* ================                                      INTERRUPT_CORE0                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief Interrupt Controller (Core 0) (INTERRUPT_CORE0)
  */

typedef struct {                                /*!< INTERRUPT_CORE0 Structure                                                 */
  
  union {
    __IOM uint32_t reg;                         /*!< mac interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t MAC_INTR_MAP : 5;          /*!< this register used to map mac interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PRO_MAC_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< mac_nmi interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t MAC_NMI_MAP : 5;           /*!< this register used to map_nmi interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } MAC_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwr interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t PWR_INTR_MAP : 5;          /*!< this register used to map pwr interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWR_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< bb interrupt configuration register                                       */
    
    struct {
      __IOM uint32_t BB_INT_MAP : 5;            /*!< this register used to map bb interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } BB_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< bb_mac interrupt configuration register                                   */
    
    struct {
      __IOM uint32_t BT_MAC_INT_MAP : 5;        /*!< this register used to map bb_mac interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } BT_MAC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< bt_bb interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t BT_BB_INT_MAP : 5;         /*!< this register used to map bt_bb interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } BT_BB_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< bt_bb_nmi interrupt configuration register                                */
    
    struct {
      __IOM uint32_t BT_BB_NMI_MAP : 5;         /*!< this register used to map bb_bt_nmi interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } BT_BB_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rwbt_irq interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t RWBT_IRQ_MAP : 5;          /*!< this register used to map rwbt_irq interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } RWBT_IRQ_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rwble_irq interrupt configuration register                                */
    
    struct {
      __IOM uint32_t RWBLE_IRQ_MAP : 5;         /*!< this register used to map rwble_irq interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } RWBLE_IRQ_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rwbt_nmi interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t RWBT_NMI_MAP : 5;          /*!< this register used to map mac rwbt_nmi to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } RWBT_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rwble_nmi interrupt configuration register                                */
    
    struct {
      __IOM uint32_t RWBLE_NMI_MAP : 5;         /*!< this register used to map rwble_nmi interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } RWBLE_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c_mst interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t I2C_MST_INT_MAP : 5;       /*!< this register used to map i2c_mst interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } I2C_MST_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< slc0 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t SLC0_INTR_MAP : 5;         /*!< this register used to map slc0 interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } SLC0_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< slc1 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t SLC1_INTR_MAP : 5;         /*!< this register used to map slc1 interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } SLC1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uhci0 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t UHCI0_INTR_MAP : 5;        /*!< this register used to map uhci0 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } UHCI0_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uhci1 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t UHCI1_INTR_MAP : 5;        /*!< this register used to map uhci1 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } UHCI1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< gpio_interrupt_pro interrupt configuration register                       */
    
    struct {
      __IOM uint32_t GPIO_INTERRUPT_PRO_MAP : 5;/*!< this register used to map gpio_interrupt_pro interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } GPIO_INTERRUPT_PRO_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< gpio_interrupt_pro_nmi interrupt configuration register                   */
    
    struct {
      __IOM uint32_t GPIO_INTERRUPT_PRO_NMI_MAP : 5;/*!< this register used to map gpio_interrupt_pro_nmi interrupt to
                                                     one of core0's external interrupt                                         */
            uint32_t            : 27;
    } bit;
  } GPIO_INTERRUPT_PRO_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< gpio_interrupt_app interrupt configuration register                       */
    
    struct {
      __IOM uint32_t GPIO_INTERRUPT_APP_MAP : 5;/*!< this register used to map gpio_interrupt_app interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } GPIO_INTERRUPT_APP_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< gpio_interrupt_app_nmi interrupt configuration register                   */
    
    struct {
      __IOM uint32_t GPIO_INTERRUPT_APP_NMI_MAP : 5;/*!< this register used to map gpio_interrupt_app_nmi interrupt to
                                                     one of core0's external interrupt                                         */
            uint32_t            : 27;
    } bit;
  } GPIO_INTERRUPT_APP_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_intr_1 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t SPI_INTR_1_MAP : 5;        /*!< this register used to map spi_intr_1 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI_INTR_1_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_intr_2 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t SPI_INTR_2_MAP : 5;        /*!< this register used to map spi_intr_2 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI_INTR_2_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_intr_3 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t SPI_INTR_3_MAP : 5;        /*!< this register used to map spi_intr_3 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI_INTR_3_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_intr_4 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t SPI_INTR_4_MAP : 5;        /*!< this register used to map spi_intr_4 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI_INTR_4_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< lcd_cam interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t LCD_CAM_INT_MAP : 5;       /*!< this register used to map lcd_cam interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } LCD_CAM_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2s0 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t I2S0_INT_MAP : 5;          /*!< this register used to map i2s0 interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } I2S0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2s1 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t I2S1_INT_MAP : 5;          /*!< this register used to map i2s1 interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } I2S1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uart interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t UART_INTR_MAP : 5;         /*!< this register used to map uart interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } UART_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uart1 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t UART1_INTR_MAP : 5;        /*!< this register used to map uart1 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } UART1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uart2 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t UART2_INTR_MAP : 5;        /*!< this register used to map uart2 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } UART2_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< sdio_host interrupt configuration register                                */
    
    struct {
      __IOM uint32_t SDIO_HOST_INTERRUPT_MAP : 5;/*!< this register used to map sdio_host interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SDIO_HOST_INTERRUPT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwm0 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PWM0_INTR_MAP : 5;         /*!< this register used to map pwm0 interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWM0_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwm1 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PWM1_INTR_MAP : 5;         /*!< this register used to map pwm1 interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWM1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwm2 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PWM2_INTR_MAP : 5;         /*!< this register used to map pwm2 interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWM2_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwm3 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PWM3_INTR_MAP : 5;         /*!< this register used to map pwm3 interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWM3_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< ledc interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t LEDC_INT_MAP : 5;          /*!< this register used to map ledc interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } LEDC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< efuse interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t EFUSE_INT_MAP : 5;         /*!< this register used to map efuse interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } EFUSE_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< can interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t CAN_INT_MAP : 5;           /*!< this register used to map can interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } CAN_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< usb interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t USB_INTR_MAP : 5;          /*!< this register used to map usb interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } USB_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc_core interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t RTC_CORE_INTR_MAP : 5;     /*!< this register used to map rtc_core interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } RTC_CORE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rmt interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t RMT_INTR_MAP : 5;          /*!< this register used to map rmt interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } RMT_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pcnt interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PCNT_INTR_MAP : 5;         /*!< this register used to map pcnt interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PCNT_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c_ext0 interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t I2C_EXT0_INTR_MAP : 5;     /*!< this register used to map i2c_ext0 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } I2C_EXT0_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c_ext1 interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t I2C_EXT1_INTR_MAP : 5;     /*!< this register used to map i2c_ext1 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } I2C_EXT1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi2_dma interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t SPI2_DMA_INT_MAP : 5;      /*!< this register used to map spi2_dma interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI2_DMA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi3_dma interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t SPI3_DMA_INT_MAP : 5;      /*!< this register used to map spi3_dma interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI3_DMA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi4_dma interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t SPI4_DMA_INT_MAP : 5;      /*!< this register used to map spi4_dma interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI4_DMA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< wdg interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t WDG_INT_MAP : 5;           /*!< this register used to map wdg interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } WDG_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< timer_int1 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t TIMER_INT1_MAP : 5;        /*!< this register used to map timer_int1 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TIMER_INT1_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< timer_int2 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t TIMER_INT2_MAP : 5;        /*!< this register used to map timer_int2 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TIMER_INT2_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg_t0 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t TG_T0_INT_MAP : 5;         /*!< this register used to map tg_t0 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG_T0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg_t1 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t TG_T1_INT_MAP : 5;         /*!< this register used to map tg_t1 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG_T1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg_wdt interrupt configuration register                                   */
    
    struct {
      __IOM uint32_t TG_WDT_INT_MAP : 5;        /*!< this register used to map rg_wdt interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG_WDT_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg1_t0 interrupt configuration register                                   */
    
    struct {
      __IOM uint32_t TG1_T0_INT_MAP : 5;        /*!< this register used to map tg1_t0 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG1_T0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg1_t1 interrupt configuration register                                   */
    
    struct {
      __IOM uint32_t TG1_T1_INT_MAP : 5;        /*!< this register used to map tg1_t1 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG1_T1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg1_wdt interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t TG1_WDT_INT_MAP : 5;       /*!< this register used to map tg1_wdt interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG1_WDT_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cache_ia interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t CACHE_IA_INT_MAP : 5;      /*!< this register used to map cache_ia interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } CACHE_IA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer_target0 interrupt configuration register                         */
    
    struct {
      __IOM uint32_t SYSTIMER_TARGET0_INT_MAP : 5;/*!< this register used to map systimer_target0 interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } SYSTIMER_TARGET0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer_target1 interrupt configuration register                         */
    
    struct {
      __IOM uint32_t SYSTIMER_TARGET1_INT_MAP : 5;/*!< this register used to map systimer_target1 interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } SYSTIMER_TARGET1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer_target2 interrupt configuration register                         */
    
    struct {
      __IOM uint32_t SYSTIMER_TARGET2_INT_MAP : 5;/*!< this register used to map systimer_target2 interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } SYSTIMER_TARGET2_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_mem_reject interrupt configuration register                           */
    
    struct {
      __IOM uint32_t SPI_MEM_REJECT_INTR_MAP : 5;/*!< this register used to map spi_mem_reject interrupt to one of
                                                     core0's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } SPI_MEM_REJECT_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dcache_prelaod interrupt configuration register                           */
    
    struct {
      __IOM uint32_t DCACHE_PRELOAD_INT_MAP : 5;/*!< this register used to map dcache_prelaod interrupt to one of
                                                     core0's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } DCACHE_PRELOAD_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< icache_preload interrupt configuration register                           */
    
    struct {
      __IOM uint32_t ICACHE_PRELOAD_INT_MAP : 5;/*!< this register used to map icache_preload interrupt to one of
                                                     core0's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } ICACHE_PRELOAD_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dcache_sync interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DCACHE_SYNC_INT_MAP : 5;   /*!< this register used to map dcache_sync interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DCACHE_SYNC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< icache_sync interrupt configuration register                              */
    
    struct {
      __IOM uint32_t ICACHE_SYNC_INT_MAP : 5;   /*!< this register used to map icache_sync interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } ICACHE_SYNC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< apb_adc interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t APB_ADC_INT_MAP : 5;       /*!< this register used to map apb_adc interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } APB_ADC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch0 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH0_INT_MAP : 5;    /*!< this register used to map dma_in_ch0 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch1 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH1_INT_MAP : 5;    /*!< this register used to map dma_in_ch1 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch2 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH2_INT_MAP : 5;    /*!< this register used to map dma_in_ch2 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH2_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch3 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH3_INT_MAP : 5;    /*!< this register used to map dma_in_ch3 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH3_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch4 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH4_INT_MAP : 5;    /*!< this register used to map dma_in_ch4 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH4_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch0 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH0_INT_MAP : 5;   /*!< this register used to map dma_out_ch0 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch1 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH1_INT_MAP : 5;   /*!< this register used to map dma_out_ch1 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch2 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH2_INT_MAP : 5;   /*!< this register used to map dma_out_ch2 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH2_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch3 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH3_INT_MAP : 5;   /*!< this register used to map dma_out_ch3 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH3_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch4 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH4_INT_MAP : 5;   /*!< this register used to map dma_out_ch4 interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH4_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rsa interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t RSA_INT_MAP : 5;           /*!< this register used to map rsa interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } RSA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< aes interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t AES_INT_MAP : 5;           /*!< this register used to map aes interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } AES_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< sha interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t SHA_INT_MAP : 5;           /*!< this register used to map sha interrupt to one of core0's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } SHA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_intr_from_cpu_0 interrupt configuration register                      */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_0_MAP : 5;/*!< this register used to map cpu_intr_from_cpu_0 interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } CPU_INTR_FROM_CPU_0_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_intr_from_cpu_1 interrupt configuration register                      */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_1_MAP : 5;/*!< this register used to map cpu_intr_from_cpu_1 interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } CPU_INTR_FROM_CPU_1_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_intr_from_cpu_2 interrupt configuration register                      */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_2_MAP : 5;/*!< this register used to map cpu_intr_from_cpu_2 interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } CPU_INTR_FROM_CPU_2_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_intr_from_cpu_3 interrupt configuration register                      */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_3_MAP : 5;/*!< this register used to map cpu_intr_from_cpu_3 interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } CPU_INTR_FROM_CPU_3_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< assist_debug interrupt configuration register                             */
    
    struct {
      __IOM uint32_t ASSIST_DEBUG_INTR_MAP : 5; /*!< this register used to map assist_debug interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } ASSIST_DEBUG_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_pms_monitor_violatile interrupt configuration register                */
    
    struct {
      __IOM uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map dma_pms_monitor_violatile interrupt
                                                     to one of core0's external interrupt                                      */
            uint32_t            : 27;
    } bit;
  } DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0_IRam0_pms_monitor_violatile interrupt configuration register        */
    
    struct {
      __IOM uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core0_IRam0_pms_monitor_violatile
                                                     interrupt to one of core0's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0_DRam0_pms_monitor_violatile interrupt configuration register        */
    
    struct {
      __IOM uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core0_DRam0_pms_monitor_violatile
                                                     interrupt to one of core0's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0_PIF_pms_monitor_violatile interrupt configuration register          */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core0_PIF_pms_monitor_violatile interrupt
                                                     to one of core0's external interrupt                                      */
            uint32_t            : 27;
    } bit;
  } CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0_PIF_pms_monitor_violatile_size interrupt configuration
                                                     register                                                                  */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP : 5;/*!< this register used to map core0_PIF_pms_monitor_violatile_size
                                                     interrupt to one of core0's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core1_IRam0_pms_monitor_violatile interrupt configuration register        */
    
    struct {
      __IOM uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core1_IRam0_pms_monitor_violatile
                                                     interrupt to one of core0's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_1_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core1_DRam0_pms_monitor_violatile interrupt configuration register        */
    
    struct {
      __IOM uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core1_DRam0_pms_monitor_violatile
                                                     interrupt to one of core0's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_1_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core1_PIF_pms_monitor_violatile interrupt configuration register          */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core1_PIF_pms_monitor_violatile interrupt
                                                     to one of core0's external interrupt                                      */
            uint32_t            : 27;
    } bit;
  } CORE_1_PIF_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core1_PIF_pms_monitor_violatile_size interrupt configuration
                                                     register                                                                  */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP : 5;/*!< this register used to map core1_PIF_pms_monitor_violatile_size
                                                     interrupt to one of core0's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_1_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< backup_pms_monitor_violatile interrupt configuration register             */
    
    struct {
      __IOM uint32_t BACKUP_PMS_VIOLATE_INTR_MAP : 5;/*!< this register used to map backup_pms_monitor_violatile interrupt
                                                     to one of core0's external interrupt                                      */
            uint32_t            : 27;
    } bit;
  } BACKUP_PMS_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cache_core0_acs interrupt configuration register                          */
    
    struct {
      __IOM uint32_t CACHE_CORE0_ACS_INT_MAP : 5;/*!< this register used to map cache_core0_acs interrupt to one of
                                                     core0's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } CACHE_CORE0_ACS_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cache_core1_acs interrupt configuration register                          */
    
    struct {
      __IOM uint32_t CACHE_CORE1_ACS_INT_MAP : 5;/*!< this register used to map cache_core1_acs interrupt to one of
                                                     core0's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } CACHE_CORE1_ACS_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< usb_device interrupt configuration register                               */
    
    struct {
      __IOM uint32_t USB_DEVICE_INT_MAP : 5;    /*!< this register used to map usb_device interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } USB_DEVICE_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< peri_backup interrupt configuration register                              */
    
    struct {
      __IOM uint32_t PERI_BACKUP_INT_MAP : 5;   /*!< this register used to map peri_backup interrupt to one of core0's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } PERI_BACKUP_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_extmem_reject interrupt configuration register                        */
    
    struct {
      __IOM uint32_t DMA_EXTMEM_REJECT_INT_MAP : 5;/*!< this register used to map dma_extmem_reject interrupt to one
                                                     of core0's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } DMA_EXTMEM_REJECT_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt status register                                                 */
    
    struct {
      __IM  uint32_t INTR_STATUS_0 : 32;        /*!< this register store the status of the first 32 interrupt source           */
    } bit;
  } PRO_INTR_STATUS_0;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt status register                                                 */
    
    struct {
      __IM  uint32_t INTR_STATUS_1 : 32;        /*!< this register store the status of the first 32 interrupt source           */
    } bit;
  } PRO_INTR_STATUS_1;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt status register                                                 */
    
    struct {
      __IM  uint32_t INTR_STATUS_2 : 32;        /*!< this register store the status of the first 32 interrupt source           */
    } bit;
  } PRO_INTR_STATUS_2;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt status register                                                 */
    
    struct {
      __IM  uint32_t INTR_STATUS_3 : 32;        /*!< this register store the status of the first 32 interrupt source           */
    } bit;
  } PRO_INTR_STATUS_3;
  
  union {
    __IOM uint32_t reg;                         /*!< clock gate register                                                       */
    
    struct {
      __IOM uint32_t REG_CLK_EN : 1;            /*!< this register uesd to control clock-gating interupt martrix               */
            uint32_t            : 31;
    } bit;
  } CLOCK_GATE;
  __IM  uint32_t  RESERVED[407];
  
  union {
    __IOM uint32_t reg;                         /*!< version register                                                          */
    
    struct {
      __IOM uint32_t INTERRUPT_REG_DATE : 28;   /*!< version register                                                          */
            uint32_t            : 4;
    } bit;
  } DATE;
} INTERRUPT_CORE0_Type;                         /*!< Size = 2048 (0x800)                                                       */



/* =========================================================================================================================== */
/* ================                                      INTERRUPT_CORE1                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief Interrupt Controller (Core 1) (INTERRUPT_CORE1)
  */

typedef struct {                                /*!< INTERRUPT_CORE1 Structure                                                 */
  __IM  uint32_t  RESERVED[512];
  
  union {
    __IOM uint32_t reg;                         /*!< mac interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t MAC_INTR_MAP : 5;          /*!< this register used to map mac interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } APP_MAC_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< mac_nmi interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t MAC_NMI_MAP : 5;           /*!< this register used to map_nmi interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } MAC_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwr interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t PWR_INTR_MAP : 5;          /*!< this register used to map pwr interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWR_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< bb interrupt configuration register                                       */
    
    struct {
      __IOM uint32_t BB_INT_MAP : 5;            /*!< this register used to map bb interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } BB_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< bb_mac interrupt configuration register                                   */
    
    struct {
      __IOM uint32_t BT_MAC_INT_MAP : 5;        /*!< this register used to map bb_mac interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } BT_MAC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< bt_bb interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t BT_BB_INT_MAP : 5;         /*!< this register used to map bt_bb interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } BT_BB_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< bt_bb_nmi interrupt configuration register                                */
    
    struct {
      __IOM uint32_t BT_BB_NMI_MAP : 5;         /*!< this register used to map bb_bt_nmi interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } BT_BB_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rwbt_irq interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t RWBT_IRQ_MAP : 5;          /*!< this register used to map rwbt_irq interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } RWBT_IRQ_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rwble_irq interrupt configuration register                                */
    
    struct {
      __IOM uint32_t RWBLE_IRQ_MAP : 5;         /*!< this register used to map rwble_irq interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } RWBLE_IRQ_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rwbt_nmi interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t RWBT_NMI_MAP : 5;          /*!< this register used to map rwbt_nmi interupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } RWBT_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rwble_nmi interrupt configuration register                                */
    
    struct {
      __IOM uint32_t RWBLE_NMI_MAP : 5;         /*!< this register used to map rwble_nmi interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } RWBLE_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c_mst interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t I2C_MST_INT_MAP : 5;       /*!< this register used to map i2c_mst interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } I2C_MST_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< slc0 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t SLC0_INTR_MAP : 5;         /*!< this register used to map slc0 interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } SLC0_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< slc1 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t SLC1_INTR_MAP : 5;         /*!< this register used to map slc1 interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } SLC1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uhci0 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t UHCI0_INTR_MAP : 5;        /*!< this register used to map uhci0 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } UHCI0_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uhci1 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t UHCI1_INTR_MAP : 5;        /*!< this register used to map uhci1 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } UHCI1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< gpio_interrupt_pro interrupt configuration register                       */
    
    struct {
      __IOM uint32_t GPIO_INTERRUPT_PRO_MAP : 5;/*!< this register used to map gpio_interrupt_pro interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } GPIO_INTERRUPT_PRO_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< gpio_interrupt_pro_nmi interrupt configuration register                   */
    
    struct {
      __IOM uint32_t GPIO_INTERRUPT_PRO_NMI_MAP : 5;/*!< this register used to map gpio_interrupt_pro_nmi interrupt to
                                                     one of core1's external interrupt                                         */
            uint32_t            : 27;
    } bit;
  } GPIO_INTERRUPT_PRO_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< gpio_interrupt_app interrupt configuration register                       */
    
    struct {
      __IOM uint32_t GPIO_INTERRUPT_APP_MAP : 5;/*!< this register used to map gpio_interrupt_app interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } GPIO_INTERRUPT_APP_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< gpio_interrupt_app_nmi interrupt configuration register                   */
    
    struct {
      __IOM uint32_t GPIO_INTERRUPT_APP_NMI_MAP : 5;/*!< this register used to map gpio_interrupt_app_nmi interrupt to
                                                     one of core1's external interrupt                                         */
            uint32_t            : 27;
    } bit;
  } GPIO_INTERRUPT_APP_NMI_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_intr_1 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t SPI_INTR_1_MAP : 5;        /*!< this register used to map spi_intr_1 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI_INTR_1_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_intr_2 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t SPI_INTR_2_MAP : 5;        /*!< this register used to map spi_intr_2 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI_INTR_2_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_intr_3 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t SPI_INTR_3_MAP : 5;        /*!< this register used to map spi_intr_3 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI_INTR_3_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_intr_4 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t SPI_INTR_4_MAP : 5;        /*!< this register used to map spi_intr_4 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI_INTR_4_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< lcd_cam interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t LCD_CAM_INT_MAP : 5;       /*!< this register used to map lcd_cam interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } LCD_CAM_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2s0 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t I2S0_INT_MAP : 5;          /*!< this register used to map i2s0 interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } I2S0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2s1 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t I2S1_INT_MAP : 5;          /*!< this register used to map i2s1 interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } I2S1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uart interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t UART_INTR_MAP : 5;         /*!< this register used to map uart interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } UART_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uart1 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t UART1_INTR_MAP : 5;        /*!< this register used to map uart1 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } UART1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< uart2 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t UART2_INTR_MAP : 5;        /*!< this register used to map uart2 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } UART2_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< sdio_host interrupt configuration register                                */
    
    struct {
      __IOM uint32_t SDIO_HOST_INTERRUPT_MAP : 5;/*!< this register used to map sdio_host interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SDIO_HOST_INTERRUPT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwm0 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PWM0_INTR_MAP : 5;         /*!< this register used to map pwm0 interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWM0_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwm1 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PWM1_INTR_MAP : 5;         /*!< this register used to map pwm1 interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWM1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwm2 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PWM2_INTR_MAP : 5;         /*!< this register used to map pwm2 interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWM2_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pwm3 interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PWM3_INTR_MAP : 5;         /*!< this register used to map pwm3 interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PWM3_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< ledc interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t LEDC_INT_MAP : 5;          /*!< this register used to map ledc interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } LEDC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< efuse interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t EFUSE_INT_MAP : 5;         /*!< this register used to map efuse interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } EFUSE_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< can interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t CAN_INT_MAP : 5;           /*!< this register used to map can interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } CAN_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< usb interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t USB_INTR_MAP : 5;          /*!< this register used to map usb interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } USB_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc_core interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t RTC_CORE_INTR_MAP : 5;     /*!< this register used to map rtc_core interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } RTC_CORE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rmt interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t RMT_INTR_MAP : 5;          /*!< this register used to map rmt interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } RMT_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< pcnt interrupt configuration register                                     */
    
    struct {
      __IOM uint32_t PCNT_INTR_MAP : 5;         /*!< this register used to map pcnt interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } PCNT_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c_ext0 interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t I2C_EXT0_INTR_MAP : 5;     /*!< this register used to map i2c_ext0 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } I2C_EXT0_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c_ext1 interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t I2C_EXT1_INTR_MAP : 5;     /*!< this register used to map i2c_ext1 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } I2C_EXT1_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi2_dma interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t SPI2_DMA_INT_MAP : 5;      /*!< this register used to map spi2_dma interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI2_DMA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi3_dma interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t SPI3_DMA_INT_MAP : 5;      /*!< this register used to map spi3_dma interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI3_DMA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi4_dma interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t SPI4_DMA_INT_MAP : 5;      /*!< this register used to map spi4_dma interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } SPI4_DMA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< wdg interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t WDG_INT_MAP : 5;           /*!< this register used to map wdg interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } WDG_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< timer_int1 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t TIMER_INT1_MAP : 5;        /*!< this register used to map timer_int1 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TIMER_INT1_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< timer_int2 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t TIMER_INT2_MAP : 5;        /*!< this register used to map timer_int2 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TIMER_INT2_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg_t0 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t TG_T0_INT_MAP : 5;         /*!< this register used to map tg_t0 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG_T0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg_t1 interrupt configuration register                                    */
    
    struct {
      __IOM uint32_t TG_T1_INT_MAP : 5;         /*!< this register used to map tg_t1 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG_T1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg_wdt interrupt configuration register                                   */
    
    struct {
      __IOM uint32_t TG_WDT_INT_MAP : 5;        /*!< this register used to map rg_wdt interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG_WDT_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg1_t0 interrupt configuration register                                   */
    
    struct {
      __IOM uint32_t TG1_T0_INT_MAP : 5;        /*!< this register used to map tg1_t0 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG1_T0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg1_t1 interrupt configuration register                                   */
    
    struct {
      __IOM uint32_t TG1_T1_INT_MAP : 5;        /*!< this register used to map tg1_t1 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG1_T1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< tg1_wdt interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t TG1_WDT_INT_MAP : 5;       /*!< this register used to map tg1_wdt interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } TG1_WDT_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cache_ia interrupt configuration register                                 */
    
    struct {
      __IOM uint32_t CACHE_IA_INT_MAP : 5;      /*!< this register used to map cache_ia interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } CACHE_IA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer_target0 interrupt configuration register                         */
    
    struct {
      __IOM uint32_t SYSTIMER_TARGET0_INT_MAP : 5;/*!< this register used to map systimer_target0 interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } SYSTIMER_TARGET0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer_target1 interrupt configuration register                         */
    
    struct {
      __IOM uint32_t SYSTIMER_TARGET1_INT_MAP : 5;/*!< this register used to map systimer_target1 interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } SYSTIMER_TARGET1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer_target2 interrupt configuration register                         */
    
    struct {
      __IOM uint32_t SYSTIMER_TARGET2_INT_MAP : 5;/*!< this register used to map systimer_target2 interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } SYSTIMER_TARGET2_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< spi_mem_reject interrupt configuration register                           */
    
    struct {
      __IOM uint32_t SPI_MEM_REJECT_INTR_MAP : 5;/*!< this register used to map spi_mem_reject interrupt to one of
                                                     core1's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } SPI_MEM_REJECT_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dcache_prelaod interrupt configuration register                           */
    
    struct {
      __IOM uint32_t DCACHE_PRELOAD_INT_MAP : 5;/*!< this register used to map dcache_prelaod interrupt to one of
                                                     core1's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } DCACHE_PRELOAD_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< icache_preload interrupt configuration register                           */
    
    struct {
      __IOM uint32_t ICACHE_PRELOAD_INT_MAP : 5;/*!< this register used to map icache_preload interrupt to one of
                                                     core1's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } ICACHE_PRELOAD_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dcache_sync interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DCACHE_SYNC_INT_MAP : 5;   /*!< this register used to map dcache_sync interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DCACHE_SYNC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< icache_sync interrupt configuration register                              */
    
    struct {
      __IOM uint32_t ICACHE_SYNC_INT_MAP : 5;   /*!< this register used to map icache_sync interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } ICACHE_SYNC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< apb_adc interrupt configuration register                                  */
    
    struct {
      __IOM uint32_t APB_ADC_INT_MAP : 5;       /*!< this register used to map apb_adc interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } APB_ADC_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch0 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH0_INT_MAP : 5;    /*!< this register used to map dma_in_ch0 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch1 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH1_INT_MAP : 5;    /*!< this register used to map dma_in_ch1 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch2 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH2_INT_MAP : 5;    /*!< this register used to map dma_in_ch2 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH2_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch3 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH3_INT_MAP : 5;    /*!< this register used to map dma_in_ch3 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH3_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_in_ch4 interrupt configuration register                               */
    
    struct {
      __IOM uint32_t DMA_IN_CH4_INT_MAP : 5;    /*!< this register used to map dma_in_ch4 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_IN_CH4_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch0 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH0_INT_MAP : 5;   /*!< this register used to map dma_out_ch0 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH0_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch1 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH1_INT_MAP : 5;   /*!< this register used to map dma_out_ch1 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH1_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch2 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH2_INT_MAP : 5;   /*!< this register used to map dma_out_ch2 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH2_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch3 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH3_INT_MAP : 5;   /*!< this register used to map dma_out_ch3 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH3_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_out_ch4 interrupt configuration register                              */
    
    struct {
      __IOM uint32_t DMA_OUT_CH4_INT_MAP : 5;   /*!< this register used to map dma_out_ch4 interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } DMA_OUT_CH4_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< rsa interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t RSA_INT_MAP : 5;           /*!< this register used to map rsa interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } RSA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< aes interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t AES_INT_MAP : 5;           /*!< this register used to map aes interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } AES_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< sha interrupt configuration register                                      */
    
    struct {
      __IOM uint32_t SHA_INT_MAP : 5;           /*!< this register used to map sha interrupt to one of core1's external
                                                     interrupt                                                                 */
            uint32_t            : 27;
    } bit;
  } SHA_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_intr_from_cpu_0 interrupt configuration register                      */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_0_MAP : 5;/*!< this register used to map cpu_intr_from_cpu_0 interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } CPU_INTR_FROM_CPU_0_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_intr_from_cpu_1 interrupt configuration register                      */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_1_MAP : 5;/*!< this register used to map cpu_intr_from_cpu_1 interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } CPU_INTR_FROM_CPU_1_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_intr_from_cpu_2 interrupt configuration register                      */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_2_MAP : 5;/*!< this register used to map cpu_intr_from_cpu_2 interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } CPU_INTR_FROM_CPU_2_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_intr_from_cpu_3 interrupt configuration register                      */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_3_MAP : 5;/*!< this register used to map cpu_intr_from_cpu_3 interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } CPU_INTR_FROM_CPU_3_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< assist_debug interrupt configuration register                             */
    
    struct {
      __IOM uint32_t ASSIST_DEBUG_INTR_MAP : 5; /*!< this register used to map assist_debug interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } ASSIST_DEBUG_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_pms_monitor_violatile interrupt configuration register                */
    
    struct {
      __IOM uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map dma_pms_monitor_violatile interrupt
                                                     to one of core1's external interrupt                                      */
            uint32_t            : 27;
    } bit;
  } DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0_IRam0_pms_monitor_violatile interrupt configuration register        */
    
    struct {
      __IOM uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core0_IRam0_pms_monitor_violatile
                                                     interrupt to one of core1's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0_DRam0_pms_monitor_violatile interrupt configuration register        */
    
    struct {
      __IOM uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core0_DRam0_pms_monitor_violatile
                                                     interrupt to one of core1's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0_PIF_pms_monitor_violatile interrupt configuration register          */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core0_PIF_pms_monitor_violatile interrupt
                                                     to one of core1's external interrupt                                      */
            uint32_t            : 27;
    } bit;
  } CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core0_PIF_pms_monitor_violatile_size interrupt configuration
                                                     register                                                                  */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP : 5;/*!< this register used to map core0_PIF_pms_monitor_violatile_size
                                                     interrupt to one of core1's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_0_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core1_IRam0_pms_monitor_violatile interrupt configuration register        */
    
    struct {
      __IOM uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core1_IRam0_pms_monitor_violatile
                                                     interrupt to one of core1's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_1_IRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core1_DRam0_pms_monitor_violatile interrupt configuration register        */
    
    struct {
      __IOM uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core1_DRam0_pms_monitor_violatile
                                                     interrupt to one of core1's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_1_DRAM0_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core1_PIF_pms_monitor_violatile interrupt configuration register          */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_INTR_MAP : 5;/*!< this register used to map core1_PIF_pms_monitor_violatile interrupt
                                                     to one of core1's external interrupt                                      */
            uint32_t            : 27;
    } bit;
  } CORE_1_PIF_PMS_MONITOR_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< core1_PIF_pms_monitor_violatile_size interrupt configuration
                                                     register                                                                  */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP : 5;/*!< this register used to map core1_PIF_pms_monitor_violatile_size
                                                     interrupt to one of core1's external interrupt                            */
            uint32_t            : 27;
    } bit;
  } CORE_1_PIF_PMS_MONITOR_VIOLATE_SIZE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< backup_pms_monitor_violatile interrupt configuration register             */
    
    struct {
      __IOM uint32_t BACKUP_PMS_VIOLATE_INTR_MAP : 5;/*!< this register used to map backup_pms_monitor_violatile interrupt
                                                     to one of core1's external interrupt                                      */
            uint32_t            : 27;
    } bit;
  } BACKUP_PMS_VIOLATE_INTR_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cache_core0_acs interrupt configuration register                          */
    
    struct {
      __IOM uint32_t CACHE_CORE0_ACS_INT_MAP : 5;/*!< this register used to map cache_core0_acs interrupt to one of
                                                     core1's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } CACHE_CORE0_ACS_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< cache_core1_acs interrupt configuration register                          */
    
    struct {
      __IOM uint32_t CACHE_CORE1_ACS_INT_MAP : 5;/*!< this register used to map cache_core1_acs interrupt to one of
                                                     core1's external interrupt                                                */
            uint32_t            : 27;
    } bit;
  } CACHE_CORE1_ACS_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< usb_device interrupt configuration register                               */
    
    struct {
      __IOM uint32_t USB_DEVICE_INT_MAP : 5;    /*!< this register used to map usb_device interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } USB_DEVICE_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< peri_backup interrupt configuration register                              */
    
    struct {
      __IOM uint32_t PERI_BACKUP_INT_MAP : 5;   /*!< this register used to map peri_backup interrupt to one of core1's
                                                     external interrupt                                                        */
            uint32_t            : 27;
    } bit;
  } PERI_BACKUP_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< dma_extmem_reject interrupt configuration register                        */
    
    struct {
      __IOM uint32_t DMA_EXTMEM_REJECT_INT_MAP : 5;/*!< this register used to map dma_extmem_reject interrupt to one
                                                     of core1's external interrupt                                             */
            uint32_t            : 27;
    } bit;
  } DMA_EXTMEM_REJECT_INT_MAP;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt status register                                                 */
    
    struct {
      __IM  uint32_t INTR_STATUS_0 : 32;        /*!< this register store the status of the first 32 interrupt source           */
    } bit;
  } APP_INTR_STATUS_0;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt status register                                                 */
    
    struct {
      __IM  uint32_t INTR_STATUS_1 : 32;        /*!< this register store the status of the first 32 interrupt source           */
    } bit;
  } APP_INTR_STATUS_1;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt status register                                                 */
    
    struct {
      __IM  uint32_t INTR_STATUS_2 : 32;        /*!< this register store the status of the first 32 interrupt source           */
    } bit;
  } APP_INTR_STATUS_2;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt status register                                                 */
    
    struct {
      __IM  uint32_t INTR_STATUS_3 : 32;        /*!< this register store the status of the first 32 interrupt source           */
    } bit;
  } APP_INTR_STATUS_3;
  
  union {
    __IOM uint32_t reg;                         /*!< clock gate register                                                       */
    
    struct {
      __IOM uint32_t REG_CLK_EN : 1;            /*!< this register uesd to control clock-gating interupt martrix               */
            uint32_t            : 31;
    } bit;
  } CLOCK_GATE;
  __IM  uint32_t  RESERVED1[407];
  
  union {
    __IOM uint32_t reg;                         /*!< version register                                                          */
    
    struct {
      __IOM uint32_t INTERRUPT_DATE : 28;       /*!< version register                                                          */
            uint32_t            : 4;
    } bit;
  } DATE;
} INTERRUPT_CORE1_Type;                         /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                          IO_MUX                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Input/Output Multiplexer (IO_MUX)
  */

typedef struct {                                /*!< IO_MUX Structure                                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< Clock Output Configuration Register                                       */
    
    struct {
      __IOM uint32_t CLK_OUT1   : 4;            /*!< If you want to output clock for I2S to CLK_OUT_out1, set this
                                                     register to 0x0. CLK_OUT_out1 can be found in peripheral
                                                     output signals.                                                           */
      __IOM uint32_t CLK_OUT2   : 4;            /*!< If you want to output clock for I2S to CLK_OUT_out2, set this
                                                     register to 0x0. CLK_OUT_out2 can be found in peripheral
                                                     output signals.                                                           */
      __IOM uint32_t CLK_OUT3   : 4;            /*!< If you want to output clock for I2S to CLK_OUT_out3, set this
                                                     register to 0x0. CLK_OUT_out3 can be found in peripheral
                                                     output signals.                                                           */
            uint32_t            : 20;
    } bit;
  } PIN_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO0;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO1;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO2;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO3;
  __IM  uint32_t  RESERVED3[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO4;
  __IM  uint32_t  RESERVED4[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO5;
  __IM  uint32_t  RESERVED5[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO6;
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO7;
  __IM  uint32_t  RESERVED7[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO8;
  __IM  uint32_t  RESERVED8[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO9;
  __IM  uint32_t  RESERVED9[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO10;
  __IM  uint32_t  RESERVED10[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO11;
  __IM  uint32_t  RESERVED11[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO12;
  __IM  uint32_t  RESERVED12[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO13;
  __IM  uint32_t  RESERVED13[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO14;
  __IM  uint32_t  RESERVED14[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO15;
  __IM  uint32_t  RESERVED15;
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Version Control Register                                           */
    
    struct {
      __IOM uint32_t REG_DATE   : 28;           /*!< Version control register                                                  */
            uint32_t            : 4;
    } bit;
  } DATE;
  __IM  uint32_t  RESERVED16;
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO16;
  __IM  uint32_t  RESERVED17[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO17;
  __IM  uint32_t  RESERVED18[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO18;
  __IM  uint32_t  RESERVED19[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO19;
  __IM  uint32_t  RESERVED20[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO20;
  __IM  uint32_t  RESERVED21[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO21;
  __IM  uint32_t  RESERVED22[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO22;
  __IM  uint32_t  RESERVED23[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO23;
  __IM  uint32_t  RESERVED24[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO24;
  __IM  uint32_t  RESERVED25[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO25;
  __IM  uint32_t  RESERVED26[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO26;
  __IM  uint32_t  RESERVED27[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO27;
  __IM  uint32_t  RESERVED28[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO28;
  __IM  uint32_t  RESERVED29[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO29;
  __IM  uint32_t  RESERVED30[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO30;
  __IM  uint32_t  RESERVED31[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO31;
  __IM  uint32_t  RESERVED32[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO32;
  __IM  uint32_t  RESERVED33[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO33;
  __IM  uint32_t  RESERVED34[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO34;
  __IM  uint32_t  RESERVED35[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO35;
  __IM  uint32_t  RESERVED36[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO36;
  __IM  uint32_t  RESERVED37[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO37;
  __IM  uint32_t  RESERVED38[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO38;
  __IM  uint32_t  RESERVED39[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO39;
  __IM  uint32_t  RESERVED40[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO40;
  __IM  uint32_t  RESERVED41[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO41;
  __IM  uint32_t  RESERVED42[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO42;
  __IM  uint32_t  RESERVED43[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO43;
  __IM  uint32_t  RESERVED44[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO44;
  __IM  uint32_t  RESERVED45[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO45;
  __IM  uint32_t  RESERVED46[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO46;
  __IM  uint32_t  RESERVED47[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO47;
  __IM  uint32_t  RESERVED48[3];
  
  union {
    __IOM uint32_t reg;                         /*!< IO MUX Configure Register for pad GPIO0                                   */
    
    struct {
      __IOM uint32_t MCU_OE     : 1;            /*!< Output enable of the pad in sleep mode. 1: output enabled; 0:
                                                     output disabled.                                                          */
      __IOM uint32_t SLP_SEL    : 1;            /*!< Sleep mode selection of this pad. Set to 1 to put the pad in
                                                     pad mode.                                                                 */
      __IOM uint32_t MCU_WPD    : 1;            /*!< Pull-down enable of the pad in sleep mode. 1: internal pull-down
                                                     enabled; 0: internal pull-down disabled.                                  */
      __IOM uint32_t MCU_WPU    : 1;            /*!< Pull-up enable of the pad during sleep mode. 1: internal pull-up
                                                     enabled; 0: internal pull-up disabled.                                    */
      __IOM uint32_t MCU_IE     : 1;            /*!< Input enable of the pad during sleep mode. 1: input enabled;
                                                     0: input disabled.                                                        */
            uint32_t            : 2;
      __IOM uint32_t FUN_WPD    : 1;            /*!< Pull-down enable of the pad. 1: internal pull-down enabled;
                                                     0: internal pull-down disabled.                                           */
      __IOM uint32_t FUN_WPU    : 1;            /*!< Pull-up enable of the pad. 1: internal pull-up enabled; 0: internal
                                                     pull-up disabled.                                                         */
      __IOM uint32_t FUN_IE     : 1;            /*!< Input enable of the pad. 1: input enabled; 0: input disabled.             */
      __IOM uint32_t FUN_DRV    : 2;            /*!< Select the drive strength of the pad. 0: ~5 mA; 1: ~10mA; 2:
                                                     ~20mA; 3: ~40mA.                                                          */
      __IOM uint32_t MCU_SEL    : 3;            /*!< Select IO MUX function for this signal. 0: Select Function 1;
                                                     1: Select Function 2; etc.                                                */
      __IOM uint32_t FILTER_EN  : 1;            /*!< Enable filter for pin input signals. 1: Filter enabled; 2: Filter
                                                     disabled.                                                                 */
            uint32_t            : 16;
    } bit;
  } GPIO48;
} IO_MUX_Type;                                  /*!< Size = 776 (0x308)                                                        */



/* =========================================================================================================================== */
/* ================                                          LCD_CAM                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Camera/LCD Controller (LCD_CAM)
  */

typedef struct {                                /*!< LCD_CAM Structure                                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< LCD clock configuration register                                          */
    
    struct {
      __IOM uint32_t LCD_CLKCNT_N : 6;          /*!< f<SUB>LCD_PCLK</SUB> = f<SUB>LCD_CLK</SUB>/(LCD_CAM_LCD_CLKCNT_N
                                                     + 1) when LCD_CAM_LCD_CLK_EQU_SYSCLK is 0. Note: this field
                                                     must not be configured to 0.                                              */
      __IOM uint32_t LCD_CLK_EQU_SYSCLK : 1;    /*!< 1: f<SUB>LCD_PCLK</SUB>= f<SUB>LCD_CLK</SUB>. 0: f<SUB>LCD_PCLK</SUB>
                                                     = f<SUB>LCD_CLK</SUB>/(LCD_CAM_LCD_CLKCNT_N + 1).                         */
      __IOM uint32_t LCD_CK_IDLE_EDGE : 1;      /*!< 1: LCD_PCLK line is high in idle. 0: LCD_PCLK line is low in
                                                     idle.                                                                     */
      __IOM uint32_t LCD_CK_OUT_EDGE : 1;       /*!< 1: LCD_PCLK is high in the first half clock cycle. 0: LCD_PCLK
                                                     is low in the first half clock cycle.                                     */
      __IOM uint32_t LCD_CLKM_DIV_NUM : 8;      /*!< Integral LCD clock divider value.                                         */
      __IOM uint32_t LCD_CLKM_DIV_B : 6;        /*!< Fractional clock divider numerator value.                                 */
      __IOM uint32_t LCD_CLKM_DIV_A : 6;        /*!< Fractional clock divider denominator value.                               */
      __IOM uint32_t LCD_CLK_SEL : 2;           /*!< Select LCD module source clock. 0: clock source is disabled.
                                                     1: XTAL_CLK. 2: PLL_D2_CLK. 3: PLL_F160M_CLK.                             */
      __IOM uint32_t CLK_EN     : 1;            /*!< Set this bit to force enable the clock for all configuration
                                                     registers. Clock gate is not used.                                        */
    } bit;
  } LCD_CLOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< Camera clock configuration register                                       */
    
    struct {
      __IOM uint32_t CAM_STOP_EN : 1;           /*!< Camera stop enable signal, 1: camera stops when GDMA Rx FIFO
                                                     is full. 0: Do not stop.                                                  */
      __IOM uint32_t CAM_VSYNC_FILTER_THRES : 3;/*!< Filter threshold value for CAM_VSYNC signal.                              */
      __IOM uint32_t CAM_UPDATE : 1;            /*!< 1: Update camera registers. This bit is cleared by hardware.
                                                     0: Do not care.                                                           */
      __IOM uint32_t CAM_BYTE_ORDER : 1;        /*!< 1: Invert data byte order, only valid in 16-bit mode. 0: Do
                                                     not change.                                                               */
      __IOM uint32_t CAM_BIT_ORDER : 1;         /*!< 1: Change data bit order, change CAM_DATA_in[7:0] to CAM_DATA_in[0:7]
                                                     in 8-bit mode, and bits[15:0] to bits[0:15] in 16-bit mode.
                                                     0: Do not change.                                                         */
      __IOM uint32_t CAM_LINE_INT_EN : 1;       /*!< 1: Enable to generate LCD_CAM_CAM_HS_INT. 0: Disable.                     */
      __IOM uint32_t CAM_VS_EOF_EN : 1;         /*!< 1: Enable CAM_VSYNC to generate in_suc_eof. 0: in_suc_eof is
                                                     controlled by LCD_CAM_CAM_REC_DATA_BYTELEN.                               */
      __IOM uint32_t CAM_CLKM_DIV_NUM : 8;      /*!< Integral camera clock divider value.                                      */
      __IOM uint32_t CAM_CLKM_DIV_B : 6;        /*!< Fractional clock divider numerator value.                                 */
      __IOM uint32_t CAM_CLKM_DIV_A : 6;        /*!< Fractional clock divider denominator value.                               */
      __IOM uint32_t CAM_CLK_SEL : 2;           /*!< Select camera module source clock. 0: Clock source is disabled.
                                                     1: XTAL_CLK. 2: PLL_D2_CLK. 3: PLL_F160M_CLK.                             */
            uint32_t            : 1;
    } bit;
  } CAM_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Camera control register                                                   */
    
    struct {
      __IOM uint32_t CAM_REC_DATA_BYTELEN : 16; /*!< Configure camera received data byte length. When the length
                                                     of received data reaches this value + 1, GDMA in_suc_eof_int
                                                     is triggered.                                                             */
      __IOM uint32_t CAM_LINE_INT_NUM : 6;      /*!< Configure line number. When the number of received lines reaches
                                                     this value + 1, LCD_CAM_CAM_HS_INT is triggered.                          */
      __IOM uint32_t CAM_CLK_INV : 1;           /*!< 1: Invert the input signal CAM_PCLK. 0: Do not invert.                    */
      __IOM uint32_t CAM_VSYNC_FILTER_EN : 1;   /*!< 1: Enable CAM_VSYNC filter function. 0: Bypass.                           */
      __IOM uint32_t CAM_2BYTE_EN : 1;          /*!< 1: The width of input data is 16 bits. 0: The width of input
                                                     data is 8 bits.                                                           */
      __IOM uint32_t CAM_DE_INV : 1;            /*!< CAM_DE invert enable signal, valid in high level.                         */
      __IOM uint32_t CAM_HSYNC_INV : 1;         /*!< CAM_HSYNC invert enable signal, valid in high level.                      */
      __IOM uint32_t CAM_VSYNC_INV : 1;         /*!< CAM_VSYNC invert enable signal, valid in high level.                      */
      __IOM uint32_t CAM_VH_DE_MODE_EN : 1;     /*!< 1: Input control signals are CAM_DE and CAM_HSYNC. CAM_VSYNC
                                                     is 1. 0: Input control signals are CAM_DE and CAM_VSYNC.
                                                     CAM_HSYNC and CAM_DE are all 1 at the the same time.                      */
      __IOM uint32_t CAM_START  : 1;            /*!< Camera module start signal.                                               */
      __OM  uint32_t CAM_RESET  : 1;            /*!< Camera module reset signal.                                               */
      __OM  uint32_t CAM_AFIFO_RESET : 1;       /*!< Camera Async Rx FIFO reset signal.                                        */
    } bit;
  } CAM_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< Camera data format conversion register                                    */
    
    struct {
            uint32_t            : 21;
      __IOM uint32_t CAM_CONV_8BITS_DATA_INV : 1;/*!< Swap every two 8-bit input data. 1: Enabled. 0: Disabled.                */
      __IOM uint32_t CAM_CONV_YUV2YUV_MODE : 2; /*!< In YUV-to-YUV mode, 0: data is converted to YUV422 format. 1:
                                                     data is converted to YUV420 format. 2: data is converted
                                                     to YUV411 format. 3: disabled. To enable YUV-to-YUV mode,
                                                     LCD_CAM_CAM_CONV_TRANS_MODE must be set to 1.                             */
      __IOM uint32_t CAM_CONV_YUV_MODE : 2;     /*!< In YUV-to-YUV mode and YUV-to-RGB mode, LCD_CAM_CAM_CONV_YUV_MODE
                                                     decides the YUV mode of input data. 0: input data is in
                                                     YUV422 format. 1: input data is in YUV420 format. 2: input
                                                     data is in YUV411 format. In RGB-to-YUV mode, 0: data is
                                                     converted to YUV422 format. 1: data is converted to YUV420
                                                     format. 2: data is converted to YUV411 format.                            */
      __IOM uint32_t CAM_CONV_PROTOCOL_MODE : 1;/*!< 0: BT601. 1: BT709.                                                       */
      __IOM uint32_t CAM_CONV_DATA_OUT_MODE : 1;/*!< Configure color range for output data. 0: limited color range.
                                                     1: full color range.                                                      */
      __IOM uint32_t CAM_CONV_DATA_IN_MODE : 1; /*!< Configure color range for input data. 0: limited color range.
                                                     1: full color range.                                                      */
      __IOM uint32_t CAM_CONV_MODE_8BITS_ON : 1;/*!< 0: 16-bit mode. 1: 8-bit mode.                                            */
      __IOM uint32_t CAM_CONV_TRANS_MODE : 1;   /*!< 0: converted to RGB format. 1: converted to YUV format.                   */
      __IOM uint32_t CAM_CONV_BYPASS : 1;       /*!< 0: Bypass converter. 1: Enable converter.                                 */
    } bit;
  } CAM_RGB_YUV;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD data format conversion register                                       */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t LCD_CONV_8BITS_DATA_INV : 1;/*!< Swap every two 8-bit input data. 1: Enabled. 0: Disabled.                */
            uint32_t            : 1;
      __IOM uint32_t LCD_CONV_YUV2YUV_MODE : 2; /*!< In YUV-to-YUV mode, 0: data is converted to YUV422 format. 1:
                                                     data is converted to YUV420 format. 2: data is converted
                                                     to YUV411 format. 3: disabled. To enable YUV-to-YUV mode,
                                                     LCD_CAM_LCD_CONV_TRANS_MODE must be set to 1.                             */
      __IOM uint32_t LCD_CONV_YUV_MODE : 2;     /*!< In YUV-to-YUV mode and YUV-to-RGB mode, LCD_CAM_LCD_CONV_YUV_MODE
                                                     decides the YUV mode of input data. 0: input data is in
                                                     YUV422 format. 1: input data is in YUV420 format. 2: input
                                                     data is in YUV411 format. In RGB-to-YUV mode, 0: data is
                                                     converted to YUV422 format. 1: data is converted to YUV420
                                                     format. 2: data is converted to YUV411 format.                            */
      __IOM uint32_t LCD_CONV_PROTOCOL_MODE : 1;/*!< 0: BT601. 1: BT709.                                                       */
      __IOM uint32_t LCD_CONV_DATA_OUT_MODE : 1;/*!< Configure color range for output data. 0: limited color range.
                                                     1: full color range.                                                      */
      __IOM uint32_t LCD_CONV_DATA_IN_MODE : 1; /*!< Configure color range for input data. 0: limited color range.
                                                     1: full color range.                                                      */
      __IOM uint32_t LCD_CONV_MODE_8BITS_ON : 1;/*!< 0: 16-bit mode. 1: 8-bit mode.                                            */
      __IOM uint32_t LCD_CONV_TRANS_MODE : 1;   /*!< 0: converted to RGB format. 1: converted to YUV format.                   */
      __IOM uint32_t LCD_CONV_BYPASS : 1;       /*!< 0: Bypass converter. 1: Enable converter.                                 */
    } bit;
  } LCD_RGB_YUV;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD user configuration register                                           */
    
    struct {
      __IOM uint32_t LCD_DOUT_CYCLELEN : 13;    /*!< Configure the cycles for DOUT phase of LCD module. The cycles
                                                     = this value + 1.                                                         */
      __IOM uint32_t LCD_ALWAYS_OUT_EN : 1;     /*!< LCD continues outputting data when LCD is in DOUT phase, till
                                                     LCD_CAM_LCD_START is cleared or LCD_CAM_LCD_RESET is set.                 */
            uint32_t            : 5;
      __IOM uint32_t LCD_8BITS_ORDER : 1;       /*!< 1: Swap every two data bytes, valid in 8-bit mode. 0: Do not
                                                     swap.                                                                     */
      __IOM uint32_t LCD_UPDATE : 1;            /*!< 1: Update LCD registers. This bit is cleared by hardware. 0:
                                                     Do not care.                                                              */
      __IOM uint32_t LCD_BIT_ORDER : 1;         /*!< 1: Change data bit order. Change LCD_DATA_out[7:0] to LCD_DATA_out[0:7]
                                                     in 8-bit mode, and bits[15:0] to bits[0:15] in 16-bit mode.
                                                     0: Do not change.                                                         */
      __IOM uint32_t LCD_BYTE_ORDER : 1;        /*!< 1: Invert data byte order, only valid in 16-bit mode. 0: Do
                                                     not invert.                                                               */
      __IOM uint32_t LCD_2BYTE_EN : 1;          /*!< 1: The width of output LCD data is 16 bits. 0: The width of
                                                     output LCD data is 8 bits.                                                */
      __IOM uint32_t LCD_DOUT   : 1;            /*!< 1: Be able to send data out in LCD sequence when LCD starts.
                                                     0: Disable.                                                               */
      __IOM uint32_t LCD_DUMMY  : 1;            /*!< 1: Enable DUMMY phase in LCD sequence when LCD starts. 0: Disable.        */
      __IOM uint32_t LCD_CMD    : 1;            /*!< 1: Be able to send command in LCD sequence when LCD starts.
                                                     0: Disable.                                                               */
      __IOM uint32_t LCD_START  : 1;            /*!< LCD starts sending data enable signal, valid in high level.               */
      __OM  uint32_t LCD_RESET  : 1;            /*!< Reset LCD module.                                                         */
      __IOM uint32_t LCD_DUMMY_CYCLELEN : 2;    /*!< Configure DUMMY cycles. DUMMY cycles = this value + 1.                    */
      __IOM uint32_t LCD_CMD_2_CYCLE_EN : 1;    /*!< The cycle length of command phase. 1: 2 cycles. 0: 1 cycle.               */
    } bit;
  } LCD_USER;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD MISC configuration register                                           */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t LCD_AFIFO_THRESHOLD_NUM : 5;/*!< Set the threshold for Async Tx FIFO full event.                          */
      __IOM uint32_t LCD_VFK_CYCLELEN : 6;      /*!< Configure the setup cycles in LCD non-RGB mode. Setup cycles
                                                     expected = this value + 1.                                                */
      __IOM uint32_t LCD_VBK_CYCLELEN : 13;     /*!< Configure the hold time cycles in LCD non-RGB mode. Hold cycles
                                                     expected = this value + 1. %Configure the cycles for vertical
                                                     back blank region in LCD RGB mode, the cycles = this value
                                                     + 1. Or configure the hold time cycles in LCD non-RGB mode,
                                                     the cycles = this value + 1.                                              */
      __IOM uint32_t LCD_NEXT_FRAME_EN : 1;     /*!< 1: Send the next frame data when the current frame is sent out.
                                                     0: LCD stops when the current frame is sent out.                          */
      __IOM uint32_t LCD_BK_EN  : 1;            /*!< 1: Enable blank region when LCD sends data out. 0: No blank
                                                     region.                                                                   */
      __OM  uint32_t LCD_AFIFO_RESET : 1;       /*!< Async Tx FIFO reset signal.                                               */
      __IOM uint32_t LCD_CD_DATA_SET : 1;       /*!< 1: LCD_CD = !LCD_CAM_LCD_CD_IDLE_EDGE when LCD is in DOUT phase.
                                                     0: LCD_CD = LCD_CAM_LCD_CD_IDLE_EDGE.                                     */
      __IOM uint32_t LCD_CD_DUMMY_SET : 1;      /*!< 1: LCD_CD = !LCD_CAM_LCD_CD_IDLE_EDGE when LCD is in DUMMY phase.
                                                     0: LCD_CD = LCD_CAM_LCD_CD_IDLE_EDGE.                                     */
      __IOM uint32_t LCD_CD_CMD_SET : 1;        /*!< 1: LCD_CD = !LCD_CAM_LCD_CD_IDLE_EDGE when LCD is in CMD phase.
                                                     0: LCD_CD = LCD_CAM_LCD_CD_IDLE_EDGE.                                     */
      __IOM uint32_t LCD_CD_IDLE_EDGE : 1;      /*!< The default value of LCD_CD.                                              */
    } bit;
  } LCD_MISC;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD signal configuration register                                         */
    
    struct {
      __IOM uint32_t LCD_HB_FRONT : 11;         /*!< It is the horizontal blank front porch of a frame.                        */
      __IOM uint32_t LCD_VA_HEIGHT : 10;        /*!< It is the vertical active height of a frame.                              */
      __IOM uint32_t LCD_VT_HEIGHT : 10;        /*!< It is the vertical total height of a frame.                               */
      __IOM uint32_t LCD_RGB_MODE_EN : 1;       /*!< 1: Enable RGB mode, and input VSYNC, HSYNC, and DE signals.
                                                     0: Disable.                                                               */
    } bit;
  } LCD_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD signal configuration register 1                                       */
    
    struct {
      __IOM uint32_t LCD_VB_FRONT : 8;          /*!< It is the vertical blank front porch of a frame.                          */
      __IOM uint32_t LCD_HA_WIDTH : 12;         /*!< It is the horizontal active width of a frame.                             */
      __IOM uint32_t LCD_HT_WIDTH : 12;         /*!< It is the horizontal total width of a frame.                              */
    } bit;
  } LCD_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD signal configuration register 2                                       */
    
    struct {
      __IOM uint32_t LCD_VSYNC_WIDTH : 7;       /*!< It is the width of LCD_VSYNC active pulse in a line.                      */
      __IOM uint32_t LCD_VSYNC_IDLE_POL : 1;    /*!< It is the idle value of LCD_VSYNC.                                        */
      __IOM uint32_t LCD_DE_IDLE_POL : 1;       /*!< It is the idle value of LCD_DE.                                           */
      __IOM uint32_t LCD_HS_BLANK_EN : 1;       /*!< 1: The pulse of LCD_HSYNC is out in vertical blanking lines
                                                     in RGB mode. 0: LCD_HSYNC pulse is valid only in active
                                                     region lines in RGB mode.                                                 */
            uint32_t            : 6;
      __IOM uint32_t LCD_HSYNC_WIDTH : 7;       /*!< It is the width of LCD_HSYNC active pulse in a line.                      */
      __IOM uint32_t LCD_HSYNC_IDLE_POL : 1;    /*!< It is the idle value of LCD_HSYNC.                                        */
      __IOM uint32_t LCD_HSYNC_POSITION : 8;    /*!< It is the position of LCD_HSYNC active pulse in a line.                   */
    } bit;
  } LCD_CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD command value configuration register                                  */
    
    struct {
      __IOM uint32_t LCD_CMD_VALUE : 32;        /*!< The LCD write command value.                                              */
    } bit;
  } LCD_CMD_VAL;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD signal delay configuration register                                   */
    
    struct {
      __IOM uint32_t LCD_CD_MODE : 2;           /*!< The output LCD_CD is delayed by module clock LCD_CLK. 0: output
                                                     without delay. 1: delayed by the rising edge of LCD_CLK.
                                                     2: delayed by the falling edge of LCD_CLK.                                */
      __IOM uint32_t LCD_DE_MODE : 2;           /*!< The output LCD_DE is delayed by module clock LCD_CLK. 0: output
                                                     without delay. 1: delayed by the rising edge of LCD_CLK.
                                                     2: delayed by the falling edge of LCD_CLK.                                */
      __IOM uint32_t LCD_HSYNC_MODE : 2;        /*!< The output LCD_HSYNC is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t LCD_VSYNC_MODE : 2;        /*!< The output LCD_VSYNC is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delay by the falling edge of LCD_CLK.                         */
            uint32_t            : 24;
    } bit;
  } LCD_DLY_MODE;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD data delay configuration register                                     */
    
    struct {
      __IOM uint32_t DOUT0_MODE : 2;            /*!< The output data bit 0 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT1_MODE : 2;            /*!< The output data bit 1 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT2_MODE : 2;            /*!< The output data bit 2 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT3_MODE : 2;            /*!< The output data bit 3 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT4_MODE : 2;            /*!< The output data bit 4 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT5_MODE : 2;            /*!< The output data bit 5 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT6_MODE : 2;            /*!< The output data bit 6 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT7_MODE : 2;            /*!< The output data bit 7 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT8_MODE : 2;            /*!< The output data bit 8 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT9_MODE : 2;            /*!< The output data bit 9 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT10_MODE : 2;           /*!< The output data bit 10 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT11_MODE : 2;           /*!< The output data bit 11 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT12_MODE : 2;           /*!< The output data bit 12 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT13_MODE : 2;           /*!< The output data bit 13 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT14_MODE : 2;           /*!< The output data bit 14 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
      __IOM uint32_t DOUT15_MODE : 2;           /*!< The output data bit 15 is delayed by module clock LCD_CLK. 0:
                                                     output without delay. 1: delayed by the rising edge of
                                                     LCD_CLK. 2: delayed by the falling edge of LCD_CLK.                       */
    } bit;
  } LCD_DATA_DOUT_MODE;
  __IM  uint32_t  RESERVED2[10];
  
  union {
    __IOM uint32_t reg;                         /*!< LCD_CAM GDMA interrupt enable register                                    */
    
    struct {
      __IOM uint32_t LCD_VSYNC_INT_ENA : 1;     /*!< The enable bit for LCD_CAM_LCD_VSYNC_INT interrupt.                       */
      __IOM uint32_t LCD_TRANS_DONE_INT_ENA : 1;/*!< The enable bit for LCD_CAM_LCD_TRANS_DONE_INT interrupt.                  */
      __IOM uint32_t CAM_VSYNC_INT_ENA : 1;     /*!< The enable bit for LCD_CAM_CAM_VSYNC_INT interrupt.                       */
      __IOM uint32_t CAM_HS_INT_ENA : 1;        /*!< The enable bit for LCD_CAM_CAM_HS_INT interrupt.                          */
            uint32_t            : 28;
    } bit;
  } LC_DMA_INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD_CAM GDMA raw interrupt status register                                */
    
    struct {
      __IM  uint32_t LCD_VSYNC_INT_RAW : 1;     /*!< The raw bit for LCD_CAM_LCD_VSYNC_INT interrupt.                          */
      __IM  uint32_t LCD_TRANS_DONE_INT_RAW : 1;/*!< The raw bit for LCD_CAM_LCD_TRANS_DONE_INT interrupt.                     */
      __IM  uint32_t CAM_VSYNC_INT_RAW : 1;     /*!< The raw bit for LCD_CAM_CAM_VSYNC_INT interrupt.                          */
      __IM  uint32_t CAM_HS_INT_RAW : 1;        /*!< The raw bit for LCD_CAM_CAM_HS_INT interrupt.                             */
            uint32_t            : 28;
    } bit;
  } LC_DMA_INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD_CAM GDMA masked interrupt status register                             */
    
    struct {
      __IM  uint32_t LCD_VSYNC_INT_ST : 1;      /*!< The status bit for LCD_CAM_LCD_VSYNC_INT interrupt.                       */
      __IM  uint32_t LCD_TRANS_DONE_INT_ST : 1; /*!< The status bit for LCD_CAM_LCD_TRANS_DONE_INT interrupt.                  */
      __IM  uint32_t CAM_VSYNC_INT_ST : 1;      /*!< The status bit for LCD_CAM_CAM_VSYNC_INT interrupt.                       */
      __IM  uint32_t CAM_HS_INT_ST : 1;         /*!< The status bit for LCD_CAM_CAM_HS_INT interrupt.                          */
            uint32_t            : 28;
    } bit;
  } LC_DMA_INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< LCD_CAM GDMA interrupt clear register                                     */
    
    struct {
      __OM  uint32_t LCD_VSYNC_INT_CLR : 1;     /*!< The clear bit for LCD_CAM_LCD_VSYNC_INT interrupt.                        */
      __OM  uint32_t LCD_TRANS_DONE_INT_CLR : 1;/*!< The clear bit for LCD_CAM_LCD_TRANS_DONE_INT interrupt.                   */
      __OM  uint32_t CAM_VSYNC_INT_CLR : 1;     /*!< The clear bit for LCD_CAM_CAM_VSYNC_INT interrupt.                        */
      __OM  uint32_t CAM_HS_INT_CLR : 1;        /*!< The clear bit for LCD_CAM_CAM_HS_INT interrupt.                           */
            uint32_t            : 28;
    } bit;
  } LC_DMA_INT_CLR;
  __IM  uint32_t  RESERVED3[34];
  
  union {
    __IOM uint32_t reg;                         /*!< Version control register                                                  */
    
    struct {
      __IOM uint32_t LC_DATE    : 28;           /*!< Version control register                                                  */
            uint32_t            : 4;
    } bit;
  } LC_REG_DATE;
} LCD_CAM_Type;                                 /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                           LEDC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief LED Control PWM (Pulse Width Modulation) (LEDC)
  */

typedef struct {                                /*!< LEDC Structure                                                            */
  __IOM uint32_t  CH0_CONF0;                    /*!< Configuration register 0 for channel 0                                    */
  
  union {
    __IOM uint32_t reg;                         /*!< High point register for channel 0                                         */
    
    struct {
      __IOM uint32_t HPOINT     : 14;           /*!< The output value changes to high when the selected timers has
                                                     reached the value specified by this register.                             */
            uint32_t            : 18;
    } bit;
  } CH0_HPOINT;
  
  union {
    __IOM uint32_t reg;                         /*!< Initial duty cycle for channel 0                                          */
    
    struct {
      __IOM uint32_t DUTY       : 19;           /*!< This register is used to change the output duty by controlling
                                                     the Lpoint.The output value turns to low when the selected
                                                     timers has reached the Lpoint.                                            */
            uint32_t            : 13;
    } bit;
  } CH0_DUTY;
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 1 for channel 0                                    */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t DUTY_NUM   : 10;           /*!< This register is used to control the number of times the duty
                                                     cycle will be changed.                                                    */
            uint32_t            : 2;
    } bit;
  } CH0_CONF1;
  __IOM uint32_t  CH0_DUTY_R;                   /*!< Current duty cycle for channel 0                                          */
  __IM  uint32_t  RESERVED[15];
  __IOM uint32_t  CH1_CONF0;                    /*!< Configuration register 0 for channel 1                                    */
  
  union {
    __IOM uint32_t reg;                         /*!< High point register for channel 1                                         */
    
    struct {
      __IOM uint32_t HPOINT     : 14;           /*!< The output value changes to high when the selected timers has
                                                     reached the value specified by this register.                             */
            uint32_t            : 18;
    } bit;
  } CH1_HPOINT;
  
  union {
    __IOM uint32_t reg;                         /*!< Initial duty cycle for channel 1                                          */
    
    struct {
      __IOM uint32_t DUTY       : 19;           /*!< This register is used to change the output duty by controlling
                                                     the Lpoint.The output value turns to low when the selected
                                                     timers has reached the Lpoint.                                            */
            uint32_t            : 13;
    } bit;
  } CH1_DUTY;
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 1 for channel 1                                    */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t DUTY_NUM   : 10;           /*!< This register is used to control the number of times the duty
                                                     cycle will be changed.                                                    */
            uint32_t            : 2;
    } bit;
  } CH1_CONF1;
  __IOM uint32_t  CH1_DUTY_R;                   /*!< Current duty cycle for channel 1                                          */
  __IM  uint32_t  RESERVED1[15];
  
  union {
    __IOM uint32_t CH2_CONF0;                   /*!< Configuration register 0 for channel 2                                    */
    
    union {
      __IOM uint32_t reg;                       /*!< Timer 0 configuration                                                     */
      
      struct {
              uint32_t          : 24;
        __IOM uint32_t TICK_SEL : 1;            /*!< This bit is used to select clock for timer %s. When this bit
                                                     is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise
                                                     the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1:
                                                     REF_TICK                                                                  */
              uint32_t          : 7;
      } bit;
    } TIMER0_CONF;
  };
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< High point register for channel 2                                         */
      
      struct {
        __IOM uint32_t HPOINT   : 14;           /*!< The output value changes to high when the selected timers has
                                                     reached the value specified by this register.                             */
              uint32_t          : 18;
      } bit;
    } CH2_HPOINT;
    __IOM uint32_t TIMER0_VALUE;                /*!< Timer 0 current counter value                                             */
  };
  
  union {
    __IOM uint32_t reg;                         /*!< Initial duty cycle for channel 2                                          */
    
    struct {
      __IOM uint32_t DUTY       : 19;           /*!< This register is used to change the output duty by controlling
                                                     the Lpoint.The output value turns to low when the selected
                                                     timers has reached the Lpoint.                                            */
            uint32_t            : 13;
    } bit;
  } CH2_DUTY;
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 1 for channel 2                                    */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t DUTY_NUM   : 10;           /*!< This register is used to control the number of times the duty
                                                     cycle will be changed.                                                    */
            uint32_t            : 2;
    } bit;
  } CH2_CONF1;
  __IOM uint32_t  CH2_DUTY_R;                   /*!< Current duty cycle for channel 2                                          */
  __IM  uint32_t  RESERVED2[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Timer 1 configuration                                                     */
      
      struct {
              uint32_t          : 24;
        __IOM uint32_t TICK_SEL : 1;            /*!< This bit is used to select clock for timer %s. When this bit
                                                     is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise
                                                     the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1:
                                                     REF_TICK                                                                  */
              uint32_t          : 7;
      } bit;
    } TIMER1_CONF;
    
    union {
      __IOM uint32_t reg;                       /*!< Raw interrupt status                                                      */
      
      struct {
        __IOM uint32_t TIMER0_OVF_INT_RAW : 1;  /*!< Triggered when the timer0 has reached its maximum counter value.          */
        __IOM uint32_t TIMER1_OVF_INT_RAW : 1;  /*!< Triggered when the timer1 has reached its maximum counter value.          */
        __IOM uint32_t TIMER2_OVF_INT_RAW : 1;  /*!< Triggered when the timer2 has reached its maximum counter value.          */
        __IOM uint32_t TIMER3_OVF_INT_RAW : 1;  /*!< Triggered when the timer3 has reached its maximum counter value.          */
        __IOM uint32_t DUTY_CHNG_END_CH0_INT_RAW : 1;/*!< Interrupt raw bit for channel 0. Triggered when the gradual
                                                     change of duty has finished.                                              */
        __IOM uint32_t DUTY_CHNG_END_CH1_INT_RAW : 1;/*!< Interrupt raw bit for channel 1. Triggered when the gradual
                                                     change of duty has finished.                                              */
        __IOM uint32_t DUTY_CHNG_END_CH2_INT_RAW : 1;/*!< Interrupt raw bit for channel 2. Triggered when the gradual
                                                     change of duty has finished.                                              */
        __IOM uint32_t DUTY_CHNG_END_CH3_INT_RAW : 1;/*!< Interrupt raw bit for channel 3. Triggered when the gradual
                                                     change of duty has finished.                                              */
        __IOM uint32_t DUTY_CHNG_END_CH4_INT_RAW : 1;/*!< Interrupt raw bit for channel 4. Triggered when the gradual
                                                     change of duty has finished.                                              */
        __IOM uint32_t DUTY_CHNG_END_CH5_INT_RAW : 1;/*!< Interrupt raw bit for channel 5. Triggered when the gradual
                                                     change of duty has finished.                                              */
        __IOM uint32_t DUTY_CHNG_END_CH6_INT_RAW : 1;/*!< Interrupt raw bit for channel 6. Triggered when the gradual
                                                     change of duty has finished.                                              */
        __IOM uint32_t DUTY_CHNG_END_CH7_INT_RAW : 1;/*!< Interrupt raw bit for channel 7. Triggered when the gradual
                                                     change of duty has finished.                                              */
        __IOM uint32_t OVF_CNT_CH0_INT_RAW : 1; /*!< Interrupt raw bit for channel 0. Triggered when the ovf_cnt
                                                     has reached the value specified by LEDC_OVF_NUM_CH0.                      */
        __IOM uint32_t OVF_CNT_CH1_INT_RAW : 1; /*!< Interrupt raw bit for channel 1. Triggered when the ovf_cnt
                                                     has reached the value specified by LEDC_OVF_NUM_CH1.                      */
        __IOM uint32_t OVF_CNT_CH2_INT_RAW : 1; /*!< Interrupt raw bit for channel 2. Triggered when the ovf_cnt
                                                     has reached the value specified by LEDC_OVF_NUM_CH2.                      */
        __IOM uint32_t OVF_CNT_CH3_INT_RAW : 1; /*!< Interrupt raw bit for channel 3. Triggered when the ovf_cnt
                                                     has reached the value specified by LEDC_OVF_NUM_CH3.                      */
        __IOM uint32_t OVF_CNT_CH4_INT_RAW : 1; /*!< Interrupt raw bit for channel 4. Triggered when the ovf_cnt
                                                     has reached the value specified by LEDC_OVF_NUM_CH4.                      */
        __IOM uint32_t OVF_CNT_CH5_INT_RAW : 1; /*!< Interrupt raw bit for channel 5. Triggered when the ovf_cnt
                                                     has reached the value specified by LEDC_OVF_NUM_CH5.                      */
        __IOM uint32_t OVF_CNT_CH6_INT_RAW : 1; /*!< Interrupt raw bit for channel 6. Triggered when the ovf_cnt
                                                     has reached the value specified by LEDC_OVF_NUM_CH6.                      */
        __IOM uint32_t OVF_CNT_CH7_INT_RAW : 1; /*!< Interrupt raw bit for channel 7. Triggered when the ovf_cnt
                                                     has reached the value specified by LEDC_OVF_NUM_CH7.                      */
              uint32_t          : 12;
      } bit;
    } INT_RAW;
  };
  
  union {
    __IOM uint32_t TIMER1_VALUE;                /*!< Timer 1 current counter value                                             */
    
    union {
      __IOM uint32_t reg;                       /*!< Masked interrupt status                                                   */
      
      struct {
        __IM  uint32_t TIMER0_OVF_INT_ST : 1;   /*!< This is the masked interrupt status bit for the LEDC_TIMER0_OVF_INT
                                                     interrupt when LEDC_TIMER0_OVF_INT_ENA is set to 1.                       */
        __IM  uint32_t TIMER1_OVF_INT_ST : 1;   /*!< This is the masked interrupt status bit for the LEDC_TIMER1_OVF_INT
                                                     interrupt when LEDC_TIMER1_OVF_INT_ENA is set to 1.                       */
        __IM  uint32_t TIMER2_OVF_INT_ST : 1;   /*!< This is the masked interrupt status bit for the LEDC_TIMER2_OVF_INT
                                                     interrupt when LEDC_TIMER2_OVF_INT_ENA is set to 1.                       */
        __IM  uint32_t TIMER3_OVF_INT_ST : 1;   /*!< This is the masked interrupt status bit for the LEDC_TIMER3_OVF_INT
                                                     interrupt when LEDC_TIMER3_OVF_INT_ENA is set to 1.                       */
        __IM  uint32_t DUTY_CHNG_END_CH0_INT_ST : 1;/*!< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH0_INT
                                                     interrupt when LEDC_DUTY_CHNG_END_CH0_INT_ENAIS set to
                                                     1.                                                                        */
        __IM  uint32_t DUTY_CHNG_END_CH1_INT_ST : 1;/*!< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH1_INT
                                                     interrupt when LEDC_DUTY_CHNG_END_CH1_INT_ENAIS set to
                                                     1.                                                                        */
        __IM  uint32_t DUTY_CHNG_END_CH2_INT_ST : 1;/*!< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH2_INT
                                                     interrupt when LEDC_DUTY_CHNG_END_CH2_INT_ENAIS set to
                                                     1.                                                                        */
        __IM  uint32_t DUTY_CHNG_END_CH3_INT_ST : 1;/*!< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH3_INT
                                                     interrupt when LEDC_DUTY_CHNG_END_CH3_INT_ENAIS set to
                                                     1.                                                                        */
        __IM  uint32_t DUTY_CHNG_END_CH4_INT_ST : 1;/*!< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH4_INT
                                                     interrupt when LEDC_DUTY_CHNG_END_CH4_INT_ENAIS set to
                                                     1.                                                                        */
        __IM  uint32_t DUTY_CHNG_END_CH5_INT_ST : 1;/*!< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH5_INT
                                                     interrupt when LEDC_DUTY_CHNG_END_CH5_INT_ENAIS set to
                                                     1.                                                                        */
        __IM  uint32_t DUTY_CHNG_END_CH6_INT_ST : 1;/*!< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH6_INT
                                                     interrupt when LEDC_DUTY_CHNG_END_CH6_INT_ENAIS set to
                                                     1.                                                                        */
        __IM  uint32_t DUTY_CHNG_END_CH7_INT_ST : 1;/*!< This is the masked interrupt status bit for the LEDC_DUTY_CHNG_END_CH7_INT
                                                     interrupt when LEDC_DUTY_CHNG_END_CH7_INT_ENAIS set to
                                                     1.                                                                        */
        __IM  uint32_t OVF_CNT_CH0_INT_ST : 1;  /*!< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH0_INT
                                                     interrupt when LEDC_OVF_CNT_CH0_INT_ENA is set to 1.                      */
        __IM  uint32_t OVF_CNT_CH1_INT_ST : 1;  /*!< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH1_INT
                                                     interrupt when LEDC_OVF_CNT_CH1_INT_ENA is set to 1.                      */
        __IM  uint32_t OVF_CNT_CH2_INT_ST : 1;  /*!< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH2_INT
                                                     interrupt when LEDC_OVF_CNT_CH2_INT_ENA is set to 1.                      */
        __IM  uint32_t OVF_CNT_CH3_INT_ST : 1;  /*!< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH3_INT
                                                     interrupt when LEDC_OVF_CNT_CH3_INT_ENA is set to 1.                      */
        __IM  uint32_t OVF_CNT_CH4_INT_ST : 1;  /*!< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH4_INT
                                                     interrupt when LEDC_OVF_CNT_CH4_INT_ENA is set to 1.                      */
        __IM  uint32_t OVF_CNT_CH5_INT_ST : 1;  /*!< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH5_INT
                                                     interrupt when LEDC_OVF_CNT_CH5_INT_ENA is set to 1.                      */
        __IM  uint32_t OVF_CNT_CH6_INT_ST : 1;  /*!< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH6_INT
                                                     interrupt when LEDC_OVF_CNT_CH6_INT_ENA is set to 1.                      */
        __IM  uint32_t OVF_CNT_CH7_INT_ST : 1;  /*!< This is the masked interrupt status bit for the LEDC_OVF_CNT_CH7_INT
                                                     interrupt when LEDC_OVF_CNT_CH7_INT_ENA is set to 1.                      */
              uint32_t          : 12;
      } bit;
    } INT_ST;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits                                                     */
    
    struct {
      __IOM uint32_t TIMER0_OVF_INT_ENA : 1;    /*!< The interrupt enable bit for the LEDC_TIMER0_OVF_INT interrupt.           */
      __IOM uint32_t TIMER1_OVF_INT_ENA : 1;    /*!< The interrupt enable bit for the LEDC_TIMER1_OVF_INT interrupt.           */
      __IOM uint32_t TIMER2_OVF_INT_ENA : 1;    /*!< The interrupt enable bit for the LEDC_TIMER2_OVF_INT interrupt.           */
      __IOM uint32_t TIMER3_OVF_INT_ENA : 1;    /*!< The interrupt enable bit for the LEDC_TIMER3_OVF_INT interrupt.           */
      __IOM uint32_t DUTY_CHNG_END_CH0_INT_ENA : 1;/*!< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH0_INT
                                                     interrupt.                                                                */
      __IOM uint32_t DUTY_CHNG_END_CH1_INT_ENA : 1;/*!< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH1_INT
                                                     interrupt.                                                                */
      __IOM uint32_t DUTY_CHNG_END_CH2_INT_ENA : 1;/*!< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH2_INT
                                                     interrupt.                                                                */
      __IOM uint32_t DUTY_CHNG_END_CH3_INT_ENA : 1;/*!< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH3_INT
                                                     interrupt.                                                                */
      __IOM uint32_t DUTY_CHNG_END_CH4_INT_ENA : 1;/*!< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH4_INT
                                                     interrupt.                                                                */
      __IOM uint32_t DUTY_CHNG_END_CH5_INT_ENA : 1;/*!< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH5_INT
                                                     interrupt.                                                                */
      __IOM uint32_t DUTY_CHNG_END_CH6_INT_ENA : 1;/*!< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH6_INT
                                                     interrupt.                                                                */
      __IOM uint32_t DUTY_CHNG_END_CH7_INT_ENA : 1;/*!< The interrupt enable bit for the LEDC_DUTY_CHNG_END_CH7_INT
                                                     interrupt.                                                                */
      __IOM uint32_t OVF_CNT_CH0_INT_ENA : 1;   /*!< The interrupt enable bit for the LEDC_OVF_CNT_CH0_INT interrupt.          */
      __IOM uint32_t OVF_CNT_CH1_INT_ENA : 1;   /*!< The interrupt enable bit for the LEDC_OVF_CNT_CH1_INT interrupt.          */
      __IOM uint32_t OVF_CNT_CH2_INT_ENA : 1;   /*!< The interrupt enable bit for the LEDC_OVF_CNT_CH2_INT interrupt.          */
      __IOM uint32_t OVF_CNT_CH3_INT_ENA : 1;   /*!< The interrupt enable bit for the LEDC_OVF_CNT_CH3_INT interrupt.          */
      __IOM uint32_t OVF_CNT_CH4_INT_ENA : 1;   /*!< The interrupt enable bit for the LEDC_OVF_CNT_CH4_INT interrupt.          */
      __IOM uint32_t OVF_CNT_CH5_INT_ENA : 1;   /*!< The interrupt enable bit for the LEDC_OVF_CNT_CH5_INT interrupt.          */
      __IOM uint32_t OVF_CNT_CH6_INT_ENA : 1;   /*!< The interrupt enable bit for the LEDC_OVF_CNT_CH6_INT interrupt.          */
      __IOM uint32_t OVF_CNT_CH7_INT_ENA : 1;   /*!< The interrupt enable bit for the LEDC_OVF_CNT_CH7_INT interrupt.          */
            uint32_t            : 12;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits                                                      */
    
    struct {
      __OM  uint32_t TIMER0_OVF_INT_CLR : 1;    /*!< Set this bit to clear the LEDC_TIMER0_OVF_INT interrupt.                  */
      __OM  uint32_t TIMER1_OVF_INT_CLR : 1;    /*!< Set this bit to clear the LEDC_TIMER1_OVF_INT interrupt.                  */
      __OM  uint32_t TIMER2_OVF_INT_CLR : 1;    /*!< Set this bit to clear the LEDC_TIMER2_OVF_INT interrupt.                  */
      __OM  uint32_t TIMER3_OVF_INT_CLR : 1;    /*!< Set this bit to clear the LEDC_TIMER3_OVF_INT interrupt.                  */
      __OM  uint32_t DUTY_CHNG_END_CH0_INT_CLR : 1;/*!< Set this bit to clear the LEDC_DUTY_CHNG_END_CH0_INT interrupt.        */
      __OM  uint32_t DUTY_CHNG_END_CH1_INT_CLR : 1;/*!< Set this bit to clear the LEDC_DUTY_CHNG_END_CH1_INT interrupt.        */
      __OM  uint32_t DUTY_CHNG_END_CH2_INT_CLR : 1;/*!< Set this bit to clear the LEDC_DUTY_CHNG_END_CH2_INT interrupt.        */
      __OM  uint32_t DUTY_CHNG_END_CH3_INT_CLR : 1;/*!< Set this bit to clear the LEDC_DUTY_CHNG_END_CH3_INT interrupt.        */
      __OM  uint32_t DUTY_CHNG_END_CH4_INT_CLR : 1;/*!< Set this bit to clear the LEDC_DUTY_CHNG_END_CH4_INT interrupt.        */
      __OM  uint32_t DUTY_CHNG_END_CH5_INT_CLR : 1;/*!< Set this bit to clear the LEDC_DUTY_CHNG_END_CH5_INT interrupt.        */
      __OM  uint32_t DUTY_CHNG_END_CH6_INT_CLR : 1;/*!< Set this bit to clear the LEDC_DUTY_CHNG_END_CH6_INT interrupt.        */
      __OM  uint32_t DUTY_CHNG_END_CH7_INT_CLR : 1;/*!< Set this bit to clear the LEDC_DUTY_CHNG_END_CH7_INT interrupt.        */
      __OM  uint32_t OVF_CNT_CH0_INT_CLR : 1;   /*!< Set this bit to clear the LEDC_OVF_CNT_CH0_INT interrupt.                 */
      __OM  uint32_t OVF_CNT_CH1_INT_CLR : 1;   /*!< Set this bit to clear the LEDC_OVF_CNT_CH1_INT interrupt.                 */
      __OM  uint32_t OVF_CNT_CH2_INT_CLR : 1;   /*!< Set this bit to clear the LEDC_OVF_CNT_CH2_INT interrupt.                 */
      __OM  uint32_t OVF_CNT_CH3_INT_CLR : 1;   /*!< Set this bit to clear the LEDC_OVF_CNT_CH3_INT interrupt.                 */
      __OM  uint32_t OVF_CNT_CH4_INT_CLR : 1;   /*!< Set this bit to clear the LEDC_OVF_CNT_CH4_INT interrupt.                 */
      __OM  uint32_t OVF_CNT_CH5_INT_CLR : 1;   /*!< Set this bit to clear the LEDC_OVF_CNT_CH5_INT interrupt.                 */
      __OM  uint32_t OVF_CNT_CH6_INT_CLR : 1;   /*!< Set this bit to clear the LEDC_OVF_CNT_CH6_INT interrupt.                 */
      __OM  uint32_t OVF_CNT_CH7_INT_CLR : 1;   /*!< Set this bit to clear the LEDC_OVF_CNT_CH7_INT interrupt.                 */
            uint32_t            : 12;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Global ledc configuration register                                        */
    
    struct {
      __IOM uint32_t APB_CLK_SEL : 2;           /*!< This bit is used to select clock source for the 4 timers .2'd1:
                                                     APB_CLK 2'd2: RTC8M_CLK 2'd3: XTAL_CLK                                    */
            uint32_t            : 29;
      __IOM uint32_t CLK_EN     : 1;            /*!< This bit is used to control clock.1'b1: Force clock on for register.
                                                     1'h0: Support clock only when application writes registers.               */
    } bit;
  } CONF;
  __IM  uint32_t  RESERVED3[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Timer 2 configuration                                                     */
    
    struct {
            uint32_t            : 24;
      __IOM uint32_t TICK_SEL   : 1;            /*!< This bit is used to select clock for timer %s. When this bit
                                                     is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise
                                                     the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1:
                                                     REF_TICK                                                                  */
            uint32_t            : 7;
    } bit;
  } TIMER2_CONF;
  __IOM uint32_t  TIMER2_VALUE;                 /*!< Timer 2 current counter value                                             */
  __IM  uint32_t  RESERVED4[2];
  __IOM uint32_t  CH3_CONF0;                    /*!< Configuration register 0 for channel 3                                    */
  
  union {
    __IOM uint32_t reg;                         /*!< High point register for channel 3                                         */
    
    struct {
      __IOM uint32_t HPOINT     : 14;           /*!< The output value changes to high when the selected timers has
                                                     reached the value specified by this register.                             */
            uint32_t            : 18;
    } bit;
  } CH3_HPOINT;
  
  union {
    __IOM uint32_t reg;                         /*!< Initial duty cycle for channel 3                                          */
    
    struct {
      __IOM uint32_t DUTY       : 19;           /*!< This register is used to change the output duty by controlling
                                                     the Lpoint.The output value turns to low when the selected
                                                     timers has reached the Lpoint.                                            */
            uint32_t            : 13;
    } bit;
  } CH3_DUTY;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Configuration register 1 for channel 3                                    */
      
      struct {
              uint32_t          : 20;
        __IOM uint32_t DUTY_NUM : 10;           /*!< This register is used to control the number of times the duty
                                                     cycle will be changed.                                                    */
              uint32_t          : 2;
      } bit;
    } CH3_CONF1;
    
    union {
      __IOM uint32_t reg;                       /*!< Version control register                                                  */
      
      struct {
        __IOM uint32_t DATE     : 32;           /*!< This is the version control register.                                     */
      } bit;
    } DATE;
  };
  
  union {
    __IOM uint32_t CH3_DUTY_R;                  /*!< Current duty cycle for channel 3                                          */
    
    union {
      __IOM uint32_t reg;                       /*!< Timer 3 configuration                                                     */
      
      struct {
              uint32_t          : 24;
        __IOM uint32_t TICK_SEL : 1;            /*!< This bit is used to select clock for timer %s. When this bit
                                                     is set to 1 LEDC_APB_CLK_SEL[1:0] should be 1, otherwise
                                                     the timer clock may be not accurate.1'h0: SLOW_CLK 1'h1:
                                                     REF_TICK                                                                  */
              uint32_t          : 7;
      } bit;
    } TIMER3_CONF;
  };
  __IOM uint32_t  TIMER3_VALUE;                 /*!< Timer 3 current counter value                                             */
  __IM  uint32_t  RESERVED5[14];
  __IOM uint32_t  CH4_CONF0;                    /*!< Configuration register 0 for channel 4                                    */
  
  union {
    __IOM uint32_t reg;                         /*!< High point register for channel 4                                         */
    
    struct {
      __IOM uint32_t HPOINT     : 14;           /*!< The output value changes to high when the selected timers has
                                                     reached the value specified by this register.                             */
            uint32_t            : 18;
    } bit;
  } CH4_HPOINT;
  
  union {
    __IOM uint32_t reg;                         /*!< Initial duty cycle for channel 4                                          */
    
    struct {
      __IOM uint32_t DUTY       : 19;           /*!< This register is used to change the output duty by controlling
                                                     the Lpoint.The output value turns to low when the selected
                                                     timers has reached the Lpoint.                                            */
            uint32_t            : 13;
    } bit;
  } CH4_DUTY;
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 1 for channel 4                                    */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t DUTY_NUM   : 10;           /*!< This register is used to control the number of times the duty
                                                     cycle will be changed.                                                    */
            uint32_t            : 2;
    } bit;
  } CH4_CONF1;
  __IOM uint32_t  CH4_DUTY_R;                   /*!< Current duty cycle for channel 4                                          */
  __IM  uint32_t  RESERVED6[15];
  __IOM uint32_t  CH5_CONF0;                    /*!< Configuration register 0 for channel 5                                    */
  
  union {
    __IOM uint32_t reg;                         /*!< High point register for channel 5                                         */
    
    struct {
      __IOM uint32_t HPOINT     : 14;           /*!< The output value changes to high when the selected timers has
                                                     reached the value specified by this register.                             */
            uint32_t            : 18;
    } bit;
  } CH5_HPOINT;
  
  union {
    __IOM uint32_t reg;                         /*!< Initial duty cycle for channel 5                                          */
    
    struct {
      __IOM uint32_t DUTY       : 19;           /*!< This register is used to change the output duty by controlling
                                                     the Lpoint.The output value turns to low when the selected
                                                     timers has reached the Lpoint.                                            */
            uint32_t            : 13;
    } bit;
  } CH5_DUTY;
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 1 for channel 5                                    */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t DUTY_NUM   : 10;           /*!< This register is used to control the number of times the duty
                                                     cycle will be changed.                                                    */
            uint32_t            : 2;
    } bit;
  } CH5_CONF1;
  __IOM uint32_t  CH5_DUTY_R;                   /*!< Current duty cycle for channel 5                                          */
  __IM  uint32_t  RESERVED7[15];
  __IOM uint32_t  CH6_CONF0;                    /*!< Configuration register 0 for channel 6                                    */
  
  union {
    __IOM uint32_t reg;                         /*!< High point register for channel 6                                         */
    
    struct {
      __IOM uint32_t HPOINT     : 14;           /*!< The output value changes to high when the selected timers has
                                                     reached the value specified by this register.                             */
            uint32_t            : 18;
    } bit;
  } CH6_HPOINT;
  
  union {
    __IOM uint32_t reg;                         /*!< Initial duty cycle for channel 6                                          */
    
    struct {
      __IOM uint32_t DUTY       : 19;           /*!< This register is used to change the output duty by controlling
                                                     the Lpoint.The output value turns to low when the selected
                                                     timers has reached the Lpoint.                                            */
            uint32_t            : 13;
    } bit;
  } CH6_DUTY;
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 1 for channel 6                                    */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t DUTY_NUM   : 10;           /*!< This register is used to control the number of times the duty
                                                     cycle will be changed.                                                    */
            uint32_t            : 2;
    } bit;
  } CH6_CONF1;
  __IOM uint32_t  CH6_DUTY_R;                   /*!< Current duty cycle for channel 6                                          */
  __IM  uint32_t  RESERVED8[15];
  __IOM uint32_t  CH7_CONF0;                    /*!< Configuration register 0 for channel 7                                    */
  
  union {
    __IOM uint32_t reg;                         /*!< High point register for channel 7                                         */
    
    struct {
      __IOM uint32_t HPOINT     : 14;           /*!< The output value changes to high when the selected timers has
                                                     reached the value specified by this register.                             */
            uint32_t            : 18;
    } bit;
  } CH7_HPOINT;
  
  union {
    __IOM uint32_t reg;                         /*!< Initial duty cycle for channel 7                                          */
    
    struct {
      __IOM uint32_t DUTY       : 19;           /*!< This register is used to change the output duty by controlling
                                                     the Lpoint.The output value turns to low when the selected
                                                     timers has reached the Lpoint.                                            */
            uint32_t            : 13;
    } bit;
  } CH7_DUTY;
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 1 for channel 7                                    */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t DUTY_NUM   : 10;           /*!< This register is used to control the number of times the duty
                                                     cycle will be changed.                                                    */
            uint32_t            : 2;
    } bit;
  } CH7_CONF1;
  __IOM uint32_t  CH7_DUTY_R;                   /*!< Current duty cycle for channel 7                                          */
} LEDC_Type;                                    /*!< Size = 580 (0x244)                                                        */



/* =========================================================================================================================== */
/* ================                                           PCNT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Count Controller (PCNT)
  */

typedef struct {                                /*!< PCNT Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 0 for unit 0                                       */
    
    struct {
      __IOM uint32_t FILTER_THRES : 10;         /*!< This sets the maximum threshold, in APB_CLK cycles, for the
                                                     filter.Any pulses with width less than this will be ignored
                                                     when the filter is enabled.                                               */
            uint32_t            : 6;
      __IOM uint32_t CH0_NEG_MODE : 2;          /*!< This register sets the behavior when the signal input of channel
                                                     0 detects a negative edge.1: Increase the counter;2: Decrease
                                                     the counter;0, 3: No effect on counter                                    */
      __IOM uint32_t CH0_POS_MODE : 2;          /*!< This register sets the behavior when the signal input of channel
                                                     0 detects a positive edge.1: Increase the counter;2: Decrease
                                                     the counter;0, 3: No effect on counter                                    */
            uint32_t            : 4;
      __IOM uint32_t CH1_NEG_MODE : 2;          /*!< This register sets the behavior when the signal input of channel
                                                     1 detects a negative edge.1: Increment the counter;2: Decrement
                                                     the counter;0, 3: No effect on counter                                    */
      __IOM uint32_t CH1_POS_MODE : 2;          /*!< This register sets the behavior when the signal input of channel
                                                     1 detects a positive edge.1: Increment the counter;2: Decrement
                                                     the counter;0, 3: No effect on counter                                    */
            uint32_t            : 4;
    } bit;
  } U0_CONF0;
  __IOM uint32_t  U0_CONF1;                     /*!< Configuration register 1 for unit 0                                       */
  __IOM uint32_t  U0_CONF2;                     /*!< Configuration register 2 for unit 0                                       */
  __IM  uint32_t  RESERVED[9];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Configuration register 0 for unit 1                                       */
      
      struct {
        __IOM uint32_t FILTER_THRES : 10;       /*!< This sets the maximum threshold, in APB_CLK cycles, for the
                                                     filter.Any pulses with width less than this will be ignored
                                                     when the filter is enabled.                                               */
              uint32_t          : 6;
        __IOM uint32_t CH0_NEG_MODE : 2;        /*!< This register sets the behavior when the signal input of channel
                                                     0 detects a negative edge.1: Increase the counter;2: Decrease
                                                     the counter;0, 3: No effect on counter                                    */
        __IOM uint32_t CH0_POS_MODE : 2;        /*!< This register sets the behavior when the signal input of channel
                                                     0 detects a positive edge.1: Increase the counter;2: Decrease
                                                     the counter;0, 3: No effect on counter                                    */
              uint32_t          : 4;
        __IOM uint32_t CH1_NEG_MODE : 2;        /*!< This register sets the behavior when the signal input of channel
                                                     1 detects a negative edge.1: Increment the counter;2: Decrement
                                                     the counter;0, 3: No effect on counter                                    */
        __IOM uint32_t CH1_POS_MODE : 2;        /*!< This register sets the behavior when the signal input of channel
                                                     1 detects a positive edge.1: Increment the counter;2: Decrement
                                                     the counter;0, 3: No effect on counter                                    */
              uint32_t          : 4;
      } bit;
    } U1_CONF0;
    __IOM uint32_t U0_CNT;                      /*!< Counter value for unit 0                                                  */
  };
  __IOM uint32_t  U1_CONF1;                     /*!< Configuration register 1 for unit 1                                       */
  __IOM uint32_t  U1_CONF2;                     /*!< Configuration register 2 for unit 1                                       */
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t U1_CNT;                      /*!< Counter value for unit 1                                                  */
    
    union {
      __IOM uint32_t reg;                       /*!< Interrupt raw status register                                             */
      
      struct {
        __IM  uint32_t CNT_THR_EVENT_U0 : 1;    /*!< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT
                                                     interrupt.                                                                */
        __IM  uint32_t CNT_THR_EVENT_U1 : 1;    /*!< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT
                                                     interrupt.                                                                */
        __IM  uint32_t CNT_THR_EVENT_U2 : 1;    /*!< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT
                                                     interrupt.                                                                */
        __IM  uint32_t CNT_THR_EVENT_U3 : 1;    /*!< The raw interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT
                                                     interrupt.                                                                */
              uint32_t          : 28;
      } bit;
    } INT_RAW;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt status register                                                 */
    
    struct {
      __IM  uint32_t CNT_THR_EVENT_U0 : 1;      /*!< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U0_INT
                                                     interrupt.                                                                */
      __IM  uint32_t CNT_THR_EVENT_U1 : 1;      /*!< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U1_INT
                                                     interrupt.                                                                */
      __IM  uint32_t CNT_THR_EVENT_U2 : 1;      /*!< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U2_INT
                                                     interrupt.                                                                */
      __IM  uint32_t CNT_THR_EVENT_U3 : 1;      /*!< The masked interrupt status bit for the PCNT_CNT_THR_EVENT_U3_INT
                                                     interrupt.                                                                */
            uint32_t            : 28;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable register                                                 */
    
    struct {
      __IOM uint32_t CNT_THR_EVENT_U0 : 1;      /*!< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U0_INT interrupt.     */
      __IOM uint32_t CNT_THR_EVENT_U1 : 1;      /*!< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U1_INT interrupt.     */
      __IOM uint32_t CNT_THR_EVENT_U2 : 1;      /*!< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U2_INT interrupt.     */
      __IOM uint32_t CNT_THR_EVENT_U3 : 1;      /*!< The interrupt enable bit for the PCNT_CNT_THR_EVENT_U3_INT interrupt.     */
            uint32_t            : 28;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear register                                                  */
    
    struct {
      __OM  uint32_t CNT_THR_EVENT_U0 : 1;      /*!< Set this bit to clear the PCNT_CNT_THR_EVENT_U0_INT interrupt.            */
      __OM  uint32_t CNT_THR_EVENT_U1 : 1;      /*!< Set this bit to clear the PCNT_CNT_THR_EVENT_U1_INT interrupt.            */
      __OM  uint32_t CNT_THR_EVENT_U2 : 1;      /*!< Set this bit to clear the PCNT_CNT_THR_EVENT_U2_INT interrupt.            */
      __OM  uint32_t CNT_THR_EVENT_U3 : 1;      /*!< Set this bit to clear the PCNT_CNT_THR_EVENT_U3_INT interrupt.            */
            uint32_t            : 28;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t U2_CNT;                      /*!< Counter value for unit 2                                                  */
    __IOM uint32_t U0_STATUS;                   /*!< PNCT UNIT0 status register                                                */
  };
  __IM  uint32_t  RESERVED2[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Configuration register 0 for unit 2                                       */
      
      struct {
        __IOM uint32_t FILTER_THRES : 10;       /*!< This sets the maximum threshold, in APB_CLK cycles, for the
                                                     filter.Any pulses with width less than this will be ignored
                                                     when the filter is enabled.                                               */
              uint32_t          : 6;
        __IOM uint32_t CH0_NEG_MODE : 2;        /*!< This register sets the behavior when the signal input of channel
                                                     0 detects a negative edge.1: Increase the counter;2: Decrease
                                                     the counter;0, 3: No effect on counter                                    */
        __IOM uint32_t CH0_POS_MODE : 2;        /*!< This register sets the behavior when the signal input of channel
                                                     0 detects a positive edge.1: Increase the counter;2: Decrease
                                                     the counter;0, 3: No effect on counter                                    */
              uint32_t          : 4;
        __IOM uint32_t CH1_NEG_MODE : 2;        /*!< This register sets the behavior when the signal input of channel
                                                     1 detects a negative edge.1: Increment the counter;2: Decrement
                                                     the counter;0, 3: No effect on counter                                    */
        __IOM uint32_t CH1_POS_MODE : 2;        /*!< This register sets the behavior when the signal input of channel
                                                     1 detects a positive edge.1: Increment the counter;2: Decrement
                                                     the counter;0, 3: No effect on counter                                    */
              uint32_t          : 4;
      } bit;
    } U2_CONF0;
    __IOM uint32_t U3_CNT;                      /*!< Counter value for unit 3                                                  */
    __IOM uint32_t U1_STATUS;                   /*!< PNCT UNIT1 status register                                                */
    
    union {
      __IOM uint32_t reg;                       /*!< Control register for all counters                                         */
      
      struct {
        __IOM uint32_t CNT_RST_U0 : 1;          /*!< Set this bit to clear unit 0's counter.                                   */
        __IOM uint32_t CNT_PAUSE_U0 : 1;        /*!< Set this bit to freeze unit 0's counter.                                  */
        __IOM uint32_t CNT_RST_U1 : 1;          /*!< Set this bit to clear unit 1's counter.                                   */
        __IOM uint32_t CNT_PAUSE_U1 : 1;        /*!< Set this bit to freeze unit 1's counter.                                  */
        __IOM uint32_t CNT_RST_U2 : 1;          /*!< Set this bit to clear unit 2's counter.                                   */
        __IOM uint32_t CNT_PAUSE_U2 : 1;        /*!< Set this bit to freeze unit 2's counter.                                  */
        __IOM uint32_t CNT_RST_U3 : 1;          /*!< Set this bit to clear unit 3's counter.                                   */
        __IOM uint32_t CNT_PAUSE_U3 : 1;        /*!< Set this bit to freeze unit 3's counter.                                  */
              uint32_t          : 8;
        __IOM uint32_t CLK_EN   : 1;            /*!< The registers clock gate enable signal of PCNT module. 1: the
                                                     registers can be read and written by application. 0: the
                                                     registers can not be read or written by application                       */
              uint32_t          : 15;
      } bit;
    } CTRL;
  };
  __IOM uint32_t  U2_CONF1;                     /*!< Configuration register 1 for unit 2                                       */
  __IOM uint32_t  U2_CONF2;                     /*!< Configuration register 2 for unit 2                                       */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  U2_STATUS;                    /*!< PNCT UNIT2 status register                                                */
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  U3_STATUS;                    /*!< PNCT UNIT3 status register                                                */
  __IM  uint32_t  RESERVED5[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 0 for unit 3                                       */
    
    struct {
      __IOM uint32_t FILTER_THRES : 10;         /*!< This sets the maximum threshold, in APB_CLK cycles, for the
                                                     filter.Any pulses with width less than this will be ignored
                                                     when the filter is enabled.                                               */
            uint32_t            : 6;
      __IOM uint32_t CH0_NEG_MODE : 2;          /*!< This register sets the behavior when the signal input of channel
                                                     0 detects a negative edge.1: Increase the counter;2: Decrease
                                                     the counter;0, 3: No effect on counter                                    */
      __IOM uint32_t CH0_POS_MODE : 2;          /*!< This register sets the behavior when the signal input of channel
                                                     0 detects a positive edge.1: Increase the counter;2: Decrease
                                                     the counter;0, 3: No effect on counter                                    */
            uint32_t            : 4;
      __IOM uint32_t CH1_NEG_MODE : 2;          /*!< This register sets the behavior when the signal input of channel
                                                     1 detects a negative edge.1: Increment the counter;2: Decrement
                                                     the counter;0, 3: No effect on counter                                    */
      __IOM uint32_t CH1_POS_MODE : 2;          /*!< This register sets the behavior when the signal input of channel
                                                     1 detects a positive edge.1: Increment the counter;2: Decrement
                                                     the counter;0, 3: No effect on counter                                    */
            uint32_t            : 4;
    } bit;
  } U3_CONF0;
  __IOM uint32_t  U3_CONF1;                     /*!< Configuration register 1 for unit 3                                       */
  __IOM uint32_t  U3_CONF2;                     /*!< Configuration register 2 for unit 3                                       */
  __IM  uint32_t  RESERVED6[24];
  
  union {
    __IOM uint32_t reg;                         /*!< PCNT version control register                                             */
    
    struct {
      __IOM uint32_t DATE       : 32;           /*!< This is the PCNT version control register.                                */
    } bit;
  } DATE;
} PCNT_Type;                                    /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                        PERI_BACKUP                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief PERI_BACKUP Peripheral (PERI_BACKUP)
  */

typedef struct {                                /*!< PERI_BACKUP Structure                                                     */
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IM  uint32_t FLOW_ERR   : 3;            /*!< x                                                                         */
      __IOM uint32_t ADDR_MAP_MODE : 1;         /*!< x                                                                         */
      __IOM uint32_t BURST_LIMIT : 5;           /*!< x                                                                         */
      __IOM uint32_t TOUT_THRES : 10;           /*!< x                                                                         */
      __IOM uint32_t SIZE       : 10;           /*!< x                                                                         */
      __OM  uint32_t START      : 1;            /*!< x                                                                         */
      __IOM uint32_t TO_MEM     : 1;            /*!< x                                                                         */
      __IOM uint32_t ENA        : 1;            /*!< x                                                                         */
    } bit;
  } CONFIG;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IOM uint32_t APB_START_ADDR : 32;       /*!< x                                                                         */
    } bit;
  } APB_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IOM uint32_t MEM_START_ADDR : 32;       /*!< x                                                                         */
    } bit;
  } MEM_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IOM uint32_t MAP0       : 32;           /*!< x                                                                         */
    } bit;
  } REG_MAP0;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IOM uint32_t MAP1       : 32;           /*!< x                                                                         */
    } bit;
  } REG_MAP1;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IOM uint32_t MAP2       : 32;           /*!< x                                                                         */
    } bit;
  } REG_MAP2;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IOM uint32_t MAP3       : 32;           /*!< x                                                                         */
    } bit;
  } REG_MAP3;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IM  uint32_t DONE_INT_RAW : 1;          /*!< x                                                                         */
      __IM  uint32_t ERR_INT_RAW : 1;           /*!< x                                                                         */
            uint32_t            : 30;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IM  uint32_t DONE_INT_ST : 1;           /*!< x                                                                         */
      __IM  uint32_t ERR_INT_ST : 1;            /*!< x                                                                         */
            uint32_t            : 30;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IOM uint32_t DONE_INT_ENA : 1;          /*!< x                                                                         */
      __IOM uint32_t ERR_INT_ENA : 1;           /*!< x                                                                         */
            uint32_t            : 30;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __OM  uint32_t DONE_INT_CLR : 1;          /*!< x                                                                         */
      __OM  uint32_t ERR_INT_CLR : 1;           /*!< x                                                                         */
            uint32_t            : 30;
    } bit;
  } INT_CLR;
  __IM  uint32_t  RESERVED[52];
  
  union {
    __IOM uint32_t reg;                         /*!< x                                                                         */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< x                                                                         */
            uint32_t            : 3;
      __IOM uint32_t CLK_EN     : 1;            /*!< register file clk gating                                                  */
    } bit;
  } DATE;
} PERI_BACKUP_Type;                             /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                          MCPWM0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Motor Control Pulse-Width Modulation 0 (MCPWM0)
  */

typedef struct {                                /*!< MCPWM0 Structure                                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< PWM clock prescaler register.                                             */
    
    struct {
      __IOM uint32_t CLK_PRESCALE : 8;          /*!< Period of PWM_clk = 6.25ns * (PWM_CLK_PRESCALE + 1)                       */
            uint32_t            : 24;
    } bit;
  } CLK_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer0 period and update method configuration register.               */
    
    struct {
      __IOM uint32_t TIMER0_PRESCALE : 8;       /*!< period of PT0_clk = Period of PWM_clk * (PWM_TIMER0_PRESCALE
                                                     + 1)                                                                      */
      __IOM uint32_t TIMER0_PERIOD : 16;        /*!< period shadow register of PWM timer0                                      */
      __IOM uint32_t TIMER0_PERIOD_UPMETHOD : 2;/*!< Update method for active register of PWM timer0 period, 0: immediate,
                                                     1: TEZ, 2: sync, 3: TEZ | sync. TEZ here and below means
                                                     timer equal zero event                                                    */
            uint32_t            : 6;
    } bit;
  } TIMER0_CFG0;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer0 working mode and start/stop control configuration
                                                     register.                                                                 */
    
    struct {
      __IOM uint32_t TIMER0_START : 3;          /*!< PWM timer0 start and stop control. 0: if PWM timer0 starts,
                                                     then stops at TEZ, 1: if timer0 starts, then stops at TEP,
                                                     2: PWM timer0 starts and runs on, 3: timer0 starts and
                                                     stops at the next TEZ, 4: timer0 starts and stops at the
                                                     next TEP. TEP here and below means the event that happens
                                                     when the timer equals to period                                           */
      __IOM uint32_t TIMER0_MOD : 2;            /*!< PWM timer0 working mode, 0: freeze, 1: increase mode, 2: decrease
                                                     mode, 3: up-down mode                                                     */
            uint32_t            : 27;
    } bit;
  } TIMER0_CFG1;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer0 sync function configuration register.                          */
    
    struct {
      __IOM uint32_t TIMER0_SYNCI_EN : 1;       /*!< When set, timer reloading with phase on sync input event is
                                                     enabled.                                                                  */
      __IOM uint32_t SW         : 1;            /*!< Toggling this bit will trigger a software sync.                           */
      __IOM uint32_t TIMER0_SYNCO_SEL : 2;      /*!< PWM timer0 sync_out selection, 0: synci, 1: TEZ, 2: TEP, otherwise:sync
                                                     out is software sync                                                      */
      __IOM uint32_t TIMER0_PHASE : 16;         /*!< phase for timer reload on sync event                                      */
      __IOM uint32_t TIMER0_PHASE_DIRECTION : 1;/*!< Configure the PWM timer0's direction when timer0 mode is up-down
                                                     mode. 0: increase; 1: decrease.                                           */
            uint32_t            : 11;
    } bit;
  } TIMER0_SYNC;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer0 status register.                                               */
    
    struct {
      __IM  uint32_t TIMER0_VALUE : 16;         /*!< current PWM timer0 counter value                                          */
      __IM  uint32_t TIMER0_DIRECTION : 1;      /*!< current PWM timer0 counter direction, 0: increment 1: decrement           */
            uint32_t            : 15;
    } bit;
  } TIMER0_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer1 period and update method configuration register.               */
    
    struct {
      __IOM uint32_t TIMER1_PRESCALE : 8;       /*!< period of PT0_clk = Period of PWM_clk * (PWM_timer1_PRESCALE
                                                     + 1)                                                                      */
      __IOM uint32_t TIMER1_PERIOD : 16;        /*!< period shadow register of PWM timer1                                      */
      __IOM uint32_t TIMER1_PERIOD_UPMETHOD : 2;/*!< Update method for active register of PWM timer1 period, 0: immediate,
                                                     1: TEZ, 2: sync, 3: TEZ | sync. TEZ here and below means
                                                     timer equal zero event                                                    */
            uint32_t            : 6;
    } bit;
  } TIMER1_CFG0;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer1 working mode and start/stop control configuration
                                                     register.                                                                 */
    
    struct {
      __IOM uint32_t TIMER1_START : 3;          /*!< PWM timer1 start and stop control. 0: if PWM timer1 starts,
                                                     then stops at TEZ, 1: if timer1 starts, then stops at TEP,
                                                     2: PWM timer1 starts and runs on, 3: timer1 starts and
                                                     stops at the next TEZ, 4: timer1 starts and stops at the
                                                     next TEP. TEP here and below means the event that happens
                                                     when the timer equals to period                                           */
      __IOM uint32_t TIMER1_MOD : 2;            /*!< PWM timer1 working mode, 0: freeze, 1: increase mode, 2: decrease
                                                     mode, 3: up-down mode                                                     */
            uint32_t            : 27;
    } bit;
  } TIMER1_CFG1;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer1 sync function configuration register.                          */
    
    struct {
      __IOM uint32_t TIMER1_SYNCI_EN : 1;       /*!< When set, timer reloading with phase on sync input event is
                                                     enabled.                                                                  */
      __IOM uint32_t SW         : 1;            /*!< Toggling this bit will trigger a software sync.                           */
      __IOM uint32_t TIMER1_SYNCO_SEL : 2;      /*!< PWM timer1 sync_out selection, 0: synci, 1: TEZ, 2: TEP, otherwise:sync
                                                     out is software sync                                                      */
      __IOM uint32_t TIMER1_PHASE : 16;         /*!< phase for timer reload on sync event                                      */
      __IOM uint32_t TIMER1_PHASE_DIRECTION : 1;/*!< Configure the PWM timer1's direction when timer1 mode is up-down
                                                     mode. 0: increase; 1: decrease.                                           */
            uint32_t            : 11;
    } bit;
  } TIMER1_SYNC;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer1 status register.                                               */
    
    struct {
      __IM  uint32_t TIMER1_VALUE : 16;         /*!< current PWM timer1 counter value                                          */
      __IM  uint32_t TIMER1_DIRECTION : 1;      /*!< current PWM timer1 counter direction, 0: increment 1: decrement           */
            uint32_t            : 15;
    } bit;
  } TIMER1_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer2 period and update method configuration register.               */
    
    struct {
      __IOM uint32_t TIMER2_PRESCALE : 8;       /*!< period of PT0_clk = Period of PWM_clk * (PWM_timer2_PRESCALE
                                                     + 1)                                                                      */
      __IOM uint32_t TIMER2_PERIOD : 16;        /*!< period shadow register of PWM timer2                                      */
      __IOM uint32_t TIMER2_PERIOD_UPMETHOD : 2;/*!< Update method for active register of PWM timer2 period, 0: immediate,
                                                     1: TEZ, 2: sync, 3: TEZ | sync. TEZ here and below means
                                                     timer equal zero event                                                    */
            uint32_t            : 6;
    } bit;
  } TIMER2_CFG0;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer2 working mode and start/stop control configuration
                                                     register.                                                                 */
    
    struct {
      __IOM uint32_t TIMER2_START : 3;          /*!< PWM timer2 start and stop control. 0: if PWM timer2 starts,
                                                     then stops at TEZ, 1: if timer2 starts, then stops at TEP,
                                                     2: PWM timer2 starts and runs on, 3: timer2 starts and
                                                     stops at the next TEZ, 4: timer2 starts and stops at the
                                                     next TEP. TEP here and below means the event that happens
                                                     when the timer equals to period                                           */
      __IOM uint32_t TIMER2_MOD : 2;            /*!< PWM timer2 working mode, 0: freeze, 1: increase mode, 2: decrease
                                                     mode, 3: up-down mode                                                     */
            uint32_t            : 27;
    } bit;
  } TIMER2_CFG1;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer2 sync function configuration register.                          */
    
    struct {
      __IOM uint32_t TIMER2_SYNCI_EN : 1;       /*!< When set, timer reloading with phase on sync input event is
                                                     enabled.                                                                  */
      __IOM uint32_t SW         : 1;            /*!< Toggling this bit will trigger a software sync.                           */
      __IOM uint32_t TIMER2_SYNCO_SEL : 2;      /*!< PWM timer2 sync_out selection, 0: synci, 1: TEZ, 2: TEP, otherwise:sync
                                                     out is software sync                                                      */
      __IOM uint32_t TIMER2_PHASE : 16;         /*!< phase for timer reload on sync event                                      */
      __IOM uint32_t TIMER2_PHASE_DIRECTION : 1;/*!< Configure the PWM timer2's direction when timer2 mode is up-down
                                                     mode. 0: increase; 1: decrease.                                           */
            uint32_t            : 11;
    } bit;
  } TIMER2_SYNC;
  
  union {
    __IOM uint32_t reg;                         /*!< PWM timer2 status register.                                               */
    
    struct {
      __IM  uint32_t TIMER2_VALUE : 16;         /*!< current PWM timer2 counter value                                          */
      __IM  uint32_t TIMER2_DIRECTION : 1;      /*!< current PWM timer2 counter direction, 0: increment 1: decrement           */
            uint32_t            : 15;
    } bit;
  } TIMER2_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Synchronization input selection for three PWM timers.                     */
    
    struct {
      __IOM uint32_t TIMER0_SYNCISEL : 3;       /*!< select sync input for PWM timer0, 1: PWM timer0 sync_out, 2:
                                                     PWM timer1 sync_out, 3: PWM timer2 sync_out, 4: SYNC0 from
                                                     GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO
                                                     matrix, other values: no sync input selected                              */
      __IOM uint32_t TIMER1_SYNCISEL : 3;       /*!< select sync input for PWM timer1, 1: PWM timer0 sync_out, 2:
                                                     PWM timer1 sync_out, 3: PWM timer2 sync_out, 4: SYNC0 from
                                                     GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO
                                                     matrix, other values: no sync input selected                              */
      __IOM uint32_t TIMER2_SYNCISEL : 3;       /*!< select sync input for PWM timer2, 1: PWM timer0 sync_out, 2:
                                                     PWM timer1 sync_out, 3: PWM timer2 sync_out, 4: SYNC0 from
                                                     GPIO matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO
                                                     matrix, other values: no sync input selected                              */
      __IOM uint32_t EXTERNAL_SYNCI0_INVERT : 1;/*!< invert SYNC0 from GPIO matrix                                             */
      __IOM uint32_t EXTERNAL_SYNCI1_INVERT : 1;/*!< invert SYNC1 from GPIO matrix                                             */
      __IOM uint32_t EXTERNAL_SYNCI2_INVERT : 1;/*!< invert SYNC2 from GPIO matrix                                             */
            uint32_t            : 20;
    } bit;
  } TIMER_SYNCI_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Select specific timer for PWM operators.                                  */
    
    struct {
      __IOM uint32_t OPERATOR0_TIMERSEL : 2;    /*!< Select which PWM timer's is the timing reference for PWM operator0,
                                                     0: timer0, 1: timer1, 2: timer2                                           */
      __IOM uint32_t OPERATOR1_TIMERSEL : 2;    /*!< Select which PWM timer's is the timing reference for PWM operator1,
                                                     0: timer0, 1: timer1, 2: timer2                                           */
      __IOM uint32_t OPERATOR2_TIMERSEL : 2;    /*!< Select which PWM timer's is the timing reference for PWM operator2,
                                                     0: timer0, 1: timer1, 2: timer2                                           */
            uint32_t            : 26;
    } bit;
  } OPERATOR_TIMERSEL;
  
  union {
    __IOM uint32_t reg;                         /*!< Transfer status and update method for time stamp registers A
                                                     and B                                                                     */
    
    struct {
      __IOM uint32_t CMPR0_A_UPMETHOD : 4;      /*!< Update method for PWM generator 0 time stamp A's active register.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set
                                                     to 1: sync, when bit3 is set to 1: disable the update.                    */
      __IOM uint32_t CMPR0_B_UPMETHOD : 4;      /*!< Update method for PWM generator 0 time stamp B's active register.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set
                                                     to 1: sync, when bit3 is set to 1: disable the update.                    */
      __IOM uint32_t CMPR0_A_SHDW_FULL : 1;     /*!< Set and reset by hardware. If set, PWM generator 0 time stamp
                                                     A's shadow reg is filled and waiting to be transferred
                                                     to A's active reg. If cleared, A's active reg has been
                                                     updated with shadow register latest value                                 */
      __IOM uint32_t CMPR0_B_SHDW_FULL : 1;     /*!< Set and reset by hardware. If set, PWM generator 0 time stamp
                                                     B's shadow reg is filled and waiting to be transferred
                                                     to B's active reg. If cleared, B's active reg has been
                                                     updated with shadow register latest value                                 */
            uint32_t            : 22;
    } bit;
  } CMPR0_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for register A.                                           */
    
    struct {
      __IOM uint32_t CMPR0_A    : 16;           /*!< PWM generator 0 time stamp A's shadow register                            */
            uint32_t            : 16;
    } bit;
  } CMPR0_VALUE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for register B.                                           */
    
    struct {
      __IOM uint32_t CMPR0_B    : 16;           /*!< PWM generator 0 time stamp B's shadow register                            */
            uint32_t            : 16;
    } bit;
  } CMPR0_VALUE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Fault event T0 and T1 handling                                            */
    
    struct {
      __IOM uint32_t GEN0_CFG_UPMETHOD : 4;     /*!< Update method for PWM generator 0's active register of configuration.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ, when bit1 is set to 1:                                         */
      __IOM uint32_t GEN0_T0_SEL : 3;           /*!< Source selection for PWM generator 0 event_t0, take effect immediately,
                                                     0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken,
                                                     4: none                                                                   */
      __IOM uint32_t GEN0_T1_SEL : 3;           /*!< Source selection for PWM generator 0 event_t1, take effect immediately,
                                                     0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken,
                                                     4: none                                                                   */
            uint32_t            : 22;
    } bit;
  } GEN0_CFG0;
  
  union {
    __IOM uint32_t reg;                         /*!< Permissives to force PWM0A and PWM0B outputs by software                  */
    
    struct {
      __IOM uint32_t GEN0_CNTUFORCE_UPMETHOD : 6;/*!< Updating method for continuous software force of PWM generator0.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ,,when bit1 is set to 1: TEP, when bit2 is set
                                                     to 1: TEA, when bit3 is set to 1: TEB, when bit4 is set
                                                     to 1: sync, when bit5 is set to 1: disable update. (TEA/B
                                                     here and below means an event generated when the timer's
                                                     value equals to that of register A/B.)                                    */
      __IOM uint32_t GEN0_A_CNTUFORCE_MODE : 2; /*!< Continuous software force mode for PWM0A. 0: disabled, 1: low,
                                                     2: high, 3: disabled                                                      */
      __IOM uint32_t GEN0_B_CNTUFORCE_MODE : 2; /*!< Continuous software force mode for PWM0B. 0: disabled, 1: low,
                                                     2: high, 3: disabled                                                      */
      __IOM uint32_t GEN0_A_NCIFORCE : 1;       /*!< Trigger of non-continuous immediate software-force event for
                                                     PWM0A, a toggle will trigger a force event.                               */
      __IOM uint32_t GEN0_A_NCIFORCE_MODE : 2;  /*!< non-continuous immediate software force mode for PWM0A, 0: disabled,
                                                     1: low, 2: high, 3: disabled                                              */
      __IOM uint32_t GEN0_B_NCIFORCE : 1;       /*!< Trigger of non-continuous immediate software-force event for
                                                     PWM0B, a toggle will trigger a force event.                               */
      __IOM uint32_t GEN0_B_NCIFORCE_MODE : 2;  /*!< non-continuous immediate software force mode for PWM0B, 0: disabled,
                                                     1: low, 2: high, 3: disabled                                              */
            uint32_t            : 16;
    } bit;
  } GEN0_FORCE;
  
  union {
    __IOM uint32_t reg;                         /*!< Actions triggered by events on PWM0A                                      */
    
    struct {
      __IOM uint32_t UTEZ       : 2;            /*!< Action on PWM0A triggered by event TEZ when timer increasing              */
      __IOM uint32_t UTEP       : 2;            /*!< Action on PWM0A triggered by event TEP when timer increasing              */
      __IOM uint32_t UTEA       : 2;            /*!< Action on PWM0A triggered by event TEA when timer increasing              */
      __IOM uint32_t UTEB       : 2;            /*!< Action on PWM0A triggered by event TEB when timer increasing              */
      __IOM uint32_t UT0        : 2;            /*!< Action on PWM0A triggered by event_t0 when timer increasing               */
      __IOM uint32_t UT1        : 2;            /*!< Action on PWM0A triggered by event_t1 when timer increasing               */
      __IOM uint32_t DTEZ       : 2;            /*!< Action on PWM0A triggered by event TEZ when timer decreasing              */
      __IOM uint32_t DTEP       : 2;            /*!< Action on PWM0A triggered by event TEP when timer decreasing              */
      __IOM uint32_t DTEA       : 2;            /*!< Action on PWM0A triggered by event TEA when timer decreasing              */
      __IOM uint32_t DTEB       : 2;            /*!< Action on PWM0A triggered by event TEB when timer decreasing              */
      __IOM uint32_t DT0        : 2;            /*!< Action on PWM0A triggered by event_t0 when timer decreasing               */
      __IOM uint32_t DT1        : 2;            /*!< Action on PWM0A triggered by event_t1 when timer decreasing.
                                                     0: no change, 1: low, 2: high, 3: toggle                                  */
            uint32_t            : 8;
    } bit;
  } GEN0_A;
  
  union {
    __IOM uint32_t reg;                         /*!< Actions triggered by events on PWM0B                                      */
    
    struct {
      __IOM uint32_t UTEZ       : 2;            /*!< Action on PWM0B triggered by event TEZ when timer increasing              */
      __IOM uint32_t UTEP       : 2;            /*!< Action on PWM0B triggered by event TEP when timer increasing              */
      __IOM uint32_t UTEA       : 2;            /*!< Action on PWM0B triggered by event TEA when timer increasing              */
      __IOM uint32_t UTEB       : 2;            /*!< Action on PWM0B triggered by event TEB when timer increasing              */
      __IOM uint32_t UT0        : 2;            /*!< Action on PWM0B triggered by event_t0 when timer increasing               */
      __IOM uint32_t UT1        : 2;            /*!< Action on PWM0B triggered by event_t1 when timer increasing               */
      __IOM uint32_t DTEZ       : 2;            /*!< Action on PWM0B triggered by event TEZ when timer decreasing              */
      __IOM uint32_t DTEP       : 2;            /*!< Action on PWM0B triggered by event TEP when timer decreasing              */
      __IOM uint32_t DTEA       : 2;            /*!< Action on PWM0B triggered by event TEA when timer decreasing              */
      __IOM uint32_t DTEB       : 2;            /*!< Action on PWM0B triggered by event TEB when timer decreasing              */
      __IOM uint32_t DT0        : 2;            /*!< Action on PWM0B triggered by event_t0 when timer decreasing               */
      __IOM uint32_t DT1        : 2;            /*!< Action on PWM0B triggered by event_t1 when timer decreasing.
                                                     0: no change, 1: low, 2: high, 3: toggle                                  */
            uint32_t            : 8;
    } bit;
  } GEN0_B;
  
  union {
    __IOM uint32_t reg;                         /*!< dead time type selection and configuration                                */
    
    struct {
      __IOM uint32_t DB0_FED_UPMETHOD : 4;      /*!< Update method for FED (falling edge delay) active register.
                                                     0: immediate, bit0: tez, bit1: tep, bit2: sync, bit3: freeze              */
      __IOM uint32_t DB0_RED_UPMETHOD : 4;      /*!< Update method for RED (rising edge delay) active register. 0:
                                                     immediate, bit0: tez, bit1: tep, bit2: sync, bit3: freeze                 */
      __IOM uint32_t DB0_DEB_MODE : 1;          /*!< S8 in documentation, dual-edge B mode, 0: fed/red take effect
                                                     on different path separately, 1: fed/red take effect on
                                                     B path, A out is in bypass or dulpB mode                                  */
      __IOM uint32_t DB0_A_OUTSWAP : 1;         /*!< S6 in documentation                                                       */
      __IOM uint32_t DB0_B_OUTSWAP : 1;         /*!< S7 in documentation                                                       */
      __IOM uint32_t DB0_RED_INSEL : 1;         /*!< S4 in documentation                                                       */
      __IOM uint32_t DB0_FED_INSEL : 1;         /*!< S5 in documentation                                                       */
      __IOM uint32_t DB0_RED_OUTINVERT : 1;     /*!< S2 in documentation                                                       */
      __IOM uint32_t DB0_FED_OUTINVERT : 1;     /*!< S3 in documentation                                                       */
      __IOM uint32_t DB0_A_OUTBYPASS : 1;       /*!< S1 in documentation                                                       */
      __IOM uint32_t DB0_B_OUTBYPASS : 1;       /*!< S0 in documentation                                                       */
      __IOM uint32_t DB0_CLK_SEL : 1;           /*!< Dead time generator 0 clock selection. 0: PWM_clk, 1: PT_clk              */
            uint32_t            : 14;
    } bit;
  } DB0_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for falling edge delay (FED).                             */
    
    struct {
      __IOM uint32_t DB0_FED    : 16;           /*!< Shadow register for FED                                                   */
            uint32_t            : 16;
    } bit;
  } DB0_FED_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for rising edge delay (RED).                              */
    
    struct {
      __IOM uint32_t DB0_RED    : 16;           /*!< Shadow register for RED                                                   */
            uint32_t            : 16;
    } bit;
  } DB0_RED_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Carrier enable and configuratoin                                          */
    
    struct {
      __IOM uint32_t CHOPPER0_EN : 1;           /*!< When set, carrier0 function is enabled. When cleared, carrier0
                                                     is bypassed                                                               */
      __IOM uint32_t CHOPPER0_PRESCALE : 4;     /*!< PWM carrier0 clock (PC_clk) prescale value. Period of PC_clk
                                                     = period of PWM_clk * (PWM_CARRIER0_PRESCALE + 1)                         */
      __IOM uint32_t CHOPPER0_DUTY : 3;         /*!< carrier duty selection. Duty = PWM_CARRIER0_DUTY / 8                      */
      __IOM uint32_t CHOPPER0_OSHTWTH : 4;      /*!< width of the fist pulse in number of periods of the carrier               */
      __IOM uint32_t CHOPPER0_OUT_INVERT : 1;   /*!< when set, invert the output of PWM0A and PWM0B for this submodule         */
      __IOM uint32_t CHOPPER0_IN_INVERT : 1;    /*!< when set, invert the input of PWM0A and PWM0B for this submodule          */
            uint32_t            : 18;
    } bit;
  } CHOPPER0_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Actions on PWM0A and PWM0B trip events                                    */
    
    struct {
      __IOM uint32_t TZ0_SW_CBC : 1;            /*!< Enable register for software force cycle-by-cycle mode action.
                                                     0: disable, 1: enable                                                     */
      __IOM uint32_t TZ0_F2_CBC : 1;            /*!< event_f2 will trigger cycle-by-cycle mode action. 0: disable,
                                                     1: enable                                                                 */
      __IOM uint32_t TZ0_F1_CBC : 1;            /*!< event_f1 will trigger cycle-by-cycle mode action. 0: disable,
                                                     1: enable                                                                 */
      __IOM uint32_t TZ0_F0_CBC : 1;            /*!< event_f0 will trigger cycle-by-cycle mode action. 0: disable,
                                                     1: enable                                                                 */
      __IOM uint32_t TZ0_SW_OST : 1;            /*!< Enable register for software force one-shot mode action. 0:
                                                     disable, 1: enable                                                        */
      __IOM uint32_t TZ0_F2_OST : 1;            /*!< event_f2 will trigger one-shot mode action. 0: disable, 1: enable         */
      __IOM uint32_t TZ0_F1_OST : 1;            /*!< event_f1 will trigger one-shot mode action. 0: disable, 1: enable         */
      __IOM uint32_t TZ0_F0_OST : 1;            /*!< event_f0 will trigger one-shot mode action. 0: disable, 1: enable         */
      __IOM uint32_t TZ0_A_CBC_D : 2;           /*!< Cycle-by-cycle mode action on PWM0A when fault event occurs
                                                     and timer is decreasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ0_A_CBC_U : 2;           /*!< Cycle-by-cycle mode action on PWM0A when fault event occurs
                                                     and timer is increasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ0_A_OST_D : 2;           /*!< One-shot mode action on PWM0A when fault event occurs and timer
                                                     is decreasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
      __IOM uint32_t TZ0_A_OST_U : 2;           /*!< One-shot mode action on PWM0A when fault event occurs and timer
                                                     is increasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
      __IOM uint32_t TZ0_B_CBC_D : 2;           /*!< Cycle-by-cycle mode action on PWM0B when fault event occurs
                                                     and timer is decreasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ0_B_CBC_U : 2;           /*!< Cycle-by-cycle mode action on PWM0B when fault event occurs
                                                     and timer is increasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ0_B_OST_D : 2;           /*!< One-shot mode action on PWM0B when fault event occurs and timer
                                                     is decreasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
      __IOM uint32_t TZ0_B_OST_U : 2;           /*!< One-shot mode action on PWM0B when fault event occurs and timer
                                                     is increasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
            uint32_t            : 8;
    } bit;
  } TZ0_CFG0;
  
  union {
    __IOM uint32_t reg;                         /*!< Software triggers for fault handler actions                               */
    
    struct {
      __IOM uint32_t TZ0_CLR_OST : 1;           /*!< a rising edge will clear on going one-shot mode action                    */
      __IOM uint32_t TZ0_CBCPULSE : 2;          /*!< cycle-by-cycle mode action refresh moment selection. Bit0: TEZ,
                                                     bit1:TEP                                                                  */
      __IOM uint32_t TZ0_FORCE_CBC : 1;         /*!< a toggle trigger a cycle-by-cycle mode action                             */
      __IOM uint32_t TZ0_FORCE_OST : 1;         /*!< a toggle (software negate its value) triggers a one-shot mode
                                                     action                                                                    */
            uint32_t            : 27;
    } bit;
  } TZ0_CFG1;
  
  union {
    __IOM uint32_t reg;                         /*!< Status of fault events.                                                   */
    
    struct {
      __IM  uint32_t TZ0_CBC_ON : 1;            /*!< Set and reset by hardware. If set, a cycle-by-cycle mode action
                                                     is on going                                                               */
      __IM  uint32_t TZ0_OST_ON : 1;            /*!< Set and reset by hardware. If set, an one-shot mode action is
                                                     on going                                                                  */
            uint32_t            : 30;
    } bit;
  } TZ0_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Transfer status and update method for time stamp registers A
                                                     and B                                                                     */
    
    struct {
      __IOM uint32_t CMPR1_A_UPMETHOD : 4;      /*!< Update method for PWM generator 1 time stamp A's active register.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set
                                                     to 1: sync, when bit3 is set to 1: disable the update.                    */
      __IOM uint32_t CMPR1_B_UPMETHOD : 4;      /*!< Update method for PWM generator 1 time stamp B's active register.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set
                                                     to 1: sync, when bit3 is set to 1: disable the update.                    */
      __IOM uint32_t CMPR1_A_SHDW_FULL : 1;     /*!< Set and reset by hardware. If set, PWM generator 1 time stamp
                                                     A's shadow reg is filled and waiting to be transferred
                                                     to A's active reg. If cleared, A's active reg has been
                                                     updated with shadow register latest value                                 */
      __IOM uint32_t CMPR1_B_SHDW_FULL : 1;     /*!< Set and reset by hardware. If set, PWM generator 1 time stamp
                                                     B's shadow reg is filled and waiting to be transferred
                                                     to B's active reg. If cleared, B's active reg has been
                                                     updated with shadow register latest value                                 */
            uint32_t            : 22;
    } bit;
  } CMPR1_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for register A.                                           */
    
    struct {
      __IOM uint32_t CMPR1_A    : 16;           /*!< PWM generator 1 time stamp A's shadow register                            */
            uint32_t            : 16;
    } bit;
  } CMPR1_VALUE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for register B.                                           */
    
    struct {
      __IOM uint32_t CMPR1_B    : 16;           /*!< PWM generator 1 time stamp B's shadow register                            */
            uint32_t            : 16;
    } bit;
  } CMPR1_VALUE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Fault event T0 and T1 handling                                            */
    
    struct {
      __IOM uint32_t GEN1_CFG_UPMETHOD : 4;     /*!< Update method for PWM generator 1's active register of configuration.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ, when bit1 is set to 1:                                         */
      __IOM uint32_t GEN1_T0_SEL : 3;           /*!< Source selection for PWM generator 1 event_t0, take effect immediately,
                                                     0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken,
                                                     4: none                                                                   */
      __IOM uint32_t GEN1_T1_SEL : 3;           /*!< Source selection for PWM generator 1 event_t1, take effect immediately,
                                                     0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken,
                                                     4: none                                                                   */
            uint32_t            : 22;
    } bit;
  } GEN1_CFG0;
  
  union {
    __IOM uint32_t reg;                         /*!< Permissives to force PWM1A and PWM1B outputs by software                  */
    
    struct {
      __IOM uint32_t GEN1_CNTUFORCE_UPMETHOD : 6;/*!< Updating method for continuous software force of PWM generator
                                                     1. When all bits are set to 0: immediately, when bit0 is
                                                     set to 1: TEZ,,when bit1 is set to 1: TEP, when bit2 is
                                                     set to 1: TEA, when bit3 is set to 1: TEB, when bit4 is
                                                     set to 1: sync, when bit5 is set to 1: disable update.
                                                     (TEA/B here and below means an event generated when the
                                                     timer's value equals to that of register A/B.)                            */
      __IOM uint32_t GEN1_A_CNTUFORCE_MODE : 2; /*!< Continuous software force mode for PWM1A. 0: disabled, 1: low,
                                                     2: high, 3: disabled                                                      */
      __IOM uint32_t GEN1_B_CNTUFORCE_MODE : 2; /*!< Continuous software force mode for PWM1B. 0: disabled, 1: low,
                                                     2: high, 3: disabled                                                      */
      __IOM uint32_t GEN1_A_NCIFORCE : 1;       /*!< Trigger of non-continuous immediate software-force event for
                                                     PWM1A, a toggle will trigger a force event.                               */
      __IOM uint32_t GEN1_A_NCIFORCE_MODE : 2;  /*!< non-continuous immediate software force mode for PWM1A, 0: disabled,
                                                     1: low, 2: high, 3: disabled                                              */
      __IOM uint32_t GEN1_B_NCIFORCE : 1;       /*!< Trigger of non-continuous immediate software-force event for
                                                     PWM1B, a toggle will trigger a force event.                               */
      __IOM uint32_t GEN1_B_NCIFORCE_MODE : 2;  /*!< non-continuous immediate software force mode for PWM1B, 0: disabled,
                                                     1: low, 2: high, 3: disabled                                              */
            uint32_t            : 16;
    } bit;
  } GEN1_FORCE;
  
  union {
    __IOM uint32_t reg;                         /*!< Actions triggered by events on PWM1A                                      */
    
    struct {
      __IOM uint32_t UTEZ       : 2;            /*!< Action on PWM1A triggered by event TEZ when timer increasing              */
      __IOM uint32_t UTEP       : 2;            /*!< Action on PWM1A triggered by event TEP when timer increasing              */
      __IOM uint32_t UTEA       : 2;            /*!< Action on PWM1A triggered by event TEA when timer increasing              */
      __IOM uint32_t UTEB       : 2;            /*!< Action on PWM1A triggered by event TEB when timer increasing              */
      __IOM uint32_t UT0        : 2;            /*!< Action on PWM1A triggered by event_t0 when timer increasing               */
      __IOM uint32_t UT1        : 2;            /*!< Action on PWM1A triggered by event_t1 when timer increasing               */
      __IOM uint32_t DTEZ       : 2;            /*!< Action on PWM1A triggered by event TEZ when timer decreasing              */
      __IOM uint32_t DTEP       : 2;            /*!< Action on PWM1A triggered by event TEP when timer decreasing              */
      __IOM uint32_t DTEA       : 2;            /*!< Action on PWM1A triggered by event TEA when timer decreasing              */
      __IOM uint32_t DTEB       : 2;            /*!< Action on PWM1A triggered by event TEB when timer decreasing              */
      __IOM uint32_t DT0        : 2;            /*!< Action on PWM1A triggered by event_t0 when timer decreasing               */
      __IOM uint32_t DT1        : 2;            /*!< Action on PWM1A triggered by event_t1 when timer decreasing.
                                                     0: no change, 1: low, 2: high, 3: toggle                                  */
            uint32_t            : 8;
    } bit;
  } GEN1_A;
  
  union {
    __IOM uint32_t reg;                         /*!< Actions triggered by events on PWM1B                                      */
    
    struct {
      __IOM uint32_t UTEZ       : 2;            /*!< Action on PWM1B triggered by event TEZ when timer increasing              */
      __IOM uint32_t UTEP       : 2;            /*!< Action on PWM1B triggered by event TEP when timer increasing              */
      __IOM uint32_t UTEA       : 2;            /*!< Action on PWM1B triggered by event TEA when timer increasing              */
      __IOM uint32_t UTEB       : 2;            /*!< Action on PWM1B triggered by event TEB when timer increasing              */
      __IOM uint32_t UT0        : 2;            /*!< Action on PWM1B triggered by event_t0 when timer increasing               */
      __IOM uint32_t UT1        : 2;            /*!< Action on PWM1B triggered by event_t1 when timer increasing               */
      __IOM uint32_t DTEZ       : 2;            /*!< Action on PWM1B triggered by event TEZ when timer decreasing              */
      __IOM uint32_t DTEP       : 2;            /*!< Action on PWM1B triggered by event TEP when timer decreasing              */
      __IOM uint32_t DTEA       : 2;            /*!< Action on PWM1B triggered by event TEA when timer decreasing              */
      __IOM uint32_t DTEB       : 2;            /*!< Action on PWM1B triggered by event TEB when timer decreasing              */
      __IOM uint32_t DT0        : 2;            /*!< Action on PWM1B triggered by event_t0 when timer decreasing               */
      __IOM uint32_t DT1        : 2;            /*!< Action on PWM1B triggered by event_t1 when timer decreasing.
                                                     0: no change, 1: low, 2: high, 3: toggle                                  */
            uint32_t            : 8;
    } bit;
  } GEN1_B;
  
  union {
    __IOM uint32_t reg;                         /*!< dead time type selection and configuration                                */
    
    struct {
      __IOM uint32_t DB1_FED_UPMETHOD : 4;      /*!< Update method for FED (falling edge delay) active register.
                                                     0: immediate, bit0: tez, bit1: tep, bit2: sync, bit3: freeze              */
      __IOM uint32_t DB1_RED_UPMETHOD : 4;      /*!< Update method for RED (rising edge delay) active register. 0:
                                                     immediate, bit0: tez, bit1: tep, bit2: sync, bit3: freeze                 */
      __IOM uint32_t DB1_DEB_MODE : 1;          /*!< S8 in documentation, dual-edge B mode, 0: fed/red take effect
                                                     on different path separately, 1: fed/red take effect on
                                                     B path, A out is in bypass or dulpB mode                                  */
      __IOM uint32_t DB1_A_OUTSWAP : 1;         /*!< S6 in documentation                                                       */
      __IOM uint32_t DB1_B_OUTSWAP : 1;         /*!< S7 in documentation                                                       */
      __IOM uint32_t DB1_RED_INSEL : 1;         /*!< S4 in documentation                                                       */
      __IOM uint32_t DB1_FED_INSEL : 1;         /*!< S5 in documentation                                                       */
      __IOM uint32_t DB1_RED_OUTINVERT : 1;     /*!< S2 in documentation                                                       */
      __IOM uint32_t DB1_FED_OUTINVERT : 1;     /*!< S3 in documentation                                                       */
      __IOM uint32_t DB1_A_OUTBYPASS : 1;       /*!< S1 in documentation                                                       */
      __IOM uint32_t DB1_B_OUTBYPASS : 1;       /*!< S0 in documentation                                                       */
      __IOM uint32_t DB1_CLK_SEL : 1;           /*!< Dead time generator 1 clock selection. 0: PWM_clk, 1: PT_clk              */
            uint32_t            : 14;
    } bit;
  } DB1_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for falling edge delay (FED).                             */
    
    struct {
      __IOM uint32_t DB1_FED    : 16;           /*!< Shadow register for FED                                                   */
            uint32_t            : 16;
    } bit;
  } DB1_FED_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for rising edge delay (RED).                              */
    
    struct {
      __IOM uint32_t DB1_RED    : 16;           /*!< Shadow register for RED                                                   */
            uint32_t            : 16;
    } bit;
  } DB1_RED_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Carrier enable and configuratoin                                          */
    
    struct {
      __IOM uint32_t CHOPPER1_EN : 1;           /*!< When set, carrier0 function is enabled. When cleared, carrier0
                                                     is bypassed                                                               */
      __IOM uint32_t CHOPPER1_PRESCALE : 4;     /*!< PWM carrier0 clock (PC_clk) prescale value. Period of PC_clk
                                                     = period of PWM_clk * (PWM_CARRIER0_PRESCALE + 1)                         */
      __IOM uint32_t CHOPPER1_DUTY : 3;         /*!< carrier duty selection. Duty = PWM_CARRIER0_DUTY / 8                      */
      __IOM uint32_t CHOPPER1_OSHTWTH : 4;      /*!< width of the fist pulse in number of periods of the carrier               */
      __IOM uint32_t CHOPPER1_OUT_INVERT : 1;   /*!< when set, invert the output of PWM1A and PWM1B for this submodule         */
      __IOM uint32_t CHOPPER1_IN_INVERT : 1;    /*!< when set, invert the input of PWM1A and PWM1B for this submodule          */
            uint32_t            : 18;
    } bit;
  } CHOPPER1_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Actions on PWM1A and PWM1B trip events                                    */
    
    struct {
      __IOM uint32_t TZ1_SW_CBC : 1;            /*!< Enable register for software force cycle-by-cycle mode action.
                                                     0: disable, 1: enable                                                     */
      __IOM uint32_t TZ1_F2_CBC : 1;            /*!< event_f2 will trigger cycle-by-cycle mode action. 0: disable,
                                                     1: enable                                                                 */
      __IOM uint32_t TZ1_F1_CBC : 1;            /*!< event_f1 will trigger cycle-by-cycle mode action. 0: disable,
                                                     1: enable                                                                 */
      __IOM uint32_t TZ1_F0_CBC : 1;            /*!< event_f0 will trigger cycle-by-cycle mode action. 0: disable,
                                                     1: enable                                                                 */
      __IOM uint32_t TZ1_SW_OST : 1;            /*!< Enable register for software force one-shot mode action. 0:
                                                     disable, 1: enable                                                        */
      __IOM uint32_t TZ1_F2_OST : 1;            /*!< event_f2 will trigger one-shot mode action. 0: disable, 1: enable         */
      __IOM uint32_t TZ1_F1_OST : 1;            /*!< event_f1 will trigger one-shot mode action. 0: disable, 1: enable         */
      __IOM uint32_t TZ1_F0_OST : 1;            /*!< event_f0 will trigger one-shot mode action. 0: disable, 1: enable         */
      __IOM uint32_t TZ1_A_CBC_D : 2;           /*!< Cycle-by-cycle mode action on PWM1A when fault event occurs
                                                     and timer is decreasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ1_A_CBC_U : 2;           /*!< Cycle-by-cycle mode action on PWM1A when fault event occurs
                                                     and timer is increasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ1_A_OST_D : 2;           /*!< One-shot mode action on PWM1A when fault event occurs and timer
                                                     is decreasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
      __IOM uint32_t TZ1_A_OST_U : 2;           /*!< One-shot mode action on PWM1A when fault event occurs and timer
                                                     is increasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
      __IOM uint32_t TZ1_B_CBC_D : 2;           /*!< Cycle-by-cycle mode action on PWM1B when fault event occurs
                                                     and timer is decreasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ1_B_CBC_U : 2;           /*!< Cycle-by-cycle mode action on PWM1B when fault event occurs
                                                     and timer is increasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ1_B_OST_D : 2;           /*!< One-shot mode action on PWM1B when fault event occurs and timer
                                                     is decreasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
      __IOM uint32_t TZ1_B_OST_U : 2;           /*!< One-shot mode action on PWM1B when fault event occurs and timer
                                                     is increasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
            uint32_t            : 8;
    } bit;
  } TZ1_CFG0;
  
  union {
    __IOM uint32_t reg;                         /*!< Software triggers for fault handler actions                               */
    
    struct {
      __IOM uint32_t TZ1_CLR_OST : 1;           /*!< a rising edge will clear on going one-shot mode action                    */
      __IOM uint32_t TZ1_CBCPULSE : 2;          /*!< cycle-by-cycle mode action refresh moment selection. Bit0: TEZ,
                                                     bit1:TEP                                                                  */
      __IOM uint32_t TZ1_FORCE_CBC : 1;         /*!< a toggle trigger a cycle-by-cycle mode action                             */
      __IOM uint32_t TZ1_FORCE_OST : 1;         /*!< a toggle (software negate its value) triggers a one-shot mode
                                                     action                                                                    */
            uint32_t            : 27;
    } bit;
  } TZ1_CFG1;
  
  union {
    __IOM uint32_t reg;                         /*!< Status of fault events.                                                   */
    
    struct {
      __IM  uint32_t TZ1_CBC_ON : 1;            /*!< Set and reset by hardware. If set, a cycle-by-cycle mode action
                                                     is on going                                                               */
      __IM  uint32_t TZ1_OST_ON : 1;            /*!< Set and reset by hardware. If set, an one-shot mode action is
                                                     on going                                                                  */
            uint32_t            : 30;
    } bit;
  } TZ1_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Transfer status and update method for time stamp registers A
                                                     and B                                                                     */
    
    struct {
      __IOM uint32_t CMPR2_A_UPMETHOD : 4;      /*!< Update method for PWM generator 2 time stamp A's active register.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set
                                                     to 1: sync, when bit3 is set to 1: disable the update.                    */
      __IOM uint32_t CMPR2_B_UPMETHOD : 4;      /*!< Update method for PWM generator 2 time stamp B's active register.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ, when bit1 is set to 1: TEP,when bit2 is set
                                                     to 1: sync, when bit3 is set to 1: disable the update.                    */
      __IOM uint32_t CMPR2_A_SHDW_FULL : 1;     /*!< Set and reset by hardware. If set, PWM generator 2 time stamp
                                                     A's shadow reg is filled and waiting to be transferred
                                                     to A's active reg. If cleared, A's active reg has been
                                                     updated with shadow register latest value                                 */
      __IOM uint32_t CMPR2_B_SHDW_FULL : 1;     /*!< Set and reset by hardware. If set, PWM generator 2 time stamp
                                                     B's shadow reg is filled and waiting to be transferred
                                                     to B's active reg. If cleared, B's active reg has been
                                                     updated with shadow register latest value                                 */
            uint32_t            : 22;
    } bit;
  } CMPR2_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for register A.                                           */
    
    struct {
      __IOM uint32_t CMPR2_A    : 16;           /*!< PWM generator 2 time stamp A's shadow register                            */
            uint32_t            : 16;
    } bit;
  } CMPR2_VALUE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for register B.                                           */
    
    struct {
      __IOM uint32_t CMPR2_B    : 16;           /*!< PWM generator 2 time stamp B's shadow register                            */
            uint32_t            : 16;
    } bit;
  } CMPR2_VALUE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Fault event T0 and T1 handling                                            */
    
    struct {
      __IOM uint32_t GEN2_CFG_UPMETHOD : 4;     /*!< Update method for PWM generator 2's active register of configuration.
                                                     When all bits are set to 0: immediately, when bit0 is set
                                                     to 1: TEZ, when bit1 is set to 1:                                         */
      __IOM uint32_t GEN2_T0_SEL : 3;           /*!< Source selection for PWM generator 2 event_t0, take effect immediately,
                                                     0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken,
                                                     4: none                                                                   */
      __IOM uint32_t GEN2_T1_SEL : 3;           /*!< Source selection for PWM generator 2 event_t1, take effect immediately,
                                                     0: fault_event0, 1: fault_event1, 2: fault_event2, 3: sync_taken,
                                                     4: none                                                                   */
            uint32_t            : 22;
    } bit;
  } GEN2_CFG0;
  
  union {
    __IOM uint32_t reg;                         /*!< Permissives to force PWM2A and PWM2B outputs by software                  */
    
    struct {
      __IOM uint32_t GEN2_CNTUFORCE_UPMETHOD : 6;/*!< Updating method for continuous software force of PWM generator
                                                     2. When all bits are set to 0: immediately, when bit0 is
                                                     set to 1: TEZ,,when bit1 is set to 1: TEP, when bit2 is
                                                     set to 1: TEA, when bit3 is set to 1: TEB, when bit4 is
                                                     set to 1: sync, when bit5 is set to 1: disable update.
                                                     (TEA/B here and below means an event generated when the
                                                     timer's value equals to that of register A/B.)                            */
      __IOM uint32_t GEN2_A_CNTUFORCE_MODE : 2; /*!< Continuous software force mode for PWM2A. 0: disabled, 1: low,
                                                     2: high, 3: disabled                                                      */
      __IOM uint32_t GEN2_B_CNTUFORCE_MODE : 2; /*!< Continuous software force mode for PWM2B. 0: disabled, 1: low,
                                                     2: high, 3: disabled                                                      */
      __IOM uint32_t GEN2_A_NCIFORCE : 1;       /*!< Trigger of non-continuous immediate software-force event for
                                                     PWM2A, a toggle will trigger a force event.                               */
      __IOM uint32_t GEN2_A_NCIFORCE_MODE : 2;  /*!< non-continuous immediate software force mode for PWM2A, 0: disabled,
                                                     1: low, 2: high, 3: disabled                                              */
      __IOM uint32_t GEN2_B_NCIFORCE : 1;       /*!< Trigger of non-continuous immediate software-force event for
                                                     PWM2B, a toggle will trigger a force event.                               */
      __IOM uint32_t GEN2_B_NCIFORCE_MODE : 2;  /*!< non-continuous immediate software force mode for PWM2B, 0: disabled,
                                                     1: low, 2: high, 3: disabled                                              */
            uint32_t            : 16;
    } bit;
  } GEN2_FORCE;
  
  union {
    __IOM uint32_t reg;                         /*!< Actions triggered by events on PWM2A                                      */
    
    struct {
      __IOM uint32_t UTEZ       : 2;            /*!< Action on PWM2A triggered by event TEZ when timer increasing              */
      __IOM uint32_t UTEP       : 2;            /*!< Action on PWM2A triggered by event TEP when timer increasing              */
      __IOM uint32_t UTEA       : 2;            /*!< Action on PWM2A triggered by event TEA when timer increasing              */
      __IOM uint32_t UTEB       : 2;            /*!< Action on PWM2A triggered by event TEB when timer increasing              */
      __IOM uint32_t UT0        : 2;            /*!< Action on PWM2A triggered by event_t0 when timer increasing               */
      __IOM uint32_t UT1        : 2;            /*!< Action on PWM2A triggered by event_t1 when timer increasing               */
      __IOM uint32_t DTEZ       : 2;            /*!< Action on PWM2A triggered by event TEZ when timer decreasing              */
      __IOM uint32_t DTEP       : 2;            /*!< Action on PWM2A triggered by event TEP when timer decreasing              */
      __IOM uint32_t DTEA       : 2;            /*!< Action on PWM2A triggered by event TEA when timer decreasing              */
      __IOM uint32_t DTEB       : 2;            /*!< Action on PWM2A triggered by event TEB when timer decreasing              */
      __IOM uint32_t DT0        : 2;            /*!< Action on PWM2A triggered by event_t0 when timer decreasing               */
      __IOM uint32_t DT1        : 2;            /*!< Action on PWM2A triggered by event_t1 when timer decreasing.
                                                     0: no change, 1: low, 2: high, 3: toggle                                  */
            uint32_t            : 8;
    } bit;
  } GEN2_A;
  
  union {
    __IOM uint32_t reg;                         /*!< Actions triggered by events on PWM2B                                      */
    
    struct {
      __IOM uint32_t UTEZ       : 2;            /*!< Action on PWM2B triggered by event TEZ when timer increasing              */
      __IOM uint32_t UTEP       : 2;            /*!< Action on PWM2B triggered by event TEP when timer increasing              */
      __IOM uint32_t UTEA       : 2;            /*!< Action on PWM2B triggered by event TEA when timer increasing              */
      __IOM uint32_t UTEB       : 2;            /*!< Action on PWM2B triggered by event TEB when timer increasing              */
      __IOM uint32_t UT0        : 2;            /*!< Action on PWM2B triggered by event_t0 when timer increasing               */
      __IOM uint32_t UT1        : 2;            /*!< Action on PWM2B triggered by event_t1 when timer increasing               */
      __IOM uint32_t DTEZ       : 2;            /*!< Action on PWM2B triggered by event TEZ when timer decreasing              */
      __IOM uint32_t DTEP       : 2;            /*!< Action on PWM2B triggered by event TEP when timer decreasing              */
      __IOM uint32_t DTEA       : 2;            /*!< Action on PWM2B triggered by event TEA when timer decreasing              */
      __IOM uint32_t DTEB       : 2;            /*!< Action on PWM2B triggered by event TEB when timer decreasing              */
      __IOM uint32_t DT0        : 2;            /*!< Action on PWM2B triggered by event_t0 when timer decreasing               */
      __IOM uint32_t DT1        : 2;            /*!< Action on PWM2B triggered by event_t1 when timer decreasing.
                                                     0: no change, 1: low, 2: high, 3: toggle                                  */
            uint32_t            : 8;
    } bit;
  } GEN2_B;
  
  union {
    __IOM uint32_t reg;                         /*!< dead time type selection and configuration                                */
    
    struct {
      __IOM uint32_t DB2_FED_UPMETHOD : 4;      /*!< Update method for FED (falling edge delay) active register.
                                                     0: immediate, bit0: tez, bit1: tep, bit2: sync, bit3: freeze              */
      __IOM uint32_t DB2_RED_UPMETHOD : 4;      /*!< Update method for RED (rising edge delay) active register. 0:
                                                     immediate, bit0: tez, bit1: tep, bit2: sync, bit3: freeze                 */
      __IOM uint32_t DB2_DEB_MODE : 1;          /*!< S8 in documentation, dual-edge B mode, 0: fed/red take effect
                                                     on different path separately, 1: fed/red take effect on
                                                     B path, A out is in bypass or dulpB mode                                  */
      __IOM uint32_t DB2_A_OUTSWAP : 1;         /*!< S6 in documentation                                                       */
      __IOM uint32_t DB2_B_OUTSWAP : 1;         /*!< S7 in documentation                                                       */
      __IOM uint32_t DB2_RED_INSEL : 1;         /*!< S4 in documentation                                                       */
      __IOM uint32_t DB2_FED_INSEL : 1;         /*!< S5 in documentation                                                       */
      __IOM uint32_t DB2_RED_OUTINVERT : 1;     /*!< S2 in documentation                                                       */
      __IOM uint32_t DB2_FED_OUTINVERT : 1;     /*!< S3 in documentation                                                       */
      __IOM uint32_t DB2_A_OUTBYPASS : 1;       /*!< S1 in documentation                                                       */
      __IOM uint32_t DB2_B_OUTBYPASS : 1;       /*!< S0 in documentation                                                       */
      __IOM uint32_t DB2_CLK_SEL : 1;           /*!< Dead time generator 2 clock selection. 0: PWM_clk, 1: PT_clk              */
            uint32_t            : 14;
    } bit;
  } DB2_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for falling edge delay (FED).                             */
    
    struct {
      __IOM uint32_t DB2_FED    : 16;           /*!< Shadow register for FED                                                   */
            uint32_t            : 16;
    } bit;
  } DB2_FED_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Shadow register for rising edge delay (RED).                              */
    
    struct {
      __IOM uint32_t DB2_RED    : 16;           /*!< Shadow register for RED                                                   */
            uint32_t            : 16;
    } bit;
  } DB2_RED_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Carrier enable and configuratoin                                          */
    
    struct {
      __IOM uint32_t CHOPPER2_EN : 1;           /*!< When set, carrier0 function is enabled. When cleared, carrier0
                                                     is bypassed                                                               */
      __IOM uint32_t CHOPPER2_PRESCALE : 4;     /*!< PWM carrier0 clock (PC_clk) prescale value. Period of PC_clk
                                                     = period of PWM_clk * (PWM_CARRIER0_PRESCALE + 1)                         */
      __IOM uint32_t CHOPPER2_DUTY : 3;         /*!< carrier duty selection. Duty = PWM_CARRIER0_DUTY / 8                      */
      __IOM uint32_t CHOPPER2_OSHTWTH : 4;      /*!< width of the fist pulse in number of periods of the carrier               */
      __IOM uint32_t CHOPPER2_OUT_INVERT : 1;   /*!< when set, invert the output of PWM2A and PWM2B for this submodule         */
      __IOM uint32_t CHOPPER2_IN_INVERT : 1;    /*!< when set, invert the input of PWM2A and PWM2B for this submodule          */
            uint32_t            : 18;
    } bit;
  } CHOPPER2_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Actions on PWM2A and PWM2B trip events                                    */
    
    struct {
      __IOM uint32_t TZ2_SW_CBC : 1;            /*!< Enable register for software force cycle-by-cycle mode action.
                                                     0: disable, 1: enable                                                     */
      __IOM uint32_t TZ2_F2_CBC : 1;            /*!< event_f2 will trigger cycle-by-cycle mode action. 0: disable,
                                                     1: enable                                                                 */
      __IOM uint32_t TZ2_F1_CBC : 1;            /*!< event_f1 will trigger cycle-by-cycle mode action. 0: disable,
                                                     1: enable                                                                 */
      __IOM uint32_t TZ2_F0_CBC : 1;            /*!< event_f0 will trigger cycle-by-cycle mode action. 0: disable,
                                                     1: enable                                                                 */
      __IOM uint32_t TZ2_SW_OST : 1;            /*!< Enable register for software force one-shot mode action. 0:
                                                     disable, 1: enable                                                        */
      __IOM uint32_t TZ2_F2_OST : 1;            /*!< event_f2 will trigger one-shot mode action. 0: disable, 1: enable         */
      __IOM uint32_t TZ2_F1_OST : 1;            /*!< event_f1 will trigger one-shot mode action. 0: disable, 1: enable         */
      __IOM uint32_t TZ2_F0_OST : 1;            /*!< event_f0 will trigger one-shot mode action. 0: disable, 1: enable         */
      __IOM uint32_t TZ2_A_CBC_D : 2;           /*!< Cycle-by-cycle mode action on PWM2A when fault event occurs
                                                     and timer is decreasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ2_A_CBC_U : 2;           /*!< Cycle-by-cycle mode action on PWM2A when fault event occurs
                                                     and timer is increasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ2_A_OST_D : 2;           /*!< One-shot mode action on PWM2A when fault event occurs and timer
                                                     is decreasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
      __IOM uint32_t TZ2_A_OST_U : 2;           /*!< One-shot mode action on PWM2A when fault event occurs and timer
                                                     is increasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
      __IOM uint32_t TZ2_B_CBC_D : 2;           /*!< Cycle-by-cycle mode action on PWM2B when fault event occurs
                                                     and timer is decreasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ2_B_CBC_U : 2;           /*!< Cycle-by-cycle mode action on PWM2B when fault event occurs
                                                     and timer is increasing. 0: do nothing, 1: force lo, 2:
                                                     force hi, 3: toggle                                                       */
      __IOM uint32_t TZ2_B_OST_D : 2;           /*!< One-shot mode action on PWM2B when fault event occurs and timer
                                                     is decreasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
      __IOM uint32_t TZ2_B_OST_U : 2;           /*!< One-shot mode action on PWM2B when fault event occurs and timer
                                                     is increasing. 0: do nothing, 1: force lo, 2: force hi,
                                                     3: toggle                                                                 */
            uint32_t            : 8;
    } bit;
  } TZ2_CFG0;
  
  union {
    __IOM uint32_t reg;                         /*!< Software triggers for fault handler actions                               */
    
    struct {
      __IOM uint32_t TZ2_CLR_OST : 1;           /*!< a rising edge will clear on going one-shot mode action                    */
      __IOM uint32_t TZ2_CBCPULSE : 2;          /*!< cycle-by-cycle mode action refresh moment selection. Bit0: TEZ,
                                                     bit1:TEP                                                                  */
      __IOM uint32_t TZ2_FORCE_CBC : 1;         /*!< a toggle trigger a cycle-by-cycle mode action                             */
      __IOM uint32_t TZ2_FORCE_OST : 1;         /*!< a toggle (software negate its value) triggers a one-shot mode
                                                     action                                                                    */
            uint32_t            : 27;
    } bit;
  } TZ2_CFG1;
  
  union {
    __IOM uint32_t reg;                         /*!< Status of fault events.                                                   */
    
    struct {
      __IM  uint32_t TZ2_CBC_ON : 1;            /*!< Set and reset by hardware. If set, a cycle-by-cycle mode action
                                                     is on going                                                               */
      __IM  uint32_t TZ2_OST_ON : 1;            /*!< Set and reset by hardware. If set, an one-shot mode action is
                                                     on going                                                                  */
            uint32_t            : 30;
    } bit;
  } TZ2_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Fault detection configuration and status                                  */
    
    struct {
      __IOM uint32_t F0_EN      : 1;            /*!< When set, event_f0 generation is enabled                                  */
      __IOM uint32_t F1_EN      : 1;            /*!< When set, event_f1 generation is enabled                                  */
      __IOM uint32_t F2_EN      : 1;            /*!< When set, event_f2 generation is enabled                                  */
      __IOM uint32_t F0_POLE    : 1;            /*!< Set event_f0 trigger polarity on FAULT2 source from GPIO matrix.
                                                     0: level low, 1: level high                                               */
      __IOM uint32_t F1_POLE    : 1;            /*!< Set event_f1 trigger polarity on FAULT2 source from GPIO matrix.
                                                     0: level low, 1: level high                                               */
      __IOM uint32_t F2_POLE    : 1;            /*!< Set event_f2 trigger polarity on FAULT2 source from GPIO matrix.
                                                     0: level low, 1: level high                                               */
      __IM  uint32_t EVENT_F0   : 1;            /*!< Set and reset by hardware. If set, event_f0 is on going                   */
      __IM  uint32_t EVENT_F1   : 1;            /*!< Set and reset by hardware. If set, event_f1 is on going                   */
      __IM  uint32_t EVENT_F2   : 1;            /*!< Set and reset by hardware. If set, event_f2 is on going                   */
            uint32_t            : 23;
    } bit;
  } FAULT_DETECT;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure capture timer                                                   */
    
    struct {
      __IOM uint32_t CAP_TIMER_EN : 1;          /*!< When set, capture timer incrementing under APB_clk is enabled.            */
      __IOM uint32_t CAP_SYNCI_EN : 1;          /*!< When set, capture timer sync is enabled.                                  */
      __IOM uint32_t CAP_SYNCI_SEL : 3;         /*!< capture module sync input selection. 0: none, 1: timer0 sync_out,
                                                     2: timer1 sync_out, 3: timer2 sync_out, 4: SYNC0 from GPIO
                                                     matrix, 5: SYNC1 from GPIO matrix, 6: SYNC2 from GPIO matrix              */
      __OM  uint32_t CAP_SYNC_SW : 1;           /*!< Write 1 will force a capture timer sync, capture timer is loaded
                                                     with value in phase register.                                             */
            uint32_t            : 26;
    } bit;
  } CAP_TIMER_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Phase for capture timer sync                                              */
    
    struct {
      __IOM uint32_t CAP_PHASE  : 32;           /*!< Phase value for capture timer sync operation.                             */
    } bit;
  } CAP_TIMER_PHASE;
  
  union {
    __IOM uint32_t reg;                         /*!< Capture channel 0 configuration and enable                                */
    
    struct {
      __IOM uint32_t CAP0_EN    : 1;            /*!< When set, capture on channel 0 is enabled                                 */
      __IOM uint32_t CAP0_MODE  : 2;            /*!< Edge of capture on channel 0 after prescaling. When bit0 is
                                                     set to 1: enable capture on the negative edge, When bit1
                                                     is set to 1: enable capture on the positive edge.                         */
      __IOM uint32_t CAP0_PRESCALE : 8;         /*!< Value of prescaling on possitive edge of CAP0. Prescale value
                                                     = PWM_CAP0_PRESCALE + 1                                                   */
      __IOM uint32_t CAP0_IN_INVERT : 1;        /*!< when set, CAP0 form GPIO matrix is inverted before prescale               */
      __OM  uint32_t CAP0_SW    : 1;            /*!< Write 1 will trigger a software forced capture on channel 0               */
            uint32_t            : 19;
    } bit;
  } CAP_CH0_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Capture channel 1 configuration and enable                                */
    
    struct {
      __IOM uint32_t CAP1_EN    : 1;            /*!< When set, capture on channel 2 is enabled                                 */
      __IOM uint32_t CAP1_MODE  : 2;            /*!< Edge of capture on channel 1 after prescaling. When bit0 is
                                                     set to 1: enable capture on the negative edge, When bit1
                                                     is set to 1: enable capture on the positive edge.                         */
      __IOM uint32_t CAP1_PRESCALE : 8;         /*!< Value of prescaling on possitive edge of CAP1. Prescale value
                                                     = PWM_CAP1_PRESCALE + 1                                                   */
      __IOM uint32_t CAP1_IN_INVERT : 1;        /*!< when set, CAP1 form GPIO matrix is inverted before prescale               */
      __OM  uint32_t CAP1_SW    : 1;            /*!< Write 1 will trigger a software forced capture on channel 1               */
            uint32_t            : 19;
    } bit;
  } CAP_CH1_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Capture channel 2 configuration and enable                                */
    
    struct {
      __IOM uint32_t CAP2_EN    : 1;            /*!< When set, capture on channel 2 is enabled                                 */
      __IOM uint32_t CAP2_MODE  : 2;            /*!< Edge of capture on channel 2 after prescaling. When bit0 is
                                                     set to 1: enable capture on the negative edge, When bit1
                                                     is set to 1: enable capture on the positive edge.                         */
      __IOM uint32_t CAP2_PRESCALE : 8;         /*!< Value of prescaling on possitive edge of CAP2. Prescale value
                                                     = PWM_CAP2_PRESCALE + 1                                                   */
      __IOM uint32_t CAP2_IN_INVERT : 1;        /*!< when set, CAP2 form GPIO matrix is inverted before prescale               */
      __OM  uint32_t CAP2_SW    : 1;            /*!< Write 1 will trigger a software forced capture on channel 2               */
            uint32_t            : 19;
    } bit;
  } CAP_CH2_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Value of last capture on channel 0                                        */
    
    struct {
      __IM  uint32_t CAP0_VALUE : 32;           /*!< Value of last capture on channel 0                                        */
    } bit;
  } CAP_CH0;
  
  union {
    __IOM uint32_t reg;                         /*!< Value of last capture on channel 1                                        */
    
    struct {
      __IM  uint32_t CAP1_VALUE : 32;           /*!< Value of last capture on channel 1                                        */
    } bit;
  } CAP_CH1;
  
  union {
    __IOM uint32_t reg;                         /*!< Value of last capture on channel 2                                        */
    
    struct {
      __IM  uint32_t CAP2_VALUE : 32;           /*!< Value of last capture on channel 2                                        */
    } bit;
  } CAP_CH2;
  
  union {
    __IOM uint32_t reg;                         /*!< Edge of last capture trigger                                              */
    
    struct {
      __IM  uint32_t CAP0_EDGE  : 1;            /*!< Edge of last capture trigger on channel 0, 0: posedge, 1: negedge         */
      __IM  uint32_t CAP1_EDGE  : 1;            /*!< Edge of last capture trigger on channel 1, 0: posedge, 1: negedge         */
      __IM  uint32_t CAP2_EDGE  : 1;            /*!< Edge of last capture trigger on channel 2, 0: posedge, 1: negedge         */
            uint32_t            : 29;
    } bit;
  } CAP_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Enable update.                                                            */
    
    struct {
      __IOM uint32_t GLOBAL_UP_EN : 1;          /*!< The global enable of update of all active registers in MCPWM
                                                     module                                                                    */
      __IOM uint32_t GLOBAL_FORCE_UP : 1;       /*!< a toggle (software invert its value) will trigger a forced update
                                                     of all active registers in MCPWM module                                   */
      __IOM uint32_t OP0_UP_EN  : 1;            /*!< When set and PWM_GLOBAL_UP_EN is set, update of active registers
                                                     in PWM operator 0 are enabled                                             */
      __IOM uint32_t OP0_FORCE_UP : 1;          /*!< a toggle (software invert its value) will trigger a forced update
                                                     of active registers in PWM operator 0                                     */
      __IOM uint32_t OP1_UP_EN  : 1;            /*!< When set and PWM_GLOBAL_UP_EN is set, update of active registers
                                                     in PWM operator 1 are enabled                                             */
      __IOM uint32_t OP1_FORCE_UP : 1;          /*!< a toggle (software invert its value) will trigger a forced update
                                                     of active registers in PWM operator 1                                     */
      __IOM uint32_t OP2_UP_EN  : 1;            /*!< When set and PWM_GLOBAL_UP_EN is set, update of active registers
                                                     in PWM operator 2 are enabled                                             */
      __IOM uint32_t OP2_FORCE_UP : 1;          /*!< a toggle (software invert its value) will trigger a forced update
                                                     of active registers in PWM operator 2                                     */
            uint32_t            : 24;
    } bit;
  } UPDATE_CFG;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits                                                     */
    
    struct {
      __IOM uint32_t TIMER0_STOP_INT_ENA : 1;   /*!< The enable bit for the interrupt triggered when the timer 0
                                                     stops.                                                                    */
      __IOM uint32_t TIMER1_STOP_INT_ENA : 1;   /*!< The enable bit for the interrupt triggered when the timer 1
                                                     stops.                                                                    */
      __IOM uint32_t TIMER2_STOP_INT_ENA : 1;   /*!< The enable bit for the interrupt triggered when the timer 2
                                                     stops.                                                                    */
      __IOM uint32_t TIMER0_TEZ_INT_ENA : 1;    /*!< The enable bit for the interrupt triggered by a PWM timer 0
                                                     TEZ event.                                                                */
      __IOM uint32_t TIMER1_TEZ_INT_ENA : 1;    /*!< The enable bit for the interrupt triggered by a PWM timer 1
                                                     TEZ event.                                                                */
      __IOM uint32_t TIMER2_TEZ_INT_ENA : 1;    /*!< The enable bit for the interrupt triggered by a PWM timer 2
                                                     TEZ event.                                                                */
      __IOM uint32_t TIMER0_TEP_INT_ENA : 1;    /*!< The enable bit for the interrupt triggered by a PWM timer 0
                                                     TEP event.                                                                */
      __IOM uint32_t TIMER1_TEP_INT_ENA : 1;    /*!< The enable bit for the interrupt triggered by a PWM timer 1
                                                     TEP event.                                                                */
      __IOM uint32_t TIMER2_TEP_INT_ENA : 1;    /*!< The enable bit for the interrupt triggered by a PWM timer 2
                                                     TEP event.                                                                */
      __IOM uint32_t FAULT0_INT_ENA : 1;        /*!< The enable bit for the interrupt triggered when event_f0 starts.          */
      __IOM uint32_t FAULT1_INT_ENA : 1;        /*!< The enable bit for the interrupt triggered when event_f1 starts.          */
      __IOM uint32_t FAULT2_INT_ENA : 1;        /*!< The enable bit for the interrupt triggered when event_f2 starts.          */
      __IOM uint32_t FAULT0_CLR_INT_ENA : 1;    /*!< The enable bit for the interrupt triggered when event_f0 ends.            */
      __IOM uint32_t FAULT1_CLR_INT_ENA : 1;    /*!< The enable bit for the interrupt triggered when event_f1 ends.            */
      __IOM uint32_t FAULT2_CLR_INT_ENA : 1;    /*!< The enable bit for the interrupt triggered when event_f2 ends.            */
      __IOM uint32_t CMPR0_TEA_INT_ENA : 1;     /*!< The enable bit for the interrupt triggered by a PWM operator
                                                     0 TEA event                                                               */
      __IOM uint32_t CMPR1_TEA_INT_ENA : 1;     /*!< The enable bit for the interrupt triggered by a PWM operator
                                                     1 TEA event                                                               */
      __IOM uint32_t CMPR2_TEA_INT_ENA : 1;     /*!< The enable bit for the interrupt triggered by a PWM operator
                                                     2 TEA event                                                               */
      __IOM uint32_t CMPR0_TEB_INT_ENA : 1;     /*!< The enable bit for the interrupt triggered by a PWM operator
                                                     0 TEB event                                                               */
      __IOM uint32_t CMPR1_TEB_INT_ENA : 1;     /*!< The enable bit for the interrupt triggered by a PWM operator
                                                     1 TEB event                                                               */
      __IOM uint32_t CMPR2_TEB_INT_ENA : 1;     /*!< The enable bit for the interrupt triggered by a PWM operator
                                                     2 TEB event                                                               */
      __IOM uint32_t TZ0_CBC_INT_ENA : 1;       /*!< The enable bit for the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM0.                                                      */
      __IOM uint32_t TZ1_CBC_INT_ENA : 1;       /*!< The enable bit for the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM1.                                                      */
      __IOM uint32_t TZ2_CBC_INT_ENA : 1;       /*!< The enable bit for the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM2.                                                      */
      __IOM uint32_t TZ0_OST_INT_ENA : 1;       /*!< The enable bit for the interrupt triggered by a one-shot mode
                                                     action on PWM0.                                                           */
      __IOM uint32_t TZ1_OST_INT_ENA : 1;       /*!< The enable bit for the interrupt triggered by a one-shot mode
                                                     action on PWM1.                                                           */
      __IOM uint32_t TZ2_OST_INT_ENA : 1;       /*!< The enable bit for the interrupt triggered by a one-shot mode
                                                     action on PWM2.                                                           */
      __IOM uint32_t CAP0_INT_ENA : 1;          /*!< The enable bit for the interrupt triggered by capture on channel
                                                     0.                                                                        */
      __IOM uint32_t CAP1_INT_ENA : 1;          /*!< The enable bit for the interrupt triggered by capture on channel
                                                     1.                                                                        */
      __IOM uint32_t CAP2_INT_ENA : 1;          /*!< The enable bit for the interrupt triggered by capture on channel
                                                     2.                                                                        */
            uint32_t            : 2;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw interrupt status                                                      */
    
    struct {
      __IOM uint32_t TIMER0_STOP_INT_RAW : 1;   /*!< The raw status bit for the interrupt triggered when the timer
                                                     0 stops.                                                                  */
      __IOM uint32_t TIMER1_STOP_INT_RAW : 1;   /*!< The raw status bit for the interrupt triggered when the timer
                                                     1 stops.                                                                  */
      __IOM uint32_t TIMER2_STOP_INT_RAW : 1;   /*!< The raw status bit for the interrupt triggered when the timer
                                                     2 stops.                                                                  */
      __IOM uint32_t TIMER0_TEZ_INT_RAW : 1;    /*!< The raw status bit for the interrupt triggered by a PWM timer
                                                     0 TEZ event.                                                              */
      __IOM uint32_t TIMER1_TEZ_INT_RAW : 1;    /*!< The raw status bit for the interrupt triggered by a PWM timer
                                                     1 TEZ event.                                                              */
      __IOM uint32_t TIMER2_TEZ_INT_RAW : 1;    /*!< The raw status bit for the interrupt triggered by a PWM timer
                                                     2 TEZ event.                                                              */
      __IOM uint32_t TIMER0_TEP_INT_RAW : 1;    /*!< The raw status bit for the interrupt triggered by a PWM timer
                                                     0 TEP event.                                                              */
      __IOM uint32_t TIMER1_TEP_INT_RAW : 1;    /*!< The raw status bit for the interrupt triggered by a PWM timer
                                                     1 TEP event.                                                              */
      __IOM uint32_t TIMER2_TEP_INT_RAW : 1;    /*!< The raw status bit for the interrupt triggered by a PWM timer
                                                     2 TEP event.                                                              */
      __IOM uint32_t FAULT0_INT_RAW : 1;        /*!< The raw status bit for the interrupt triggered when event_f0
                                                     starts.                                                                   */
      __IOM uint32_t FAULT1_INT_RAW : 1;        /*!< The raw status bit for the interrupt triggered when event_f1
                                                     starts.                                                                   */
      __IOM uint32_t FAULT2_INT_RAW : 1;        /*!< The raw status bit for the interrupt triggered when event_f2
                                                     starts.                                                                   */
      __IOM uint32_t FAULT0_CLR_INT_RAW : 1;    /*!< The raw status bit for the interrupt triggered when event_f0
                                                     ends.                                                                     */
      __IOM uint32_t FAULT1_CLR_INT_RAW : 1;    /*!< The raw status bit for the interrupt triggered when event_f1
                                                     ends.                                                                     */
      __IOM uint32_t FAULT2_CLR_INT_RAW : 1;    /*!< The raw status bit for the interrupt triggered when event_f2
                                                     ends.                                                                     */
      __IOM uint32_t CMPR0_TEA_INT_RAW : 1;     /*!< The raw status bit for the interrupt triggered by a PWM operator
                                                     0 TEA event                                                               */
      __IOM uint32_t CMPR1_TEA_INT_RAW : 1;     /*!< The raw status bit for the interrupt triggered by a PWM operator
                                                     1 TEA event                                                               */
      __IOM uint32_t CMPR2_TEA_INT_RAW : 1;     /*!< The raw status bit for the interrupt triggered by a PWM operator
                                                     2 TEA event                                                               */
      __IOM uint32_t CMPR0_TEB_INT_RAW : 1;     /*!< The raw status bit for the interrupt triggered by a PWM operator
                                                     0 TEB event                                                               */
      __IOM uint32_t CMPR1_TEB_INT_RAW : 1;     /*!< The raw status bit for the interrupt triggered by a PWM operator
                                                     1 TEB event                                                               */
      __IOM uint32_t CMPR2_TEB_INT_RAW : 1;     /*!< The raw status bit for the interrupt triggered by a PWM operator
                                                     2 TEB event                                                               */
      __IOM uint32_t TZ0_CBC_INT_RAW : 1;       /*!< The raw status bit for the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM0.                                                      */
      __IOM uint32_t TZ1_CBC_INT_RAW : 1;       /*!< The raw status bit for the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM1.                                                      */
      __IOM uint32_t TZ2_CBC_INT_RAW : 1;       /*!< The raw status bit for the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM2.                                                      */
      __IOM uint32_t TZ0_OST_INT_RAW : 1;       /*!< The raw status bit for the interrupt triggered by a one-shot
                                                     mode action on PWM0.                                                      */
      __IOM uint32_t TZ1_OST_INT_RAW : 1;       /*!< The raw status bit for the interrupt triggered by a one-shot
                                                     mode action on PWM1.                                                      */
      __IOM uint32_t TZ2_OST_INT_RAW : 1;       /*!< The raw status bit for the interrupt triggered by a one-shot
                                                     mode action on PWM2.                                                      */
      __IOM uint32_t CAP0_INT_RAW : 1;          /*!< The raw status bit for the interrupt triggered by capture on
                                                     channel 0.                                                                */
      __IOM uint32_t CAP1_INT_RAW : 1;          /*!< The raw status bit for the interrupt triggered by capture on
                                                     channel 1.                                                                */
      __IOM uint32_t CAP2_INT_RAW : 1;          /*!< The raw status bit for the interrupt triggered by capture on
                                                     channel 2.                                                                */
            uint32_t            : 2;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt status                                                   */
    
    struct {
      __IM  uint32_t TIMER0_STOP_INT_ST : 1;    /*!< The masked status bit for the interrupt triggered when the timer
                                                     0 stops.                                                                  */
      __IM  uint32_t TIMER1_STOP_INT_ST : 1;    /*!< The masked status bit for the interrupt triggered when the timer
                                                     1 stops.                                                                  */
      __IM  uint32_t TIMER2_STOP_INT_ST : 1;    /*!< The masked status bit for the interrupt triggered when the timer
                                                     2 stops.                                                                  */
      __IM  uint32_t TIMER0_TEZ_INT_ST : 1;     /*!< The masked status bit for the interrupt triggered by a PWM timer
                                                     0 TEZ event.                                                              */
      __IM  uint32_t TIMER1_TEZ_INT_ST : 1;     /*!< The masked status bit for the interrupt triggered by a PWM timer
                                                     1 TEZ event.                                                              */
      __IM  uint32_t TIMER2_TEZ_INT_ST : 1;     /*!< The masked status bit for the interrupt triggered by a PWM timer
                                                     2 TEZ event.                                                              */
      __IM  uint32_t TIMER0_TEP_INT_ST : 1;     /*!< The masked status bit for the interrupt triggered by a PWM timer
                                                     0 TEP event.                                                              */
      __IM  uint32_t TIMER1_TEP_INT_ST : 1;     /*!< The masked status bit for the interrupt triggered by a PWM timer
                                                     1 TEP event.                                                              */
      __IM  uint32_t TIMER2_TEP_INT_ST : 1;     /*!< The masked status bit for the interrupt triggered by a PWM timer
                                                     2 TEP event.                                                              */
      __IM  uint32_t FAULT0_INT_ST : 1;         /*!< The masked status bit for the interrupt triggered when event_f0
                                                     starts.                                                                   */
      __IM  uint32_t FAULT1_INT_ST : 1;         /*!< The masked status bit for the interrupt triggered when event_f1
                                                     starts.                                                                   */
      __IM  uint32_t FAULT2_INT_ST : 1;         /*!< The masked status bit for the interrupt triggered when event_f2
                                                     starts.                                                                   */
      __IM  uint32_t FAULT0_CLR_INT_ST : 1;     /*!< The masked status bit for the interrupt triggered when event_f0
                                                     ends.                                                                     */
      __IM  uint32_t FAULT1_CLR_INT_ST : 1;     /*!< The masked status bit for the interrupt triggered when event_f1
                                                     ends.                                                                     */
      __IM  uint32_t FAULT2_CLR_INT_ST : 1;     /*!< The masked status bit for the interrupt triggered when event_f2
                                                     ends.                                                                     */
      __IM  uint32_t CMPR0_TEA_INT_ST : 1;      /*!< The masked status bit for the interrupt triggered by a PWM operator
                                                     0 TEA event                                                               */
      __IM  uint32_t CMPR1_TEA_INT_ST : 1;      /*!< The masked status bit for the interrupt triggered by a PWM operator
                                                     1 TEA event                                                               */
      __IM  uint32_t CMPR2_TEA_INT_ST : 1;      /*!< The masked status bit for the interrupt triggered by a PWM operator
                                                     2 TEA event                                                               */
      __IM  uint32_t CMPR0_TEB_INT_ST : 1;      /*!< The masked status bit for the interrupt triggered by a PWM operator
                                                     0 TEB event                                                               */
      __IM  uint32_t CMPR1_TEB_INT_ST : 1;      /*!< The masked status bit for the interrupt triggered by a PWM operator
                                                     1 TEB event                                                               */
      __IM  uint32_t CMPR2_TEB_INT_ST : 1;      /*!< The masked status bit for the interrupt triggered by a PWM operator
                                                     2 TEB event                                                               */
      __IM  uint32_t TZ0_CBC_INT_ST : 1;        /*!< The masked status bit for the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM0.                                                      */
      __IM  uint32_t TZ1_CBC_INT_ST : 1;        /*!< The masked status bit for the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM1.                                                      */
      __IM  uint32_t TZ2_CBC_INT_ST : 1;        /*!< The masked status bit for the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM2.                                                      */
      __IM  uint32_t TZ0_OST_INT_ST : 1;        /*!< The masked status bit for the interrupt triggered by a one-shot
                                                     mode action on PWM0.                                                      */
      __IM  uint32_t TZ1_OST_INT_ST : 1;        /*!< The masked status bit for the interrupt triggered by a one-shot
                                                     mode action on PWM1.                                                      */
      __IM  uint32_t TZ2_OST_INT_ST : 1;        /*!< The masked status bit for the interrupt triggered by a one-shot
                                                     mode action on PWM2.                                                      */
      __IM  uint32_t CAP0_INT_ST : 1;           /*!< The masked status bit for the interrupt triggered by capture
                                                     on channel 0.                                                             */
      __IM  uint32_t CAP1_INT_ST : 1;           /*!< The masked status bit for the interrupt triggered by capture
                                                     on channel 1.                                                             */
      __IM  uint32_t CAP2_INT_ST : 1;           /*!< The masked status bit for the interrupt triggered by capture
                                                     on channel 2.                                                             */
            uint32_t            : 2;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits                                                      */
    
    struct {
      __OM  uint32_t TIMER0_STOP_INT_CLR : 1;   /*!< Set this bit to clear the interrupt triggered when the timer
                                                     0 stops.                                                                  */
      __OM  uint32_t TIMER1_STOP_INT_CLR : 1;   /*!< Set this bit to clear the interrupt triggered when the timer
                                                     1 stops.                                                                  */
      __OM  uint32_t TIMER2_STOP_INT_CLR : 1;   /*!< Set this bit to clear the interrupt triggered when the timer
                                                     2 stops.                                                                  */
      __OM  uint32_t TIMER0_TEZ_INT_CLR : 1;    /*!< Set this bit to clear the interrupt triggered by a PWM timer
                                                     0 TEZ event.                                                              */
      __OM  uint32_t TIMER1_TEZ_INT_CLR : 1;    /*!< Set this bit to clear the interrupt triggered by a PWM timer
                                                     1 TEZ event.                                                              */
      __OM  uint32_t TIMER2_TEZ_INT_CLR : 1;    /*!< Set this bit to clear the interrupt triggered by a PWM timer
                                                     2 TEZ event.                                                              */
      __OM  uint32_t TIMER0_TEP_INT_CLR : 1;    /*!< Set this bit to clear the interrupt triggered by a PWM timer
                                                     0 TEP event.                                                              */
      __OM  uint32_t TIMER1_TEP_INT_CLR : 1;    /*!< Set this bit to clear the interrupt triggered by a PWM timer
                                                     1 TEP event.                                                              */
      __OM  uint32_t TIMER2_TEP_INT_CLR : 1;    /*!< Set this bit to clear the interrupt triggered by a PWM timer
                                                     2 TEP event.                                                              */
      __OM  uint32_t FAULT0_INT_CLR : 1;        /*!< Set this bit to clear the interrupt triggered when event_f0
                                                     starts.                                                                   */
      __OM  uint32_t FAULT1_INT_CLR : 1;        /*!< Set this bit to clear the interrupt triggered when event_f1
                                                     starts.                                                                   */
      __OM  uint32_t FAULT2_INT_CLR : 1;        /*!< Set this bit to clear the interrupt triggered when event_f2
                                                     starts.                                                                   */
      __OM  uint32_t FAULT0_CLR_INT_CLR : 1;    /*!< Set this bit to clear the interrupt triggered when event_f0
                                                     ends.                                                                     */
      __OM  uint32_t FAULT1_CLR_INT_CLR : 1;    /*!< Set this bit to clear the interrupt triggered when event_f1
                                                     ends.                                                                     */
      __OM  uint32_t FAULT2_CLR_INT_CLR : 1;    /*!< Set this bit to clear the interrupt triggered when event_f2
                                                     ends.                                                                     */
      __OM  uint32_t CMPR0_TEA_INT_CLR : 1;     /*!< Set this bit to clear the interrupt triggered by a PWM operator
                                                     0 TEA event                                                               */
      __OM  uint32_t CMPR1_TEA_INT_CLR : 1;     /*!< Set this bit to clear the interrupt triggered by a PWM operator
                                                     1 TEA event                                                               */
      __OM  uint32_t CMPR2_TEA_INT_CLR : 1;     /*!< Set this bit to clear the interrupt triggered by a PWM operator
                                                     2 TEA event                                                               */
      __OM  uint32_t CMPR0_TEB_INT_CLR : 1;     /*!< Set this bit to clear the interrupt triggered by a PWM operator
                                                     0 TEB event                                                               */
      __OM  uint32_t CMPR1_TEB_INT_CLR : 1;     /*!< Set this bit to clear the interrupt triggered by a PWM operator
                                                     1 TEB event                                                               */
      __OM  uint32_t CMPR2_TEB_INT_CLR : 1;     /*!< Set this bit to clear the interrupt triggered by a PWM operator
                                                     2 TEB event                                                               */
      __OM  uint32_t TZ0_CBC_INT_CLR : 1;       /*!< Set this bit to clear the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM0.                                                      */
      __OM  uint32_t TZ1_CBC_INT_CLR : 1;       /*!< Set this bit to clear the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM1.                                                      */
      __OM  uint32_t TZ2_CBC_INT_CLR : 1;       /*!< Set this bit to clear the interrupt triggered by a cycle-by-cycle
                                                     mode action on PWM2.                                                      */
      __OM  uint32_t TZ0_OST_INT_CLR : 1;       /*!< Set this bit to clear the interrupt triggered by a one-shot
                                                     mode action on PWM0.                                                      */
      __OM  uint32_t TZ1_OST_INT_CLR : 1;       /*!< Set this bit to clear the interrupt triggered by a one-shot
                                                     mode action on PWM1.                                                      */
      __OM  uint32_t TZ2_OST_INT_CLR : 1;       /*!< Set this bit to clear the interrupt triggered by a one-shot
                                                     mode action on PWM2.                                                      */
      __OM  uint32_t CAP0_INT_CLR : 1;          /*!< Set this bit to clear the interrupt triggered by capture on
                                                     channel 0.                                                                */
      __OM  uint32_t CAP1_INT_CLR : 1;          /*!< Set this bit to clear the interrupt triggered by capture on
                                                     channel 1.                                                                */
      __OM  uint32_t CAP2_INT_CLR : 1;          /*!< Set this bit to clear the interrupt triggered by capture on
                                                     channel 2.                                                                */
            uint32_t            : 2;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< MCPWM APB configuration register                                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< Force clock on for this register file                                     */
            uint32_t            : 31;
    } bit;
  } CLK;
  
  union {
    __IOM uint32_t reg;                         /*!< Version register.                                                         */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< Version of this register file                                             */
            uint32_t            : 4;
    } bit;
  } VERSION;
} MCPWM0_Type;                                  /*!< Size = 296 (0x128)                                                        */



/* =========================================================================================================================== */
/* ================                                            RMT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Remote Control (RMT)
  */

typedef struct {                                /*!< RMT Structure                                                             */
  __IOM uint32_t  CH0DATA;                      /*!< The read and write data register for CHANNEL0 by apb fifo access.         */
  __IM  uint32_t  RESERVED[3];
  __IOM uint32_t  CH1DATA;                      /*!< The read and write data register for CHANNEL1 by apb fifo access.         */
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t CH2DATA;                     /*!< The read and write data register for CHANNEL2 by apb fifo access.         */
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 0 configure register 0                                            */
      
      struct {
              uint32_t          : 23;
        __OM  uint32_t AFIFO_RST : 1;           /*!< Reserved                                                                  */
              uint32_t          : 8;
      } bit;
    } CH0_TX_CONF0;
  };
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t CH3DATA;                     /*!< The read and write data register for CHANNEL3 by apb fifo access.         */
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 1 configure register 0                                            */
      
      struct {
              uint32_t          : 23;
        __OM  uint32_t AFIFO_RST : 1;           /*!< Reserved                                                                  */
              uint32_t          : 8;
      } bit;
    } CH1_TX_CONF0;
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 4 configure register 0                                            */
      
      struct {
              uint32_t          : 8;
        __IOM uint32_t IDLE_THRES : 15;         /*!< When no edge is detected on the input signal and continuous
                                                     clock cycles is longer than this register value, received
                                                     process is finished.                                                      */
              uint32_t          : 9;
      } bit;
    } CH4_RX_CONF0;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< Channel 4 configure register 1                                            */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t RX_FILTER_THRES : 8;       /*!< Ignores the input pulse when its width is smaller than this
                                                     register value in APB clock periods (in receive mode).                    */
            uint32_t            : 1;
      __OM  uint32_t AFIFO_RST  : 1;            /*!< Reserved                                                                  */
            uint32_t            : 17;
    } bit;
  } CH4_RX_CONF1;
  __IM  uint32_t  RESERVED3[2];
  
  union {
    __IOM uint32_t CH4DATA;                     /*!< The read and write data register for CHANNEL4 by apb fifo access.         */
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 2 configure register 0                                            */
      
      struct {
              uint32_t          : 23;
        __OM  uint32_t AFIFO_RST : 1;           /*!< Reserved                                                                  */
              uint32_t          : 8;
      } bit;
    } CH2_TX_CONF0;
  };
  __IM  uint32_t  RESERVED4[3];
  
  union {
    __IOM uint32_t CH5DATA;                     /*!< The read and write data register for CHANNEL5 by apb fifo access.         */
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 3 configure register 0                                            */
      
      struct {
              uint32_t          : 23;
        __OM  uint32_t AFIFO_RST : 1;           /*!< Reserved                                                                  */
              uint32_t          : 8;
      } bit;
    } CH3_TX_CONF0;
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 5 configure register 0                                            */
      
      struct {
              uint32_t          : 8;
        __IOM uint32_t IDLE_THRES : 15;         /*!< When no edge is detected on the input signal and continuous
                                                     clock cycles is longer than this register value, received
                                                     process is finished.                                                      */
              uint32_t          : 9;
      } bit;
    } CH5_RX_CONF0;
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 0 status register                                                 */
      
      struct {
              uint32_t          : 11;
        __IM  uint32_t APB_MEM_WADDR : 10;      /*!< This register records the memory address offset when writes
                                                     RAM over APB bus.                                                         */
              uint32_t          : 4;
        __IM  uint32_t MEM_EMPTY : 1;           /*!< This status bit will be set when the data to be set is more
                                                     than memory size and the wraparound mode is disabled.                     */
        __IM  uint32_t APB_MEM_WR_ERR : 1;      /*!< This status bit will be set if the offset address out of memory
                                                     size when writes via APB bus.                                             */
              uint32_t          : 5;
      } bit;
    } CH0_TX_STATUS;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< Channel 5 configure register 1                                            */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t RX_FILTER_THRES : 8;       /*!< Ignores the input pulse when its width is smaller than this
                                                     register value in APB clock periods (in receive mode).                    */
            uint32_t            : 1;
      __OM  uint32_t AFIFO_RST  : 1;            /*!< Reserved                                                                  */
            uint32_t            : 17;
    } bit;
  } CH5_RX_CONF1;
  __IM  uint32_t  RESERVED5[2];
  
  union {
    __IOM uint32_t CH6DATA;                     /*!< The read and write data register for CHANNEL6 by apb fifo access.         */
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 1 status register                                                 */
      
      struct {
              uint32_t          : 11;
        __IM  uint32_t APB_MEM_WADDR : 10;      /*!< This register records the memory address offset when writes
                                                     RAM over APB bus.                                                         */
              uint32_t          : 4;
        __IM  uint32_t MEM_EMPTY : 1;           /*!< This status bit will be set when the data to be set is more
                                                     than memory size and the wraparound mode is disabled.                     */
        __IM  uint32_t APB_MEM_WR_ERR : 1;      /*!< This status bit will be set if the offset address out of memory
                                                     size when writes via APB bus.                                             */
              uint32_t          : 5;
      } bit;
    } CH1_TX_STATUS;
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 0 status register                                                 */
      
      struct {
              uint32_t          : 11;
        __IM  uint32_t APB_MEM_RADDR : 10;      /*!< This register records the memory address offset when reads RAM
                                                     over APB bus.                                                             */
              uint32_t          : 4;
        __IM  uint32_t MEM_OWNER_ERR : 1;       /*!< This status bit will be set when the ownership of memory block
                                                     is wrong.                                                                 */
        __IM  uint32_t MEM_FULL : 1;            /*!< This status bit will be set if the receiver receives more data
                                                     than the memory size.                                                     */
        __IM  uint32_t APB_MEM_RD_ERR : 1;      /*!< This status bit will be set if the offset address out of memory
                                                     size when reads via APB bus.                                              */
              uint32_t          : 4;
      } bit;
    } CH0_RX_STATUS;
  };
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t CH7DATA;                     /*!< The read and write data register for CHANNEL7 by apb fifo access.         */
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 6 configure register 0                                            */
      
      struct {
              uint32_t          : 8;
        __IOM uint32_t IDLE_THRES : 15;         /*!< When no edge is detected on the input signal and continuous
                                                     clock cycles is longer than this register value, received
                                                     process is finished.                                                      */
              uint32_t          : 9;
      } bit;
    } CH6_RX_CONF0;
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 2 status register                                                 */
      
      struct {
              uint32_t          : 11;
        __IM  uint32_t APB_MEM_WADDR : 10;      /*!< This register records the memory address offset when writes
                                                     RAM over APB bus.                                                         */
              uint32_t          : 4;
        __IM  uint32_t MEM_EMPTY : 1;           /*!< This status bit will be set when the data to be set is more
                                                     than memory size and the wraparound mode is disabled.                     */
        __IM  uint32_t APB_MEM_WR_ERR : 1;      /*!< This status bit will be set if the offset address out of memory
                                                     size when writes via APB bus.                                             */
              uint32_t          : 5;
      } bit;
    } CH2_TX_STATUS;
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 1 status register                                                 */
      
      struct {
              uint32_t          : 11;
        __IM  uint32_t APB_MEM_RADDR : 10;      /*!< This register records the memory address offset when reads RAM
                                                     over APB bus.                                                             */
              uint32_t          : 4;
        __IM  uint32_t MEM_OWNER_ERR : 1;       /*!< This status bit will be set when the ownership of memory block
                                                     is wrong.                                                                 */
        __IM  uint32_t MEM_FULL : 1;            /*!< This status bit will be set if the receiver receives more data
                                                     than the memory size.                                                     */
        __IM  uint32_t APB_MEM_RD_ERR : 1;      /*!< This status bit will be set if the offset address out of memory
                                                     size when reads via APB bus.                                              */
              uint32_t          : 4;
      } bit;
    } CH1_RX_STATUS;
    
    union {
      __IOM uint32_t reg;                       /*!< Raw interrupt status                                                      */
      
      struct {
        __IOM uint32_t CH0_TX_END : 1;          /*!< The interrupt raw bit for CHANNEL0. Triggered when transmission
                                                     done.                                                                     */
              uint32_t          : 3;
        __IOM uint32_t CH1_TX_END : 1;          /*!< The interrupt raw bit for CHANNEL1. Triggered when transmission
                                                     done.                                                                     */
              uint32_t          : 3;
        __IOM uint32_t CH2_TX_END : 1;          /*!< The interrupt raw bit for CHANNEL2. Triggered when transmission
                                                     done.                                                                     */
              uint32_t          : 3;
        __IOM uint32_t CH3_TX_END : 1;          /*!< The interrupt raw bit for CHANNEL3. Triggered when transmission
                                                     done.                                                                     */
              uint32_t          : 3;
        __IOM uint32_t CH3_TX_ERR : 1;          /*!< The interrupt raw bit for CHANNEL3. Triggered when error occurs.          */
              uint32_t          : 3;
        __IOM uint32_t CH3_TX_THR_EVENT : 1;    /*!< The interrupt raw bit for CHANNEL3. Triggered when transmitter
                                                     sent more data than configured value.                                     */
              uint32_t          : 3;
        __IOM uint32_t CH3_TX_LOOP : 1;         /*!< The interrupt raw bit for CHANNEL3. Triggered when the loop
                                                     count reaches the configured threshold value.                             */
              uint32_t          : 3;
        __IOM uint32_t CH7_RX_END : 1;          /*!< The interrupt raw bit for CHANNEL4. Triggered when reception
                                                     done.                                                                     */
        __IOM uint32_t RX_CH7_DMA_ACCESS_FAIL : 1;/*!< The interrupt raw bit for CHANNEL7. Triggered when dma accessing
                                                     CHANNEL7 fails.                                                           */
              uint32_t          : 2;
      } bit_0;
      
      struct {
              uint32_t          : 4;
        __IOM uint32_t CH0_TX_ERR : 1;          /*!< The interrupt raw bit for CHANNEL0. Triggered when error occurs.          */
              uint32_t          : 3;
        __IOM uint32_t CH1_TX_ERR : 1;          /*!< The interrupt raw bit for CHANNEL1. Triggered when error occurs.          */
              uint32_t          : 3;
        __IOM uint32_t CH2_TX_ERR : 1;          /*!< The interrupt raw bit for CHANNEL2. Triggered when error occurs.          */
              uint32_t          : 3;
        __IOM uint32_t CH2_TX_THR_EVENT : 1;    /*!< The interrupt raw bit for CHANNEL2. Triggered when transmitter
                                                     sent more data than configured value.                                     */
              uint32_t          : 3;
        __IOM uint32_t CH2_TX_LOOP : 1;         /*!< The interrupt raw bit for CHANNEL2. Triggered when the loop
                                                     count reaches the configured threshold value.                             */
              uint32_t          : 3;
        __IOM uint32_t CH6_RX_END : 1;          /*!< The interrupt raw bit for CHANNEL4. Triggered when reception
                                                     done.                                                                     */
              uint32_t          : 3;
        __IOM uint32_t CH6_RX_ERR : 1;          /*!< The interrupt raw bit for CHANNEL4. Triggered when error occurs.          */
              uint32_t          : 3;
      } bit_1;
      
      struct {
              uint32_t          : 8;
        __IOM uint32_t CH0_TX_THR_EVENT : 1;    /*!< The interrupt raw bit for CHANNEL0. Triggered when transmitter
                                                     sent more data than configured value.                                     */
              uint32_t          : 3;
        __IOM uint32_t CH1_TX_THR_EVENT : 1;    /*!< The interrupt raw bit for CHANNEL1. Triggered when transmitter
                                                     sent more data than configured value.                                     */
              uint32_t          : 3;
        __IOM uint32_t CH1_TX_LOOP : 1;         /*!< The interrupt raw bit for CHANNEL1. Triggered when the loop
                                                     count reaches the configured threshold value.                             */
              uint32_t          : 3;
        __IOM uint32_t CH5_RX_END : 1;          /*!< The interrupt raw bit for CHANNEL4. Triggered when reception
                                                     done.                                                                     */
              uint32_t          : 3;
        __IOM uint32_t CH5_RX_ERR : 1;          /*!< The interrupt raw bit for CHANNEL4. Triggered when error occurs.          */
              uint32_t          : 3;
        __IOM uint32_t CH5_RX_THR_EVENT : 1;    /*!< The interrupt raw bit for CHANNEL4. Triggered when receiver
                                                     receive more data than configured value.                                  */
              uint32_t          : 3;
      } bit_2;
      
      struct {
              uint32_t          : 12;
        __IOM uint32_t CH0_TX_LOOP : 1;         /*!< The interrupt raw bit for CHANNEL0. Triggered when the loop
                                                     count reaches the configured threshold value.                             */
              uint32_t          : 3;
        __IOM uint32_t CH4_RX_END : 1;          /*!< The interrupt raw bit for CHANNEL4. Triggered when reception
                                                     done.                                                                     */
              uint32_t          : 3;
        __IOM uint32_t CH4_RX_ERR : 1;          /*!< The interrupt raw bit for CHANNEL4. Triggered when error occurs.          */
              uint32_t          : 3;
        __IOM uint32_t CH4_RX_THR_EVENT : 1;    /*!< The interrupt raw bit for CHANNEL4. Triggered when receiver
                                                     receive more data than configured value.                                  */
              uint32_t          : 3;
        __IOM uint32_t TX_CH3_DMA_ACCESS_FAIL : 1;/*!< The interrupt raw bit for CHANNEL3. Triggered when dma accessing
                                                     CHANNEL3 fails.                                                           */
              uint32_t          : 3;
      } bit_3;
    } INT_RAW;
  };
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Channel 6 configure register 1                                            */
      
      struct {
              uint32_t          : 5;
        __IOM uint32_t RX_FILTER_THRES : 8;     /*!< Ignores the input pulse when its width is smaller than this
                                                     register value in APB clock periods (in receive mode).                    */
              uint32_t          : 1;
        __OM  uint32_t AFIFO_RST : 1;           /*!< Reserved                                                                  */
              uint32_t          : 17;
      } bit;
    } CH6_RX_CONF1;
    
    union {
      __IOM uint32_t reg;                       /*!< Masked interrupt status                                                   */
      
      struct {
        __IM  uint32_t CH0_TX_END : 1;          /*!< The masked interrupt status bit for CH0_TX_END_INT.                       */
              uint32_t          : 3;
        __IM  uint32_t CH1_TX_END : 1;          /*!< The masked interrupt status bit for CH1_TX_END_INT.                       */
              uint32_t          : 3;
        __IM  uint32_t CH2_TX_END : 1;          /*!< The masked interrupt status bit for CH2_TX_END_INT.                       */
              uint32_t          : 3;
        __IM  uint32_t CH3_TX_END : 1;          /*!< The masked interrupt status bit for CH3_TX_END_INT.                       */
              uint32_t          : 3;
        __IM  uint32_t CH3_TX_ERR : 1;          /*!< The masked interrupt status bit for CH3_ERR_INT.                          */
              uint32_t          : 3;
        __IM  uint32_t CH3_TX_THR_EVENT : 1;    /*!< The masked interrupt status bit for CH3_TX_THR_EVENT_INT.                 */
              uint32_t          : 3;
        __IM  uint32_t CH3_TX_LOOP : 1;         /*!< The masked interrupt status bit for CH3_TX_LOOP_INT.                      */
              uint32_t          : 3;
        __IM  uint32_t CH7_RX_END : 1;          /*!< The masked interrupt status bit for CH4_RX_END_INT.                       */
        __IM  uint32_t RX_CH7_DMA_ACCESS_FAIL : 1;/*!< The masked interrupt status bit for CH7_DMA_ACCESS_FAIL_INT.            */
              uint32_t          : 2;
      } bit_0;
      
      struct {
              uint32_t          : 4;
        __IM  uint32_t CH0_TX_ERR : 1;          /*!< The masked interrupt status bit for CH0_ERR_INT.                          */
              uint32_t          : 3;
        __IM  uint32_t CH1_TX_ERR : 1;          /*!< The masked interrupt status bit for CH1_ERR_INT.                          */
              uint32_t          : 3;
        __IM  uint32_t CH2_TX_ERR : 1;          /*!< The masked interrupt status bit for CH2_ERR_INT.                          */
              uint32_t          : 3;
        __IM  uint32_t CH2_TX_THR_EVENT : 1;    /*!< The masked interrupt status bit for CH2_TX_THR_EVENT_INT.                 */
              uint32_t          : 3;
        __IM  uint32_t CH2_TX_LOOP : 1;         /*!< The masked interrupt status bit for CH2_TX_LOOP_INT.                      */
              uint32_t          : 3;
        __IM  uint32_t CH6_RX_END : 1;          /*!< The masked interrupt status bit for CH4_RX_END_INT.                       */
              uint32_t          : 3;
        __IM  uint32_t CH6_RX_ERR : 1;          /*!< The masked interrupt status bit for CH4_ERR_INT.                          */
              uint32_t          : 3;
      } bit_1;
      
      struct {
              uint32_t          : 8;
        __IM  uint32_t CH0_TX_THR_EVENT : 1;    /*!< The masked interrupt status bit for CH0_TX_THR_EVENT_INT.                 */
              uint32_t          : 3;
        __IM  uint32_t CH1_TX_THR_EVENT : 1;    /*!< The masked interrupt status bit for CH1_TX_THR_EVENT_INT.                 */
              uint32_t          : 3;
        __IM  uint32_t CH1_TX_LOOP : 1;         /*!< The masked interrupt status bit for CH1_TX_LOOP_INT.                      */
              uint32_t          : 3;
        __IM  uint32_t CH5_RX_END : 1;          /*!< The masked interrupt status bit for CH4_RX_END_INT.                       */
              uint32_t          : 3;
        __IM  uint32_t CH5_RX_ERR : 1;          /*!< The masked interrupt status bit for CH4_ERR_INT.                          */
              uint32_t          : 3;
        __IM  uint32_t CH5_RX_THR_EVENT : 1;    /*!< The masked interrupt status bit for CH4_RX_THR_EVENT_INT.                 */
              uint32_t          : 3;
      } bit_2;
      
      struct {
              uint32_t          : 12;
        __IM  uint32_t CH0_TX_LOOP : 1;         /*!< The masked interrupt status bit for CH0_TX_LOOP_INT.                      */
              uint32_t          : 3;
        __IM  uint32_t CH4_RX_END : 1;          /*!< The masked interrupt status bit for CH4_RX_END_INT.                       */
              uint32_t          : 3;
        __IM  uint32_t CH4_RX_ERR : 1;          /*!< The masked interrupt status bit for CH4_ERR_INT.                          */
              uint32_t          : 3;
        __IM  uint32_t CH4_RX_THR_EVENT : 1;    /*!< The masked interrupt status bit for CH4_RX_THR_EVENT_INT.                 */
              uint32_t          : 3;
        __IM  uint32_t TX_CH3_DMA_ACCESS_FAIL : 1;/*!< The masked interrupt status bit for CH3_DMA_ACCESS_FAIL_INT.            */
              uint32_t          : 3;
      } bit_3;
    } INT_ST;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits                                                     */
    
    struct {
      __IOM uint32_t CH0_TX_END : 1;            /*!< The interrupt enable bit for CH0_TX_END_INT.                              */
            uint32_t            : 3;
      __IOM uint32_t CH1_TX_END : 1;            /*!< The interrupt enable bit for CH1_TX_END_INT.                              */
            uint32_t            : 3;
      __IOM uint32_t CH2_TX_END : 1;            /*!< The interrupt enable bit for CH2_TX_END_INT.                              */
            uint32_t            : 3;
      __IOM uint32_t CH3_TX_END : 1;            /*!< The interrupt enable bit for CH3_TX_END_INT.                              */
            uint32_t            : 3;
      __IOM uint32_t CH3_TX_ERR : 1;            /*!< The interrupt enable bit for CH3_ERR_INT.                                 */
            uint32_t            : 3;
      __IOM uint32_t CH3_TX_THR_EVENT : 1;      /*!< The interrupt enable bit for CH3_TX_THR_EVENT_INT.                        */
            uint32_t            : 3;
      __IOM uint32_t CH3_TX_LOOP : 1;           /*!< The interrupt enable bit for CH3_TX_LOOP_INT.                             */
            uint32_t            : 3;
      __IOM uint32_t CH7_RX_END : 1;            /*!< The interrupt enable bit for CH4_RX_END_INT.                              */
      __IOM uint32_t RX_CH7_DMA_ACCESS_FAIL : 1;/*!< The interrupt enable bit for CH7_DMA_ACCESS_FAIL_INT.                     */
            uint32_t            : 2;
    } bit_0;
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t CH0_TX_ERR : 1;            /*!< The interrupt enable bit for CH0_ERR_INT.                                 */
            uint32_t            : 3;
      __IOM uint32_t CH1_TX_ERR : 1;            /*!< The interrupt enable bit for CH1_ERR_INT.                                 */
            uint32_t            : 3;
      __IOM uint32_t CH2_TX_ERR : 1;            /*!< The interrupt enable bit for CH2_ERR_INT.                                 */
            uint32_t            : 3;
      __IOM uint32_t CH2_TX_THR_EVENT : 1;      /*!< The interrupt enable bit for CH2_TX_THR_EVENT_INT.                        */
            uint32_t            : 3;
      __IOM uint32_t CH2_TX_LOOP : 1;           /*!< The interrupt enable bit for CH2_TX_LOOP_INT.                             */
            uint32_t            : 3;
      __IOM uint32_t CH6_RX_END : 1;            /*!< The interrupt enable bit for CH4_RX_END_INT.                              */
            uint32_t            : 3;
      __IOM uint32_t CH6_RX_ERR : 1;            /*!< The interrupt enable bit for CH4_ERR_INT.                                 */
            uint32_t            : 3;
    } bit_1;
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t CH0_TX_THR_EVENT : 1;      /*!< The interrupt enable bit for CH0_TX_THR_EVENT_INT.                        */
            uint32_t            : 3;
      __IOM uint32_t CH1_TX_THR_EVENT : 1;      /*!< The interrupt enable bit for CH1_TX_THR_EVENT_INT.                        */
            uint32_t            : 3;
      __IOM uint32_t CH1_TX_LOOP : 1;           /*!< The interrupt enable bit for CH1_TX_LOOP_INT.                             */
            uint32_t            : 3;
      __IOM uint32_t CH5_RX_END : 1;            /*!< The interrupt enable bit for CH4_RX_END_INT.                              */
            uint32_t            : 3;
      __IOM uint32_t CH5_RX_ERR : 1;            /*!< The interrupt enable bit for CH4_ERR_INT.                                 */
            uint32_t            : 3;
      __IOM uint32_t CH5_RX_THR_EVENT : 1;      /*!< The interrupt enable bit for CH4_RX_THR_EVENT_INT.                        */
            uint32_t            : 3;
    } bit_2;
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t CH0_TX_LOOP : 1;           /*!< The interrupt enable bit for CH0_TX_LOOP_INT.                             */
            uint32_t            : 3;
      __IOM uint32_t CH4_RX_END : 1;            /*!< The interrupt enable bit for CH4_RX_END_INT.                              */
            uint32_t            : 3;
      __IOM uint32_t CH4_RX_ERR : 1;            /*!< The interrupt enable bit for CH4_ERR_INT.                                 */
            uint32_t            : 3;
      __IOM uint32_t CH4_RX_THR_EVENT : 1;      /*!< The interrupt enable bit for CH4_RX_THR_EVENT_INT.                        */
            uint32_t            : 3;
      __IOM uint32_t TX_CH3_DMA_ACCESS_FAIL : 1;/*!< The interrupt enable bit for CH3_DMA_ACCESS_FAIL_INT.                     */
            uint32_t            : 3;
    } bit_3;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits                                                      */
    
    struct {
      __OM  uint32_t CH0_TX_END : 1;            /*!< Set this bit to clear theCH0_TX_END_INT interrupt.                        */
            uint32_t            : 3;
      __OM  uint32_t CH1_TX_END : 1;            /*!< Set this bit to clear theCH1_TX_END_INT interrupt.                        */
            uint32_t            : 3;
      __OM  uint32_t CH2_TX_END : 1;            /*!< Set this bit to clear theCH2_TX_END_INT interrupt.                        */
            uint32_t            : 3;
      __OM  uint32_t CH3_TX_END : 1;            /*!< Set this bit to clear theCH3_TX_END_INT interrupt.                        */
            uint32_t            : 3;
      __OM  uint32_t CH3_TX_ERR : 1;            /*!< Set this bit to clear theCH3_ERR_INT interrupt.                           */
            uint32_t            : 3;
      __OM  uint32_t CH3_TX_THR_EVENT : 1;      /*!< Set this bit to clear theCH3_TX_THR_EVENT_INT interrupt.                  */
            uint32_t            : 3;
      __OM  uint32_t CH3_TX_LOOP : 1;           /*!< Set this bit to clear theCH3_TX_LOOP_INT interrupt.                       */
            uint32_t            : 3;
      __OM  uint32_t CH7_RX_END : 1;            /*!< Set this bit to clear theCH4_RX_END_INT interrupt.                        */
      __OM  uint32_t RX_CH7_DMA_ACCESS_FAIL : 1;/*!< Set this bit to clear the CH7_DMA_ACCESS_FAIL_INT interrupt.              */
            uint32_t            : 2;
    } bit_0;
    
    struct {
            uint32_t            : 4;
      __OM  uint32_t CH0_TX_ERR : 1;            /*!< Set this bit to clear theCH0_ERR_INT interrupt.                           */
            uint32_t            : 3;
      __OM  uint32_t CH1_TX_ERR : 1;            /*!< Set this bit to clear theCH1_ERR_INT interrupt.                           */
            uint32_t            : 3;
      __OM  uint32_t CH2_TX_ERR : 1;            /*!< Set this bit to clear theCH2_ERR_INT interrupt.                           */
            uint32_t            : 3;
      __OM  uint32_t CH2_TX_THR_EVENT : 1;      /*!< Set this bit to clear theCH2_TX_THR_EVENT_INT interrupt.                  */
            uint32_t            : 3;
      __OM  uint32_t CH2_TX_LOOP : 1;           /*!< Set this bit to clear theCH2_TX_LOOP_INT interrupt.                       */
            uint32_t            : 3;
      __OM  uint32_t CH6_RX_END : 1;            /*!< Set this bit to clear theCH4_RX_END_INT interrupt.                        */
            uint32_t            : 3;
      __OM  uint32_t CH6_RX_ERR : 1;            /*!< Set this bit to clear theCH4_ERR_INT interrupt.                           */
            uint32_t            : 3;
    } bit_1;
    
    struct {
            uint32_t            : 8;
      __OM  uint32_t CH0_TX_THR_EVENT : 1;      /*!< Set this bit to clear theCH0_TX_THR_EVENT_INT interrupt.                  */
            uint32_t            : 3;
      __OM  uint32_t CH1_TX_THR_EVENT : 1;      /*!< Set this bit to clear theCH1_TX_THR_EVENT_INT interrupt.                  */
            uint32_t            : 3;
      __OM  uint32_t CH1_TX_LOOP : 1;           /*!< Set this bit to clear theCH1_TX_LOOP_INT interrupt.                       */
            uint32_t            : 3;
      __OM  uint32_t CH5_RX_END : 1;            /*!< Set this bit to clear theCH4_RX_END_INT interrupt.                        */
            uint32_t            : 3;
      __OM  uint32_t CH5_RX_ERR : 1;            /*!< Set this bit to clear theCH4_ERR_INT interrupt.                           */
            uint32_t            : 3;
      __OM  uint32_t CH5_RX_THR_EVENT : 1;      /*!< Set this bit to clear theCH4_RX_THR_EVENT_INT interrupt.                  */
            uint32_t            : 3;
    } bit_2;
    
    struct {
            uint32_t            : 12;
      __OM  uint32_t CH0_TX_LOOP : 1;           /*!< Set this bit to clear theCH0_TX_LOOP_INT interrupt.                       */
            uint32_t            : 3;
      __OM  uint32_t CH4_RX_END : 1;            /*!< Set this bit to clear theCH4_RX_END_INT interrupt.                        */
            uint32_t            : 3;
      __OM  uint32_t CH4_RX_ERR : 1;            /*!< Set this bit to clear theCH4_ERR_INT interrupt.                           */
            uint32_t            : 3;
      __OM  uint32_t CH4_RX_THR_EVENT : 1;      /*!< Set this bit to clear theCH4_RX_THR_EVENT_INT interrupt.                  */
            uint32_t            : 3;
      __OM  uint32_t TX_CH3_DMA_ACCESS_FAIL : 1;/*!< Set this bit to clear the CH3_DMA_ACCESS_FAIL_INT interrupt.              */
            uint32_t            : 3;
    } bit_3;
  } INT_CLR;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Channel 3 status register                                                 */
      
      struct {
              uint32_t          : 11;
        __IM  uint32_t APB_MEM_WADDR : 10;      /*!< This register records the memory address offset when writes
                                                     RAM over APB bus.                                                         */
              uint32_t          : 4;
        __IM  uint32_t MEM_EMPTY : 1;           /*!< This status bit will be set when the data to be set is more
                                                     than memory size and the wraparound mode is disabled.                     */
        __IM  uint32_t APB_MEM_WR_ERR : 1;      /*!< This status bit will be set if the offset address out of memory
                                                     size when writes via APB bus.                                             */
              uint32_t          : 5;
      } bit;
    } CH3_TX_STATUS;
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 2 status register                                                 */
      
      struct {
              uint32_t          : 11;
        __IM  uint32_t APB_MEM_RADDR : 10;      /*!< This register records the memory address offset when reads RAM
                                                     over APB bus.                                                             */
              uint32_t          : 4;
        __IM  uint32_t MEM_OWNER_ERR : 1;       /*!< This status bit will be set when the ownership of memory block
                                                     is wrong.                                                                 */
        __IM  uint32_t MEM_FULL : 1;            /*!< This status bit will be set if the receiver receives more data
                                                     than the memory size.                                                     */
        __IM  uint32_t APB_MEM_RD_ERR : 1;      /*!< This status bit will be set if the offset address out of memory
                                                     size when reads via APB bus.                                              */
              uint32_t          : 4;
      } bit;
    } CH2_RX_STATUS;
    __IOM uint32_t CH0CARRIER_DUTY;             /*!< Channel 0 duty cycle configuration register                               */
  };
  __IM  uint32_t  RESERVED7[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Channel 7 configure register 0                                            */
      
      struct {
              uint32_t          : 8;
        __IOM uint32_t IDLE_THRES : 15;         /*!< When no edge is detected on the input signal and continuous
                                                     clock cycles is longer than this register value, received
                                                     process is finished.                                                      */
              uint32_t          : 9;
      } bit;
    } CH7_RX_CONF0;
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 3 status register                                                 */
      
      struct {
              uint32_t          : 11;
        __IM  uint32_t APB_MEM_RADDR : 10;      /*!< This register records the memory address offset when reads RAM
                                                     over APB bus.                                                             */
              uint32_t          : 4;
        __IM  uint32_t MEM_OWNER_ERR : 1;       /*!< This status bit will be set when the ownership of memory block
                                                     is wrong.                                                                 */
        __IM  uint32_t MEM_FULL : 1;            /*!< This status bit will be set if the receiver receives more data
                                                     than the memory size.                                                     */
        __IM  uint32_t APB_MEM_RD_ERR : 1;      /*!< This status bit will be set if the offset address out of memory
                                                     size when reads via APB bus.                                              */
              uint32_t          : 4;
      } bit;
    } CH3_RX_STATUS;
    __IOM uint32_t CH1CARRIER_DUTY;             /*!< Channel 1 duty cycle configuration register                               */
    __IOM uint32_t CH0_RX_CARRIER_RM;           /*!< Channel 0 carrier remove register                                         */
  };
  
  union {
    __IOM uint32_t reg;                         /*!< Channel 7 configure register 1                                            */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t RX_FILTER_THRES : 8;       /*!< Ignores the input pulse when its width is smaller than this
                                                     register value in APB clock periods (in receive mode).                    */
            uint32_t            : 1;
      __OM  uint32_t AFIFO_RST  : 1;            /*!< Reserved                                                                  */
            uint32_t            : 17;
    } bit;
  } CH7_RX_CONF1;
  __IM  uint32_t  RESERVED8[2];
  
  union {
    __IOM uint32_t CH2CARRIER_DUTY;             /*!< Channel 2 duty cycle configuration register                               */
    __IOM uint32_t CH1_RX_CARRIER_RM;           /*!< Channel 1 carrier remove register                                         */
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 0 Tx event configuration register                                 */
      
      struct {
              uint32_t          : 9;
        __IOM uint32_t TX_LOOP_NUM : 10;        /*!< This register is used to configure the maximum loop count when
                                                     tx_conti_mode is valid.                                                   */
        __IOM uint32_t TX_LOOP_CNT_EN : 1;      /*!< This register is the enabled bit for loop count.                          */
        __OM  uint32_t LOOP_COUNT_RESET : 1;    /*!< This register is used to reset the loop count when tx_conti_mode
                                                     is valid.                                                                 */
              uint32_t          : 11;
      } bit;
    } CH0_TX_LIM;
  };
  __IM  uint32_t  RESERVED9[3];
  
  union {
    __IOM uint32_t CH3CARRIER_DUTY;             /*!< Channel 3 duty cycle configuration register                               */
    __IOM uint32_t CH2_RX_CARRIER_RM;           /*!< Channel 2 carrier remove register                                         */
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 1 Tx event configuration register                                 */
      
      struct {
              uint32_t          : 9;
        __IOM uint32_t TX_LOOP_NUM : 10;        /*!< This register is used to configure the maximum loop count when
                                                     tx_conti_mode is valid.                                                   */
        __IOM uint32_t TX_LOOP_CNT_EN : 1;      /*!< This register is the enabled bit for loop count.                          */
        __OM  uint32_t LOOP_COUNT_RESET : 1;    /*!< This register is used to reset the loop count when tx_conti_mode
                                                     is valid.                                                                 */
              uint32_t          : 11;
      } bit;
    } CH1_TX_LIM;
    __IOM uint32_t CH0_RX_LIM;                  /*!< Channel 0 Rx event configuration register                                 */
  };
  __IM  uint32_t  RESERVED10[3];
  
  union {
    __IOM uint32_t CH3_RX_CARRIER_RM;           /*!< Channel 3 carrier remove register                                         */
    
    union {
      __IOM uint32_t reg;                       /*!< Channel 2 Tx event configuration register                                 */
      
      struct {
              uint32_t          : 9;
        __IOM uint32_t TX_LOOP_NUM : 10;        /*!< This register is used to configure the maximum loop count when
                                                     tx_conti_mode is valid.                                                   */
        __IOM uint32_t TX_LOOP_CNT_EN : 1;      /*!< This register is the enabled bit for loop count.                          */
        __OM  uint32_t LOOP_COUNT_RESET : 1;    /*!< This register is used to reset the loop count when tx_conti_mode
                                                     is valid.                                                                 */
              uint32_t          : 11;
      } bit;
    } CH2_TX_LIM;
    __IOM uint32_t CH1_RX_LIM;                  /*!< Channel 1 Rx event configuration register                                 */
    
    union {
      __IOM uint32_t reg;                       /*!< RMT apb configuration register                                            */
      
      struct {
        __IOM uint32_t APB_FIFO_MASK : 1;       /*!< 1'h1: access memory directly. 1'h0: access memory by FIFO.                */
        __IOM uint32_t MEM_CLK_FORCE_ON : 1;    /*!< Set this bit to enable the clock for RMT memory.                          */
        __IOM uint32_t MEM_FORCE_PD : 1;        /*!< Set this bit to power down RMT memory.                                    */
        __IOM uint32_t MEM_FORCE_PU : 1;        /*!< 1: Disable RMT memory light sleep power down function. 0: Power
                                                     down RMT memory when RMT is in light sleep mode.                          */
        __IOM uint32_t SCLK_DIV_NUM : 8;        /*!< the integral part of the fractional divisor                               */
        __IOM uint32_t SCLK_DIV_A : 6;          /*!< the numerator of the fractional part of the fractional divisor            */
        __IOM uint32_t SCLK_DIV_B : 6;          /*!< the denominator of the fractional part of the fractional divisor          */
        __IOM uint32_t SCLK_SEL : 2;            /*!< choose the clock source of rmt_sclk. 1:CLK_80Mhz;2:CLK_8MHz;
                                                     2:XTAL                                                                    */
        __IOM uint32_t SCLK_ACTIVE : 1;         /*!< rmt_sclk switch                                                           */
              uint32_t          : 4;
        __IOM uint32_t CLK_EN   : 1;            /*!< RMT register clock gate enable signal. 1: Power up the drive
                                                     clock of registers. 0: Power down the drive clock of registers            */
      } bit;
    } SYS_CONF;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< RMT TX synchronous register                                               */
    
    struct {
      __IOM uint32_t CH0        : 1;            /*!< Set this bit to enable CHANNEL0 to start sending data synchronously
                                                     with other enabled channels.                                              */
      __IOM uint32_t CH1        : 1;            /*!< Set this bit to enable CHANNEL1 to start sending data synchronously
                                                     with other enabled channels.                                              */
      __IOM uint32_t CH2        : 1;            /*!< Set this bit to enable CHANNEL2 to start sending data synchronously
                                                     with other enabled channels.                                              */
      __IOM uint32_t CH3        : 1;            /*!< Set this bit to enable CHANNEL3 to start sending data synchronously
                                                     with other enabled channels.                                              */
      __IOM uint32_t EN         : 1;            /*!< This register is used to enable multiple of channels to start
                                                     sending data synchronously.                                               */
            uint32_t            : 27;
    } bit;
  } TX_SIM;
  
  union {
    __IOM uint32_t reg;                         /*!< RMT clock divider reset register                                          */
    
    struct {
      __OM  uint32_t CH0        : 1;            /*!< This register is used to reset the clock divider of CHANNEL0.             */
            uint32_t            : 3;
      __OM  uint32_t CH1        : 1;            /*!< This register is used to reset the clock divider of CHANNEL1.             */
            uint32_t            : 3;
      __OM  uint32_t CH2        : 1;            /*!< This register is used to reset the clock divider of CHANNEL2.             */
            uint32_t            : 3;
      __OM  uint32_t CH3        : 1;            /*!< This register is used to reset the clock divider of CHANNEL3.             */
            uint32_t            : 3;
      __OM  uint32_t CH4        : 1;            /*!< This register is used to reset the clock divider of CHANNEL4.             */
            uint32_t            : 3;
      __OM  uint32_t CH5        : 1;            /*!< This register is used to reset the clock divider of CHANNEL5.             */
            uint32_t            : 3;
      __OM  uint32_t CH6        : 1;            /*!< This register is used to reset the clock divider of CHANNEL6.             */
            uint32_t            : 3;
      __OM  uint32_t CH7        : 1;            /*!< This register is used to reset the clock divider of CHANNEL7.             */
            uint32_t            : 3;
    } bit;
  } REF_CNT_RST;
  
  union {
    __IOM uint32_t reg;                         /*!< RMT version register                                                      */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< This is the version register.                                             */
            uint32_t            : 4;
    } bit;
  } DATE;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Channel 3 Tx event configuration register                                 */
      
      struct {
              uint32_t          : 9;
        __IOM uint32_t TX_LOOP_NUM : 10;        /*!< This register is used to configure the maximum loop count when
                                                     tx_conti_mode is valid.                                                   */
        __IOM uint32_t TX_LOOP_CNT_EN : 1;      /*!< This register is the enabled bit for loop count.                          */
        __OM  uint32_t LOOP_COUNT_RESET : 1;    /*!< This register is used to reset the loop count when tx_conti_mode
                                                     is valid.                                                                 */
              uint32_t          : 11;
      } bit;
    } CH3_TX_LIM;
    __IOM uint32_t CH2_RX_LIM;                  /*!< Channel 2 Rx event configuration register                                 */
  };
  __IM  uint32_t  RESERVED11[3];
  __IOM uint32_t  CH3_RX_LIM;                   /*!< Channel 3 Rx event configuration register                                 */
} RMT_Type;                                     /*!< Size = 228 (0xe4)                                                         */



/* =========================================================================================================================== */
/* ================                                            RNG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Hardware Random Number Generator (RNG)
  */

typedef struct {                                /*!< RNG Structure                                                             */
  __IM  uint32_t  RESERVED[68];
  __IM  uint32_t  DATA;                         /*!< Random number data                                                        */
} RNG_Type;                                     /*!< Size = 276 (0x114)                                                        */



/* =========================================================================================================================== */
/* ================                                            RSA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief RSA (Rivest Shamir Adleman) Accelerator (RSA)
  */

typedef struct {                                /*!< RSA Structure                                                             */
  __OM  uint32_t  M_MEM[128];                   /*!< Memory M                                                                  */
  __IOM uint32_t  Z_MEM[128];                   /*!< Memory Z                                                                  */
  __OM  uint32_t  Y_MEM[128];                   /*!< Memory Y                                                                  */
  __OM  uint32_t  X_MEM[128];                   /*!< Memory X                                                                  */
  
  union {
    __IOM uint32_t reg;                         /*!< RSA M' register                                                           */
    
    struct {
      __IOM uint32_t M_PRIME    : 32;           /*!< Stores M'                                                                 */
    } bit;
  } M_PRIME;
  
  union {
    __IOM uint32_t reg;                         /*!< RSA length mode register                                                  */
    
    struct {
      __IOM uint32_t MODE       : 7;            /*!< Stores the RSA length mode                                                */
            uint32_t            : 25;
    } bit;
  } MODE;
  
  union {
    __IOM uint32_t reg;                         /*!< RSA clean register                                                        */
    
    struct {
      __IM  uint32_t CLEAN      : 1;            /*!< The content of this bit is 1 when memories complete initialization.       */
            uint32_t            : 31;
    } bit;
  } CLEAN;
  
  union {
    __IOM uint32_t reg;                         /*!< Modular exponentiation trigger register.                                  */
    
    struct {
      __OM  uint32_t MODEXP_START : 1;          /*!< Set this bit to 1 to start the modular exponentiation.                    */
            uint32_t            : 31;
    } bit;
  } MODEXP_START;
  
  union {
    __IOM uint32_t reg;                         /*!< Modular multiplication trigger register.                                  */
    
    struct {
      __OM  uint32_t MODMULT_START : 1;         /*!< Set this bit to 1 to start the modular multiplication                     */
            uint32_t            : 31;
    } bit;
  } MODMULT_START;
  
  union {
    __IOM uint32_t reg;                         /*!< Normal multiplication trigger register.                                   */
    
    struct {
      __OM  uint32_t MULT_START : 1;            /*!< Set this bit to 1 to start the multiplicaiton.                            */
            uint32_t            : 31;
    } bit;
  } MULT_START;
  
  union {
    __IOM uint32_t reg;                         /*!< RSA idle register                                                         */
    
    struct {
      __IM  uint32_t IDLE       : 1;            /*!< The content of this bit is 1 when the RSA accelerator is idle.            */
            uint32_t            : 31;
    } bit;
  } IDLE;
  
  union {
    __IOM uint32_t reg;                         /*!< RSA interrupt clear register                                              */
    
    struct {
      __OM  uint32_t CLEAR_INTERRUPT : 1;       /*!< set this bit to 1 to clear the RSA interrupt.                             */
            uint32_t            : 31;
    } bit;
  } CLEAR_INTERRUPT;
  
  union {
    __IOM uint32_t reg;                         /*!< CONSTANT_TIME option control register                                     */
    
    struct {
      __IOM uint32_t CONSTANT_TIME : 1;         /*!< Controls the CONSTANT_TIME option. 0: acceleration. 1: no acceleration(by
                                                     default).                                                                 */
            uint32_t            : 31;
    } bit;
  } CONSTANT_TIME;
  
  union {
    __IOM uint32_t reg;                         /*!< SEARCH option enable register                                             */
    
    struct {
      __IOM uint32_t SEARCH_ENABLE : 1;         /*!< Controls the SEARCH option. 0: no acceleration(by default).
                                                     1: acceleration.                                                          */
            uint32_t            : 31;
    } bit;
  } SEARCH_ENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< RSA search position configure register                                    */
    
    struct {
      __IOM uint32_t SEARCH_POS : 12;           /*!< This field is used to configure the starting search position
                                                     when the acceleration option of SEARCH is used.                           */
            uint32_t            : 20;
    } bit;
  } SEARCH_POS;
  
  union {
    __IOM uint32_t reg;                         /*!< RSA interrupt enable register                                             */
    
    struct {
      __IOM uint32_t INTERRUPT_ENA : 1;         /*!< Set this bit to 1 to enable the RSA interrupt. This option is
                                                     enabled by default.                                                       */
            uint32_t            : 31;
    } bit;
  } INTERRUPT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< RSA version control register                                              */
    
    struct {
      __IOM uint32_t DATE       : 30;           /*!< rsa version information                                                   */
            uint32_t            : 2;
    } bit;
  } DATE;
} RSA_Type;                                     /*!< Size = 2100 (0x834)                                                       */



/* =========================================================================================================================== */
/* ================                                         RTC_CNTL                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Real-Time Clock Control (RTC_CNTL)
  */

typedef struct {                                /*!< RTC_CNTL Structure                                                        */
  
  union {
    __IOM uint32_t reg;                         /*!< RTC common configure register                                             */
    
    struct {
      __IOM uint32_t SW_STALL_APPCPU_C0 : 2;    /*!< {reg_sw_stall_appcpu_c1[5:0], reg_sw_stall_appcpu_c0[1:0]} ==
                                                     0x86 will stall APP CPU                                                   */
      __IOM uint32_t SW_STALL_PROCPU_C0 : 2;    /*!< {reg_sw_stall_procpu_c1[5:0], reg_sw_stall_procpu_c0[1:0]} ==
                                                     0x86 will stall PRO CPU                                                   */
      __OM  uint32_t SW_APPCPU_RST : 1;         /*!< APP CPU SW reset                                                          */
      __OM  uint32_t SW_PROCPU_RST : 1;         /*!< PRO CPU SW reset                                                          */
      __IOM uint32_t BB_I2C_FORCE_PD : 1;       /*!< BB_I2C force power down                                                   */
      __IOM uint32_t BB_I2C_FORCE_PU : 1;       /*!< BB_I2C force power up                                                     */
      __IOM uint32_t BBPLL_I2C_FORCE_PD : 1;    /*!< BB_PLL _I2C force power down                                              */
      __IOM uint32_t BBPLL_I2C_FORCE_PU : 1;    /*!< BB_PLL_I2C force power up                                                 */
      __IOM uint32_t BBPLL_FORCE_PD : 1;        /*!< BB_PLL force power down                                                   */
      __IOM uint32_t BBPLL_FORCE_PU : 1;        /*!< BB_PLL force power up                                                     */
      __IOM uint32_t XTL_FORCE_PD : 1;          /*!< crystall force power down                                                 */
      __IOM uint32_t XTL_FORCE_PU : 1;          /*!< crystall force power up                                                   */
      __IOM uint32_t XTL_EN_WAIT : 4;           /*!< wait bias_sleep and current source wakeup                                 */
            uint32_t            : 5;
      __IOM uint32_t XTL_FORCE_ISO : 1;         /*!< No public                                                                 */
      __IOM uint32_t PLL_FORCE_ISO : 1;         /*!< No public                                                                 */
      __IOM uint32_t ANALOG_FORCE_ISO : 1;      /*!< No public                                                                 */
      __IOM uint32_t XTL_FORCE_NOISO : 1;       /*!< No public                                                                 */
      __IOM uint32_t PLL_FORCE_NOISO : 1;       /*!< No public                                                                 */
      __IOM uint32_t ANALOG_FORCE_NOISO : 1;    /*!< No public                                                                 */
      __IOM uint32_t DG_WRAP_FORCE_RST : 1;     /*!< digital wrap force reset in deep sleep                                    */
      __IOM uint32_t DG_WRAP_FORCE_NORST : 1;   /*!< digital core force no reset in deep sleep                                 */
      __OM  uint32_t SW_SYS_RST : 1;            /*!< SW system reset                                                           */
    } bit;
  } OPTIONS0;
  
  union {
    __IOM uint32_t reg;                         /*!< configure min sleep time                                                  */
    
    struct {
      __IOM uint32_t SLP_VAL_LO : 32;           /*!< RTC sleep timer low 32 bits                                               */
    } bit;
  } SLP_TIMER0;
  
  union {
    __IOM uint32_t reg;                         /*!< configure sleep time hi                                                   */
    
    struct {
      __IOM uint32_t SLP_VAL_HI : 16;           /*!< RTC sleep timer high 16 bits                                              */
      __OM  uint32_t MAIN_TIMER_ALARM_EN : 1;   /*!< timer alarm enable bit                                                    */
            uint32_t            : 15;
    } bit;
  } SLP_TIMER1;
  
  union {
    __IOM uint32_t reg;                         /*!< update rtc main timer                                                     */
    
    struct {
            uint32_t            : 27;
      __IOM uint32_t TIMER_SYS_STALL : 1;       /*!< Enable to record system stall time                                        */
      __IOM uint32_t TIMER_XTL_OFF : 1;         /*!< Enable to record 40M XTAL OFF time                                        */
      __IOM uint32_t TIMER_SYS_RST : 1;         /*!< enable to record system reset time                                        */
            uint32_t            : 1;
      __OM  uint32_t TIME_UPDATE : 1;           /*!< Set 1: to update register with RTC timer                                  */
    } bit;
  } TIME_UPDATE;
  
  union {
    __IOM uint32_t reg;                         /*!< read rtc_main timer low bits                                              */
    
    struct {
      __IM  uint32_t TIMER_VALUE0_LOW : 32;     /*!< RTC timer low 32 bits                                                     */
    } bit;
  } TIME_LOW0;
  
  union {
    __IOM uint32_t reg;                         /*!< read rtc_main timer high bits                                             */
    
    struct {
      __IM  uint32_t TIMER_VALUE0_HIGH : 16;    /*!< RTC timer high 16 bits                                                    */
            uint32_t            : 16;
    } bit;
  } TIME_HIGH0;
  
  union {
    __IOM uint32_t reg;                         /*!< configure chip sleep                                                      */
    
    struct {
      __OM  uint32_t SW_CPU_INT : 1;            /*!< rtc software interrupt to main cpu                                        */
      __OM  uint32_t SLP_REJECT_CAUSE_CLR : 1;  /*!< clear rtc sleep reject cause                                              */
            uint32_t            : 20;
      __IOM uint32_t APB2RTC_BRIDGE_SEL : 1;    /*!< 1: APB to RTC using bridge, 0: APB to RTC using sync                      */
            uint32_t            : 5;
      __IM  uint32_t SDIO_ACTIVE_IND : 1;       /*!< SDIO active indication                                                    */
      __IOM uint32_t SLP_WAKEUP : 1;            /*!< leep wakeup bit                                                           */
      __IOM uint32_t SLP_REJECT : 1;            /*!< leep reject bit                                                           */
      __IOM uint32_t SLEEP_EN   : 1;            /*!< sleep enable bit                                                          */
    } bit;
  } STATE0;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc state wait time                                                       */
    
    struct {
      __IOM uint32_t CPU_STALL_EN : 1;          /*!< CPU stall enable bit                                                      */
      __IOM uint32_t CPU_STALL_WAIT : 5;        /*!< CPU stall wait cycles in fast_clk_rtc                                     */
      __IOM uint32_t CK8M_WAIT  : 8;            /*!< CK8M wait cycles in slow_clk_rtc                                          */
      __IOM uint32_t XTL_BUF_WAIT : 10;         /*!< XTAL wait cycles in slow_clk_rtc                                          */
      __IOM uint32_t PLL_BUF_WAIT : 8;          /*!< PLL wait cycles in slow_clk_rtc                                           */
    } bit;
  } TIMER1;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc monitor state delay time                                              */
    
    struct {
            uint32_t            : 15;
      __IOM uint32_t ULPCP_TOUCH_START_WAIT : 9;/*!< wait cycles in slow_clk_rtc before ULP-coprocessor / touch controller
                                                     start to work                                                             */
      __IOM uint32_t MIN_TIME_CK8M_OFF : 8;     /*!< minimal cycles in slow_clk_rtc for CK8M in power down state               */
    } bit;
  } TIMER2;
  
  union {
    __IOM uint32_t reg;                         /*!< No public                                                                 */
    
    struct {
      __IOM uint32_t WIFI_WAIT_TIMER : 9;       /*!< No public                                                                 */
      __IOM uint32_t WIFI_POWERUP_TIMER : 7;    /*!< No public                                                                 */
      __IOM uint32_t BT_WAIT_TIMER : 9;         /*!< No public                                                                 */
      __IOM uint32_t BT_POWERUP_TIMER : 7;      /*!< No public                                                                 */
    } bit;
  } TIMER3;
  
  union {
    __IOM uint32_t reg;                         /*!< No public                                                                 */
    
    struct {
      __IOM uint32_t WAIT_TIMER : 9;            /*!< No public                                                                 */
      __IOM uint32_t POWERUP_TIMER : 7;         /*!< No public                                                                 */
      __IOM uint32_t DG_WRAP_WAIT_TIMER : 9;    /*!< No public                                                                 */
      __IOM uint32_t DG_WRAP_POWERUP_TIMER : 7; /*!< No public                                                                 */
    } bit;
  } TIMER4;
  
  union {
    __IOM uint32_t reg;                         /*!< configure min sleep time                                                  */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t MIN_SLP_VAL : 8;           /*!< minimal sleep cycles in slow_clk_rtc                                      */
            uint32_t            : 16;
    } bit;
  } TIMER5;
  
  union {
    __IOM uint32_t reg;                         /*!< No public                                                                 */
    
    struct {
      __IOM uint32_t CPU_TOP_WAIT_TIMER : 9;    /*!< No public                                                                 */
      __IOM uint32_t CPU_TOP_POWERUP_TIMER : 7; /*!< No public                                                                 */
      __IOM uint32_t DG_PERI_WAIT_TIMER : 9;    /*!< No public                                                                 */
      __IOM uint32_t DG_PERI_POWERUP_TIMER : 7; /*!< No public                                                                 */
    } bit;
  } TIMER6;
  
  union {
    __IOM uint32_t reg;                         /*!< analog configure register                                                 */
    
    struct {
            uint32_t            : 18;
      __IOM uint32_t I2C_RESET_POR_FORCE_PD : 1;/*!< force down I2C_RESET_POR                                                  */
      __IOM uint32_t I2C_RESET_POR_FORCE_PU : 1;/*!< force on I2C_RESET_POR                                                    */
      __IOM uint32_t GLITCH_RST_EN : 1;         /*!< enable clk glitch                                                         */
            uint32_t            : 1;
      __IOM uint32_t SAR_I2C_PU : 1;            /*!< PLLA force power up                                                       */
      __IOM uint32_t ANALOG_TOP_ISO_SLEEP : 1;  /*!< PLLA force power down                                                     */
      __IOM uint32_t ANALOG_TOP_ISO_MONITOR : 1;/*!< PLLA force power up                                                       */
      __IOM uint32_t BBPLL_CAL_SLP_START : 1;   /*!< start BBPLL calibration during sleep                                      */
      __IOM uint32_t PVTMON_PU  : 1;            /*!< 1: PVTMON power up, otherwise power down                                  */
      __IOM uint32_t TXRF_I2C_PU : 1;           /*!< 1: TXRF_I2C power up, otherwise power down                                */
      __IOM uint32_t RFRX_PBUS_PU : 1;          /*!< 1: RFRX_PBUS power up, otherwise power down                               */
            uint32_t            : 1;
      __IOM uint32_t CKGEN_I2C_PU : 1;          /*!< 1: CKGEN_I2C power up, otherwise power down                               */
      __IOM uint32_t PLL_I2C_PU : 1;            /*!< power on pll i2c                                                          */
    } bit;
  } ANA_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< get reset state                                                           */
    
    struct {
      __IM  uint32_t RESET_CAUSE_PROCPU : 6;    /*!< reset cause of PRO CPU                                                    */
      __IM  uint32_t RESET_CAUSE_APPCPU : 6;    /*!< reset cause of APP CPU                                                    */
      __IOM uint32_t APPCPU_STAT_VECTOR_SEL : 1;/*!< APP CPU state vector sel                                                  */
      __IOM uint32_t PROCPU_STAT_VECTOR_SEL : 1;/*!< PRO CPU state vector sel                                                  */
      __IM  uint32_t RESET_FLAG_PROCPU : 1;     /*!< PRO CPU reset_flag                                                        */
      __IM  uint32_t RESET_FLAG_APPCPU : 1;     /*!< APP CPU reset flag                                                        */
      __OM  uint32_t RESET_FLAG_PROCPU_CLR : 1; /*!< clear PRO CPU reset_flag                                                  */
      __OM  uint32_t RESET_FLAG_APPCPU_CLR : 1; /*!< clear APP CPU reset flag                                                  */
      __IOM uint32_t APPCPU_OCD_HALT_ON_RESET : 1;/*!< APPCPU OcdHaltOnReset                                                   */
      __IOM uint32_t PROCPU_OCD_HALT_ON_RESET : 1;/*!< PROCPU OcdHaltOnReset                                                   */
      __IM  uint32_t RESET_FLAG_JTAG_PROCPU : 1;/*!< jtag reset flag                                                           */
      __IM  uint32_t RESET_FLAG_JTAG_APPCPU : 1;/*!< jtag reset flag                                                           */
      __OM  uint32_t RESET_FLAG_JTAG_PROCPU_CLR : 1;/*!< clear jtag reset flag                                                 */
      __OM  uint32_t RESET_FLAG_JTAG_APPCPU_CLR : 1;/*!< clear jtag reset flag                                                 */
      __IOM uint32_t APP_DRESET_MASK : 1;       /*!< bypass cpu1 dreset                                                        */
      __IOM uint32_t PRO_DRESET_MASK : 1;       /*!< bypass cpu0 dreset                                                        */
            uint32_t            : 6;
    } bit;
  } RESET_STATE;
  
  union {
    __IOM uint32_t reg;                         /*!< configure wakeup state                                                    */
    
    struct {
            uint32_t            : 15;
      __IOM uint32_t WAKEUP_ENA : 17;           /*!< wakeup enable bitmap                                                      */
    } bit;
  } WAKEUP_STATE;
  
  union {
    __IOM uint32_t reg;                         /*!< configure rtc interrupt register                                          */
    
    struct {
      __IOM uint32_t SLP_WAKEUP_INT_ENA : 1;    /*!< enable sleep wakeup interrupt                                             */
      __IOM uint32_t SLP_REJECT_INT_ENA : 1;    /*!< enable sleep reject interrupt                                             */
      __IOM uint32_t SDIO_IDLE_INT_ENA : 1;     /*!< enable SDIO idle interrupt                                                */
      __IOM uint32_t WDT_INT_ENA : 1;           /*!< enable RTC WDT interrupt                                                  */
      __IOM uint32_t TOUCH_SCAN_DONE_INT_ENA : 1;/*!< enable touch scan done interrupt                                         */
      __IOM uint32_t ULP_CP_INT_ENA : 1;        /*!< enable ULP-coprocessor interrupt                                          */
      __IOM uint32_t TOUCH_DONE_INT_ENA : 1;    /*!< enable touch done interrupt                                               */
      __IOM uint32_t TOUCH_ACTIVE_INT_ENA : 1;  /*!< enable touch active interrupt                                             */
      __IOM uint32_t TOUCH_INACTIVE_INT_ENA : 1;/*!< enable touch inactive interrupt                                           */
      __IOM uint32_t BROWN_OUT_INT_ENA : 1;     /*!< enable brown out interrupt                                                */
      __IOM uint32_t MAIN_TIMER_INT_ENA : 1;    /*!< enable RTC main timer interrupt                                           */
      __IOM uint32_t SARADC1_INT_ENA : 1;       /*!< enable saradc1 interrupt                                                  */
      __IOM uint32_t TSENS_INT_ENA : 1;         /*!< enable tsens interrupt                                                    */
      __IOM uint32_t COCPU_INT_ENA : 1;         /*!< enable riscV cocpu interrupt                                              */
      __IOM uint32_t SARADC2_INT_ENA : 1;       /*!< enable saradc2 interrupt                                                  */
      __IOM uint32_t SWD_INT_ENA : 1;           /*!< enable super watch dog interrupt                                          */
      __IOM uint32_t XTAL32K_DEAD_INT_ENA : 1;  /*!< enable xtal32k_dead interrupt                                             */
      __IOM uint32_t COCPU_TRAP_INT_ENA : 1;    /*!< enable cocpu trap interrupt                                               */
      __IOM uint32_t TOUCH_TIMEOUT_INT_ENA : 1; /*!< enable touch timeout interrupt                                            */
      __IOM uint32_t GLITCH_DET_INT_ENA : 1;    /*!< enbale gitch det interrupt                                                */
      __IOM uint32_t TOUCH_APPROACH_LOOP_DONE_INT_ENA : 1;/*!< touch approach mode loop interrupt                              */
            uint32_t            : 11;
    } bit;
  } INT_ENA_RTC;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc interrupt register                                                    */
    
    struct {
      __IM  uint32_t SLP_WAKEUP_INT_RAW : 1;    /*!< sleep wakeup interrupt raw                                                */
      __IM  uint32_t SLP_REJECT_INT_RAW : 1;    /*!< sleep reject interrupt raw                                                */
      __IM  uint32_t SDIO_IDLE_INT_RAW : 1;     /*!< SDIO idle interrupt raw                                                   */
      __IM  uint32_t WDT_INT_RAW : 1;           /*!< RTC WDT interrupt raw                                                     */
      __IM  uint32_t TOUCH_SCAN_DONE_INT_RAW : 1;/*!< enable touch scan done interrupt raw                                     */
      __IM  uint32_t ULP_CP_INT_RAW : 1;        /*!< ULP-coprocessor interrupt raw                                             */
      __IM  uint32_t TOUCH_DONE_INT_RAW : 1;    /*!< touch interrupt raw                                                       */
      __IM  uint32_t TOUCH_ACTIVE_INT_RAW : 1;  /*!< touch active interrupt raw                                                */
      __IM  uint32_t TOUCH_INACTIVE_INT_RAW : 1;/*!< touch inactive interrupt raw                                              */
      __IM  uint32_t BROWN_OUT_INT_RAW : 1;     /*!< brown out interrupt raw                                                   */
      __IM  uint32_t MAIN_TIMER_INT_RAW : 1;    /*!< RTC main timer interrupt raw                                              */
      __IM  uint32_t SARADC1_INT_RAW : 1;       /*!< saradc1 interrupt raw                                                     */
      __IM  uint32_t TSENS_INT_RAW : 1;         /*!< tsens interrupt raw                                                       */
      __IM  uint32_t COCPU_INT_RAW : 1;         /*!< riscV cocpu interrupt raw                                                 */
      __IM  uint32_t SARADC2_INT_RAW : 1;       /*!< saradc2 interrupt raw                                                     */
      __IM  uint32_t SWD_INT_RAW : 1;           /*!< super watch dog interrupt raw                                             */
      __IM  uint32_t XTAL32K_DEAD_INT_RAW : 1;  /*!< xtal32k dead detection interrupt raw                                      */
      __IM  uint32_t COCPU_TRAP_INT_RAW : 1;    /*!< cocpu trap interrupt raw                                                  */
      __IM  uint32_t TOUCH_TIMEOUT_INT_RAW : 1; /*!< touch timeout interrupt raw                                               */
      __IM  uint32_t GLITCH_DET_INT_RAW : 1;    /*!< glitch_det_interrupt_raw                                                  */
      __IOM uint32_t TOUCH_APPROACH_LOOP_DONE_INT_RAW : 1;/*!< touch approach mode loop interrupt raw                          */
            uint32_t            : 11;
    } bit;
  } INT_RAW_RTC;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc interrupt register                                                    */
    
    struct {
      __IM  uint32_t SLP_WAKEUP_INT_ST : 1;     /*!< sleep wakeup interrupt state                                              */
      __IM  uint32_t SLP_REJECT_INT_ST : 1;     /*!< sleep reject interrupt state                                              */
      __IM  uint32_t SDIO_IDLE_INT_ST : 1;      /*!< SDIO idle interrupt state                                                 */
      __IM  uint32_t WDT_INT_ST : 1;            /*!< RTC WDT interrupt state                                                   */
      __IM  uint32_t TOUCH_SCAN_DONE_INT_ST : 1;/*!< enable touch scan done interrupt raw                                      */
      __IM  uint32_t ULP_CP_INT_ST : 1;         /*!< ULP-coprocessor interrupt state                                           */
      __IM  uint32_t TOUCH_DONE_INT_ST : 1;     /*!< touch done interrupt state                                                */
      __IM  uint32_t TOUCH_ACTIVE_INT_ST : 1;   /*!< touch active interrupt state                                              */
      __IM  uint32_t TOUCH_INACTIVE_INT_ST : 1; /*!< touch inactive interrupt state                                            */
      __IM  uint32_t BROWN_OUT_INT_ST : 1;      /*!< brown out interrupt state                                                 */
      __IM  uint32_t MAIN_TIMER_INT_ST : 1;     /*!< RTC main timer interrupt state                                            */
      __IM  uint32_t SARADC1_INT_ST : 1;        /*!< saradc1 interrupt state                                                   */
      __IM  uint32_t TSENS_INT_ST : 1;          /*!< tsens interrupt state                                                     */
      __IM  uint32_t COCPU_INT_ST : 1;          /*!< riscV cocpu interrupt state                                               */
      __IM  uint32_t SARADC2_INT_ST : 1;        /*!< saradc2 interrupt state                                                   */
      __IM  uint32_t SWD_INT_ST : 1;            /*!< super watch dog interrupt state                                           */
      __IM  uint32_t XTAL32K_DEAD_INT_ST : 1;   /*!< xtal32k dead detection interrupt state                                    */
      __IM  uint32_t COCPU_TRAP_INT_ST : 1;     /*!< cocpu trap interrupt state                                                */
      __IM  uint32_t TOUCH_TIMEOUT_INT_ST : 1;  /*!< Touch timeout interrupt state                                             */
      __IM  uint32_t GLITCH_DET_INT_ST : 1;     /*!< glitch_det_interrupt state                                                */
      __IM  uint32_t TOUCH_APPROACH_LOOP_DONE_INT_ST : 1;/*!< touch approach mode loop interrupt state                         */
            uint32_t            : 11;
    } bit;
  } INT_ST_RTC;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc interrupt register                                                    */
    
    struct {
      __OM  uint32_t SLP_WAKEUP_INT_CLR : 1;    /*!< Clear sleep wakeup interrupt state                                        */
      __OM  uint32_t SLP_REJECT_INT_CLR : 1;    /*!< Clear sleep reject interrupt state                                        */
      __OM  uint32_t SDIO_IDLE_INT_CLR : 1;     /*!< Clear SDIO idle interrupt state                                           */
      __OM  uint32_t WDT_INT_CLR : 1;           /*!< Clear RTC WDT interrupt state                                             */
      __OM  uint32_t TOUCH_SCAN_DONE_INT_CLR : 1;/*!< clear touch scan done interrupt raw                                      */
      __OM  uint32_t ULP_CP_INT_CLR : 1;        /*!< Clear ULP-coprocessor interrupt state                                     */
      __OM  uint32_t TOUCH_DONE_INT_CLR : 1;    /*!< Clear touch done interrupt state                                          */
      __OM  uint32_t TOUCH_ACTIVE_INT_CLR : 1;  /*!< Clear touch active interrupt state                                        */
      __OM  uint32_t TOUCH_INACTIVE_INT_CLR : 1;/*!< Clear touch inactive interrupt state                                      */
      __OM  uint32_t BROWN_OUT_INT_CLR : 1;     /*!< Clear brown out interrupt state                                           */
      __OM  uint32_t MAIN_TIMER_INT_CLR : 1;    /*!< Clear RTC main timer interrupt state                                      */
      __OM  uint32_t SARADC1_INT_CLR : 1;       /*!< Clear saradc1 interrupt state                                             */
      __OM  uint32_t TSENS_INT_CLR : 1;         /*!< Clear tsens interrupt state                                               */
      __OM  uint32_t COCPU_INT_CLR : 1;         /*!< Clear riscV cocpu interrupt state                                         */
      __OM  uint32_t SARADC2_INT_CLR : 1;       /*!< Clear saradc2 interrupt state                                             */
      __OM  uint32_t SWD_INT_CLR : 1;           /*!< Clear super watch dog interrupt state                                     */
      __OM  uint32_t XTAL32K_DEAD_INT_CLR : 1;  /*!< Clear RTC WDT interrupt state                                             */
      __OM  uint32_t COCPU_TRAP_INT_CLR : 1;    /*!< Clear cocpu trap interrupt state                                          */
      __OM  uint32_t TOUCH_TIMEOUT_INT_CLR : 1; /*!< Clear touch timeout interrupt state                                       */
      __OM  uint32_t GLITCH_DET_INT_CLR : 1;    /*!< Clear glitch det interrupt state                                          */
      __OM  uint32_t TOUCH_APPROACH_LOOP_DONE_INT_CLR : 1;/*!< cleartouch approach mode loop interrupt state                   */
            uint32_t            : 11;
    } bit;
  } INT_CLR_RTC;
  
  union {
    __IOM uint32_t reg;                         /*!< Reserved register                                                         */
    
    struct {
      __IOM uint32_t SCRATCH0   : 32;           /*!< Reserved register                                                         */
    } bit;
  } STORE0;
  
  union {
    __IOM uint32_t reg;                         /*!< Reserved register                                                         */
    
    struct {
      __IOM uint32_t SCRATCH1   : 32;           /*!< Reserved register                                                         */
    } bit;
  } STORE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Reserved register                                                         */
    
    struct {
      __IOM uint32_t SCRATCH2   : 32;           /*!< Reserved register                                                         */
    } bit;
  } STORE2;
  
  union {
    __IOM uint32_t reg;                         /*!< Reserved register                                                         */
    
    struct {
      __IOM uint32_t SCRATCH3   : 32;           /*!< Reserved register                                                         */
    } bit;
  } STORE3;
  
  union {
    __IOM uint32_t reg;                         /*!< Reserved register                                                         */
    
    struct {
      __IOM uint32_t XTAL32K_WDT_EN : 1;        /*!< xtal 32k watch dog enable                                                 */
      __IOM uint32_t XTAL32K_WDT_CLK_FO : 1;    /*!< xtal 32k watch dog clock force on                                         */
      __IOM uint32_t XTAL32K_WDT_RESET : 1;     /*!< xtal 32k watch dog sw reset                                               */
      __IOM uint32_t XTAL32K_EXT_CLK_FO : 1;    /*!< xtal 32k external xtal clock force on                                     */
      __IOM uint32_t XTAL32K_AUTO_BACKUP : 1;   /*!< xtal 32k switch to back up clock when xtal is dead                        */
      __IOM uint32_t XTAL32K_AUTO_RESTART : 1;  /*!< xtal 32k restart xtal when xtal is dead                                   */
      __IOM uint32_t XTAL32K_AUTO_RETURN : 1;   /*!< xtal 32k switch back xtal when xtal is restarted                          */
      __IOM uint32_t XTAL32K_XPD_FORCE : 1;     /*!< Xtal 32k xpd control by sw or fsm                                         */
      __IOM uint32_t ENCKINIT_XTAL_32K : 1;     /*!< apply an internal clock to help xtal 32k to start                         */
      __IOM uint32_t DBUF_XTAL_32K : 1;         /*!< 0: single-end buffer 1: differential buffer                               */
      __IOM uint32_t DGM_XTAL_32K : 3;          /*!< xtal_32k gm control                                                       */
      __IOM uint32_t DRES_XTAL_32K : 3;         /*!< DRES_XTAL_32K                                                             */
      __IOM uint32_t XPD_XTAL_32K : 1;          /*!< XPD_XTAL_32K                                                              */
      __IOM uint32_t DAC_XTAL_32K : 3;          /*!< DAC_XTAL_32K                                                              */
      __IM  uint32_t WDT_STATE  : 3;            /*!< state of 32k_wdt                                                          */
      __IOM uint32_t XTAL32K_GPIO_SEL : 1;      /*!< XTAL_32K sel. 0: external XTAL_32K, 1: CLK from RTC pad X32P_C            */
            uint32_t            : 6;
      __IOM uint32_t XTL_EXT_CTR_LV : 1;        /*!< 0: power down XTAL at high level, 1: power down XTAL at low
                                                     level                                                                     */
      __IOM uint32_t XTL_EXT_CTR_EN : 1;        /*!< Reserved register                                                         */
    } bit;
  } EXT_XTL_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< ext wakeup configure                                                      */
    
    struct {
            uint32_t            : 29;
      __IOM uint32_t GPIO_WAKEUP_FILTER : 1;    /*!< enable filter for gpio wakeup event                                       */
      __IOM uint32_t EXT_WAKEUP0_LV : 1;        /*!< 0: external wakeup at low level, 1: external wakeup at high
                                                     level                                                                     */
      __IOM uint32_t EXT_WAKEUP1_LV : 1;        /*!< 0: external wakeup at low level, 1: external wakeup at high
                                                     level                                                                     */
    } bit;
  } EXT_WAKEUP_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< reject sleep register                                                     */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t SLEEP_REJECT_ENA : 18;     /*!< sleep reject enable                                                       */
      __IOM uint32_t LIGHT_SLP_REJECT_EN : 1;   /*!< enable reject for light sleep                                             */
      __IOM uint32_t DEEP_SLP_REJECT_EN : 1;    /*!< enable reject for deep sleep                                              */
    } bit;
  } SLP_REJECT_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< conigure cpu freq                                                         */
    
    struct {
            uint32_t            : 29;
      __IOM uint32_t CPUSEL_CONF : 1;           /*!< CPU sel option                                                            */
      __IOM uint32_t CPUPERIOD_SEL : 2;         /*!< conigure cpu freq                                                         */
    } bit;
  } CPU_PERIOD_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< No public                                                                 */
    
    struct {
            uint32_t            : 22;
      __IOM uint32_t SDIO_ACT_DNUM : 10;        /*!< No public                                                                 */
    } bit;
  } SDIO_ACT_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< configure clock register                                                  */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t EFUSE_CLK_FORCE_GATING : 1;/*!< force efuse clk gating                                                    */
      __IOM uint32_t EFUSE_CLK_FORCE_NOGATING : 1;/*!< force efuse clk nogating                                                */
      __IOM uint32_t CK8M_DIV_SEL_VLD : 1;      /*!< used to sync reg_ck8m_div_sel bus. Clear vld before set reg_ck8m_div_sel,
                                                     then set vld to actually switch the clk                                   */
      __IOM uint32_t CK8M_DIV   : 2;            /*!< CK8M_D256_OUT divider. 00: div128, 01: div256, 10: div512, 11:
                                                     div1024.                                                                  */
      __IOM uint32_t ENB_CK8M   : 1;            /*!< disable CK8M and CK8M_D256_OUT                                            */
      __IOM uint32_t ENB_CK8M_DIV : 1;          /*!< 1: CK8M_D256_OUT is actually CK8M, 0: CK8M_D256_OUT is CK8M
                                                     divided by 256                                                            */
      __IOM uint32_t DIG_XTAL32K_EN : 1;        /*!< enable CK_XTAL_32K for digital core (no relationship with RTC
                                                     core)                                                                     */
      __IOM uint32_t DIG_CLK8M_D256_EN : 1;     /*!< enable CK8M_D256_OUT for digital core (no relationship with
                                                     RTC core)                                                                 */
      __IOM uint32_t DIG_CLK8M_EN : 1;          /*!< enable CK8M for digital core (no relationship with RTC core)              */
            uint32_t            : 1;
      __IOM uint32_t CK8M_DIV_SEL : 3;          /*!< divider = reg_ck8m_div_sel + 1                                            */
      __IOM uint32_t XTAL_FORCE_NOGATING : 1;   /*!< XTAL force no gating during sleep                                         */
      __IOM uint32_t CK8M_FORCE_NOGATING : 1;   /*!< CK8M force no gating during sleep                                         */
      __IOM uint32_t CK8M_DFREQ : 8;            /*!< CK8M_DFREQ                                                                */
      __IOM uint32_t CK8M_FORCE_PD : 1;         /*!< CK8M force power down                                                     */
      __IOM uint32_t CK8M_FORCE_PU : 1;         /*!< CK8M force power up                                                       */
      __IOM uint32_t XTAL_GLOBAL_FORCE_GATING : 1;/*!< force global xtal gating                                                */
      __IOM uint32_t XTAL_GLOBAL_FORCE_NOGATING : 1;/*!< force global xtal no gating                                           */
      __IOM uint32_t FAST_CLK_RTC_SEL : 1;      /*!< fast_clk_rtc sel. 0: XTAL div 4, 1: CK8M                                  */
      __IOM uint32_t ANA_CLK_RTC_SEL : 2;       /*!< select slow clock                                                         */
    } bit;
  } CLK_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< configure slow clk                                                        */
    
    struct {
            uint32_t            : 22;
      __IOM uint32_t ANA_CLK_DIV_VLD : 1;       /*!< used to sync div bus. clear vld before set reg_rtc_ana_clk_div,
                                                     then set vld to actually switch the clk                                   */
      __IOM uint32_t ANA_CLK_DIV : 8;           /*!< rtc clk div                                                               */
      __IOM uint32_t SLOW_CLK_NEXT_EDGE : 1;    /*!< No public                                                                 */
    } bit;
  } SLOW_CLK_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< configure flash power                                                     */
    
    struct {
      __IOM uint32_t SDIO_TIMER_TARGET : 8;     /*!< timer count to apply reg_sdio_dcap after sdio power on                    */
            uint32_t            : 1;
      __IOM uint32_t SDIO_DTHDRV : 2;           /*!< Tieh = 1 mode drive ability. Initially set to 0 to limit charge
                                                     current, set to 3 after several us.                                       */
      __IOM uint32_t SDIO_DCAP  : 2;            /*!< ability to prevent LDO from overshoot                                     */
      __IOM uint32_t SDIO_INITI : 2;            /*!< add resistor from ldo output to ground. 0: no res, 1: 6k,2:4k,3:2k        */
      __IOM uint32_t SDIO_EN_INITI : 1;         /*!< 0 to set init[1:0]=0                                                      */
      __IOM uint32_t SDIO_DCURLIM : 3;          /*!< tune current limit threshold when tieh = 0. About 800mA/(8+d)             */
      __IOM uint32_t SDIO_MODECURLIM : 1;       /*!< select current limit mode                                                 */
      __IOM uint32_t SDIO_ENCURLIM : 1;         /*!< enable current limit                                                      */
      __IOM uint32_t SDIO_REG_PD_EN : 1;        /*!< power down SDIO_REG in sleep. Only active when reg_sdio_force
                                                     = 0                                                                       */
      __IOM uint32_t SDIO_FORCE : 1;            /*!< 1: use SW option to control SDIO_REG, 0: use state machine                */
      __IOM uint32_t SDIO_TIEH  : 1;            /*!< SW option for SDIO_TIEH. Only active when reg_sdio_force = 1              */
      __IM  uint32_t REG1P8_READY : 1;          /*!< read only register for REG1P8_READY                                       */
      __IOM uint32_t DREFL_SDIO : 2;            /*!< SW option for DREFL_SDIO. Only active when reg_sdio_force =
                                                     1                                                                         */
      __IOM uint32_t DREFM_SDIO : 2;            /*!< SW option for DREFM_SDIO. Only active when reg_sdio_force =
                                                     1                                                                         */
      __IOM uint32_t DREFH_SDIO : 2;            /*!< SW option for DREFH_SDIO. Only active when reg_sdio_force =
                                                     1                                                                         */
      __IOM uint32_t XPD_SDIO   : 1;            /*!< power on flash regulator                                                  */
    } bit;
  } SDIO_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< No public                                                                 */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t BIAS_BUF_IDLE : 1;         /*!< No public                                                                 */
      __IOM uint32_t BIAS_BUF_WAKE : 1;         /*!< No public                                                                 */
      __IOM uint32_t BIAS_BUF_DEEP_SLP : 1;     /*!< No public                                                                 */
      __IOM uint32_t BIAS_BUF_MONITOR : 1;      /*!< No public                                                                 */
      __IOM uint32_t PD_CUR_DEEP_SLP : 1;       /*!< xpd cur when rtc in sleep_state                                           */
      __IOM uint32_t PD_CUR_MONITOR : 1;        /*!< xpd cur when rtc in monitor state                                         */
      __IOM uint32_t BIAS_SLEEP_DEEP_SLP : 1;   /*!< bias_sleep when rtc in sleep_state                                        */
      __IOM uint32_t BIAS_SLEEP_MONITOR : 1;    /*!< bias_sleep when rtc in monitor state                                      */
      __IOM uint32_t DBG_ATTEN_DEEP_SLP : 4;    /*!< DBG_ATTEN when rtc in sleep state                                         */
      __IOM uint32_t DBG_ATTEN_MONITOR : 4;     /*!< DBG_ATTEN when rtc in monitor state                                       */
      __IOM uint32_t DBG_ATTEN_WAKEUP : 4;      /*!< No public                                                                 */
            uint32_t            : 2;
    } bit;
  } BIAS_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< configure rtc regulator                                                   */
    
    struct {
            uint32_t            : 7;
      __IOM uint32_t DIG_REG_CAL_EN : 1;        /*!< enable dig regulator cali                                                 */
            uint32_t            : 6;
      __IOM uint32_t SCK_DCAP   : 8;            /*!< SCK_DCAP                                                                  */
            uint32_t            : 6;
      __IOM uint32_t DBOOST_FORCE_PD : 1;       /*!< RTC_DBOOST force power down                                               */
      __IOM uint32_t DBOOST_FORCE_PU : 1;       /*!< RTC_DBOOST force power up                                                 */
      __IOM uint32_t REGULATOR_FORCE_PD : 1;    /*!< RTC_REG force power down (for RTC_REG power down means decrease
                                                     the voltage to 0.8v or lower )                                            */
      __IOM uint32_t REGULATOR_FORCE_PU : 1;    /*!< RTC_REG force power on (for RTC_REG power down means decrease
                                                     the voltage to 0.8v or lower )                                            */
    } bit;
  } RTC;
  
  union {
    __IOM uint32_t reg;                         /*!< configure rtc power                                                       */
    
    struct {
      __IOM uint32_t FASTMEM_FORCE_NOISO : 1;   /*!< Fast RTC memory force no ISO                                              */
      __IOM uint32_t FASTMEM_FORCE_ISO : 1;     /*!< Fast RTC memory force ISO                                                 */
      __IOM uint32_t SLOWMEM_FORCE_NOISO : 1;   /*!< RTC memory force no ISO                                                   */
      __IOM uint32_t SLOWMEM_FORCE_ISO : 1;     /*!< RTC memory force ISO                                                      */
      __IOM uint32_t FORCE_ISO  : 1;            /*!< rtc_peri force ISO                                                        */
      __IOM uint32_t FORCE_NOISO : 1;           /*!< rtc_peri force no ISO                                                     */
      __IOM uint32_t FASTMEM_FOLW_CPU : 1;      /*!< 1: Fast RTC memory PD following CPU, 0: fast RTC memory PD following
                                                     RTC state machine                                                         */
      __IOM uint32_t FASTMEM_FORCE_LPD : 1;     /*!< Fast RTC memory force PD                                                  */
      __IOM uint32_t FASTMEM_FORCE_LPU : 1;     /*!< Fast RTC memory force no PD                                               */
      __IOM uint32_t SLOWMEM_FOLW_CPU : 1;      /*!< 1: RTC memory PD following CPU, 0: RTC memory PD following RTC
                                                     state machine                                                             */
      __IOM uint32_t SLOWMEM_FORCE_LPD : 1;     /*!< RTC memory force PD                                                       */
      __IOM uint32_t SLOWMEM_FORCE_LPU : 1;     /*!< RTC memory force no PD                                                    */
            uint32_t            : 6;
      __IOM uint32_t FORCE_PD   : 1;            /*!< rtc_peri force power down                                                 */
      __IOM uint32_t FORCE_PU   : 1;            /*!< rtc_peri force power up                                                   */
      __IOM uint32_t PD_EN      : 1;            /*!< enable power down rtc_peri in sleep                                       */
      __IOM uint32_t PAD_FORCE_HOLD : 1;        /*!< rtc pad force hold                                                        */
            uint32_t            : 10;
    } bit;
  } PWC;
  
  union {
    __IOM uint32_t reg;                         /*!< No public                                                                 */
    
    struct {
      __IOM uint32_t REGULATOR_DRV_B_MONITOR : 6;/*!< No public                                                                */
      __IOM uint32_t REGULATOR_DRV_B_SLP : 6;   /*!< No public                                                                 */
      __IOM uint32_t DG_VDD_DRV_B_SLP : 8;      /*!< No public                                                                 */
      __IOM uint32_t DG_VDD_DRV_B_MONITOR : 8;  /*!< No public                                                                 */
            uint32_t            : 4;
    } bit;
  } REGULATOR_DRV_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure digital power                                                   */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t LSLP_MEM_FORCE_PD : 1;     /*!< memories in digital core force PD in sleep                                */
      __IOM uint32_t LSLP_MEM_FORCE_PU : 1;     /*!< memories in digital core force no PD in sleep                             */
            uint32_t            : 6;
      __IOM uint32_t BT_FORCE_PD : 1;           /*!< internal SRAM 2 force power down                                          */
      __IOM uint32_t BT_FORCE_PU : 1;           /*!< internal SRAM 2 force power up                                            */
      __IOM uint32_t DG_PERI_FORCE_PD : 1;      /*!< internal SRAM 3 force power down                                          */
      __IOM uint32_t DG_PERI_FORCE_PU : 1;      /*!< internal SRAM 3 force power up                                            */
            uint32_t            : 2;
      __IOM uint32_t WIFI_FORCE_PD : 1;         /*!< wifi force power down                                                     */
      __IOM uint32_t WIFI_FORCE_PU : 1;         /*!< wifi force power up                                                       */
      __IOM uint32_t DG_WRAP_FORCE_PD : 1;      /*!< digital core force power down                                             */
      __IOM uint32_t DG_WRAP_FORCE_PU : 1;      /*!< digital core force power up                                               */
      __IOM uint32_t CPU_TOP_FORCE_PD : 1;      /*!< digital dcdc force power down                                             */
      __IOM uint32_t CPU_TOP_FORCE_PU : 1;      /*!< digital dcdc force power up                                               */
            uint32_t            : 4;
      __IOM uint32_t BT_PD_EN   : 1;            /*!< enable power down internal SRAM 2 in sleep                                */
      __IOM uint32_t DG_PERI_PD_EN : 1;         /*!< enable power down internal SRAM 3 in sleep                                */
      __IOM uint32_t CPU_TOP_PD_EN : 1;         /*!< enable power down internal SRAM 4 in sleep                                */
      __IOM uint32_t WIFI_PD_EN : 1;            /*!< enable power down wifi in sleep                                           */
      __IOM uint32_t DG_WRAP_PD_EN : 1;         /*!< enable power down all digital logic                                       */
    } bit;
  } DIG_PWC;
  
  union {
    __IOM uint32_t reg;                         /*!< congigure digital power isolation                                         */
    
    struct {
            uint32_t            : 7;
      __IOM uint32_t FORCE_OFF  : 1;            /*!< No public                                                                 */
      __IOM uint32_t FORCE_ON   : 1;            /*!< No public                                                                 */
      __IM  uint32_t DG_PAD_AUTOHOLD : 1;       /*!< read only register to indicate digital pad auto-hold status               */
      __OM  uint32_t CLR_DG_PAD_AUTOHOLD : 1;   /*!< wtite only register to clear digital pad auto-hold                        */
      __IOM uint32_t DG_PAD_AUTOHOLD_EN : 1;    /*!< digital pad enable auto-hold                                              */
      __IOM uint32_t DG_PAD_FORCE_NOISO : 1;    /*!< digital pad force no ISO                                                  */
      __IOM uint32_t DG_PAD_FORCE_ISO : 1;      /*!< digital pad force ISO                                                     */
      __IOM uint32_t DG_PAD_FORCE_UNHOLD : 1;   /*!< digital pad force un-hold                                                 */
      __IOM uint32_t DG_PAD_FORCE_HOLD : 1;     /*!< digital pad force hold                                                    */
            uint32_t            : 6;
      __IOM uint32_t BT_FORCE_ISO : 1;          /*!< internal SRAM 2 force ISO                                                 */
      __IOM uint32_t BT_FORCE_NOISO : 1;        /*!< internal SRAM 2 force no ISO                                              */
      __IOM uint32_t DG_PERI_FORCE_ISO : 1;     /*!< internal SRAM 3 force ISO                                                 */
      __IOM uint32_t DG_PERI_FORCE_NOISO : 1;   /*!< internal SRAM 3 force no ISO                                              */
      __IOM uint32_t CPU_TOP_FORCE_ISO : 1;     /*!< internal SRAM 4 force ISO                                                 */
      __IOM uint32_t CPU_TOP_FORCE_NOISO : 1;   /*!< internal SRAM 4 force no ISO                                              */
      __IOM uint32_t WIFI_FORCE_ISO : 1;        /*!< wifi force ISO                                                            */
      __IOM uint32_t WIFI_FORCE_NOISO : 1;      /*!< wifi force no ISO                                                         */
      __IOM uint32_t DG_WRAP_FORCE_ISO : 1;     /*!< digital core force ISO                                                    */
      __IOM uint32_t DG_WRAP_FORCE_NOISO : 1;   /*!< digita core force no ISO                                                  */
    } bit;
  } DIG_ISO;
  
  union {
    __IOM uint32_t reg;                         /*!< configure rtc watch dog                                                   */
    
    struct {
      __IOM uint32_t WDT_CHIP_RESET_WIDTH : 8;  /*!< chip reset siginal pulse width                                            */
      __IOM uint32_t WDT_CHIP_RESET_EN : 1;     /*!< wdt reset whole chip enable                                               */
      __IOM uint32_t WDT_PAUSE_IN_SLP : 1;      /*!< pause WDT in sleep                                                        */
      __IOM uint32_t WDT_APPCPU_RESET_EN : 1;   /*!< enable WDT reset APP CPU                                                  */
      __IOM uint32_t WDT_PROCPU_RESET_EN : 1;   /*!< enable WDT reset PRO CPU                                                  */
      __IOM uint32_t WDT_FLASHBOOT_MOD_EN : 1;  /*!< enable WDT in flash boot                                                  */
      __IOM uint32_t WDT_SYS_RESET_LENGTH : 3;  /*!< system reset counter length                                               */
      __IOM uint32_t WDT_CPU_RESET_LENGTH : 3;  /*!< CPU reset counter length                                                  */
      __IOM uint32_t WDT_STG3   : 3;            /*!< 1: interrupt stage en 2: CPU reset stage en 3: system reset
                                                     stage en 4: RTC reset stage en                                            */
      __IOM uint32_t WDT_STG2   : 3;            /*!< 1: interrupt stage en 2: CPU reset stage en 3: system reset
                                                     stage en 4: RTC reset stage en                                            */
      __IOM uint32_t WDT_STG1   : 3;            /*!< 1: interrupt stage en 2: CPU reset stage en 3: system reset
                                                     stage en 4: RTC reset stage en                                            */
      __IOM uint32_t WDT_STG0   : 3;            /*!< 1: interrupt stage en 2: CPU reset stage en 3: system reset
                                                     stage en 4: RTC reset stage en                                            */
      __IOM uint32_t WDT_EN     : 1;            /*!< enable rtc watch dog                                                      */
    } bit;
  } WDTCONFIG0;
  
  union {
    __IOM uint32_t reg;                         /*!< stage0 hold time                                                          */
    
    struct {
      __IOM uint32_t WDT_STG0_HOLD : 32;        /*!< stage0 hold time                                                          */
    } bit;
  } WDTCONFIG1;
  
  union {
    __IOM uint32_t reg;                         /*!< stage1 hold time                                                          */
    
    struct {
      __IOM uint32_t WDT_STG1_HOLD : 32;        /*!< stage1 hold time                                                          */
    } bit;
  } WDTCONFIG2;
  
  union {
    __IOM uint32_t reg;                         /*!< stage2 hold time                                                          */
    
    struct {
      __IOM uint32_t WDT_STG2_HOLD : 32;        /*!< stage2 hold time                                                          */
    } bit;
  } WDTCONFIG3;
  
  union {
    __IOM uint32_t reg;                         /*!< stage3 hold time                                                          */
    
    struct {
      __IOM uint32_t WDT_STG3_HOLD : 32;        /*!< stage3 hold time                                                          */
    } bit;
  } WDTCONFIG4;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc wdt feed                                                              */
    
    struct {
            uint32_t            : 31;
      __OM  uint32_t WDT_FEED   : 1;            /*!< rtc wdt feed                                                              */
    } bit;
  } WDTFEED;
  
  union {
    __IOM uint32_t reg;                         /*!< configure rtc watch dog                                                   */
    
    struct {
      __IOM uint32_t WDT_WKEY   : 32;           /*!< rtc watch dog key                                                         */
    } bit;
  } WDTWPROTECT;
  
  union {
    __IOM uint32_t reg;                         /*!< congfigure super watch dog                                                */
    
    struct {
      __IM  uint32_t SWD_RESET_FLAG : 1;        /*!< swd reset flag                                                            */
      __IM  uint32_t SWD_FEED_INT : 1;          /*!< swd interrupt for feeding                                                 */
            uint32_t            : 15;
      __IOM uint32_t SWD_BYPASS_RST : 1;        /*!< bypass super watch dog reset                                              */
      __IOM uint32_t SWD_SIGNAL_WIDTH : 10;     /*!< adjust signal width send to swd                                           */
      __OM  uint32_t SWD_RST_FLAG_CLR : 1;      /*!< reset swd reset flag                                                      */
      __OM  uint32_t SWD_FEED   : 1;            /*!< Sw feed swd                                                               */
      __IOM uint32_t SWD_DISABLE : 1;           /*!< disabel SWD                                                               */
      __IOM uint32_t SWD_AUTO_FEED_EN : 1;      /*!< automatically feed swd when int comes                                     */
    } bit;
  } SWD_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< super watch dog key                                                       */
    
    struct {
      __IOM uint32_t SWD_WKEY   : 32;           /*!< super watch dog key                                                       */
    } bit;
  } SWD_WPROTECT;
  
  union {
    __IOM uint32_t reg;                         /*!< configure cpu stall by sw                                                 */
    
    struct {
            uint32_t            : 20;
      __IOM uint32_t SW_STALL_APPCPU_C1 : 6;    /*!< {reg_sw_stall_appcpu_c1[5:0], reg_sw_stall_appcpu_c0[1:0]} ==
                                                     0x86 will stall APP CPU                                                   */
      __IOM uint32_t SW_STALL_PROCPU_C1 : 6;    /*!< {reg_sw_stall_appcpu_c1[5:0], reg_sw_stall_appcpu_c0[1:0]} ==
                                                     0x86 will stall APP CPU                                                   */
    } bit;
  } SW_CPU_STALL;
  
  union {
    __IOM uint32_t reg;                         /*!< reserved register                                                         */
    
    struct {
      __IOM uint32_t SCRATCH4   : 32;           /*!< reserved register                                                         */
    } bit;
  } STORE4;
  
  union {
    __IOM uint32_t reg;                         /*!< reserved register                                                         */
    
    struct {
      __IOM uint32_t SCRATCH5   : 32;           /*!< reserved register                                                         */
    } bit;
  } STORE5;
  
  union {
    __IOM uint32_t reg;                         /*!< reserved register                                                         */
    
    struct {
      __IOM uint32_t SCRATCH6   : 32;           /*!< reserved register                                                         */
    } bit;
  } STORE6;
  
  union {
    __IOM uint32_t reg;                         /*!< reserved register                                                         */
    
    struct {
      __IOM uint32_t SCRATCH7   : 32;           /*!< reserved register                                                         */
    } bit;
  } STORE7;
  
  union {
    __IOM uint32_t reg;                         /*!< reserved register                                                         */
    
    struct {
      __IM  uint32_t XPD_ROM0   : 1;            /*!< rom0 power down                                                           */
            uint32_t            : 1;
      __IM  uint32_t XPD_DIG_DCDC : 1;          /*!< External DCDC power down                                                  */
      __IM  uint32_t PERI_ISO   : 1;            /*!< rtc peripheral iso                                                        */
      __IM  uint32_t XPD_RTC_PERI : 1;          /*!< rtc peripheral power down                                                 */
      __IM  uint32_t WIFI_ISO   : 1;            /*!< wifi iso                                                                  */
      __IM  uint32_t XPD_WIFI   : 1;            /*!< wifi wrap power down                                                      */
      __IM  uint32_t DIG_ISO    : 1;            /*!< digital wrap iso                                                          */
      __IM  uint32_t XPD_DIG    : 1;            /*!< digital wrap power down                                                   */
      __IM  uint32_t TOUCH_STATE_START : 1;     /*!< touch should start to work                                                */
      __IM  uint32_t TOUCH_STATE_SWITCH : 1;    /*!< touch is about to working. Switch rtc main state                          */
      __IM  uint32_t TOUCH_STATE_SLP : 1;       /*!< touch is in sleep state                                                   */
      __IM  uint32_t TOUCH_STATE_DONE : 1;      /*!< touch is done                                                             */
      __IM  uint32_t COCPU_STATE_START : 1;     /*!< ulp/cocpu should start to work                                            */
      __IM  uint32_t COCPU_STATE_SWITCH : 1;    /*!< ulp/cocpu is about to working. Switch rtc main state                      */
      __IM  uint32_t COCPU_STATE_SLP : 1;       /*!< ulp/cocpu is in sleep state                                               */
      __IM  uint32_t COCPU_STATE_DONE : 1;      /*!< ulp/cocpu is done                                                         */
      __IM  uint32_t MAIN_STATE_XTAL_ISO : 1;   /*!< no use any more                                                           */
      __IM  uint32_t MAIN_STATE_PLL_ON : 1;     /*!< rtc main state machine is in states that pll should be running            */
      __IM  uint32_t RDY_FOR_WAKEUP : 1;        /*!< rtc is ready to receive wake up trigger from wake up source               */
      __IM  uint32_t MAIN_STATE_WAIT_END : 1;   /*!< rtc main state machine has been waited for some cycles                    */
      __IM  uint32_t IN_WAKEUP_STATE : 1;       /*!< rtc main state machine is in the states of wakeup process                 */
      __IM  uint32_t IN_LOW_POWER_STATE : 1;    /*!< rtc main state machine is in the states of low power                      */
      __IM  uint32_t MAIN_STATE_IN_WAIT_8M : 1; /*!< rtc main state machine is in wait 8m state                                */
      __IM  uint32_t MAIN_STATE_IN_WAIT_PLL : 1;/*!< rtc main state machine is in wait pll state                               */
      __IM  uint32_t MAIN_STATE_IN_WAIT_XTL : 1;/*!< rtc main state machine is in wait xtal state                              */
      __IM  uint32_t MAIN_STATE_IN_SLP : 1;     /*!< rtc main state machine is in sleep state                                  */
      __IM  uint32_t MAIN_STATE_IN_IDLE : 1;    /*!< rtc main state machine is in idle state                                   */
      __IM  uint32_t MAIN_STATE : 4;            /*!< rtc main state machine status                                             */
    } bit;
  } LOW_POWER_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< No public                                                                 */
    
    struct {
      __IM  uint32_t LOW_POWER_DIAG1 : 32;      /*!< No public                                                                 */
    } bit;
  } DIAG0;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc pad hold configure                                                    */
    
    struct {
      __IOM uint32_t TOUCH_PAD0_HOLD : 1;       /*!< hold rtc pad0                                                             */
      __IOM uint32_t TOUCH_PAD1_HOLD : 1;       /*!< hold rtc pad-1                                                            */
      __IOM uint32_t TOUCH_PAD2_HOLD : 1;       /*!< hold rtc pad-2                                                            */
      __IOM uint32_t TOUCH_PAD3_HOLD : 1;       /*!< hold rtc pad-3                                                            */
      __IOM uint32_t TOUCH_PAD4_HOLD : 1;       /*!< hold rtc pad-4                                                            */
      __IOM uint32_t TOUCH_PAD5_HOLD : 1;       /*!< hold rtc pad-5                                                            */
      __IOM uint32_t TOUCH_PAD6_HOLD : 1;       /*!< hold rtc pad-6                                                            */
      __IOM uint32_t TOUCH_PAD7_HOLD : 1;       /*!< hold rtc pad-7                                                            */
      __IOM uint32_t TOUCH_PAD8_HOLD : 1;       /*!< hold rtc pad-8                                                            */
      __IOM uint32_t TOUCH_PAD9_HOLD : 1;       /*!< hold rtc pad-9                                                            */
      __IOM uint32_t TOUCH_PAD10_HOLD : 1;      /*!< hold rtc pad-10                                                           */
      __IOM uint32_t TOUCH_PAD11_HOLD : 1;      /*!< hold rtc pad-11                                                           */
      __IOM uint32_t TOUCH_PAD12_HOLD : 1;      /*!< hold rtc pad-12                                                           */
      __IOM uint32_t TOUCH_PAD13_HOLD : 1;      /*!< hold rtc pad-13                                                           */
      __IOM uint32_t TOUCH_PAD14_HOLD : 1;      /*!< hold rtc pad-14                                                           */
      __IOM uint32_t X32P_HOLD  : 1;            /*!< hold rtc pad-15                                                           */
      __IOM uint32_t X32N_HOLD  : 1;            /*!< hold rtc pad-16                                                           */
      __IOM uint32_t PDAC1_HOLD : 1;            /*!< hold rtc pad-17                                                           */
      __IOM uint32_t PDAC2_HOLD : 1;            /*!< hold rtc pad-18                                                           */
      __IOM uint32_t PAD19_HOLD : 1;            /*!< hold rtc pad-19                                                           */
      __IOM uint32_t PAD20_HOLD : 1;            /*!< hold rtc pad-20                                                           */
      __IOM uint32_t PAD21_HOLD : 1;            /*!< hold rtc pad-21                                                           */
            uint32_t            : 10;
    } bit;
  } PAD_HOLD;
  
  union {
    __IOM uint32_t reg;                         /*!< configure digtal pad hold                                                 */
    
    struct {
      __IOM uint32_t DIG_PAD_HOLD : 32;         /*!< configure digtal pad hold                                                 */
    } bit;
  } DIG_PAD_HOLD;
  
  union {
    __IOM uint32_t reg;                         /*!< configure ext1 wakeup                                                     */
    
    struct {
      __IOM uint32_t EXT_WAKEUP1_SEL : 22;      /*!< Bitmap to select RTC pads for ext wakeup1                                 */
      __OM  uint32_t EXT_WAKEUP1_STATUS_CLR : 1;/*!< clear ext wakeup1 status                                                  */
            uint32_t            : 9;
    } bit;
  } EXT_WAKEUP1;
  
  union {
    __IOM uint32_t reg;                         /*!< check ext wakeup1 status                                                  */
    
    struct {
      __IM  uint32_t EXT_WAKEUP1_STATUS : 22;   /*!< ext wakeup1 status                                                        */
            uint32_t            : 10;
    } bit;
  } EXT_WAKEUP1_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< congfigure brownout                                                       */
    
    struct {
            uint32_t            : 4;
      __IOM uint32_t BROWN_OUT_INT_WAIT : 10;   /*!< brown out interrupt wait cycles                                           */
      __IOM uint32_t BROWN_OUT_CLOSE_FLASH_ENA : 1;/*!< enable close flash when brown out happens                              */
      __IOM uint32_t BROWN_OUT_PD_RF_ENA : 1;   /*!< enable power down RF when brown out happens                               */
      __IOM uint32_t BROWN_OUT_RST_WAIT : 10;   /*!< brown out reset wait cycles                                               */
      __IOM uint32_t BROWN_OUT_RST_ENA : 1;     /*!< enable brown out reset                                                    */
      __IOM uint32_t BROWN_OUT_RST_SEL : 1;     /*!< 1: 4-pos reset, 0: sys_reset                                              */
      __IOM uint32_t BROWN_OUT_ANA_RST_EN : 1;  /*!< enable brown out reset en                                                 */
      __OM  uint32_t BROWN_OUT_CNT_CLR : 1;     /*!< clear brown out counter                                                   */
      __IOM uint32_t BROWN_OUT_ENA : 1;         /*!< enable brown out                                                          */
      __IM  uint32_t DET        : 1;            /*!< get brown out detect                                                      */
    } bit;
  } BROWN_OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC timer low 32 bits                                                     */
    
    struct {
      __IM  uint32_t TIMER_VALUE1_LOW : 32;     /*!< RTC timer low 32 bits                                                     */
    } bit;
  } TIME_LOW1;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC timer high 16 bits                                                    */
    
    struct {
      __IM  uint32_t TIMER_VALUE1_HIGH : 16;    /*!< RTC timer high 16 bits                                                    */
            uint32_t            : 16;
    } bit;
  } TIME_HIGH1;
  
  union {
    __IOM uint32_t reg;                         /*!< xtal 32k watch dog backup clock factor                                    */
    
    struct {
      __IOM uint32_t XTAL32K_CLK_FACTOR : 32;   /*!< xtal 32k watch dog backup clock factor                                    */
    } bit;
  } XTAL32K_CLK_FACTOR;
  
  union {
    __IOM uint32_t reg;                         /*!< configure xtal32k                                                         */
    
    struct {
      __IOM uint32_t XTAL32K_RETURN_WAIT : 4;   /*!< cycles to wait to return noral xtal 32k                                   */
      __IOM uint32_t XTAL32K_RESTART_WAIT : 16; /*!< cycles to wait to repower on xtal 32k                                     */
      __IOM uint32_t XTAL32K_WDT_TIMEOUT : 8;   /*!< If no clock detected for this amount of time 32k is regarded
                                                     as dead                                                                   */
      __IOM uint32_t XTAL32K_STABLE_THRES : 4;  /*!< if restarted xtal32k period is smaller than this, it is regarded
                                                     as stable                                                                 */
    } bit;
  } XTAL32K_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< configure ulp                                                             */
    
    struct {
      __IOM uint32_t ULP_CP_PC_INIT : 11;       /*!< ULP-coprocessor PC initial address                                        */
            uint32_t            : 18;
      __IOM uint32_t ULP_CP_GPIO_WAKEUP_ENA : 1;/*!< ULP-coprocessor wakeup by GPIO enable                                     */
      __OM  uint32_t ULP_CP_GPIO_WAKEUP_CLR : 1;/*!< ULP-coprocessor wakeup by GPIO state clear                                */
      __IOM uint32_t ULP_CP_SLP_TIMER_EN : 1;   /*!< ULP-coprocessor timer enable bit                                          */
    } bit;
  } ULP_CP_TIMER;
  
  union {
    __IOM uint32_t reg;                         /*!< configure ulp                                                             */
    
    struct {
      __IOM uint32_t ULP_CP_MEM_ADDR_INIT : 11; /*!< No public                                                                 */
      __IOM uint32_t ULP_CP_MEM_ADDR_SIZE : 11; /*!< No public                                                                 */
      __OM  uint32_t ULP_CP_MEM_OFFST_CLR : 1;  /*!< No public                                                                 */
            uint32_t            : 5;
      __IOM uint32_t ULP_CP_CLK_FO : 1;         /*!< ulp coprocessor clk force on                                              */
      __IOM uint32_t ULP_CP_RESET : 1;          /*!< ulp coprocessor clk software reset                                        */
      __IOM uint32_t ULP_CP_FORCE_START_TOP : 1;/*!< 1: ULP-coprocessor is started by SW                                       */
      __IOM uint32_t ULP_CP_START_TOP : 1;      /*!< Write 1 to start ULP-coprocessor                                          */
    } bit;
  } ULP_CP_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure ulp-riscv                                                       */
    
    struct {
      __IOM uint32_t COCPU_CLK_FO : 1;          /*!< cocpu clk force on                                                        */
      __IOM uint32_t COCPU_START_2_RESET_DIS : 6;/*!< time from start cocpu to pull down reset                                 */
      __IOM uint32_t COCPU_START_2_INTR_EN : 6; /*!< time from start cocpu to give start interrupt                             */
      __IOM uint32_t COCPU_SHUT : 1;            /*!< to shut cocpu                                                             */
      __IOM uint32_t COCPU_SHUT_2_CLK_DIS : 8;  /*!< time from shut cocpu to disable clk                                       */
      __IOM uint32_t COCPU_SHUT_RESET_EN : 1;   /*!< to reset cocpu                                                            */
      __IOM uint32_t COCPU_SEL  : 1;            /*!< 1: old ULP 0: new riscV                                                   */
      __IOM uint32_t COCPU_DONE_FORCE : 1;      /*!< 1: select riscv done 0: select ulp done                                   */
      __IOM uint32_t COCPU_DONE : 1;            /*!< done signal used by riscv to control timer.                               */
      __OM  uint32_t COCPU_SW_INT_TRIGGER : 1;  /*!< trigger cocpu register interrupt                                          */
      __IOM uint32_t COCPU_CLKGATE_EN : 1;      /*!< open ulp-riscv clk gate                                                   */
            uint32_t            : 4;
    } bit;
  } COCPU_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch controller                                                */
    
    struct {
      __IOM uint32_t TOUCH_SLEEP_CYCLES : 16;   /*!< sleep cycles for timer                                                    */
      __IOM uint32_t TOUCH_MEAS_NUM : 16;       /*!< the meas length (in 8MHz)                                                 */
    } bit;
  } TOUCH_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch controller                                                */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t TOUCH_DRANGE : 2;          /*!< TOUCH_DRANGE                                                              */
      __IOM uint32_t TOUCH_DREFL : 2;           /*!< TOUCH_DREFL                                                               */
      __IOM uint32_t TOUCH_DREFH : 2;           /*!< TOUCH_DREFH                                                               */
      __IOM uint32_t TOUCH_XPD_BIAS : 1;        /*!< TOUCH_XPD_BIAS                                                            */
      __IOM uint32_t TOUCH_REFC : 3;            /*!< TOUCH pad0 reference cap                                                  */
      __IOM uint32_t TOUCH_DBIAS : 1;           /*!< 1:use self bias 0:use bandgap bias                                        */
      __IOM uint32_t TOUCH_SLP_TIMER_EN : 1;    /*!< touch timer enable bit                                                    */
      __IOM uint32_t TOUCH_START_FSM_EN : 1;    /*!< 1: TOUCH_START & TOUCH_XPD is controlled by touch fsm                     */
      __IOM uint32_t TOUCH_START_EN : 1;        /*!< 1: start touch fsm                                                        */
      __IOM uint32_t TOUCH_START_FORCE : 1;     /*!< 1: to start touch fsm by SW                                               */
      __IOM uint32_t TOUCH_XPD_WAIT : 8;        /*!< the waiting cycles (in 8MHz) between TOUCH_START and TOUCH_XPD            */
      __IOM uint32_t TOUCH_SLP_CYC_DIV : 2;     /*!< when a touch pad is active sleep cycle could be divided by this
                                                     number                                                                    */
      __IOM uint32_t TOUCH_TIMER_FORCE_DONE : 2;/*!< force touch timer done                                                    */
      __IOM uint32_t TOUCH_RESET : 1;           /*!< reset upgrade touch                                                       */
      __IOM uint32_t TOUCH_CLK_FO : 1;          /*!< touch clock force on                                                      */
      __IOM uint32_t TOUCH_CLKGATE_EN : 1;      /*!< touch clock enable                                                        */
    } bit;
  } TOUCH_CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch controller                                                */
    
    struct {
      __IOM uint32_t TOUCH_DENOISE_RES : 2;     /*!< De-noise resolution: 12/10/8/4 bit                                        */
      __IOM uint32_t TOUCH_DENOISE_EN : 1;      /*!< touch pad0 will be used to de-noise                                       */
            uint32_t            : 5;
      __IOM uint32_t TOUCH_INACTIVE_CONNECTION : 1;/*!< inactive touch pads connect to 1: gnd 0: HighZ                         */
      __IOM uint32_t TOUCH_SHIELD_PAD_EN : 1;   /*!< touch pad14 will be used as shield                                        */
      __IOM uint32_t TOUCH_SCAN_PAD_MAP : 15;   /*!< touch scan mode pad enable map                                            */
      __IOM uint32_t TOUCH_BUFDRV : 3;          /*!< touch7 buffer driver strength                                             */
      __IOM uint32_t TOUCH_OUT_RING : 4;        /*!< select out ring pad                                                       */
    } bit;
  } TOUCH_SCAN_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch controller                                                */
    
    struct {
      __IOM uint32_t TOUCH_SLP_TH : 22;         /*!< the threshold for sleep touch pad                                         */
            uint32_t            : 4;
      __IOM uint32_t TOUCH_SLP_APPROACH_EN : 1; /*!< sleep pad approach function enable                                        */
      __IOM uint32_t TOUCH_SLP_PAD : 5;         /*!< configure which pad as slp pad                                            */
    } bit;
  } TOUCH_SLP_THRES;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch controller                                                */
    
    struct {
            uint32_t            : 23;
      __OM  uint32_t TOUCH_SLP_CHANNEL_CLR : 1; /*!< clear touch slp channel                                                   */
      __IOM uint32_t TOUCH_APPROACH_MEAS_TIME : 8;/*!< approach pads total meas times                                          */
    } bit;
  } TOUCH_APPROACH;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch controller                                                */
    
    struct {
            uint32_t            : 7;
      __IOM uint32_t TOUCH_BYPASS_NEG_NOISE_THRES : 1;/*!< bypass neg noise thres                                              */
      __IOM uint32_t TOUCH_BYPASS_NOISE_THRES : 1;/*!< bypaas noise thres                                                      */
      __IOM uint32_t TOUCH_SMOOTH_LVL : 2;      /*!< smooth filter factor                                                      */
      __IOM uint32_t TOUCH_JITTER_STEP : 4;     /*!< touch jitter step                                                         */
      __IOM uint32_t TOUCH_NEG_NOISE_LIMIT : 4; /*!< negative threshold counter limit                                          */
      __IOM uint32_t TOUCH_NEG_NOISE_THRES : 2; /*!< neg noise thres                                                           */
      __IOM uint32_t TOUCH_NOISE_THRES : 2;     /*!< noise thres                                                               */
      __IOM uint32_t TOUCH_HYSTERESIS : 2;      /*!< hysteresis                                                                */
      __IOM uint32_t TOUCH_DEBOUNCE : 3;        /*!< debounce counter                                                          */
      __IOM uint32_t TOUCH_FILTER_MODE : 3;     /*!< 0: IIR ? 1: IIR ? 2: IIR 1/8 3: Jitter                                    */
      __IOM uint32_t TOUCH_FILTER_EN : 1;       /*!< touch filter enable                                                       */
    } bit;
  } TOUCH_FILTER_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< usb configure                                                             */
    
    struct {
      __IOM uint32_t USB_VREFH  : 2;            /*!< reg_usb_vrefh                                                             */
      __IOM uint32_t USB_VREFL  : 2;            /*!< reg_usb_vrefl                                                             */
      __IOM uint32_t USB_VREF_OVERRIDE : 1;     /*!< reg_usb_vref_override                                                     */
      __IOM uint32_t USB_PAD_PULL_OVERRIDE : 1; /*!< reg_usb_pad_pull_override                                                 */
      __IOM uint32_t USB_DP_PULLUP : 1;         /*!< reg_usb_dp_pullup                                                         */
      __IOM uint32_t USB_DP_PULLDOWN : 1;       /*!< reg_usb_dp_pulldown                                                       */
      __IOM uint32_t USB_DM_PULLUP : 1;         /*!< reg_usb_dm_pullup                                                         */
      __IOM uint32_t USB_DM_PULLDOWN : 1;       /*!< reg_usb_dm_pulldown                                                       */
      __IOM uint32_t USB_PULLUP_VALUE : 1;      /*!< reg_usb_pullup_value                                                      */
      __IOM uint32_t USB_PAD_ENABLE_OVERRIDE : 1;/*!< reg_usb_pad_enable_override                                              */
      __IOM uint32_t USB_PAD_ENABLE : 1;        /*!< reg_usb_pad_enable                                                        */
      __IOM uint32_t USB_TXM    : 1;            /*!< reg_usb_txm                                                               */
      __IOM uint32_t USB_TXP    : 1;            /*!< reg_usb_txp                                                               */
      __IOM uint32_t USB_TX_EN  : 1;            /*!< reg_usb_tx_en                                                             */
      __IOM uint32_t USB_TX_EN_OVERRIDE : 1;    /*!< reg_usb_tx_en_override                                                    */
      __IOM uint32_t USB_RESET_DISABLE : 1;     /*!< reg_usb_reset_disable                                                     */
      __IOM uint32_t IO_MUX_RESET_DISABLE : 1;  /*!< reg_io_mux_reset_disable                                                  */
      __IOM uint32_t SW_USB_PHY_SEL : 1;        /*!< reg_sw_usb_phy_sel                                                        */
      __IOM uint32_t SW_HW_USB_PHY_SEL : 1;     /*!< reg_sw_hw_usb_phy_sel                                                     */
            uint32_t            : 11;
    } bit;
  } USB_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch controller                                                */
    
    struct {
      __IOM uint32_t TOUCH_TIMEOUT_NUM : 22;    /*!< configure touch timerout time                                             */
      __IOM uint32_t TOUCH_TIMEOUT_EN : 1;      /*!< enable touch timerout                                                     */
            uint32_t            : 9;
    } bit;
  } TOUCH_TIMEOUT_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< get reject casue                                                          */
    
    struct {
      __IM  uint32_t REJECT_CAUSE : 18;         /*!< sleep reject cause                                                        */
            uint32_t            : 14;
    } bit;
  } SLP_REJECT_CAUSE;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc common configure                                                      */
    
    struct {
      __IOM uint32_t FORCE_DOWNLOAD_BOOT : 1;   /*!< force chip entry download boot by sw                                      */
            uint32_t            : 31;
    } bit;
  } OPTION1;
  
  union {
    __IOM uint32_t reg;                         /*!< get wakeup cause                                                          */
    
    struct {
      __IM  uint32_t WAKEUP_CAUSE : 17;         /*!< sleep wakeup cause                                                        */
            uint32_t            : 15;
    } bit;
  } SLP_WAKEUP_CAUSE;
  
  union {
    __IOM uint32_t reg;                         /*!< configure ulp sleep time                                                  */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t ULP_CP_TIMER_SLP_CYCLE : 24;/*!< sleep cycles for ULP-coprocessor timer                                   */
    } bit;
  } ULP_CP_TIMER_1;
  
  union {
    __IOM uint32_t reg;                         /*!< oneset rtc interrupt                                                      */
    
    struct {
      __OM  uint32_t SLP_WAKEUP_INT_ENA_W1TS : 1;/*!< enable sleep wakeup interrupt                                            */
      __OM  uint32_t SLP_REJECT_INT_ENA_W1TS : 1;/*!< enable sleep reject interrupt                                            */
      __OM  uint32_t SDIO_IDLE_INT_ENA_W1TS : 1;/*!< enable SDIO idle interrupt                                                */
      __OM  uint32_t WDT_INT_ENA_W1TS : 1;      /*!< enable RTC WDT interrupt                                                  */
      __OM  uint32_t TOUCH_SCAN_DONE_INT_ENA_W1TS : 1;/*!< enable touch scan done interrupt                                    */
      __OM  uint32_t ULP_CP_INT_ENA_W1TS : 1;   /*!< enable ULP-coprocessor interrupt                                          */
      __OM  uint32_t TOUCH_DONE_INT_ENA_W1TS : 1;/*!< enable touch done interrupt                                              */
      __OM  uint32_t TOUCH_ACTIVE_INT_ENA_W1TS : 1;/*!< enable touch active interrupt                                          */
      __OM  uint32_t TOUCH_INACTIVE_INT_ENA_W1TS : 1;/*!< enable touch inactive interrupt                                      */
      __OM  uint32_t BROWN_OUT_INT_ENA_W1TS : 1;/*!< enable brown out interrupt                                                */
      __OM  uint32_t MAIN_TIMER_INT_ENA_W1TS : 1;/*!< enable RTC main timer interrupt                                          */
      __OM  uint32_t SARADC1_INT_ENA_W1TS : 1;  /*!< enable saradc1 interrupt                                                  */
      __OM  uint32_t TSENS_INT_ENA_W1TS : 1;    /*!< enable tsens interrupt                                                    */
      __OM  uint32_t COCPU_INT_ENA_W1TS : 1;    /*!< enable riscV cocpu interrupt                                              */
      __OM  uint32_t SARADC2_INT_ENA_W1TS : 1;  /*!< enable saradc2 interrupt                                                  */
      __OM  uint32_t SWD_INT_ENA_W1TS : 1;      /*!< enable super watch dog interrupt                                          */
      __OM  uint32_t XTAL32K_DEAD_INT_ENA_W1TS : 1;/*!< enable xtal32k_dead interrupt                                          */
      __OM  uint32_t COCPU_TRAP_INT_ENA_W1TS : 1;/*!< enable cocpu trap interrupt                                              */
      __OM  uint32_t TOUCH_TIMEOUT_INT_ENA_W1TS : 1;/*!< enable touch timeout interrupt                                        */
      __OM  uint32_t GLITCH_DET_INT_ENA_W1TS : 1;/*!< enbale gitch det interrupt                                               */
      __OM  uint32_t TOUCH_APPROACH_LOOP_DONE_INT_ENA_W1TS : 1;/*!< enbale touch approach_loop done interrupt                  */
            uint32_t            : 11;
    } bit;
  } INT_ENA_RTC_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< oneset clr rtc interrupt enable                                           */
    
    struct {
      __OM  uint32_t SLP_WAKEUP_INT_ENA_W1TC : 1;/*!< enable sleep wakeup interrupt                                            */
      __OM  uint32_t SLP_REJECT_INT_ENA_W1TC : 1;/*!< enable sleep reject interrupt                                            */
      __OM  uint32_t SDIO_IDLE_INT_ENA_W1TC : 1;/*!< enable SDIO idle interrupt                                                */
      __OM  uint32_t WDT_INT_ENA_W1TC : 1;      /*!< enable RTC WDT interrupt                                                  */
      __OM  uint32_t TOUCH_SCAN_DONE_INT_ENA_W1TC : 1;/*!< enable touch scan done interrupt                                    */
      __OM  uint32_t ULP_CP_INT_ENA_W1TC : 1;   /*!< enable ULP-coprocessor interrupt                                          */
      __OM  uint32_t TOUCH_DONE_INT_ENA_W1TC : 1;/*!< enable touch done interrupt                                              */
      __OM  uint32_t TOUCH_ACTIVE_INT_ENA_W1TC : 1;/*!< enable touch active interrupt                                          */
      __OM  uint32_t TOUCH_INACTIVE_INT_ENA_W1TC : 1;/*!< enable touch inactive interrupt                                      */
      __OM  uint32_t BROWN_OUT_INT_ENA_W1TC : 1;/*!< enable brown out interrupt                                                */
      __OM  uint32_t MAIN_TIMER_INT_ENA_W1TC : 1;/*!< enable RTC main timer interrupt                                          */
      __OM  uint32_t SARADC1_INT_ENA_W1TC : 1;  /*!< enable saradc1 interrupt                                                  */
      __OM  uint32_t TSENS_INT_ENA_W1TC : 1;    /*!< enable tsens interrupt                                                    */
      __OM  uint32_t COCPU_INT_ENA_W1TC : 1;    /*!< enable riscV cocpu interrupt                                              */
      __OM  uint32_t SARADC2_INT_ENA_W1TC : 1;  /*!< enable saradc2 interrupt                                                  */
      __OM  uint32_t SWD_INT_ENA_W1TC : 1;      /*!< enable super watch dog interrupt                                          */
      __OM  uint32_t XTAL32K_DEAD_INT_ENA_W1TC : 1;/*!< enable xtal32k_dead interrupt                                          */
      __OM  uint32_t COCPU_TRAP_INT_ENA_W1TC : 1;/*!< enable cocpu trap interrupt                                              */
      __OM  uint32_t TOUCH_TIMEOUT_INT_ENA_W1TC : 1;/*!< enable touch timeout interrupt                                        */
      __OM  uint32_t GLITCH_DET_INT_ENA_W1TC : 1;/*!< enbale gitch det interrupt                                               */
      __OM  uint32_t TOUCH_APPROACH_LOOP_DONE_INT_ENA_W1TC : 1;/*!< enbale touch approach_loop done interrupt                  */
            uint32_t            : 11;
    } bit;
  } INT_ENA_RTC_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< configure retention                                                       */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t RETENTION_TAG_MODE : 4;    /*!< No public                                                                 */
      __IOM uint32_t RETENTION_TARGET : 2;      /*!< congfigure retention target cpu and/or tag                                */
      __IOM uint32_t RETENTION_CLK_SEL : 1;     /*!< No public                                                                 */
      __IOM uint32_t RETENTION_DONE_WAIT : 3;   /*!< wait retention done cycle                                                 */
      __IOM uint32_t RETENTION_CLKOFF_WAIT : 4; /*!< wait clk off cycle                                                        */
      __IOM uint32_t RETENTION_EN : 1;          /*!< enable retention                                                          */
      __IOM uint32_t RETENTION_WAIT : 7;        /*!< wait cycles for rention operation                                         */
    } bit;
  } RETENTION_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure power glitch                                                    */
    
    struct {
            uint32_t            : 26;
      __IOM uint32_t POWER_GLITCH_DSENSE : 2;   /*!< GLITCH_DSENSE                                                             */
      __IOM uint32_t POWER_GLITCH_FORCE_PD : 1; /*!< force power glitch disable                                                */
      __IOM uint32_t POWER_GLITCH_FORCE_PU : 1; /*!< force power glitch enable                                                 */
      __IOM uint32_t POWER_GLITCH_EFUSE_SEL : 1;/*!< select use analog fib signal                                              */
      __IOM uint32_t POWER_GLITCH_EN : 1;       /*!< enable power glitch                                                       */
    } bit;
  } PG_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< No public                                                                 */
    
    struct {
      __IOM uint32_t FIB_SEL    : 3;            /*!< No public                                                                 */
            uint32_t            : 29;
    } bit;
  } FIB_SEL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch dac                                                       */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t TOUCH_PAD9_DAC : 3;        /*!< configure touch pad dac9                                                  */
      __IOM uint32_t TOUCH_PAD8_DAC : 3;        /*!< configure touch pad dac8                                                  */
      __IOM uint32_t TOUCH_PAD7_DAC : 3;        /*!< configure touch pad dac7                                                  */
      __IOM uint32_t TOUCH_PAD6_DAC : 3;        /*!< configure touch pad dac6                                                  */
      __IOM uint32_t TOUCH_PAD5_DAC : 3;        /*!< configure touch pad dac5                                                  */
      __IOM uint32_t TOUCH_PAD4_DAC : 3;        /*!< configure touch pad dac4                                                  */
      __IOM uint32_t TOUCH_PAD3_DAC : 3;        /*!< configure touch pad dac3                                                  */
      __IOM uint32_t TOUCH_PAD2_DAC : 3;        /*!< configure touch pad dac2                                                  */
      __IOM uint32_t TOUCH_PAD1_DAC : 3;        /*!< configure touch pad dac1                                                  */
      __IOM uint32_t TOUCH_PAD0_DAC : 3;        /*!< configure touch pad dac0                                                  */
    } bit;
  } TOUCH_DAC;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch dac                                                       */
    
    struct {
            uint32_t            : 17;
      __IOM uint32_t TOUCH_PAD14_DAC : 3;       /*!< configure touch pad dac14                                                 */
      __IOM uint32_t TOUCH_PAD13_DAC : 3;       /*!< configure touch pad dac13                                                 */
      __IOM uint32_t TOUCH_PAD12_DAC : 3;       /*!< configure touch pad dac12                                                 */
      __IOM uint32_t TOUCH_PAD11_DAC : 3;       /*!< configure touch pad dac11                                                 */
      __IOM uint32_t TOUCH_PAD10_DAC : 3;       /*!< configure touch pad dac10                                                 */
    } bit;
  } TOUCH_DAC1;
  
  union {
    __IOM uint32_t reg;                         /*!< configure ulp diable                                                      */
    
    struct {
            uint32_t            : 31;
      __IOM uint32_t DISABLE_RTC_CPU : 1;       /*!< configure ulp diable                                                      */
    } bit;
  } COCPU_DISABLE;
  __IM  uint32_t  RESERVED[41];
  
  union {
    __IOM uint32_t reg;                         /*!< version register                                                          */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< version register                                                          */
            uint32_t            : 4;
    } bit;
  } DATE;
} RTC_CNTL_Type;                                /*!< Size = 512 (0x200)                                                        */



/* =========================================================================================================================== */
/* ================                                          RTC_I2C                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Low-power I2C (Inter-Integrated Circuit) Controller (RTC_I2C)
  */

typedef struct {                                /*!< RTC_I2C Structure                                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< configure low scl period                                                  */
    
    struct {
      __IOM uint32_t PERIOD     : 20;           /*!< time period that scl =0                                                   */
            uint32_t            : 12;
    } bit;
  } SCL_LOW;
  
  union {
    __IOM uint32_t reg;                         /*!< configure i2c ctrl                                                        */
    
    struct {
      __IOM uint32_t SDA_FORCE_OUT : 1;         /*!< 1=push pull,0=open drain                                                  */
      __IOM uint32_t SCL_FORCE_OUT : 1;         /*!< 1=push pull,0=open drain                                                  */
      __IOM uint32_t MS_MODE    : 1;            /*!< 1=master,0=slave                                                          */
      __IOM uint32_t TRANS_START : 1;           /*!< force start                                                               */
      __IOM uint32_t TX_LSB_FIRST : 1;          /*!< transit lsb first                                                         */
      __IOM uint32_t RX_LSB_FIRST : 1;          /*!< receive lsb first                                                         */
            uint32_t            : 23;
      __IOM uint32_t I2C_CTRL_CLK_GATE_EN : 1;  /*!< configure i2c ctrl clk enable                                             */
      __IOM uint32_t I2C_RESET  : 1;            /*!< rtc i2c sw reset                                                          */
      __IOM uint32_t I2CCLK_EN  : 1;            /*!< rtc i2c reg clk gating                                                    */
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< get i2c status                                                            */
    
    struct {
      __IM  uint32_t ACK_REC    : 1;            /*!< ack response                                                              */
      __IM  uint32_t SLAVE_RW   : 1;            /*!< slave read or write                                                       */
      __IM  uint32_t ARB_LOST   : 1;            /*!< arbitration is lost                                                       */
      __IM  uint32_t BUS_BUSY   : 1;            /*!< bus is busy                                                               */
      __IM  uint32_t SLAVE_ADDRESSED : 1;       /*!< slave reg sub address                                                     */
      __IM  uint32_t BYTE_TRANS : 1;            /*!< One byte transit done                                                     */
      __IM  uint32_t OP_CNT     : 2;            /*!< which operation is working                                                */
            uint32_t            : 8;
      __IM  uint32_t SHIFT      : 8;            /*!< shifter content                                                           */
      __IM  uint32_t SCL_MAIN_STATE_LAST : 3;   /*!< i2c last main status                                                      */
            uint32_t            : 1;
      __IM  uint32_t SCL_STATE_LAST : 3;        /*!< scl last status                                                           */
            uint32_t            : 1;
    } bit;
  } STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< configure time out                                                        */
    
    struct {
      __IOM uint32_t TIME_OUT   : 20;           /*!< time out threshold                                                        */
            uint32_t            : 12;
    } bit;
  } TO;
  
  union {
    __IOM uint32_t reg;                         /*!< configure slave id                                                        */
    
    struct {
      __IOM uint32_t SLAVE_ADDR : 15;           /*!< slave address                                                             */
            uint32_t            : 16;
      __IOM uint32_t ADDR_10BIT_EN : 1;         /*!< i2c 10bit mode enable                                                     */
    } bit;
  } SLAVE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< configure high scl period                                                 */
    
    struct {
      __IOM uint32_t PERIOD     : 20;           /*!< time period that scl = 1                                                  */
            uint32_t            : 12;
    } bit;
  } SCL_HIGH;
  
  union {
    __IOM uint32_t reg;                         /*!< configure sda duty                                                        */
    
    struct {
      __IOM uint32_t NUM        : 20;           /*!< time period for SDA to toggle after SCL goes low                          */
            uint32_t            : 12;
    } bit;
  } SDA_DUTY;
  
  union {
    __IOM uint32_t reg;                         /*!< configure scl start period                                                */
    
    struct {
      __IOM uint32_t SCL_START_PERIOD : 20;     /*!< time period for SCL to toggle after I2C start is triggered                */
            uint32_t            : 12;
    } bit;
  } SCL_START_PERIOD;
  
  union {
    __IOM uint32_t reg;                         /*!< configure scl stop period                                                 */
    
    struct {
      __IOM uint32_t SCL_STOP_PERIOD : 20;      /*!< time period for SCL to stop after I2C end is triggered                    */
            uint32_t            : 12;
    } bit;
  } SCL_STOP_PERIOD;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt clear register                                                  */
    
    struct {
      __OM  uint32_t SLAVE_TRAN_COMP_INT_CLR : 1;/*!< clear slave transit complete interrupt                                   */
      __OM  uint32_t ARBITRATION_LOST_INT_CLR : 1;/*!< clear arbitration lost interrupt                                        */
      __OM  uint32_t MASTER_TRAN_COMP_INT_CLR : 1;/*!< clear master transit complete interrupt                                 */
      __OM  uint32_t TRANS_COMPLETE_INT_CLR : 1;/*!< clear transit complete interrupt                                          */
      __OM  uint32_t TIME_OUT_INT_CLR : 1;      /*!< clear time out interrupt                                                  */
      __OM  uint32_t ACK_ERR_INT_CLR : 1;       /*!< clear ack error interrupt                                                 */
      __OM  uint32_t RX_DATA_INT_CLR : 1;       /*!< clear receive data interrupt                                              */
      __OM  uint32_t TX_DATA_INT_CLR : 1;       /*!< clear transit load data complete interrupt                                */
      __OM  uint32_t DETECT_START_INT_CLR : 1;  /*!< clear detect start interrupt                                              */
            uint32_t            : 23;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt raw register                                                    */
    
    struct {
      __IM  uint32_t SLAVE_TRAN_COMP_INT_RAW : 1;/*!< slave transit complete interrupt raw                                     */
      __IM  uint32_t ARBITRATION_LOST_INT_RAW : 1;/*!< arbitration lost interrupt raw                                          */
      __IM  uint32_t MASTER_TRAN_COMP_INT_RAW : 1;/*!< master transit complete interrupt raw                                   */
      __IM  uint32_t TRANS_COMPLETE_INT_RAW : 1;/*!< transit complete interrupt raw                                            */
      __IM  uint32_t TIME_OUT_INT_RAW : 1;      /*!< time out interrupt raw                                                    */
      __IM  uint32_t ACK_ERR_INT_RAW : 1;       /*!< ack error interrupt raw                                                   */
      __IM  uint32_t RX_DATA_INT_RAW : 1;       /*!< receive data interrupt raw                                                */
      __IM  uint32_t TX_DATA_INT_RAW : 1;       /*!< transit data interrupt raw                                                */
      __IM  uint32_t DETECT_START_INT_RAW : 1;  /*!< detect start interrupt raw                                                */
            uint32_t            : 23;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt state register                                                  */
    
    struct {
      __IM  uint32_t SLAVE_TRAN_COMP_INT_ST : 1;/*!< slave transit complete interrupt state                                    */
      __IM  uint32_t ARBITRATION_LOST_INT_ST : 1;/*!< arbitration lost interrupt state                                         */
      __IM  uint32_t MASTER_TRAN_COMP_INT_ST : 1;/*!< master transit complete interrupt state                                  */
      __IM  uint32_t TRANS_COMPLETE_INT_ST : 1; /*!< transit complete interrupt state                                          */
      __IM  uint32_t TIME_OUT_INT_ST : 1;       /*!< time out interrupt state                                                  */
      __IM  uint32_t ACK_ERR_INT_ST : 1;        /*!< ack error interrupt state                                                 */
      __IM  uint32_t RX_DATA_INT_ST : 1;        /*!< receive data interrupt state                                              */
      __IM  uint32_t TX_DATA_INT_ST : 1;        /*!< transit data interrupt state                                              */
      __IM  uint32_t DETECT_START_INT_ST : 1;   /*!< detect start interrupt state                                              */
            uint32_t            : 23;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt enable register                                                 */
    
    struct {
      __IOM uint32_t SLAVE_TRAN_COMP_INT_ENA : 1;/*!< enable slave transit complete interrupt                                  */
      __IOM uint32_t ARBITRATION_LOST_INT_ENA : 1;/*!< enable arbitration lost interrupt                                       */
      __IOM uint32_t MASTER_TRAN_COMP_INT_ENA : 1;/*!< enable master transit complete interrupt                                */
      __IOM uint32_t TRANS_COMPLETE_INT_ENA : 1;/*!< enable transit complete interrupt                                         */
      __IOM uint32_t TIME_OUT_INT_ENA : 1;      /*!< enable time out interrupt                                                 */
      __IOM uint32_t ACK_ERR_INT_ENA : 1;       /*!< enable eack error interrupt                                               */
      __IOM uint32_t RX_DATA_INT_ENA : 1;       /*!< enable receive data interrupt                                             */
      __IOM uint32_t TX_DATA_INT_ENA : 1;       /*!< enable transit data interrupt                                             */
      __IOM uint32_t DETECT_START_INT_ENA : 1;  /*!< enable detect start interrupt                                             */
            uint32_t            : 23;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< get i2c data status                                                       */
    
    struct {
      __IM  uint32_t I2C_RDATA  : 8;            /*!< data received                                                             */
      __IOM uint32_t SLAVE_TX_DATA : 8;         /*!< data sent by slave                                                        */
            uint32_t            : 15;
      __IM  uint32_t I2C_DONE   : 1;            /*!< i2c done                                                                  */
    } bit;
  } DATA;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond0 register                                                     */
    
    struct {
      __IOM uint32_t COMMAND0   : 14;           /*!< command0                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND0_DONE : 1;         /*!< command0_done                                                             */
    } bit;
  } CMD0;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond1 register                                                     */
    
    struct {
      __IOM uint32_t COMMAND1   : 14;           /*!< command1                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND1_DONE : 1;         /*!< command1_done                                                             */
    } bit;
  } CMD1;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond2 register                                                     */
    
    struct {
      __IOM uint32_t COMMAND2   : 14;           /*!< command2                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND2_DONE : 1;         /*!< command2_done                                                             */
    } bit;
  } CMD2;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond3 register                                                     */
    
    struct {
      __IOM uint32_t COMMAND3   : 14;           /*!< command3                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND3_DONE : 1;         /*!< command3_done                                                             */
    } bit;
  } CMD3;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond4 register                                                     */
    
    struct {
      __IOM uint32_t COMMAND4   : 14;           /*!< command4                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND4_DONE : 1;         /*!< command4_done                                                             */
    } bit;
  } CMD4;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond5_register                                                     */
    
    struct {
      __IOM uint32_t COMMAND5   : 14;           /*!< command5                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND5_DONE : 1;         /*!< command5_done                                                             */
    } bit;
  } CMD5;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond6 register                                                     */
    
    struct {
      __IOM uint32_t COMMAND6   : 14;           /*!< command6                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND6_DONE : 1;         /*!< command6_done                                                             */
    } bit;
  } CMD6;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond7 register                                                     */
    
    struct {
      __IOM uint32_t COMMAND7   : 14;           /*!< command7                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND7_DONE : 1;         /*!< command7_done                                                             */
    } bit;
  } CMD7;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond8 register                                                     */
    
    struct {
      __IOM uint32_t COMMAND8   : 14;           /*!< command8                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND8_DONE : 1;         /*!< command8_done                                                             */
    } bit;
  } CMD8;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond9 register                                                     */
    
    struct {
      __IOM uint32_t COMMAND9   : 14;           /*!< command9                                                                  */
            uint32_t            : 17;
      __IM  uint32_t COMMAND9_DONE : 1;         /*!< command9_done                                                             */
    } bit;
  } CMD9;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond10 register                                                    */
    
    struct {
      __IOM uint32_t COMMAND10  : 14;           /*!< command10                                                                 */
            uint32_t            : 17;
      __IM  uint32_t COMMAND10_DONE : 1;        /*!< command10_done                                                            */
    } bit;
  } CMD10;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond11 register                                                    */
    
    struct {
      __IOM uint32_t COMMAND11  : 14;           /*!< command11                                                                 */
            uint32_t            : 17;
      __IM  uint32_t COMMAND11_DONE : 1;        /*!< command11_done                                                            */
    } bit;
  } CMD11;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond12 register                                                    */
    
    struct {
      __IOM uint32_t COMMAND12  : 14;           /*!< command12                                                                 */
            uint32_t            : 17;
      __IM  uint32_t COMMAND12_DONE : 1;        /*!< command12_done                                                            */
    } bit;
  } CMD12;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond13 register                                                    */
    
    struct {
      __IOM uint32_t COMMAND13  : 14;           /*!< command13                                                                 */
            uint32_t            : 17;
      __IM  uint32_t COMMAND13_DONE : 1;        /*!< command13_done                                                            */
    } bit;
  } CMD13;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond14 register                                                    */
    
    struct {
      __IOM uint32_t COMMAND14  : 14;           /*!< command14                                                                 */
            uint32_t            : 17;
      __IM  uint32_t COMMAND14_DONE : 1;        /*!< command14_done                                                            */
    } bit;
  } CMD14;
  
  union {
    __IOM uint32_t reg;                         /*!< i2c commond15 register                                                    */
    
    struct {
      __IOM uint32_t COMMAND15  : 14;           /*!< command15                                                                 */
            uint32_t            : 17;
      __IM  uint32_t COMMAND15_DONE : 1;        /*!< command15_done                                                            */
    } bit;
  } CMD15;
  __IM  uint32_t  RESERVED[33];
  
  union {
    __IOM uint32_t reg;                         /*!< version register                                                          */
    
    struct {
      __IOM uint32_t I2C_DATE   : 28;           /*!< version                                                                   */
            uint32_t            : 4;
    } bit;
  } DATE;
} RTC_I2C_Type;                                 /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                          RTC_IO                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low-power Input/Output (RTC_IO)
  */

typedef struct {                                /*!< RTC_IO Structure                                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< RTC GPIO 0 ~ 21 output data register                                      */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t DATA       : 22;           /*!< RTC GPIO 0 ~ 21 output data                                               */
    } bit;
  } RTC_GPIO_OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< one set RTC GPIO output data                                              */
    
    struct {
            uint32_t            : 10;
      __OM  uint32_t RTC_GPIO_OUT_DATA_W1TS : 22;/*!< RTC GPIO 0 ~ 21 output data write 1 to set                               */
    } bit;
  } RTC_GPIO_OUT_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< one clear RTC GPIO output data                                            */
    
    struct {
            uint32_t            : 10;
      __OM  uint32_t RTC_GPIO_OUT_DATA_W1TC : 22;/*!< RTC GPIO 0 ~ 21 output data write 1 to clear                             */
    } bit;
  } RTC_GPIO_OUT_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure RTC GPIO output enable                                          */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t RTC_GPIO_ENABLE : 22;      /*!< RTC GPIO 0 ~ 21 enable                                                    */
    } bit;
  } RTC_GPIO_ENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< one set RTC GPIO output enable                                            */
    
    struct {
            uint32_t            : 10;
      __OM  uint32_t RTC_GPIO_ENABLE_W1TS : 22; /*!< RTC GPIO 0 ~ 21 enable write 1 to set                                     */
    } bit;
  } RTC_GPIO_ENABLE_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< one clear RTC GPIO output enable                                          */
    
    struct {
            uint32_t            : 10;
      __OM  uint32_t ENABLE_W1TC : 22;          /*!< RTC GPIO 0 ~ 21 enable write 1 to clear                                   */
    } bit;
  } ENABLE_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC GPIO 0 ~ 21 interrupt status                                          */
    
    struct {
            uint32_t            : 10;
      __IOM uint32_t INT        : 22;           /*!< RTC GPIO 0 ~ 21 interrupt status                                          */
    } bit;
  } RTC_GPIO_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< One set RTC GPIO 0 ~ 21 interrupt status                                  */
    
    struct {
            uint32_t            : 10;
      __OM  uint32_t RTC_GPIO_STATUS_INT_W1TS : 22;/*!< RTC GPIO 0 ~ 21 interrupt status write 1 to set                        */
    } bit;
  } RTC_GPIO_STATUS_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< One clear RTC GPIO 0 ~ 21 interrupt status                                */
    
    struct {
            uint32_t            : 10;
      __OM  uint32_t RTC_GPIO_STATUS_INT_W1TC : 22;/*!< RTC GPIO 0 ~ 21 interrupt status write 1 to clear                      */
    } bit;
  } RTC_GPIO_STATUS_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC GPIO input data                                                       */
    
    struct {
            uint32_t            : 10;
      __IM  uint32_t NEXT       : 22;           /*!< RTC GPIO input data                                                       */
    } bit;
  } RTC_GPIO_IN;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO0                                                       */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN0;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO1                                                       */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN1;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO2                                                       */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN2;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO3                                                       */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN3;
  __IM  uint32_t  RESERVED3[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO4                                                       */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN4;
  __IM  uint32_t  RESERVED4[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO5                                                       */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN5;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IOM uint32_t reg;                         /*!< configure rtc debug                                                       */
    
    struct {
      __IOM uint32_t RTC_DEBUG_SEL0 : 5;        /*!< configure rtc debug                                                       */
      __IOM uint32_t RTC_DEBUG_SEL1 : 5;        /*!< configure rtc debug                                                       */
      __IOM uint32_t RTC_DEBUG_SEL2 : 5;        /*!< configure rtc debug                                                       */
      __IOM uint32_t RTC_DEBUG_SEL3 : 5;        /*!< configure rtc debug                                                       */
      __IOM uint32_t RTC_DEBUG_SEL4 : 5;        /*!< configure rtc debug                                                       */
      __IOM uint32_t RTC_DEBUG_12M_NO_GATING : 1;/*!< configure rtc debug                                                      */
            uint32_t            : 6;
    } bit;
  } RTC_DEBUG_SEL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD0                                                        */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD0;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< configure RTC GPIO6                                                       */
      
      struct {
              uint32_t          : 2;
        __IOM uint32_t PAD_DRIVER : 1;          /*!< if set to 0: normal output, if set to 1: open drain                       */
              uint32_t          : 4;
        __IOM uint32_t INT_TYPE : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< RTC GPIO wakeup enable bit                                                */
              uint32_t          : 21;
      } bit;
    } PIN6;
    
    union {
      __IOM uint32_t reg;                       /*!< configure RTC PAD1                                                        */
      
      struct {
              uint32_t          : 13;
        __IOM uint32_t FUN_IE   : 1;            /*!< input enable in work mode                                                 */
        __IOM uint32_t SLP_OE   : 1;            /*!< output enable in sleep mode                                               */
        __IOM uint32_t SLP_IE   : 1;            /*!< input enable in sleep mode                                                */
        __IOM uint32_t SLP_SEL  : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
        __IOM uint32_t FUN_SEL  : 2;            /*!< function sel                                                              */
        __IOM uint32_t MUX_SEL  : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
        __IOM uint32_t XPD      : 1;            /*!< TOUCH_XPD                                                                 */
        __IOM uint32_t TIE_OPT  : 1;            /*!< TOUCH_TIE_OPT                                                             */
        __IOM uint32_t START    : 1;            /*!< TOUCH_START                                                               */
              uint32_t          : 4;
        __IOM uint32_t RUE      : 1;            /*!< RUE                                                                       */
        __IOM uint32_t RDE      : 1;            /*!< RDE                                                                       */
        __IOM uint32_t DRV      : 2;            /*!< DRV                                                                       */
              uint32_t          : 1;
      } bit;
    } TOUCH_PAD1;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD2                                                        */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD3                                                        */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD3;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD4                                                        */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD4;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< configure RTC GPIO7                                                       */
      
      struct {
              uint32_t          : 2;
        __IOM uint32_t PAD_DRIVER : 1;          /*!< if set to 0: normal output, if set to 1: open drain                       */
              uint32_t          : 4;
        __IOM uint32_t INT_TYPE : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< RTC GPIO wakeup enable bit                                                */
              uint32_t          : 21;
      } bit;
    } PIN7;
    
    union {
      __IOM uint32_t reg;                       /*!< configure RTC PAD5                                                        */
      
      struct {
              uint32_t          : 13;
        __IOM uint32_t FUN_IE   : 1;            /*!< input enable in work mode                                                 */
        __IOM uint32_t SLP_OE   : 1;            /*!< output enable in sleep mode                                               */
        __IOM uint32_t SLP_IE   : 1;            /*!< input enable in sleep mode                                                */
        __IOM uint32_t SLP_SEL  : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
        __IOM uint32_t FUN_SEL  : 2;            /*!< function sel                                                              */
        __IOM uint32_t MUX_SEL  : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
        __IOM uint32_t XPD      : 1;            /*!< TOUCH_XPD                                                                 */
        __IOM uint32_t TIE_OPT  : 1;            /*!< TOUCH_TIE_OPT                                                             */
        __IOM uint32_t START    : 1;            /*!< TOUCH_START                                                               */
              uint32_t          : 4;
        __IOM uint32_t RUE      : 1;            /*!< RUE                                                                       */
        __IOM uint32_t RDE      : 1;            /*!< RDE                                                                       */
        __IOM uint32_t DRV      : 2;            /*!< DRV                                                                       */
              uint32_t          : 1;
      } bit;
    } TOUCH_PAD5;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD6                                                        */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD6;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD7                                                        */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD7;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD8                                                        */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD8;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< configure RTC GPIO8                                                       */
      
      struct {
              uint32_t          : 2;
        __IOM uint32_t PAD_DRIVER : 1;          /*!< if set to 0: normal output, if set to 1: open drain                       */
              uint32_t          : 4;
        __IOM uint32_t INT_TYPE : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< RTC GPIO wakeup enable bit                                                */
              uint32_t          : 21;
      } bit;
    } PIN8;
    
    union {
      __IOM uint32_t reg;                       /*!< configure RTC PAD9                                                        */
      
      struct {
              uint32_t          : 13;
        __IOM uint32_t FUN_IE   : 1;            /*!< input enable in work mode                                                 */
        __IOM uint32_t SLP_OE   : 1;            /*!< output enable in sleep mode                                               */
        __IOM uint32_t SLP_IE   : 1;            /*!< input enable in sleep mode                                                */
        __IOM uint32_t SLP_SEL  : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
        __IOM uint32_t FUN_SEL  : 2;            /*!< function sel                                                              */
        __IOM uint32_t MUX_SEL  : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
        __IOM uint32_t XPD      : 1;            /*!< TOUCH_XPD                                                                 */
        __IOM uint32_t TIE_OPT  : 1;            /*!< TOUCH_TIE_OPT                                                             */
        __IOM uint32_t START    : 1;            /*!< TOUCH_START                                                               */
              uint32_t          : 4;
        __IOM uint32_t RUE      : 1;            /*!< RUE                                                                       */
        __IOM uint32_t RDE      : 1;            /*!< RDE                                                                       */
        __IOM uint32_t DRV      : 2;            /*!< DRV                                                                       */
              uint32_t          : 1;
      } bit;
    } TOUCH_PAD9;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD10                                                       */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD10;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD11                                                       */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD11;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD12                                                       */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD12;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< configure RTC GPIO9                                                       */
      
      struct {
              uint32_t          : 2;
        __IOM uint32_t PAD_DRIVER : 1;          /*!< if set to 0: normal output, if set to 1: open drain                       */
              uint32_t          : 4;
        __IOM uint32_t INT_TYPE : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< RTC GPIO wakeup enable bit                                                */
              uint32_t          : 21;
      } bit;
    } PIN9;
    
    union {
      __IOM uint32_t reg;                       /*!< configure RTC PAD13                                                       */
      
      struct {
              uint32_t          : 13;
        __IOM uint32_t FUN_IE   : 1;            /*!< input enable in work mode                                                 */
        __IOM uint32_t SLP_OE   : 1;            /*!< output enable in sleep mode                                               */
        __IOM uint32_t SLP_IE   : 1;            /*!< input enable in sleep mode                                                */
        __IOM uint32_t SLP_SEL  : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
        __IOM uint32_t FUN_SEL  : 2;            /*!< function sel                                                              */
        __IOM uint32_t MUX_SEL  : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
        __IOM uint32_t XPD      : 1;            /*!< TOUCH_XPD                                                                 */
        __IOM uint32_t TIE_OPT  : 1;            /*!< TOUCH_TIE_OPT                                                             */
        __IOM uint32_t START    : 1;            /*!< TOUCH_START                                                               */
              uint32_t          : 4;
        __IOM uint32_t RUE      : 1;            /*!< RUE                                                                       */
        __IOM uint32_t RDE      : 1;            /*!< RDE                                                                       */
        __IOM uint32_t DRV      : 2;            /*!< DRV                                                                       */
              uint32_t          : 1;
      } bit;
    } TOUCH_PAD13;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD14                                                       */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
      __IOM uint32_t XPD        : 1;            /*!< TOUCH_XPD                                                                 */
      __IOM uint32_t TIE_OPT    : 1;            /*!< TOUCH_TIE_OPT                                                             */
      __IOM uint32_t START      : 1;            /*!< TOUCH_START                                                               */
            uint32_t            : 4;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } TOUCH_PAD14;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD15                                                       */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t X32P_FUN_IE : 1;           /*!< input enable in work mode                                                 */
      __IOM uint32_t X32P_SLP_OE : 1;           /*!< output enable in sleep mode                                               */
      __IOM uint32_t X32P_SLP_IE : 1;           /*!< input enable in sleep mode                                                */
      __IOM uint32_t X32P_SLP_SEL : 1;          /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t X32P_FUN_SEL : 2;          /*!< function sel                                                              */
      __IOM uint32_t X32P_MUX_SEL : 1;          /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
            uint32_t            : 7;
      __IOM uint32_t X32P_RUE   : 1;            /*!< RUE                                                                       */
      __IOM uint32_t X32P_RDE   : 1;            /*!< RDE                                                                       */
      __IOM uint32_t X32P_DRV   : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } XTAL_32P_PAD;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD16                                                       */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t X32N_FUN_IE : 1;           /*!< input enable in work mode                                                 */
      __IOM uint32_t X32N_SLP_OE : 1;           /*!< output enable in sleep mode                                               */
      __IOM uint32_t X32N_SLP_IE : 1;           /*!< input enable in sleep mode                                                */
      __IOM uint32_t X32N_SLP_SEL : 1;          /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t X32N_FUN_SEL : 2;          /*!< function sel                                                              */
      __IOM uint32_t X32N_MUX_SEL : 1;          /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
            uint32_t            : 7;
      __IOM uint32_t X32N_RUE   : 1;            /*!< RUE                                                                       */
      __IOM uint32_t X32N_RDE   : 1;            /*!< RDE                                                                       */
      __IOM uint32_t X32N_DRV   : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } XTAL_32N_PAD;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< configure RTC GPIO10                                                      */
      
      struct {
              uint32_t          : 2;
        __IOM uint32_t PAD_DRIVER : 1;          /*!< if set to 0: normal output, if set to 1: open drain                       */
              uint32_t          : 4;
        __IOM uint32_t INT_TYPE : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< RTC GPIO wakeup enable bit                                                */
              uint32_t          : 21;
      } bit;
    } PIN10;
    
    union {
      __IOM uint32_t reg;                       /*!< configure RTC PAD17                                                       */
      
      struct {
              uint32_t          : 3;
        __IOM uint32_t PDAC1_DAC : 8;           /*!< PDAC1_DAC                                                                 */
        __IOM uint32_t PDAC1_XPD_DAC : 1;       /*!< PDAC1_XPD_DAC                                                             */
        __IOM uint32_t PDAC1_DAC_XPD_FORCE : 1; /*!< 1: use reg_pdac1_xpd_dac to control PDAC1_XPD_DAC,0: use SAR
                                                     ADC FSM to control PDAC1_XPD_DAC                                          */
        __IOM uint32_t PDAC1_FUN_IE : 1;        /*!< input enable in work mode                                                 */
        __IOM uint32_t PDAC1_SLP_OE : 1;        /*!< output enable in sleep mode                                               */
        __IOM uint32_t PDAC1_SLP_IE : 1;        /*!< input enable in sleep mode                                                */
        __IOM uint32_t PDAC1_SLP_SEL : 1;       /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
        __IOM uint32_t PDAC1_FUN_SEL : 2;       /*!< PDAC1 function sel                                                        */
        __IOM uint32_t PDAC1_MUX_SEL : 1;       /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
              uint32_t          : 7;
        __IOM uint32_t PDAC1_RUE : 1;           /*!< PDAC1_RUE                                                                 */
        __IOM uint32_t PDAC1_RDE : 1;           /*!< PDAC1_RDE                                                                 */
        __IOM uint32_t PDAC1_DRV : 2;           /*!< PDAC1_DRV                                                                 */
              uint32_t          : 1;
      } bit;
    } PAD_DAC1;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD18                                                       */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t PDAC2_DAC  : 8;            /*!< PDAC2_DAC                                                                 */
      __IOM uint32_t PDAC2_XPD_DAC : 1;         /*!< PDAC2_XPD_DAC                                                             */
      __IOM uint32_t PDAC2_DAC_XPD_FORCE : 1;   /*!< 1: use reg_pdac2_xpd_dac to control PDAC2_XPD_DAC,0: use SAR
                                                     ADC FSM to control PDAC2_XPD_DAC                                          */
      __IOM uint32_t PDAC2_FUN_IE : 1;          /*!< input enable in work mode                                                 */
      __IOM uint32_t PDAC2_SLP_OE : 1;          /*!< output enable in sleep mode                                               */
      __IOM uint32_t PDAC2_SLP_IE : 1;          /*!< input enable in sleep mode                                                */
      __IOM uint32_t PDAC2_SLP_SEL : 1;         /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t PDAC2_FUN_SEL : 2;         /*!< PDAC1 function sel                                                        */
      __IOM uint32_t PDAC2_MUX_SEL : 1;         /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
            uint32_t            : 7;
      __IOM uint32_t PDAC2_RUE  : 1;            /*!< PDAC2_RUE                                                                 */
      __IOM uint32_t PDAC2_RDE  : 1;            /*!< PDAC2_RDE                                                                 */
      __IOM uint32_t PDAC2_DRV  : 2;            /*!< PDAC2_DRV                                                                 */
            uint32_t            : 1;
    } bit;
  } PAD_DAC2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD19                                                       */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
            uint32_t            : 7;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } RTC_PAD19;
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC PAD20                                                       */
    
    struct {
            uint32_t            : 13;
      __IOM uint32_t FUN_IE     : 1;            /*!< input enable in work mode                                                 */
      __IOM uint32_t SLP_OE     : 1;            /*!< output enable in sleep mode                                               */
      __IOM uint32_t SLP_IE     : 1;            /*!< input enable in sleep mode                                                */
      __IOM uint32_t SLP_SEL    : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
      __IOM uint32_t FUN_SEL    : 2;            /*!< function sel                                                              */
      __IOM uint32_t MUX_SEL    : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
            uint32_t            : 7;
      __IOM uint32_t RUE        : 1;            /*!< RUE                                                                       */
      __IOM uint32_t RDE        : 1;            /*!< RDE                                                                       */
      __IOM uint32_t DRV        : 2;            /*!< DRV                                                                       */
            uint32_t            : 1;
    } bit;
  } RTC_PAD20;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< configure RTC GPIO11                                                      */
      
      struct {
              uint32_t          : 2;
        __IOM uint32_t PAD_DRIVER : 1;          /*!< if set to 0: normal output, if set to 1: open drain                       */
              uint32_t          : 4;
        __IOM uint32_t INT_TYPE : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< RTC GPIO wakeup enable bit                                                */
              uint32_t          : 21;
      } bit;
    } PIN11;
    
    union {
      __IOM uint32_t reg;                       /*!< configure RTC PAD21                                                       */
      
      struct {
              uint32_t          : 13;
        __IOM uint32_t FUN_IE   : 1;            /*!< input enable in work mode                                                 */
        __IOM uint32_t SLP_OE   : 1;            /*!< output enable in sleep mode                                               */
        __IOM uint32_t SLP_IE   : 1;            /*!< input enable in sleep mode                                                */
        __IOM uint32_t SLP_SEL  : 1;            /*!< 1: enable sleep mode during sleep,0: no sleep mode                        */
        __IOM uint32_t FUN_SEL  : 2;            /*!< function sel                                                              */
        __IOM uint32_t MUX_SEL  : 1;            /*!< 1: use RTC GPIO,0: use digital GPIO                                       */
              uint32_t          : 7;
        __IOM uint32_t RUE      : 1;            /*!< RUE                                                                       */
        __IOM uint32_t RDE      : 1;            /*!< RDE                                                                       */
        __IOM uint32_t DRV      : 2;            /*!< DRV                                                                       */
              uint32_t          : 1;
      } bit;
    } RTC_PAD21;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< configure EXT0 wakeup                                                     */
    
    struct {
            uint32_t            : 27;
      __IOM uint32_t SEL        : 5;            /*!< ******* Description configure***                                          */
    } bit;
  } EXT_WAKEUP0;
  
  union {
    __IOM uint32_t reg;                         /*!< configure gpio pd XTAL                                                    */
    
    struct {
            uint32_t            : 27;
      __IOM uint32_t SEL        : 5;            /*!< select RTC GPIO 0 ~ 17 to control XTAL                                    */
    } bit;
  } XTL_EXT_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< configure rtc i2c mux                                                     */
    
    struct {
            uint32_t            : 23;
      __IOM uint32_t SAR_DEBUG_BIT_SEL : 5;     /*!< ******* Description configure***                                          */
      __IOM uint32_t SAR_I2C_SCL_SEL : 2;       /*!< ******* Description configure***                                          */
      __IOM uint32_t SAR_I2C_SDA_SEL : 2;       /*!< ******* Description configure***                                          */
    } bit;
  } SAR_I2C_IO;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< configure RTC GPIO12                                                      */
      
      struct {
              uint32_t          : 2;
        __IOM uint32_t PAD_DRIVER : 1;          /*!< if set to 0: normal output, if set to 1: open drain                       */
              uint32_t          : 4;
        __IOM uint32_t INT_TYPE : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
        __IOM uint32_t WAKEUP_ENABLE : 1;       /*!< RTC GPIO wakeup enable bit                                                */
              uint32_t          : 21;
      } bit;
    } PIN12;
    
    union {
      __IOM uint32_t reg;                       /*!< configure touch pad bufmode                                               */
      
      struct {
        __IOM uint32_t IO_TOUCH_BUFSEL : 4;     /*!< BUF_SEL when touch work without fsm                                       */
        __IOM uint32_t IO_TOUCH_BUFMODE : 1;    /*!< BUF_MODE when touch work without fsm                                      */
              uint32_t          : 27;
      } bit;
    } TOUCH_CTRL;
  };
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO13                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN13;
  __IM  uint32_t  RESERVED7[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO14                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN14;
  __IM  uint32_t  RESERVED8[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO15                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN15;
  __IM  uint32_t  RESERVED9[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO16                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN16;
  __IM  uint32_t  RESERVED10[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO17                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN17;
  __IM  uint32_t  RESERVED11[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO18                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN18;
  __IM  uint32_t  RESERVED12[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO19                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN19;
  __IM  uint32_t  RESERVED13[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO20                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN20;
  __IM  uint32_t  RESERVED14[3];
  
  union {
    __IOM uint32_t reg;                         /*!< configure RTC GPIO21                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t PAD_DRIVER : 1;            /*!< if set to 0: normal output, if set to 1: open drain                       */
            uint32_t            : 4;
      __IOM uint32_t INT_TYPE   : 3;            /*!< if set to 0: GPIO interrupt disable, if set to 1: rising edge
                                                     trigger, if set to 2: falling edge trigger, if set to 3:
                                                     any edge trigger, if set to 4: low level trigger, if set
                                                     to 5: high level trigger                                                  */
      __IOM uint32_t WAKEUP_ENABLE : 1;         /*!< RTC GPIO wakeup enable bit                                                */
            uint32_t            : 21;
    } bit;
  } PIN21;
  __IM  uint32_t  RESERVED15[32];
  
  union {
    __IOM uint32_t reg;                         /*!< version                                                                   */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< version                                                                   */
            uint32_t            : 4;
    } bit;
  } DATE;
} RTC_IO_Type;                                  /*!< Size = 512 (0x200)                                                        */



/* =========================================================================================================================== */
/* ================                                          SDHOST                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief SD/MMC Host Controller (SDHOST)
  */

typedef struct {                                /*!< SDHOST Structure                                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< Control register                                                          */
    
    struct {
      __IOM uint32_t CONTROLLER_RESET : 1;      /*!< To reset controller, firmware should set this bit. This bit
                                                     is auto-cleared after two AHB and two sdhost_cclk_in clock
                                                     cycles.                                                                   */
      __IOM uint32_t FIFO_RESET : 1;            /*!< To reset FIFO, firmware should set bit to 1. This bit is auto-cleared
                                                     after completion of reset operation.Note: FIFO pointers
                                                     will be out of reset after 2 cycles of system clocks in
                                                     addition to synchronization delay (2 cycles of card clock),
                                                     after the fifo_reset is cleared.                                          */
      __IOM uint32_t DMA_RESET  : 1;            /*!< To reset DMA interface, firmware should set bit to 1. This bit
                                                     is auto-cleared after two AHB clocks.                                     */
            uint32_t            : 1;
      __IOM uint32_t INT_ENABLE : 1;            /*!< Global interrupt enable/disable bit. 0: Disable; 1: Enable.               */
            uint32_t            : 1;
      __IOM uint32_t READ_WAIT  : 1;            /*!< For sending read-wait to SDIO cards.                                      */
      __IOM uint32_t SEND_IRQ_RESPONSE : 1;     /*!< Bit automatically clears once response is sent. To wait for
                                                     MMC card interrupts, host issues CMD40 and waits for interrupt
                                                     response from MMC card(s). In the meantime, if host wants
                                                     SD/MMC to exit waiting for interrupt state, it can set
                                                     this bit, at which time SD/MMC command state-machine sends
                                                     CMD40 response on bus and returns to idle state.                          */
      __IOM uint32_t ABORT_READ_DATA : 1;       /*!< After a suspend-command is issued during a read-operation, software
                                                     polls the card to find when the suspend-event occurred.
                                                     Once the suspend-event has occurred, software sets the
                                                     bit which will reset the data state machine that is waiting
                                                     for the next block of data. This bit is automatically cleared
                                                     once the data state machine is reset to idle.                             */
      __IOM uint32_t SEND_CCSD  : 1;            /*!< When set, SD/MMC sends CCSD to the CE-ATA device. Software sets
                                                     this bit only if the current command is expecting CCS (that
                                                     is, RW_BLK), and if interrupts are enabled for the CE-ATA
                                                     device. Once the CCSD pattern is sent to the device, SD/MMC
                                                     automatically clears the SDHOST_SEND_CCSD bit. It also
                                                     sets the Command Done (CD) bit in the SDHOST_RINTSTS_REG
                                                     register, and generates an interrupt for the host, in case
                                                     the Command Done interrupt is not masked. NOTE: Once the
                                                     SDHOST_SEND_CCSD bit is set, it takes two card clock cycles
                                                     to drive the CCSD on the CMD line. Due to this, within
                                                     the boundary conditions the CCSD may be sent to the CE-ATA
                                                     device, even if the device has signalled CCS.                             */
      __IOM uint32_t SEND_AUTO_STOP_CCSD : 1;   /*!< Always Set SDHOST_SEND_AUTO_STOP_CCSD and SDHOST_SEND_CCSD bits
                                                     together; SDHOST_SEND_AUTO_STOP_CCSD should not be set
                                                     independently of send_ccsd. When set, SD/MMC automatically
                                                     sends an internally-generated STOP command (CMD12) to the
                                                     CE-ATA device. After sending this internally-generated
                                                     STOP command, the Auto Command Done (ACD) bit in SDHOST_RINTSTS_REG
                                                     is set and an interrupt is generated for the host, in case
                                                     the ACD interrupt is not masked. After sending the Command
                                                     Completion Signal Disable (CCSD), SD/MMC automatically
                                                     clears the SDHOST_SEND_AUTO_STOP_CCSD bit.                                */
      __IOM uint32_t CEATA_DEVICE_INTERRUPT_STATUS : 1;/*!< Software should appropriately write to this bit after the power-on
                                                     reset or any other reset to the CE-ATA device. After reset,
                                                     the CE-ATA device's interrupt is usually disabled (nIEN
                                                     = 1). If the host enables the CE-ATA device's interrupt,
                                                     then software should set this bit.                                        */
            uint32_t            : 20;
    } bit;
  } CTRL;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divider configuration register                                      */
    
    struct {
      __IOM uint32_t CLK_DIVIDER0 : 8;          /*!< Clock divider0 value. Clock divisor is 2*n, where n = 0 bypasses
                                                     the divider (divisor of 1). For example, a value of 1 means
                                                     divided by 2*1 = 2, a value of 0xFF means divided by 2*255
                                                     = 510, and so on.                                                         */
      __IOM uint32_t CLK_DIVIDER1 : 8;          /*!< Clock divider1 value. Clock divisor is 2*n, where n = 0 bypasses
                                                     the divider (divisor of 1). For example, a value of 1 means
                                                     divided by 2*1 = 2, a value of 0xFF means divided by 2*255
                                                     = 510, and so on.                                                         */
      __IOM uint32_t CLK_DIVIDER2 : 8;          /*!< Clock divider2 value. Clock divisor is 2*n, where n = 0 bypasses
                                                     the divider (divisor of 1). For example, a value of 1 means
                                                     divided by 2*1 = 2, a value of 0xFF means divided by 2*255
                                                     = 510, and so on.                                                         */
      __IOM uint32_t CLK_DIVIDER3 : 8;          /*!< Clock divider3 value. Clock divisor is 2*n, where n = 0 bypasses
                                                     the divider (divisor of 1). For example, a value of 1 means
                                                     divided by 2*1 = 2, a value of 0xFF means divided by 2*255
                                                     = 510, and so on.                                                         */
    } bit;
  } CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock source selection register                                           */
    
    struct {
      __IOM uint32_t CLKSRC     : 4;            /*!< Clock divider source for two SD cards is supported. Each card
                                                     has two bits assigned to it. For example, bit[1:0] are
                                                     assigned for card 0, bit[3:2] are assigned for card 1.
                                                     Card 0 maps and internally routes clock divider[0:3] outputs
                                                     to cclk_out[1:0] pins, depending on bit value.00 : Clock
                                                     divider 0;01 : Clock divider 1;10 : Clock divider 2;11
                                                     : Clock divider 3.                                                        */
            uint32_t            : 28;
    } bit;
  } CLKSRC;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock enable register                                                     */
    
    struct {
      __IOM uint32_t CCLK_ENABLE : 2;           /*!< Clock-enable control for two SD card clocks and one MMC card
                                                     clock is supported. One bit per card.0: Clock disabled;1:
                                                     Clock enabled.                                                            */
            uint32_t            : 14;
      __IOM uint32_t LP_ENABLE  : 2;            /*!< Disable clock when the card is in IDLE state. One bit per card.0:
                                                     clock disabled;1: clock enabled.                                          */
            uint32_t            : 14;
    } bit;
  } CLKENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Data and response timeout configuration register                          */
    
    struct {
      __IOM uint32_t RESPONSE_TIMEOUT : 8;      /*!< Response timeout value. Value is specified in terms of number
                                                     of card output clocks, i.e., sdhost_cclk_out.                             */
      __IOM uint32_t DATA_TIMEOUT : 24;         /*!< Value for card data read timeout. This value is also used for
                                                     data starvation by host timeout. The timeout counter is
                                                     started only after the card clock is stopped. This value
                                                     is specified in number of card output clocks, i.e. sdhost_cclk_out
                                                     of the selected card.NOTE: The software timer should be
                                                     used if the timeout value is in the order of 100 ms. In
                                                     this case, read data timeout interrupt needs to be disabled.              */
    } bit;
  } TMOUT;
  
  union {
    __IOM uint32_t reg;                         /*!< Card bus width configuration register                                     */
    
    struct {
      __IOM uint32_t CARD_WIDTH4 : 2;           /*!< One bit per card indicates if card is 1-bit or 4-bit mode.0:
                                                     1-bit mode;1: 4-bit mode.Bit[1:0] correspond to card[1:0]
                                                     respectively.                                                             */
            uint32_t            : 14;
      __IOM uint32_t CARD_WIDTH8 : 2;           /*!< One bit per card indicates if card is in 8-bit mode.0: Non 8-bit
                                                     mode;1: 8-bit mode.Bit[17:16] correspond to card[1:0] respectively.       */
            uint32_t            : 14;
    } bit;
  } CTYPE;
  
  union {
    __IOM uint32_t reg;                         /*!< Card data block size configuration register                               */
    
    struct {
      __IOM uint32_t BLOCK_SIZE : 16;           /*!< Block size.                                                               */
            uint32_t            : 16;
    } bit;
  } BLKSIZ;
  
  union {
    __IOM uint32_t reg;                         /*!< Data transfer length configuration register                               */
    
    struct {
      __IOM uint32_t BYTE_COUNT : 32;           /*!< Number of bytes to be transferred, should be an integral multiple
                                                     of Block Size for block transfers. For data transfers of
                                                     undefined byte lengths, byte count should be set to 0.
                                                     When byte count is set to 0, it is the responsibility of
                                                     host to explicitly send stop/abort command to terminate
                                                     data transfer.                                                            */
    } bit;
  } BYTCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< SDIO interrupt mask register                                              */
    
    struct {
      __IOM uint32_t INT_MASK   : 16;           /*!< These bits used to mask unwanted interrupts. A value of 0 masks
                                                     interrupt, and a value of 1 enables the interrupt.Bit 15
                                                     (EBE): End-bit error/no CRC error;Bit 14 (ACD): Auto command
                                                     done;Bit 13 (SBE/BCI): Rx Start Bit Error;Bit 12 (HLE):
                                                     Hardware locked write error;Bit 11 (FRUN): FIFO underrun/overrun
                                                     error;Bit 10 (HTO): Data starvation-by-host timeout;Bit
                                                     9 (DRTO): Data read timeout;Bit 8 (RTO): Response timeout;
                                                     Bit 7 (DCRC): Data CRC error; Bit 6 (RCRC): Response CRC
                                                     error; Bit 5 (RXDR): Receive FIFO data request; Bit 4 (TXDR):
                                                     Transmit FIFO data request; Bit 3 (DTO): Data transfer
                                                     over; Bit 2 (CD): Command done; Bit 1 (RE): Response error;Bit
                                                     0 (CD): Card detect.                                                      */
      __IOM uint32_t SDIO_INT_MASK : 2;         /*!< SDIO interrupt mask, one bit for each card. Bit[17:16] correspond
                                                     to card[15:0] respectively. When masked, SDIO interrupt
                                                     detection for that card is disabled. 0 masks an interrupt,
                                                     and 1 enables an interrupt.                                               */
            uint32_t            : 14;
    } bit;
  } INTMASK;
  
  union {
    __IOM uint32_t reg;                         /*!< Command argument data register                                            */
    
    struct {
      __IOM uint32_t CMDARG     : 32;           /*!< Value indicates command argument to be passed to the card.                */
    } bit;
  } CMDARG;
  
  union {
    __IOM uint32_t reg;                         /*!< Command and boot configuration register                                   */
    
    struct {
      __IOM uint32_t INDEX      : 6;            /*!< Command index.                                                            */
      __IOM uint32_t RESPONSE_EXPECT : 1;       /*!< 0: No response expected from card; 1: Response expected from
                                                     card.                                                                     */
      __IOM uint32_t RESPONSE_LENGTH : 1;       /*!< 0: Short response expected from card; 1: Long response expected
                                                     from card.                                                                */
      __IOM uint32_t CHECK_RESPONSE_CRC : 1;    /*!< 0: Do not check; 1: Check response CRC.Some of command responses
                                                     do not return valid CRC bits. Software should disable CRC
                                                     checks for those commands in order to disable CRC checking
                                                     by controller.                                                            */
      __IOM uint32_t DATA_EXPECTED : 1;         /*!< 0: No data transfer expected; 1: Data transfer expected.                  */
      __IOM uint32_t READ_WRITE : 1;            /*!< 0: Read from card; 1: Write to card.Don't care if no data is
                                                     expected from card.                                                       */
      __IOM uint32_t TRANSFER_MODE : 1;         /*!< 0: Block data transfer command; 1: Stream data transfer command.Don't
                                                     care if no data expected.                                                 */
      __IOM uint32_t SEND_AUTO_STOP : 1;        /*!< 0: No stop command is sent at the end of data transfer; 1: Send
                                                     stop command at the end of data transfer.                                 */
      __IOM uint32_t WAIT_PRVDATA_COMPLETE : 1; /*!< 0: Send command at once, even if previous data transfer has
                                                     not completed; 1: Wait for previous data transfer to complete
                                                     before sending Command.The SDHOST_WAIT_PRVDATA_COMPLETE]
                                                     = 0 option is typically used to query status of card during
                                                     data transfer or to stop current data transfer. SDHOST_CARD_NUMBERr
                                                     should be same as in previous command.                                    */
      __IOM uint32_t STOP_ABORT_CMD : 1;        /*!< 0: Neither stop nor abort command can stop current data transfer.
                                                     If abort is sent to function-number currently selected
                                                     or not in data-transfer mode, then bit should be set to
                                                     0; 1: Stop or abort command intended to stop current data
                                                     transfer in progress.When open-ended or predefined data
                                                     transfer is in progress, and host issues stop or abort
                                                     command to stop data transfer, bit should be set so that
                                                     command/data state-machines of CIU can return correctly
                                                     to idle state.                                                            */
      __IOM uint32_t SEND_INITIALIZATION : 1;   /*!< 0: Do not send initialization sequence (80 clocks of 1) before
                                                     sending this command; 1: Send initialization sequence before
                                                     sending this command.After powered on, 80 clocks must be
                                                     sent to card for initialization before sending any commands
                                                     to card. Bit should be set while sending first command
                                                     to card so that controller will initialize clocks before
                                                     sending command to card.                                                  */
      __IOM uint32_t CARD_NUMBER : 5;           /*!< Card number in use. Represents physical slot number of card
                                                     being accessed. In SD-only mode, up to two cards are supported.           */
      __IOM uint32_t UPDATE_CLOCK_REGISTERS_ONLY : 1;/*!< 0: Normal command sequence; 1: Do not send commands, just update
                                                     clock register value into card clock domain.Following register
                                                     values are transferred into card clock domain: CLKDIV,
                                                     CLRSRC, and CLKENA.Changes card clocks (change frequency,
                                                     truncate off or on, and set low-frequency mode). This is
                                                     provided in order to change clock frequency or stop clock
                                                     without having to send command to cards. During normal
                                                     command sequence, when sdhost_update_clock_registers_only
                                                     = 0, following control registers are transferred from BIU
                                                     to CIU: CMD, CMDARG, TMOUT, CTYPE, BLKSIZ, and BYTCNT.
                                                     CIU uses new register values for new command sequence to
                                                     card(s). When bit is set, there are no Command Done interrupts
                                                     because no command is sent to SD_MMC_CEATA cards.                         */
      __IOM uint32_t READ_CEATA_DEVICE : 1;     /*!< Read access flag.0: Host is not performing read access (RW_REG
                                                     or RW_BLK)towards CE-ATA device;1: Host is performing read
                                                     access (RW_REG or RW_BLK) towards CE-ATA device.Software
                                                     should set this bit to indicate that CE-ATA device is being
                                                     accessed for read transfer. This bit is used to disable
                                                     read data timeout indication while performing CE-ATA read
                                                     transfers. Maximum value of I/O transmission delay can
                                                     be no less than 10 seconds. SD/MMC should not indicate
                                                     read data timeout while waiting for data from CE-ATA device.              */
      __IOM uint32_t CCS_EXPECTED : 1;          /*!< Expected Command Completion Signal (CCS) configuration.0: Interrupts
                                                     are not enabled in CE-ATA device (nIEN = 1 in ATA control
                                                     register), or command does not expect CCS from device;1:
                                                     Interrupts are enabled in CE-ATA device (nIEN = 0), and
                                                     RW_BLK command expects command completion signal from CE-ATA
                                                     device. If the command expects Command Completion Signal
                                                     (CCS) from the CE-ATA device, the software should set this
                                                     control bit. SD/MMC sets Data Transfer Over (DTO) bit in
                                                     RINTSTS register and generates interrupt to host if Data
                                                     Transfer Over interrupt is not masked.                                    */
            uint32_t            : 5;
      __IOM uint32_t USE_HOLE   : 1;            /*!< Use Hold Register.0: CMD and DATA sent to card bypassing HOLD
                                                     Register;1: CMD and DATA sent to card through the HOLD
                                                     Register.                                                                 */
            uint32_t            : 1;
      __IOM uint32_t START_CMD  : 1;            /*!< Start command. Once command is served by the CIU, this bit is
                                                     automatically cleared. When this bit is set, host should
                                                     not attempt to write to any command registers. If a write
                                                     is attempted, hardware lock error is set in raw interrupt
                                                     register. Once command is sent and a response is received
                                                     from SD_MMC_CEATA cards, Command Done bit is set in the
                                                     raw interrupt Register.                                                   */
    } bit;
  } CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< Response data register                                                    */
    
    struct {
      __IM  uint32_t RESPONSE0  : 32;           /*!< Bit[31:0] of response.                                                    */
    } bit;
  } RESP0;
  
  union {
    __IOM uint32_t reg;                         /*!< Long response data register                                               */
    
    struct {
      __IM  uint32_t RESPONSE1  : 32;           /*!< Bit[63:32] of long response.                                              */
    } bit;
  } RESP1;
  
  union {
    __IOM uint32_t reg;                         /*!< Long response data register                                               */
    
    struct {
      __IM  uint32_t RESPONSE2  : 32;           /*!< Bit[95:64] of long response.                                              */
    } bit;
  } RESP2;
  
  union {
    __IOM uint32_t reg;                         /*!< Long response data register                                               */
    
    struct {
      __IM  uint32_t RESPONSE3  : 32;           /*!< Bit[127:96] of long response.                                             */
    } bit;
  } RESP3;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt status register                                          */
    
    struct {
      __IM  uint32_t INT_STATUS_MSK : 16;       /*!< Interrupt enabled only if corresponding bit in interrupt mask
                                                     register is set.Bit 15 (EBE): End-bit error/no CRC error;Bit
                                                     14 (ACD): Auto command done;Bit 13 (SBE/BCI): RX Start
                                                     Bit Error;Bit 12 (HLE): Hardware locked write error; Bit
                                                     11 (FRUN): FIFO underrun/overrun error;Bit 10 (HTO): Data
                                                     starvation by host timeout (HTO);Bit 9 (DTRO): Data read
                                                     timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data
                                                     CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR):
                                                     Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO
                                                     data request;Bit 3 (DTO): Data transfer over; Bit 2 (CD):
                                                     Command done; Bit 1 (RE): Response error;Bit 0 (CD): Card
                                                     detect.                                                                   */
      __IM  uint32_t SDIO_INTERRUPT_MSK : 2;    /*!< Interrupt from SDIO card, one bit for each card. Bit[17:16]
                                                     correspond to card1 and card0, respectively. SDIO interrupt
                                                     for card is enabled only if corresponding sdhost_sdio_int_mask
                                                     bit is set in Interrupt mask register (Setting mask bit
                                                     enables interrupt).                                                       */
            uint32_t            : 14;
    } bit;
  } MINTSTS;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw interrupt status register                                             */
    
    struct {
      __IOM uint32_t INT_STATUS_RAW : 16;       /*!< Setting a bit clears the corresponding interrupt and writing
                                                     0 has no effect. Bits are logged regardless of interrupt
                                                     mask status.Bit 15 (EBE): End-bit error/no CRC error;Bit
                                                     14 (ACD): Auto command done;Bit 13 (SBE/BCI): RX Start
                                                     Bit Error;Bit 12 (HLE): Hardware locked write error; Bit
                                                     11 (FRUN): FIFO underrun/overrun error;Bit 10 (HTO): Data
                                                     starvation by host timeout (HTO);Bit 9 (DTRO): Data read
                                                     timeout; Bit 8 (RTO): Response timeout; Bit 7 (DCRC): Data
                                                     CRC error; Bit 6 (RCRC): Response CRC error; Bit 5 (RXDR):
                                                     Receive FIFO data request; Bit 4 (TXDR): Transmit FIFO
                                                     data request;Bit 3 (DTO): Data transfer over; Bit 2 (CD):
                                                     Command done; Bit 1 (RE): Response error;Bit 0 (CD): Card
                                                     detect.                                                                   */
      __IOM uint32_t SDIO_INTERRUPT_RAW : 2;    /*!< Interrupt from SDIO card, one bit for each card. Bit[17:16]
                                                     correspond to card1 and card0, respectively. Setting a
                                                     bit clears the corresponding interrupt bit and writing
                                                     0 has no effect.0: No SDIO interrupt from card;1: SDIO
                                                     interrupt from card.                                                      */
            uint32_t            : 14;
    } bit;
  } RINTSTS;
  
  union {
    __IOM uint32_t reg;                         /*!< SD/MMC status register                                                    */
    
    struct {
      __IM  uint32_t FIFO_RX_WATERMARK : 1;     /*!< FIFO reached Receive watermark level, not qualified with data
                                                     transfer.                                                                 */
      __IM  uint32_t FIFO_TX_WATERMARK : 1;     /*!< FIFO reached Transmit watermark level, not qualified with data
                                                     transfer.                                                                 */
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< FIFO is empty status.                                                     */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< FIFO is full status.                                                      */
      __IM  uint32_t COMMAND_FSM_STATES : 4;    /*!< Command FSM states.0: Idle;1: Send init sequence; 2: Send cmd
                                                     start bit; 3: Send cmd tx bit;4: Send cmd index + arg;5:
                                                     Send cmd crc7;6: Send cmd end bit;7: Receive resp start
                                                     bit;8: Receive resp IRQ response;9: Receive resp tx bit;10:
                                                     Receive resp cmd idx;11: Receive resp data;12: Receive
                                                     resp crc7;13: Receive resp end bit;14: Cmd path wait NCC;15:
                                                     Wait, cmd-to-response turnaround.                                         */
      __IM  uint32_t DATA_3_STATUS : 1;         /*!< Raw selected sdhost_card_data[3], checks whether card is present.0:
                                                     card not present;1: card present.                                         */
      __IM  uint32_t DATA_BUSY  : 1;            /*!< Inverted version of raw selected sdhost_card_data[0].0: Card
                                                     data not busy;1: Card data busy.                                          */
      __IM  uint32_t DATA_STATE_MC_BUSY : 1;    /*!< Data transmit or receive state-machine is busy.                           */
      __IM  uint32_t RESPONSE_INDEX : 6;        /*!< Index of previous response, including any auto-stop sent by
                                                     core.                                                                     */
      __IM  uint32_t FIFO_COUNT : 13;           /*!< FIFO count, number of filled locations in FIFO.                           */
            uint32_t            : 2;
    } bit;
  } STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO configuration register                                               */
    
    struct {
      __IOM uint32_t TX_WMARK   : 12;           /*!< FIFO threshold watermark level when transmitting data to card.
                                                     When FIFO data count is less than or equal to this number,
                                                     DMA/FIFO request is raised. If Interrupt is enabled, then
                                                     interrupt occurs. During end of packet, request or interrupt
                                                     is generated, regardless of threshold programming.In non-DMA
                                                     mode, when transmit FIFO threshold (TXDR) interrupt is
                                                     enabled, then interrupt is generated instead of DMA request.
                                                     During end of packet, on last interrupt, host is responsible
                                                     for filling FIFO with only required remaining bytes (not
                                                     before FIFO is full or after CIU completes data transfers,
                                                     because FIFO may not be empty). In DMA mode, at end of
                                                     packet, if last transfer is less than burst size, DMA controller
                                                     does single cycles until required bytes are transferred.                  */
            uint32_t            : 4;
      __IOM uint32_t RX_WMARK   : 11;           /*!< FIFO threshold watermark level when receiving data to card.When
                                                     FIFO data count reaches greater than this number , DMA/FIFO
                                                     request is raised. During end of packet, request is generated
                                                     regardless of threshold programming in order to complete
                                                     any remaining data.In non-DMA mode, when receiver FIFO
                                                     threshold (RXDR) interrupt is enabled, then interrupt is
                                                     generated instead of DMA request.During end of packet,
                                                     interrupt is not generated if threshold programming is
                                                     larger than any remaining data. It is responsibility of
                                                     host to read remaining bytes on seeing Data Transfer Done
                                                     interrupt.In DMA mode, at end of packet, even if remaining
                                                     bytes are less than threshold, DMA request does single
                                                     transfers to flush out any remaining bytes before Data
                                                     Transfer Done interrupt is set.                                           */
            uint32_t            : 1;
      __IOM uint32_t DMA_MULTIPLE_TRANSACTION_SIZE : 3;/*!< Burst size of multiple transaction, should be programmed same
                                                     as DMA controller multiple-transaction-size SDHOST_SRC/DEST_MSIZE.000:
                                                     1-byte transfer; 001: 4-byte transfer; 010: 8-byte transfer;
                                                     011: 16-byte transfer; 100: 32-byte transfer; 101: 64-byte
                                                     transfer; 110: 128-byte transfer; 111: 256-byte transfer.                 */
            uint32_t            : 1;
    } bit;
  } FIFOTH;
  
  union {
    __IOM uint32_t reg;                         /*!< Card detect register                                                      */
    
    struct {
      __IM  uint32_t CARD_DETECT_N : 2;         /*!< Value on sdhost_card_detect_n input ports (1 bit per card),
                                                     read-only bits. 0 represents presence of card. Only NUM_CARDS
                                                     number of bits are implemented.                                           */
            uint32_t            : 30;
    } bit;
  } CDETECT;
  
  union {
    __IOM uint32_t reg;                         /*!< Card write protection (WP) status register                                */
    
    struct {
      __IM  uint32_t WRITE_PROTECT : 2;         /*!< Value on sdhost_card_write_prt input ports (1 bit per card).
                                                     1 represents write protection. Only NUM_CARDS number of
                                                     bits are implemented.                                                     */
            uint32_t            : 30;
    } bit;
  } WRTPRT;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< Transferred byte count register                                           */
    
    struct {
      __IM  uint32_t TCBCNT     : 32;           /*!< Number of bytes transferred by CIU unit to card.                          */
    } bit;
  } TCBCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Transferred byte count register                                           */
    
    struct {
      __IM  uint32_t TBBCNT     : 32;           /*!< Number of bytes transferred between Host/DMA memory and BIU
                                                     FIFO.                                                                     */
    } bit;
  } TBBCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Debounce filter time configuration register                               */
    
    struct {
      __IOM uint32_t DEBOUNCE_COUNT : 24;       /*!< Number of host clocks (clk) used by debounce filter logic. The
                                                     typical debounce time is 5 \verb+~+ 25 ms to prevent the
                                                     card instability when the card is inserted or removed.                    */
            uint32_t            : 8;
    } bit;
  } DEBNCE;
  
  union {
    __IOM uint32_t reg;                         /*!< User ID (scratchpad) register                                             */
    
    struct {
      __IOM uint32_t USRID      : 32;           /*!< User identification register, value set by user. Can also be
                                                     used as a scratchpad register by user.                                    */
    } bit;
  } USRID;
  
  union {
    __IOM uint32_t reg;                         /*!< Version ID (scratchpad) register                                          */
    
    struct {
      __IM  uint32_t VERSIONID  : 32;           /*!< Hardware version register. Can also be read by fireware.                  */
    } bit;
  } VERID;
  
  union {
    __IOM uint32_t reg;                         /*!< Hardware feature register                                                 */
    
    struct {
      __IM  uint32_t CARD_TYPE  : 1;            /*!< Hardware support SDIO and MMC.                                            */
      __IM  uint32_t CARD_NUM   : 5;            /*!< Support card number is 2.                                                 */
      __IM  uint32_t BUS_TYPE   : 1;            /*!< Register config is APB bus.                                               */
      __IM  uint32_t DATA_WIDTH : 3;            /*!< Regisger data widht is 32.                                                */
      __IM  uint32_t ADDR_WIDTH : 6;            /*!< Register address width is 32.                                             */
            uint32_t            : 2;
      __IM  uint32_t DMA_WIDTH  : 3;            /*!< DMA data witdth is 32.                                                    */
      __IM  uint32_t RAM_INDISE : 1;            /*!< Inside RAM in SDMMC module.                                               */
      __IM  uint32_t HOLD       : 1;            /*!< Have a hold regiser in data path .                                        */
            uint32_t            : 1;
      __IM  uint32_t NUM_CLK_DIV : 2;           /*!< Have 4 clk divider in design .                                            */
            uint32_t            : 6;
    } bit;
  } HCON;
  
  union {
    __IOM uint32_t reg;                         /*!< UHS-1 register                                                            */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t DDR        : 2;            /*!< DDR mode selecton,1 bit for each card.0-Non-DDR mdoe.1-DDR mdoe.          */
            uint32_t            : 14;
    } bit;
  } UHS;
  
  union {
    __IOM uint32_t reg;                         /*!< Card reset register                                                       */
    
    struct {
      __IOM uint32_t CARD_RESET : 2;            /*!< Hardware reset.1: Active mode; 0: Reset. These bits cause the
                                                     cards to enter pre-idle state, which requires them to be
                                                     re-initialized. SDHOST_RST_CARD_RESET[0] should be set
                                                     to 1'b0 to reset card0, SDHOST_RST_CARD_RESET[1] should
                                                     be set to 1'b0 to reset card1.                                            */
            uint32_t            : 30;
    } bit;
  } RST_N;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< Burst mode transfer configuration register                                */
    
    struct {
      __IOM uint32_t SWR        : 1;            /*!< Software Reset. When set, the DMA Controller resets all its
                                                     internal registers. It is automatically cleared after one
                                                     clock cycle.                                                              */
      __IOM uint32_t FB         : 1;            /*!< Fixed Burst. Controls whether the AHB Master interface performs
                                                     fixed burst transfers or not. When set, the AHB will use
                                                     only SINGLE, INCR4, INCR8 or INCR16 during start of normal
                                                     burst transfers. When reset, the AHB will use SINGLE and
                                                     INCR burst transfer operations.                                           */
            uint32_t            : 5;
      __IOM uint32_t DE         : 1;            /*!< IDMAC Enable. When set, the IDMAC is enabled.                             */
      __IOM uint32_t PBL        : 3;            /*!< Programmable Burst Length. These bits indicate the maximum number
                                                     of beats to be performed in one IDMAC???Internal DMA Control???transactio
                                                     . The IDMAC will always attempt to burst as specified in
                                                     PBL each time it starts a burst transfer on the host bus.
                                                     The permissible values are 1, 4, 8, 16, 32, 64, 128 and
                                                     256. This value is the mirror of MSIZE of FIFOTH register.
                                                     In order to change this value, write the required value
                                                     to FIFOTH register. This is an encode value as follows:000:
                                                     1-byte transfer; 001: 4-byte transfer; 010: 8-byte transfer;
                                                     011: 16-byte transfer; 100: 32-byte transfer; 101: 64-byte
                                                     transfer; 110: 128-byte transfer; 111: 256-byte transfer.PBL
                                                     is a read-only value and is applicable only for data access,
                                                     it does not apply to descriptor access.                                   */
            uint32_t            : 21;
    } bit;
  } BMOD;
  
  union {
    __IOM uint32_t reg;                         /*!< Poll demand configuration register                                        */
    
    struct {
      __OM  uint32_t PD         : 32;           /*!< Poll Demand. If the OWNER bit of a descriptor is not set, the
                                                     FSM goes to the Suspend state. The host needs to write
                                                     any value into this register for the IDMAC FSM to resume
                                                     normal descriptor fetch operation. This is a write only
                                                     .                                                                         */
    } bit;
  } PLDMND;
  
  union {
    __IOM uint32_t reg;                         /*!< Descriptor base address register                                          */
    
    struct {
      __IOM uint32_t DBADDR     : 32;           /*!< Start of Descriptor List. Contains the base address of the First
                                                     Descriptor. The LSB bits [1:0] are ignored and taken as
                                                     all-zero by the IDMAC internally. Hence these LSB bits
                                                     may be treated as read-only.                                              */
    } bit;
  } DBADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< IDMAC status register                                                     */
    
    struct {
      __IOM uint32_t TI         : 1;            /*!< Transmit Interrupt. Indicates that data transmission is finished
                                                     for a descriptor. Writing 1 clears this bit.                              */
      __IOM uint32_t RI         : 1;            /*!< Receive Interrupt. Indicates the completion of data reception
                                                     for a descriptor. Writing 1 clears this bit.                              */
      __IOM uint32_t FBE        : 1;            /*!< Fatal Bus Error Interrupt. Indicates that a Bus Error occurred
                                                     (IDSTS[12:10]) . When this bit is set, the DMA disables
                                                     all its bus accesses. Writing 1 clears this bit.                          */
            uint32_t            : 1;
      __IOM uint32_t DU         : 1;            /*!< Descriptor Unavailable Interrupt. This bit is set when the descriptor
                                                     is unavailable due to OWNER bit = 0 (DES0[31] = 0). Writing
                                                     1 clears this bit.                                                        */
      __IOM uint32_t CES        : 1;            /*!< Card Error Summary. Indicates the status of the transaction
                                                     to/from the card, also present in RINTSTS. Indicates the
                                                     logical OR of the following bits:EBE : End Bit Error; RTO
                                                     : Response Timeout/Boot Ack Timeout; RCRC : Response CRC;
                                                     SBE : Start Bit Error; DRTO : Data Read Timeout/BDS timeout;
                                                     DCRC : Data CRC for Receive; RE : Response Error.Writing
                                                     1 clears this bit. The abort condition of the IDMAC depends
                                                     on the setting of this CES bit. If the CES bit is enabled,
                                                     then the IDMAC aborts on a response error.                                */
            uint32_t            : 2;
      __IOM uint32_t NIS        : 1;            /*!< Normal Interrupt Summary. Logical OR of the following: IDSTS[0]
                                                     : Transmit Interrupt, IDSTS[1] : Receive Interrupt. Only
                                                     unmasked bits affect this bit. This is a sticky bit and
                                                     must be cleared each time a corresponding bit that causes
                                                     NIS to be set is cleared. Writing 1 clears this bit.                      */
      __IOM uint32_t AIS        : 1;            /*!< Abnormal Interrupt Summary. Logical OR of the following: IDSTS[2]
                                                     : Fatal Bus Interrupt, IDSTS[4] : DU bit Interrupt. Only
                                                     unmasked bits affect this bit. This is a sticky bit and
                                                     must be cleared each time a corresponding bit that causes
                                                     AIS to be set is cleared. Writing 1 clears this bit.                      */
      __IOM uint32_t FBE_CODE   : 3;            /*!< Fatal Bus Error Code. Indicates the type of error that caused
                                                     a Bus Error. Valid only when the Fatal Bus Error bit IDSTS[2]
                                                     is set. This field does not generate an interrupt.001:
                                                     Host Abort received during transmission;010: Host Abort
                                                     received during reception;Others: Reserved.                               */
      __IOM uint32_t FSM        : 4;            /*!< DMAC FSM present state.0: DMA_IDLE (idle state); 1: DMA_SUSPEND
                                                     (suspend state); 2: DESC_RD (descriptor reading state);
                                                     3: DESC_CHK (descriptor checking state); 4: DMA_RD_REQ_WAIT
                                                     (read-data request waiting state);5: DMA_WR_REQ_WAIT (write-data
                                                     request waiting state); 6: DMA_RD (data-read state); 7:
                                                     DMA_WR (data-write state); 8: DESC_CLOSE (descriptor close
                                                     state).                                                                   */
            uint32_t            : 15;
    } bit;
  } IDSTS;
  
  union {
    __IOM uint32_t reg;                         /*!< IDMAC interrupt enable register                                           */
    
    struct {
      __IOM uint32_t TI         : 1;            /*!< Transmit Interrupt Enable. When set with Normal Interrupt Summary
                                                     Enable, Transmit Interrupt is enabled. When reset, Transmit
                                                     Interrupt is disabled.                                                    */
      __IOM uint32_t RI         : 1;            /*!< Receive Interrupt Enable. When set with Normal Interrupt Summary
                                                     Enable, Receive Interrupt is enabled. When reset, Receive
                                                     Interrupt is disabled.                                                    */
      __IOM uint32_t FBE        : 1;            /*!< Fatal Bus Error Enable. When set with Abnormal Interrupt Summary
                                                     Enable, the Fatal Bus Error Interrupt is enabled. When
                                                     reset, Fatal Bus Error Enable Interrupt is disabled.                      */
            uint32_t            : 1;
      __IOM uint32_t DU         : 1;            /*!< Descriptor Unavailable Interrupt. When set along with Abnormal
                                                     Interrupt Summary Enable, the DU interrupt is enabled.                    */
      __IOM uint32_t CES        : 1;            /*!< Card Error summary Interrupt Enable. When set, it enables the
                                                     Card Interrupt summary.                                                   */
            uint32_t            : 2;
      __IOM uint32_t NI         : 1;            /*!< Normal Interrupt Summary Enable. When set, a normal interrupt
                                                     is enabled. When reset, a normal interrupt is disabled.
                                                     This bit enables the following bits:IDINTEN[0]: Transmit
                                                     Interrupt;IDINTEN[1]: Receive Interrupt.                                  */
      __IOM uint32_t AI         : 1;            /*!< Abnormal Interrupt Summary Enable. When set, an abnormal interrupt
                                                     is enabled. This bit enables the following bits:IDINTEN[2]:
                                                     Fatal Bus Error Interrupt;IDINTEN[4]: DU Interrupt.                       */
            uint32_t            : 22;
    } bit;
  } IDINTEN;
  
  union {
    __IOM uint32_t reg;                         /*!< Host descriptor address pointer                                           */
    
    struct {
      __IM  uint32_t DSCADDR    : 32;           /*!< Host Descriptor Address Pointer, updated by IDMAC during operation
                                                     and cleared on reset. This register points to the start
                                                     address of the current descriptor read by the IDMAC.                      */
    } bit;
  } DSCADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Host buffer address pointer register                                      */
    
    struct {
      __IM  uint32_t BUFADDR    : 32;           /*!< Host Buffer Address Pointer, updated by IDMAC during operation
                                                     and cleared on reset. This register points to the current
                                                     Data Buffer Address being accessed by the IDMAC.                          */
    } bit;
  } BUFADDR;
  __IM  uint32_t  RESERVED3[25];
  
  union {
    __IOM uint32_t reg;                         /*!< Card Threshold Control register                                           */
    
    struct {
      __IOM uint32_t CARDRDTHREN : 1;           /*!< Card read threshold enable.1'b0-Card read threshold disabled.1'b1-Card
                                                     read threshold enabled.                                                   */
      __IOM uint32_t CARDCLRINTEN : 1;          /*!< Busy clear interrupt generation:1'b0-Busy clear interrypt disabled.1'b1-Busy
                                                     clear interrypt enabled.                                                  */
      __IOM uint32_t CARDWRTHREN : 1;           /*!< Applicable when HS400 mode is enabled.1'b0-Card write Threshold
                                                     disabled.1'b1-Card write Threshold enabled.                               */
            uint32_t            : 13;
      __IOM uint32_t CARDTHRESHOLD : 16;        /*!< The inside FIFO size is 512,This register is applicable when
                                                     SDHOST_CARDERTHREN_REG is set to 1 or SDHOST_CARDRDTHREN_REG
                                                     set to 1.                                                                 */
    } bit;
  } CARDTHRCTL;
  __IM  uint32_t  RESERVED4[2];
  
  union {
    __IOM uint32_t reg;                         /*!< eMMC DDR register                                                         */
    
    struct {
      __IOM uint32_t HALFSTARTBIT : 2;          /*!< Control for start bit detection mechanism duration of start
                                                     bit.Each bit refers to one slot.Set this bit to 1 for eMMC4.5
                                                     and above,set to 0 for SD applications.For eMMC4.5,start
                                                     bit can be:1'b0-Full cycle.1'b1-less than one full cycle.                 */
            uint32_t            : 29;
      __IOM uint32_t HS400_MODE : 1;            /*!< Set 1 to enable HS400 mode.                                               */
    } bit;
  } EMMCDDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Enable Phase Shift register                                               */
    
    struct {
      __IOM uint32_t ENABLE_SHIFT : 4;          /*!< Control for the amount of phase shift provided on the default
                                                     enables in the design.Two bits assigned for each card.2'b00-Default
                                                     phase shift.2'b01-Enables shifted to next immediate positive
                                                     edge.2'b10-Enables shifted to next immediate negative edge.2'b11-Reserved
                                                                                                                               */
            uint32_t            : 28;
    } bit;
  } ENSHIFT;
  __IM  uint32_t  RESERVED5[59];
  
  union {
    __IOM uint32_t reg;                         /*!< CPU write and read transmit data by FIFO                                  */
    
    struct {
      __IOM uint32_t BUFFIFO    : 32;           /*!< CPU write and read transmit data by FIFO. This register points
                                                     to the current Data FIFO .                                                */
    } bit;
  } BUFFIFO;
  __IM  uint32_t  RESERVED6[383];
  
  union {
    __IOM uint32_t reg;                         /*!< SDIO control register.                                                    */
    
    struct {
      __IOM uint32_t CCLKIN_EDGE_DRV_SEL : 3;   /*!< It's used to select the clock phase of the output signal from
                                                     phase 0, phase 90, phase 180, phase 270.                                  */
      __IOM uint32_t CCLKIN_EDGE_SAM_SEL : 3;   /*!< It's used to select the clock phase of the input signal from
                                                     phase 0, phase 90, phase 180, phase 270.                                  */
      __IOM uint32_t CCLKIN_EDGE_SLF_SEL : 3;   /*!< It's used to select the clock phase of the internal signal from
                                                     phase 0, phase 90, phase 180, phase 270.                                  */
      __IOM uint32_t CCLLKIN_EDGE_H : 4;        /*!< The high level of the divider clock. The value should be smaller
                                                     than CCLKIN_EDGE_L.                                                       */
      __IOM uint32_t CCLLKIN_EDGE_L : 4;        /*!< The low level of the divider clock. The value should be larger
                                                     than CCLKIN_EDGE_H.                                                       */
      __IOM uint32_t CCLLKIN_EDGE_N : 4;        /*!< The clock division of cclk_in.                                            */
      __IOM uint32_t ESDIO_MODE : 1;            /*!< Enable esdio mode.                                                        */
      __IOM uint32_t ESD_MODE   : 1;            /*!< Enable esd mode.                                                          */
      __IOM uint32_t CCLK_EN    : 1;            /*!< Sdio clock enable.                                                        */
            uint32_t            : 8;
    } bit;
  } CLK_EDGE_SEL;
} SDHOST_Type;                                  /*!< Size = 2052 (0x804)                                                       */



/* =========================================================================================================================== */
/* ================                                           SENS                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SENS Peripheral (SENS)
  */

typedef struct {                                /*!< SENS Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc1 reader                                                  */
    
    struct {
      __IOM uint32_t SAR_SAR1_CLK_DIV : 8;      /*!< clock divider                                                             */
            uint32_t            : 10;
      __IOM uint32_t SAR_SAR1_CLK_GATED : 1;    /*!< no public                                                                 */
      __IOM uint32_t SAR_SAR1_SAMPLE_NUM : 8;   /*!< no public                                                                 */
            uint32_t            : 1;
      __IOM uint32_t SAR_SAR1_DATA_INV : 1;     /*!< Invert SAR ADC1 data                                                      */
      __IOM uint32_t SAR_SAR1_INT_EN : 1;       /*!< enable saradc1 to send out interrupt                                      */
            uint32_t            : 2;
    } bit;
  } SAR_READER1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< get saradc1 reader controller status                                      */
    
    struct {
      __IM  uint32_t SAR_SAR1_READER_STATUS : 32;/*!< get saradc1 reader controller status                                     */
    } bit;
  } SAR_READER1_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< no public                                                                 */
    
    struct {
            uint32_t            : 24;
      __IOM uint32_t FORCE_XPD_AMP : 2;         /*!< no public                                                                 */
      __IOM uint32_t AMP_RST_FB_FORCE : 2;      /*!< no public                                                                 */
      __IOM uint32_t AMP_SHORT_REF_FORCE : 2;   /*!< no public                                                                 */
      __IOM uint32_t AMP_SHORT_REF_GND_FORCE : 2;/*!< no public                                                                */
    } bit;
  } SAR_MEAS1_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc1 controller                                              */
    
    struct {
      __IM  uint32_t MEAS1_DATA_SAR : 16;       /*!< SAR ADC1 data                                                             */
      __IM  uint32_t MEAS1_DONE_SAR : 1;        /*!< SAR ADC1 conversion done indication                                       */
      __IOM uint32_t MEAS1_START_SAR : 1;       /*!< SAR ADC1 controller (in RTC) starts conversion                            */
      __IOM uint32_t MEAS1_START_FORCE : 1;     /*!< 1: SAR ADC1 controller (in RTC) is started by SW                          */
      __IOM uint32_t SAR1_EN_PAD : 12;          /*!< SAR ADC1 pad enable bitmap                                                */
      __IOM uint32_t SAR1_EN_PAD_FORCE : 1;     /*!< 1: SAR ADC1 pad enable bitmap is controlled by SW                         */
    } bit;
  } SAR_MEAS1_CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc1 controller                                              */
    
    struct {
            uint32_t            : 31;
      __IOM uint32_t SAR1_DIG_FORCE : 1;        /*!< 1: SAR ADC1 controlled by DIG ADC1 CTRL                                   */
    } bit;
  } SAR_MEAS1_MUX;
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc1 controller                                              */
    
    struct {
      __IOM uint32_t SAR1_ATTEN : 32;           /*!< 2-bit attenuation for each pad                                            */
    } bit;
  } SAR_ATTEN1;
  
  union {
    __IOM uint32_t reg;                         /*!< no public                                                                 */
    
    struct {
      __IOM uint32_t SAR_AMP_WAIT1 : 16;        /*!< no public                                                                 */
      __IOM uint32_t SAR_AMP_WAIT2 : 16;        /*!< no public                                                                 */
    } bit;
  } SAR_AMP_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< no public                                                                 */
    
    struct {
      __IOM uint32_t SAR_SAR1_DAC_XPD_FSM_IDLE : 1;/*!< no public                                                              */
      __IOM uint32_t SAR_XPD_SAR_AMP_FSM_IDLE : 1;/*!< no public                                                               */
      __IOM uint32_t SAR_AMP_RST_FB_FSM_IDLE : 1;/*!< no public                                                                */
      __IOM uint32_t SAR_AMP_SHORT_REF_FSM_IDLE : 1;/*!< no public                                                             */
      __IOM uint32_t SAR_AMP_SHORT_REF_GND_FSM_IDLE : 1;/*!< no public                                                         */
      __IOM uint32_t SAR_XPD_SAR_FSM_IDLE : 1;  /*!< no public                                                                 */
      __IOM uint32_t SAR_RSTB_FSM_IDLE : 1;     /*!< no public                                                                 */
            uint32_t            : 9;
      __IOM uint32_t SAR_AMP_WAIT3 : 16;        /*!< no public                                                                 */
    } bit;
  } SAR_AMP_CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< no public                                                                 */
    
    struct {
      __IOM uint32_t SAR1_DAC_XPD_FSM : 4;      /*!< no public                                                                 */
      __IOM uint32_t XPD_SAR_AMP_FSM : 4;       /*!< no public                                                                 */
      __IOM uint32_t AMP_RST_FB_FSM : 4;        /*!< no public                                                                 */
      __IOM uint32_t AMP_SHORT_REF_FSM : 4;     /*!< no public                                                                 */
      __IOM uint32_t AMP_SHORT_REF_GND_FSM : 4; /*!< no public                                                                 */
      __IOM uint32_t XPD_SAR_FSM : 4;           /*!< no public                                                                 */
      __IOM uint32_t RSTB_FSM   : 4;            /*!< no public                                                                 */
            uint32_t            : 4;
    } bit;
  } SAR_AMP_CTRL3;
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc2 reader                                                  */
    
    struct {
      __IOM uint32_t SAR_SAR2_CLK_DIV : 8;      /*!< clock divider                                                             */
            uint32_t            : 8;
      __IOM uint32_t SAR_SAR2_WAIT_ARB_CYCLE : 2;/*!< wait arbit stable after sar_done                                         */
      __IOM uint32_t SAR_SAR2_CLK_GATED : 1;    /*!< ******* Description ***********                                           */
      __IOM uint32_t SAR_SAR2_SAMPLE_NUM : 8;   /*!< ******* Description ***********                                           */
            uint32_t            : 2;
      __IOM uint32_t SAR_SAR2_DATA_INV : 1;     /*!< Invert SAR ADC2 data                                                      */
      __IOM uint32_t SAR_SAR2_INT_EN : 1;       /*!< enable saradc2 to send out interrupt                                      */
            uint32_t            : 1;
    } bit;
  } SAR_READER2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< get saradc1 reader controller status                                      */
    
    struct {
      __IM  uint32_t SAR_SAR2_READER_STATUS : 32;/*!< get saradc1 reader controller status                                     */
    } bit;
  } SAR_READER2_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc2 controller                                              */
    
    struct {
      __IM  uint32_t SAR_SAR2_CNTL_STATE : 3;   /*!< saradc2_cntl_fsm                                                          */
      __IOM uint32_t SAR_SAR2_PWDET_CAL_EN : 1; /*!< rtc control pwdet enable                                                  */
      __IOM uint32_t SAR_SAR2_PKDET_CAL_EN : 1; /*!< rtc control pkdet enable                                                  */
      __IOM uint32_t SAR_SAR2_EN_TEST : 1;      /*!< SAR2_EN_TEST                                                              */
      __IOM uint32_t SAR_SAR2_RSTB_FORCE : 2;   /*!< no public                                                                 */
      __IOM uint32_t SAR_SAR2_STANDBY_WAIT : 8; /*!< no public                                                                 */
      __IOM uint32_t SAR_SAR2_RSTB_WAIT : 8;    /*!< no public                                                                 */
      __IOM uint32_t SAR_SAR2_XPD_WAIT : 8;     /*!< no public                                                                 */
    } bit;
  } SAR_MEAS2_CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc2 controller                                              */
    
    struct {
      __IM  uint32_t MEAS2_DATA_SAR : 16;       /*!< SAR ADC2 data                                                             */
      __IM  uint32_t MEAS2_DONE_SAR : 1;        /*!< SAR ADC2 conversion done indication                                       */
      __IOM uint32_t MEAS2_START_SAR : 1;       /*!< SAR ADC2 controller (in RTC) starts conversion                            */
      __IOM uint32_t MEAS2_START_FORCE : 1;     /*!< 1: SAR ADC2 controller (in RTC) is started by SW                          */
      __IOM uint32_t SAR2_EN_PAD : 12;          /*!< SAR ADC2 pad enable bitmap                                                */
      __IOM uint32_t SAR2_EN_PAD_FORCE : 1;     /*!< 1: SAR ADC2 pad enable bitmap is controlled by SW                         */
    } bit;
  } SAR_MEAS2_CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc2 controller                                              */
    
    struct {
            uint32_t            : 28;
      __IOM uint32_t SAR2_PWDET_CCT : 3;        /*!< SAR2_PWDET_CCT                                                            */
      __IOM uint32_t SAR2_RTC_FORCE : 1;        /*!< in sleep, force to use rtc to control ADC                                 */
    } bit;
  } SAR_MEAS2_MUX;
  
  union {
    __IOM uint32_t reg;                         /*!< configure saradc2 controller                                              */
    
    struct {
      __IOM uint32_t SAR2_ATTEN : 32;           /*!< 2-bit attenuation for each pad                                            */
    } bit;
  } SAR_ATTEN2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure power of saradc                                                 */
    
    struct {
            uint32_t            : 29;
      __IOM uint32_t FORCE_XPD_SAR : 2;         /*!< force power on/off saradc                                                 */
      __IOM uint32_t SARCLK_EN  : 1;            /*!< no public                                                                 */
    } bit;
  } SAR_POWER_XPD_SAR;
  
  union {
    __IOM uint32_t reg;                         /*!< configure i2c slave address                                               */
    
    struct {
      __IOM uint32_t SAR_I2C_SLAVE_ADDR1 : 11;  /*!< configure i2c slave address1                                              */
      __IOM uint32_t SAR_I2C_SLAVE_ADDR0 : 11;  /*!< configure i2c slave address0                                              */
      __IM  uint32_t SAR_SARADC_MEAS_STATUS : 8;/*!< no public                                                                 */
            uint32_t            : 2;
    } bit;
  } SAR_SLAVE_ADDR1;
  
  union {
    __IOM uint32_t reg;                         /*!< configure i2c slave address                                               */
    
    struct {
      __IOM uint32_t SAR_I2C_SLAVE_ADDR3 : 11;  /*!< configure i2c slave address3                                              */
      __IOM uint32_t SAR_I2C_SLAVE_ADDR2 : 11;  /*!< configure i2c slave address2                                              */
            uint32_t            : 10;
    } bit;
  } SAR_SLAVE_ADDR2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure i2c slave address                                               */
    
    struct {
      __IOM uint32_t SAR_I2C_SLAVE_ADDR5 : 11;  /*!< configure i2c slave address5                                              */
      __IOM uint32_t SAR_I2C_SLAVE_ADDR4 : 11;  /*!< configure i2c slave address4                                              */
            uint32_t            : 10;
    } bit;
  } SAR_SLAVE_ADDR3;
  
  union {
    __IOM uint32_t reg;                         /*!< configure i2c slave address                                               */
    
    struct {
      __IOM uint32_t SAR_I2C_SLAVE_ADDR7 : 11;  /*!< configure i2c slave address7                                              */
      __IOM uint32_t SAR_I2C_SLAVE_ADDR6 : 11;  /*!< configure i2c slave address6                                              */
            uint32_t            : 10;
    } bit;
  } SAR_SLAVE_ADDR4;
  
  union {
    __IOM uint32_t reg;                         /*!< configure tsens controller                                                */
    
    struct {
      __IM  uint32_t SAR_TSENS_OUT : 8;         /*!< temperature sensor data out                                               */
      __IM  uint32_t SAR_TSENS_READY : 1;       /*!< indicate temperature sensor out ready                                     */
            uint32_t            : 3;
      __IOM uint32_t SAR_TSENS_INT_EN : 1;      /*!< enable temperature sensor to send out interrupt                           */
      __IOM uint32_t SAR_TSENS_IN_INV : 1;      /*!< invert temperature sensor data                                            */
      __IOM uint32_t SAR_TSENS_CLK_DIV : 8;     /*!< temperature sensor clock divider                                          */
      __IOM uint32_t SAR_TSENS_POWER_UP : 1;    /*!< temperature sensor power up                                               */
      __IOM uint32_t SAR_TSENS_POWER_UP_FORCE : 1;/*!< 1: dump out & power up controlled by SW 0: by FSM                       */
      __IOM uint32_t SAR_TSENS_DUMP_OUT : 1;    /*!< temperature sensor dump out only active when reg_tsens_power_up_force
                                                     = 1                                                                       */
            uint32_t            : 7;
    } bit;
  } SAR_TSENS_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure tsens controller                                                */
    
    struct {
      __IOM uint32_t SAR_TSENS_XPD_WAIT : 12;   /*!< no public                                                                 */
      __IOM uint32_t SAR_TSENS_XPD_FORCE : 2;   /*!< no public                                                                 */
      __IOM uint32_t SAR_TSENS_CLK_INV : 1;     /*!< no public                                                                 */
            uint32_t            : 17;
    } bit;
  } SAR_TSENS_CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure rtc i2c controller by sw                                        */
    
    struct {
      __IOM uint32_t SAR_I2C_CTRL : 28;         /*!< I2C control data only active when reg_sar_i2c_start_force =
                                                     1                                                                         */
      __IOM uint32_t SAR_I2C_START : 1;         /*!< start I2C only active when reg_sar_i2c_start_force = 1                    */
      __IOM uint32_t SAR_I2C_START_FORCE : 1;   /*!< 1: I2C started by SW 0: I2C started by FSM                                */
            uint32_t            : 2;
    } bit;
  } SAR_I2C_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch controller                                                */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUTEN : 15;      /*!< touch controller output enable                                            */
      __OM  uint32_t SAR_TOUCH_STATUS_CLR : 1;  /*!< clear all touch active status                                             */
      __IOM uint32_t SAR_TOUCH_DATA_SEL : 2;    /*!< 3: smooth data 2: baseline 1,0: raw_data                                  */
      __IM  uint32_t SAR_TOUCH_DENOISE_END : 1; /*!< touch_denoise_done                                                        */
      __IM  uint32_t SAR_TOUCH_UNIT_END : 1;    /*!< touch_unit_done                                                           */
      __IOM uint32_t SAR_TOUCH_APPROACH_PAD2 : 4;/*!< indicate which pad is approach pad2                                      */
      __IOM uint32_t SAR_TOUCH_APPROACH_PAD1 : 4;/*!< indicate which pad is approach pad1                                      */
      __IOM uint32_t SAR_TOUCH_APPROACH_PAD0 : 4;/*!< indicate which pad is approach pad0                                      */
    } bit;
  } SAR_TOUCH_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch controller                                                */
    
    struct {
      __IM  uint32_t DATA       : 22;           /*!< configure touch controller                                                */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_DENOISE;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH1 : 22;    /*!< Finger threshold for touch pad 1                                          */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES1;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH2 : 22;    /*!< Finger threshold for touch pad 2                                          */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES2;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH3 : 22;    /*!< Finger threshold for touch pad 3                                          */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES3;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH4 : 22;    /*!< Finger threshold for touch pad 4                                          */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES4;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH5 : 22;    /*!< Finger threshold for touch pad 5                                          */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES5;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH6 : 22;    /*!< Finger threshold for touch pad 6                                          */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES6;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH7 : 22;    /*!< Finger threshold for touch pad 7                                          */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES7;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH8 : 22;    /*!< Finger threshold for touch pad 8                                          */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES8;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH9 : 22;    /*!< Finger threshold for touch pad 9                                          */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES9;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH10 : 22;   /*!< Finger threshold for touch pad 10                                         */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES10;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH11 : 22;   /*!< Finger threshold for touch pad 11                                         */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES11;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH12 : 22;   /*!< Finger threshold for touch pad 12                                         */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES12;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH13 : 22;   /*!< Finger threshold for touch pad 13                                         */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES13;
  
  union {
    __IOM uint32_t reg;                         /*!< configure touch thres of touch pad                                        */
    
    struct {
      __IOM uint32_t SAR_TOUCH_OUT_TH14 : 22;   /*!< Finger threshold for touch pad 14                                         */
            uint32_t            : 10;
    } bit;
  } SAR_TOUCH_THRES14;
  
  union {
    __IOM uint32_t reg;                         /*!< Get touch channel status                                                  */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD_ACTIVE : 15; /*!< touch active status                                                       */
      __OM  uint32_t SAR_TOUCH_CHANNEL_CLR : 15;/*!< Clear touch channel                                                       */
            uint32_t            : 1;
      __IM  uint32_t SAR_TOUCH_MEAS_DONE : 1;   /*!< get touch meas done                                                       */
    } bit;
  } SAR_TOUCH_CHN_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< get touch scan status                                                     */
    
    struct {
            uint32_t            : 22;
      __IM  uint32_t SAR_TOUCH_SCAN_CURR : 4;   /*!< current sample channel                                                    */
            uint32_t            : 6;
    } bit;
  } SAR_TOUCH_STATUS0;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 1                                       */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD1_DATA : 22;  /*!< touch data debounce of touch pad 1                                        */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD1_DEBOUNCE : 3;/*!< touch current debounce of touch pad 1                                    */
    } bit;
  } SAR_TOUCH_STATUS1;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 2                                       */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD2_DATA : 22;  /*!< touch data debounce of touch pad 2                                        */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD2_DEBOUNCE : 3;/*!< touch current debounce of touch pad 2                                    */
    } bit;
  } SAR_TOUCH_STATUS2;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 3                                       */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD3_DATA : 22;  /*!< touch data debounce of touch pad 3                                        */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD3_DEBOUNCE : 3;/*!< touch current debounce of touch pad 3                                    */
    } bit;
  } SAR_TOUCH_STATUS3;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 4                                       */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD4_DATA : 22;  /*!< touch data debounce of touch pad 4                                        */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD4_DEBOUNCE : 3;/*!< touch current debounce of touch pad 4                                    */
    } bit;
  } SAR_TOUCH_STATUS4;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 5                                       */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD5_DATA : 22;  /*!< touch data debounce of touch pad 5                                        */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD5_DEBOUNCE : 3;/*!< touch current debounce of touch pad 5                                    */
    } bit;
  } SAR_TOUCH_STATUS5;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 6                                       */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD6_DATA : 22;  /*!< touch data debounce of touch pad 6                                        */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD6_DEBOUNCE : 3;/*!< touch current debounce of touch pad 6                                    */
    } bit;
  } SAR_TOUCH_STATUS6;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 7                                       */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD7_DATA : 22;  /*!< touch data debounce of touch pad 7                                        */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD7_DEBOUNCE : 3;/*!< touch current debounce of touch pad 7                                    */
    } bit;
  } SAR_TOUCH_STATUS7;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 8                                       */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD8_DATA : 22;  /*!< touch data debounce of touch pad 8                                        */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD8_DEBOUNCE : 3;/*!< touch current debounce of touch pad 8                                    */
    } bit;
  } SAR_TOUCH_STATUS8;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 9                                       */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD9_DATA : 22;  /*!< touch data debounce of touch pad 9                                        */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD9_DEBOUNCE : 3;/*!< touch current debounce of touch pad 9                                    */
    } bit;
  } SAR_TOUCH_STATUS9;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 10                                      */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD10_DATA : 22; /*!< touch data debounce of touch pad 10                                       */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD10_DEBOUNCE : 3;/*!< touch current debounce of touch pad 10                                  */
    } bit;
  } SAR_TOUCH_STATUS10;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 11                                      */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD11_DATA : 22; /*!< touch data debounce of touch pad 11                                       */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD11_DEBOUNCE : 3;/*!< touch current debounce of touch pad 11                                  */
    } bit;
  } SAR_TOUCH_STATUS11;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 12                                      */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD12_DATA : 22; /*!< touch data debounce of touch pad 12                                       */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD12_DEBOUNCE : 3;/*!< touch current debounce of touch pad 12                                  */
    } bit;
  } SAR_TOUCH_STATUS12;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 13                                      */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD13_DATA : 22; /*!< touch data debounce of touch pad 13                                       */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD13_DEBOUNCE : 3;/*!< touch current debounce of touch pad 13                                  */
    } bit;
  } SAR_TOUCH_STATUS13;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of touch pad 14                                      */
    
    struct {
      __IM  uint32_t SAR_TOUCH_PAD14_DATA : 22; /*!< touch data debounce of touch pad 14                                       */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_PAD14_DEBOUNCE : 3;/*!< touch current debounce of touch pad 14                                  */
    } bit;
  } SAR_TOUCH_STATUS14;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of sleep pad                                         */
    
    struct {
      __IM  uint32_t SAR_TOUCH_SLP_DATA : 22;   /*!< touch data debounce of sleep pad                                          */
            uint32_t            : 7;
      __IM  uint32_t SAR_TOUCH_SLP_DEBOUNCE : 3;/*!< touch current debounce of sleep pad                                       */
    } bit;
  } SAR_TOUCH_STATUS15;
  
  union {
    __IOM uint32_t reg;                         /*!< touch channel status of approach mode                                     */
    
    struct {
      __IM  uint32_t SAR_TOUCH_APPROACH_PAD2_CNT : 8;/*!< touch current approach count of approach pad2                        */
      __IM  uint32_t SAR_TOUCH_APPROACH_PAD1_CNT : 8;/*!< touch current approach count of approach pad1                        */
      __IM  uint32_t SAR_TOUCH_APPROACH_PAD0_CNT : 8;/*!< touch current approach count of approach pad0                        */
      __IM  uint32_t SAR_TOUCH_SLP_APPROACH_CNT : 8;/*!< touch current approach count of slp pad                               */
    } bit;
  } SAR_TOUCH_STATUS16;
  
  union {
    __IOM uint32_t reg;                         /*!< get cocpu status                                                          */
    
    struct {
            uint32_t            : 25;
      __OM  uint32_t SAR_COCPU_DBG_TRIGGER : 1; /*!< trigger cocpu debug registers                                             */
      __IM  uint32_t SAR_COCPU_CLK_EN_ST : 1;   /*!< check cocpu whether clk on                                                */
      __IM  uint32_t SAR_COCPU_RESET_N : 1;     /*!< check cocpu whether in reset state                                        */
      __IM  uint32_t SAR_COCPU_EOI : 1;         /*!< check cocpu whether in interrupt state                                    */
      __IM  uint32_t SAR_COCPU_TRAP : 1;        /*!< check cocpu whether in trap state                                         */
      __IM  uint32_t SAR_COCPU_EBREAK : 1;      /*!< check cocpu whether in ebreak                                             */
            uint32_t            : 1;
    } bit;
  } SAR_COCPU_STATE;
  
  union {
    __IOM uint32_t reg;                         /*!< the interrupt raw of ulp                                                  */
    
    struct {
      __IM  uint32_t SAR_COCPU_TOUCH_DONE_INT_RAW : 1;/*!< int from touch done                                                 */
      __IM  uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_RAW : 1;/*!< int from touch inactive                                         */
      __IM  uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_RAW : 1;/*!< int from touch active                                             */
      __IM  uint32_t SAR_COCPU_SARADC1_INT_RAW : 1;/*!< int from saradc1                                                       */
      __IM  uint32_t SAR_COCPU_SARADC2_INT_RAW : 1;/*!< int from saradc2                                                       */
      __IM  uint32_t SAR_COCPU_TSENS_INT_RAW : 1;/*!< int from tsens                                                           */
      __IM  uint32_t SAR_COCPU_START_INT_RAW : 1;/*!< int from start                                                           */
      __IM  uint32_t SAR_COCPU_SW_INT_RAW : 1;  /*!< int from software                                                         */
      __IM  uint32_t SAR_COCPU_SWD_INT_RAW : 1; /*!< int from super watch dog                                                  */
      __IM  uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_RAW : 1;/*!< int from timeout done                                            */
      __IM  uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_RAW : 1;/*!< int from approach loop done                           */
      __IM  uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_RAW : 1;/*!< int from touch scan done                                       */
            uint32_t            : 20;
    } bit;
  } SAR_COCPU_INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< the interrupt enable of ulp                                               */
    
    struct {
      __IOM uint32_t SAR_COCPU_TOUCH_DONE_INT_ENA : 1;/*!< int enable of touch done                                            */
      __IOM uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_ENA : 1;/*!< int enable of from touch inactive                               */
      __IOM uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_ENA : 1;/*!< int enable of touch active                                        */
      __IOM uint32_t SAR_COCPU_SARADC1_INT_ENA : 1;/*!< int enable of from saradc1                                             */
      __IOM uint32_t SAR_COCPU_SARADC2_INT_ENA : 1;/*!< int enable of from saradc2                                             */
      __IOM uint32_t SAR_COCPU_TSENS_INT_ENA : 1;/*!< int enable of tsens                                                      */
      __IOM uint32_t SAR_COCPU_START_INT_ENA : 1;/*!< int enable of start                                                      */
      __IOM uint32_t SAR_COCPU_SW_INT_ENA : 1;  /*!< int enable of software                                                    */
      __IOM uint32_t SAR_COCPU_SWD_INT_ENA : 1; /*!< int enable of super watch dog                                             */
      __IOM uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_ENA : 1;/*!< int enable of timeout done                                       */
      __IOM uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_ENA : 1;/*!< int enable of approach loop done                      */
      __IOM uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_ENA : 1;/*!< int enable of touch scan done                                  */
            uint32_t            : 20;
    } bit;
  } SAR_COCPU_INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< the interrupt state of ulp                                                */
    
    struct {
      __IM  uint32_t SAR_COCPU_TOUCH_DONE_INT_ST : 1;/*!< int state of touch done                                              */
      __IM  uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_ST : 1;/*!< int state of from touch inactive                                 */
      __IM  uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_ST : 1;/*!< int state of touch active                                          */
      __IM  uint32_t SAR_COCPU_SARADC1_INT_ST : 1;/*!< int state of from saradc1                                               */
      __IM  uint32_t SAR_COCPU_SARADC2_INT_ST : 1;/*!< int state of from saradc2                                               */
      __IM  uint32_t SAR_COCPU_TSENS_INT_ST : 1;/*!< int state of tsens                                                        */
      __IM  uint32_t SAR_COCPU_START_INT_ST : 1;/*!< int state of start                                                        */
      __IM  uint32_t SAR_COCPU_SW_INT_ST : 1;   /*!< int state of software                                                     */
      __IM  uint32_t SAR_COCPU_SWD_INT_ST : 1;  /*!< int state of super watch dog                                              */
      __IM  uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_ST : 1;/*!< int state of timeout done                                         */
      __IM  uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_ST : 1;/*!< int state of approach loop done                        */
      __IM  uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_ST : 1;/*!< int state of touch scan done                                    */
            uint32_t            : 20;
    } bit;
  } SAR_COCPU_INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< the interrupt clear of ulp                                                */
    
    struct {
      __OM  uint32_t SAR_COCPU_TOUCH_DONE_INT_CLR : 1;/*!< int clear of touch done                                             */
      __OM  uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_CLR : 1;/*!< int clear of from touch inactive                                */
      __OM  uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_CLR : 1;/*!< int clear of touch active                                         */
      __OM  uint32_t SAR_COCPU_SARADC1_INT_CLR : 1;/*!< int clear of from saradc1                                              */
      __OM  uint32_t SAR_COCPU_SARADC2_INT_CLR : 1;/*!< int clear of from saradc2                                              */
      __OM  uint32_t SAR_COCPU_TSENS_INT_CLR : 1;/*!< int clear of tsens                                                       */
      __OM  uint32_t SAR_COCPU_START_INT_CLR : 1;/*!< int clear of start                                                       */
      __OM  uint32_t SAR_COCPU_SW_INT_CLR : 1;  /*!< int clear of software                                                     */
      __OM  uint32_t SAR_COCPU_SWD_INT_CLR : 1; /*!< int clear of super watch dog                                              */
      __OM  uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_CLR : 1;/*!< int clear of timeout done                                        */
      __OM  uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_CLR : 1;/*!< int clear of approach loop done                       */
      __OM  uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_CLR : 1;/*!< int clear of touch scan done                                   */
            uint32_t            : 20;
    } bit;
  } SAR_COCPU_INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Ulp-riscv debug signal                                                    */
    
    struct {
      __IM  uint32_t SAR_COCPU_PC : 13;         /*!< cocpu Program counter                                                     */
      __IM  uint32_t SAR_COCPU_MEM_VLD : 1;     /*!< cocpu mem valid output                                                    */
      __IM  uint32_t SAR_COCPU_MEM_RDY : 1;     /*!< cocpu mem ready input                                                     */
      __IM  uint32_t SAR_COCPU_MEM_WEN : 4;     /*!< cocpu mem write enable output                                             */
      __IM  uint32_t SAR_COCPU_MEM_ADDR : 13;   /*!< cocpu mem address output                                                  */
    } bit;
  } SAR_COCPU_DEBUG;
  
  union {
    __IOM uint32_t reg;                         /*!< no public                                                                 */
    
    struct {
            uint32_t            : 28;
      __IOM uint32_t XPD_HALL   : 1;            /*!< Power on hall sensor and connect to VP and VN                             */
      __IOM uint32_t XPD_HALL_FORCE : 1;        /*!< 1: XPD HALL is controlled by SW. 0: XPD HALL is controlled by
                                                     FSM in ULP-coprocessor                                                    */
      __IOM uint32_t HALL_PHASE : 1;            /*!< Reverse phase of hall sensor                                              */
      __IOM uint32_t HALL_PHASE_FORCE : 1;      /*!< 1: HALL PHASE is controlled by SW 0: HALL PHASE is controlled
                                                     by FSM in ULP-coprocessor                                                 */
    } bit;
  } SAR_HALL_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< no public                                                                 */
    
    struct {
      __IOM uint32_t SAR_NOUSE  : 32;           /*!< no public                                                                 */
    } bit;
  } SAR_NOUSE;
  
  union {
    __IOM uint32_t reg;                         /*!< the peri clock gate of rtc peri                                           */
    
    struct {
            uint32_t            : 27;
      __IOM uint32_t RTC_I2C_CLK_EN : 1;        /*!< enable rtc i2c clock                                                      */
            uint32_t            : 1;
      __IOM uint32_t TSENS_CLK_EN : 1;          /*!< enable tsens clock                                                        */
      __IOM uint32_t SARADC_CLK_EN : 1;         /*!< enbale saradc clock                                                       */
      __IOM uint32_t IOMUX_CLK_EN : 1;          /*!< enable io_mux clock                                                       */
    } bit;
  } SAR_PERI_CLK_GATE_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< the peri reset of rtc peri                                                */
    
    struct {
            uint32_t            : 25;
      __IOM uint32_t SAR_COCPU_RESET : 1;       /*!< enable ulp-riscv reset                                                    */
            uint32_t            : 1;
      __IOM uint32_t SAR_RTC_I2C_RESET : 1;     /*!< Reserved.                                                                 */
            uint32_t            : 1;
      __IOM uint32_t SAR_TSENS_RESET : 1;       /*!< enbale saradc reset                                                       */
      __IOM uint32_t SAR_SARADC_RESET : 1;      /*!< enable io_mux reset                                                       */
            uint32_t            : 1;
    } bit;
  } SAR_PERI_RESET_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< the interrupt enable of ulp                                               */
    
    struct {
      __OM  uint32_t SAR_COCPU_TOUCH_DONE_INT_ENA_W1TS : 1;/*!< int enable of touch done                                       */
      __OM  uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_ENA_W1TS : 1;/*!< int enable of from touch inactive                          */
      __OM  uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_ENA_W1TS : 1;/*!< int enable of touch active                                   */
      __OM  uint32_t SAR_COCPU_SARADC1_INT_ENA_W1TS : 1;/*!< int enable of from saradc1                                        */
      __OM  uint32_t SAR_COCPU_SARADC2_INT_ENA_W1TS : 1;/*!< int enable of from saradc2                                        */
      __OM  uint32_t SAR_COCPU_TSENS_INT_ENA_W1TS : 1;/*!< int enable of tsens                                                 */
      __OM  uint32_t SAR_COCPU_START_INT_ENA_W1TS : 1;/*!< int enable of start                                                 */
      __OM  uint32_t SAR_COCPU_SW_INT_ENA_W1TS : 1;/*!< int enable of software                                                 */
      __OM  uint32_t SAR_COCPU_SWD_INT_ENA_W1TS : 1;/*!< int enable of super watch dog                                         */
      __OM  uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_ENA_W1TS : 1;/*!< int enable of timeout done                                  */
      __OM  uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_ENA_W1TS : 1;/*!< int enable of approach loop done                 */
      __OM  uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_ENA_W1TS : 1;/*!< int enable of touch scan done                             */
            uint32_t            : 20;
    } bit;
  } SAR_COCPU_INT_ENA_W1TS;
  
  union {
    __IOM uint32_t reg;                         /*!< the interrupt enable clear of ulp                                         */
    
    struct {
      __OM  uint32_t SAR_COCPU_TOUCH_DONE_INT_ENA_W1TC : 1;/*!< Clear int enable of touch done                                 */
      __OM  uint32_t SAR_COCPU_TOUCH_INACTIVE_INT_ENA_W1TC : 1;/*!< Clear int enable of from touch inactive                    */
      __OM  uint32_t SAR_COCPU_TOUCH_ACTIVE_INT_ENA_W1TC : 1;/*!< Clear int enable of touch active                             */
      __OM  uint32_t SAR_COCPU_SARADC1_INT_ENA_W1TC : 1;/*!< Clear int enable of from saradc1                                  */
      __OM  uint32_t SAR_COCPU_SARADC2_INT_ENA_W1TC : 1;/*!< Clear int enable of from saradc2                                  */
      __OM  uint32_t SAR_COCPU_TSENS_INT_ENA_W1TC : 1;/*!< Clear int enable of tsens                                           */
      __OM  uint32_t SAR_COCPU_START_INT_ENA_W1TC : 1;/*!< Clear int enable of start                                           */
      __OM  uint32_t SAR_COCPU_SW_INT_ENA_W1TC : 1;/*!< Clear int enable of software                                           */
      __OM  uint32_t SAR_COCPU_SWD_INT_ENA_W1TC : 1;/*!< Clear int enable of super watch dog                                   */
      __OM  uint32_t SAR_COCPU_TOUCH_TIMEOUT_INT_ENA_W1TC : 1;/*!< Clear int enable of timeout done                            */
      __OM  uint32_t SAR_COCPU_TOUCH_APPROACH_LOOP_DONE_INT_ENA_W1TC : 1;/*!< Clear int enable of approach loop done           */
      __OM  uint32_t SAR_COCPU_TOUCH_SCAN_DONE_INT_ENA_W1TC : 1;/*!< Clear int enable of touch scan done                       */
            uint32_t            : 20;
    } bit;
  } SAR_COCPU_INT_ENA_W1TC;
  
  union {
    __IOM uint32_t reg;                         /*!< rtc peri debug configure                                                  */
    
    struct {
      __IOM uint32_t SAR_DEBUG_BIT_SEL : 5;     /*!< no public                                                                 */
            uint32_t            : 27;
    } bit;
  } SAR_DEBUG_CONF;
  __IM  uint32_t  RESERVED[57];
  
  union {
    __IOM uint32_t reg;                         /*!< version                                                                   */
    
    struct {
      __IOM uint32_t SAR_DATE   : 28;           /*!< version                                                                   */
            uint32_t            : 4;
    } bit;
  } SAR_SARDATE;
} SENS_Type;                                    /*!< Size = 512 (0x200)                                                        */



/* =========================================================================================================================== */
/* ================                                         SENSITIVE                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief SENSITIVE Peripheral (SENSITIVE)
  */

typedef struct {                                /*!< SENSITIVE Structure                                                       */
  
  union {
    __IOM uint32_t reg;                         /*!< Cache data array configuration register 0.                                */
    
    struct {
      __IOM uint32_t CACHE_DATAARRAY_CONNECT_LOCK : 1;/*!< Set 1 to lock cache data array registers.                           */
            uint32_t            : 31;
    } bit;
  } CACHE_DATAARRAY_CONNECT_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache data array configuration register 1.                                */
    
    struct {
      __IOM uint32_t CACHE_DATAARRAY_CONNECT_FLATTEN : 8;/*!< Cache data array connection configuration.                       */
            uint32_t            : 24;
    } bit;
  } CACHE_DATAARRAY_CONNECT_1;
  
  union {
    __IOM uint32_t reg;                         /*!< APB peripheral configuration register 0.                                  */
    
    struct {
      __IOM uint32_t APB_PERIPHERAL_ACCESS_LOCK : 1;/*!< Set 1 to lock APB peripheral Configuration Register.                  */
            uint32_t            : 31;
    } bit;
  } APB_PERIPHERAL_ACCESS_0;
  
  union {
    __IOM uint32_t reg;                         /*!< APB peripheral configuration register 1.                                  */
    
    struct {
      __IOM uint32_t APB_PERIPHERAL_ACCESS_SPLIT_BURST : 1;/*!< Set 1 to support split function for AHB access to APB peripherals. */
            uint32_t            : 31;
    } bit;
  } APB_PERIPHERAL_ACCESS_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Internal SRAM configuration register 0.                                   */
    
    struct {
      __IOM uint32_t INTERNAL_SRAM_USAGE_LOCK : 1;/*!< Set 1 to lock internal SRAM Configuration Register.                     */
            uint32_t            : 31;
    } bit;
  } INTERNAL_SRAM_USAGE_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Internal SRAM configuration register 1.                                   */
    
    struct {
      __IOM uint32_t INTERNAL_SRAM_ICACHE_USAGE : 2;/*!< Set 1 to someone bit means corresponding internal SRAM level
                                                     can be accessed by icache.                                                */
      __IOM uint32_t INTERNAL_SRAM_DCACHE_USAGE : 2;/*!< Set 1 to someone bit means corresponding internal SRAM level
                                                     can be accessed by dcache.                                                */
      __IOM uint32_t INTERNAL_SRAM_CPU_USAGE : 7;/*!< Set 1 to someone bit means corresponding internal SRAM level
                                                     can be accessed by cpu.                                                   */
            uint32_t            : 21;
    } bit;
  } INTERNAL_SRAM_USAGE_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Internal SRAM configuration register 2.                                   */
    
    struct {
      __IOM uint32_t INTERNAL_SRAM_CORE0_TRACE_USAGE : 7;/*!< Set 1 to someone bit means corresponding internal SRAM level
                                                     can be accessed by core0 trace bus.                                       */
      __IOM uint32_t INTERNAL_SRAM_CORE1_TRACE_USAGE : 7;/*!< Set 1 to someone bit means corresponding internal SRAM level
                                                     can be accessed by core1 trace bus.                                       */
      __IOM uint32_t INTERNAL_SRAM_CORE0_TRACE_ALLOC : 2;/*!< Which internal SRAM bank (16KB) of 64KB can be accessed by core0
                                                     trace bus.                                                                */
      __IOM uint32_t INTERNAL_SRAM_CORE1_TRACE_ALLOC : 2;/*!< Which internal SRAM bank (16KB) of 64KB can be accessed by core1
                                                     trace bus.                                                                */
            uint32_t            : 14;
    } bit;
  } INTERNAL_SRAM_USAGE_2;
  
  union {
    __IOM uint32_t reg;                         /*!< Internal SRAM configuration register 3.                                   */
    
    struct {
      __IOM uint32_t INTERNAL_SRAM_MAC_DUMP_USAGE : 4;/*!< Set 1 to someone bit means corresponding internal SRAM level
                                                     can be accessed by mac dump.                                              */
            uint32_t            : 28;
    } bit;
  } INTERNAL_SRAM_USAGE_3;
  
  union {
    __IOM uint32_t reg;                         /*!< Internal SRAM configuration register 4.                                   */
    
    struct {
      __IOM uint32_t INTERNAL_SRAM_LOG_USAGE : 7;/*!< Set 1 to someone bit means corresponding internal SRAM level
                                                     can be accessed by log bus.                                               */
            uint32_t            : 25;
    } bit;
  } INTERNAL_SRAM_USAGE_4;
  
  union {
    __IOM uint32_t reg;                         /*!< Retention configuration register.                                         */
    
    struct {
      __IOM uint32_t RETENTION_DISABLE : 1;     /*!< Set 1 to disable retention function and lock disable state.               */
            uint32_t            : 31;
    } bit;
  } RETENTION_DISABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache tag configuration register 0.                                       */
    
    struct {
      __IOM uint32_t CACHE_TAG_ACCESS_LOCK : 1; /*!< Set 1 to lock cache tag Configuration Register.                           */
            uint32_t            : 31;
    } bit;
  } CACHE_TAG_ACCESS_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache tag configuration register 1.                                       */
    
    struct {
      __IOM uint32_t PRO_I_TAG_RD_ACS : 1;      /*!< Set 1 to enable Icache read access tag memory.                            */
      __IOM uint32_t PRO_I_TAG_WR_ACS : 1;      /*!< Set 1 to enable Icache wrtie access tag memory.                           */
      __IOM uint32_t PRO_D_TAG_RD_ACS : 1;      /*!< Set 1 to enable Dcache read access tag memory.                            */
      __IOM uint32_t PRO_D_TAG_WR_ACS : 1;      /*!< Set 1 to enable Dcache wrtie access tag memory.                           */
            uint32_t            : 28;
    } bit;
  } CACHE_TAG_ACCESS_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache MMU configuration register 0.                                       */
    
    struct {
      __IOM uint32_t CACHE_MMU_ACCESS_LOCK : 1; /*!< Set 1 to lock cache MMU registers.                                        */
            uint32_t            : 31;
    } bit;
  } CACHE_MMU_ACCESS_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache MMU configuration register 1.                                       */
    
    struct {
      __IOM uint32_t PRO_MMU_RD_ACS : 1;        /*!< Set 1 to enable read access MMU memory.                                   */
      __IOM uint32_t PRO_MMU_WR_ACS : 1;        /*!< Set 1 to enable write access MMU memory.                                  */
            uint32_t            : 30;
    } bit;
  } CACHE_MMU_ACCESS_1;
  
  union {
    __IOM uint32_t reg;                         /*!< spi2 dma permission configuration register 0.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock spi2 dma permission Configuration Register.    */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_SPI2_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< spi2 dma permission configuration register 1.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< spi2's permission(store,load) in data region0 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< spi2's permission(store,load) in data region1 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< spi2's permission(store,load) in data region2 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< spi2's permission(store,load) in data region3 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< spi2's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_SPI2_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< spi2's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_SPI2_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< spi3 dma permission configuration register 0.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock spi3 dma permission Configuration Register.    */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_SPI3_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< spi3 dma permission configuration register 1.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< spi3's permission(store,load) in data region0 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< spi3's permission(store,load) in data region1 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< spi3's permission(store,load) in data region2 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< spi3's permission(store,load) in data region3 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< spi3's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_SPI3_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< spi3's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_SPI3_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< uhci0 dma permission configuration register 0.                            */
    
    struct {
      __IOM uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock uhci0 dma permission Configuration Register.  */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_UHCI0_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< uhci0 dma permission configuration register 1.                            */
    
    struct {
      __IOM uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< uhci0's permission(store,load) in data region0 of SRAM */
      __IOM uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< uhci0's permission(store,load) in data region1 of SRAM */
      __IOM uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< uhci0's permission(store,load) in data region2 of SRAM */
      __IOM uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< uhci0's permission(store,load) in data region3 of SRAM */
      __IOM uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< uhci0's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_UHCI0_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< uhci0's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_UHCI0_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< i2s0 dma permission configuration register 0.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock i2s0 dma permission Configuration Register.    */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_I2S0_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< i2s0 dma permission configuration register 1.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< i2s0's permission(store,load) in data region0 of SRAM  */
      __IOM uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< i2s0's permission(store,load) in data region1 of SRAM  */
      __IOM uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< i2s0's permission(store,load) in data region2 of SRAM  */
      __IOM uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< i2s0's permission(store,load) in data region3 of SRAM  */
      __IOM uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< i2s0's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_I2S0_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< i2s0's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_I2S0_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< i2s1 dma permission configuration register 0.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock i2s1 dma permission Configuration Register.    */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_I2S1_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< i2s1 dma permission configuration register 1.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< i2s1's permission(store,load) in data region0 of SRAM  */
      __IOM uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< i2s1's permission(store,load) in data region1 of SRAM  */
      __IOM uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< i2s1's permission(store,load) in data region2 of SRAM  */
      __IOM uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< i2s1's permission(store,load) in data region3 of SRAM  */
      __IOM uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< i2s1's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_I2S1_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< i2s1's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_I2S1_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< mac dma permission configuration register 0.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock mac dma permission Configuration Register.      */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_MAC_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< mac dma permission configuration register 1.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< mac's permission(store,load) in data region0 of SRAM    */
      __IOM uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< mac's permission(store,load) in data region1 of SRAM    */
      __IOM uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< mac's permission(store,load) in data region2 of SRAM    */
      __IOM uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< mac's permission(store,load) in data region3 of SRAM    */
      __IOM uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< mac's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_MAC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< mac's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_MAC_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< backup dma permission configuration register 0.                           */
    
    struct {
      __IOM uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock backup dma permission Configuration Register. */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_BACKUP_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< backup dma permission configuration register 1.                           */
    
    struct {
      __IOM uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< backup's permission(store,load) in data region0 of SRAM */
      __IOM uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< backup's permission(store,load) in data region1 of SRAM */
      __IOM uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< backup's permission(store,load) in data region2 of SRAM */
      __IOM uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< backup's permission(store,load) in data region3 of SRAM */
      __IOM uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< backup's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_BACKUP_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< backup's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_BACKUP_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< aes dma permission configuration register 0.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock aes dma permission Configuration Register.      */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_AES_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< aes dma permission configuration register 1.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< aes's permission(store,load) in data region0 of SRAM    */
      __IOM uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< aes's permission(store,load) in data region1 of SRAM    */
      __IOM uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< aes's permission(store,load) in data region2 of SRAM    */
      __IOM uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< aes's permission(store,load) in data region3 of SRAM    */
      __IOM uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< aes's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_AES_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< aes's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_AES_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< sha dma permission configuration register 0.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock sha dma permission Configuration Register.      */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_SHA_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< sha dma permission configuration register 1.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< sha's permission(store,load) in data region0 of SRAM    */
      __IOM uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< sha's permission(store,load) in data region1 of SRAM    */
      __IOM uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< sha's permission(store,load) in data region2 of SRAM    */
      __IOM uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< sha's permission(store,load) in data region3 of SRAM    */
      __IOM uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< sha's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_SHA_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< sha's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_SHA_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< adc_dac dma permission configuration register 0.                          */
    
    struct {
      __IOM uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock adc_dac dma permission Configuration Register. */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< adc_dac dma permission configuration register 1.                          */
    
    struct {
      __IOM uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< adc_dac's permission(store,load) in data region0 of SRAM */
      __IOM uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< adc_dac's permission(store,load) in data region1 of SRAM */
      __IOM uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< adc_dac's permission(store,load) in data region2 of SRAM */
      __IOM uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< adc_dac's permission(store,load) in data region3 of SRAM */
      __IOM uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< adc_dac's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< adc_dac's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_ADC_DAC_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< rmt dma permission configuration register 0.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock rmt dma permission Configuration Register.      */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_RMT_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< rmt dma permission configuration register 1.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< rmt's permission(store,load) in data region0 of SRAM    */
      __IOM uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< rmt's permission(store,load) in data region1 of SRAM    */
      __IOM uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< rmt's permission(store,load) in data region2 of SRAM    */
      __IOM uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< rmt's permission(store,load) in data region3 of SRAM    */
      __IOM uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< rmt's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_RMT_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< rmt's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_RMT_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< lcd_cam dma permission configuration register 0.                          */
    
    struct {
      __IOM uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock lcd_cam dma permission Configuration Register. */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< lcd_cam dma permission configuration register 1.                          */
    
    struct {
      __IOM uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< lcd_cam's permission(store,load) in data region0 of SRAM */
      __IOM uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< lcd_cam's permission(store,load) in data region1 of SRAM */
      __IOM uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< lcd_cam's permission(store,load) in data region2 of SRAM */
      __IOM uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< lcd_cam's permission(store,load) in data region3 of SRAM */
      __IOM uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< lcd_cam's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< lcd_cam's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_LCD_CAM_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< usb dma permission configuration register 0.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock usb dma permission Configuration Register.      */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_USB_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< usb dma permission configuration register 1.                              */
    
    struct {
      __IOM uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< usb's permission(store,load) in data region0 of SRAM    */
      __IOM uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< usb's permission(store,load) in data region1 of SRAM    */
      __IOM uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< usb's permission(store,load) in data region2 of SRAM    */
      __IOM uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< usb's permission(store,load) in data region3 of SRAM    */
      __IOM uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< usb's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_USB_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< usb's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_USB_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< lc dma permission configuration register 0.                               */
    
    struct {
      __IOM uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock lc dma permission Configuration Register.        */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_LC_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< lc dma permission configuration register 1.                               */
    
    struct {
      __IOM uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< lc's permission(store,load) in data region0 of SRAM      */
      __IOM uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< lc's permission(store,load) in data region1 of SRAM      */
      __IOM uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< lc's permission(store,load) in data region2 of SRAM      */
      __IOM uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< lc's permission(store,load) in data region3 of SRAM      */
      __IOM uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< lc's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_LC_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< lc's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_LC_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< sdio dma permission configuration register 0.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock sdio dma permission Configuration Register.    */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_SDIO_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< sdio dma permission configuration register 1.                             */
    
    struct {
      __IOM uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_PMS_0 : 2;/*!< sdio's permission(store,load) in data region0 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_PMS_1 : 2;/*!< sdio's permission(store,load) in data region1 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_PMS_2 : 2;/*!< sdio's permission(store,load) in data region2 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_PMS_3 : 2;/*!< sdio's permission(store,load) in data region3 of SRAM  */
      __IOM uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_0 : 2;/*!< sdio's permission(store,load) in dcache data sram block0 */
      __IOM uint32_t DMA_APBPERI_SDIO_PMS_CONSTRAIN_SRAM_CACHEDATAARRAY_PMS_1 : 2;/*!< sdio's permission(store,load) in dcache data sram block1 */
            uint32_t            : 20;
    } bit;
  } DMA_APBPERI_SDIO_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< dma permission monitor configuration register 0.                          */
    
    struct {
      __IOM uint32_t DMA_APBPERI_PMS_MONITOR_LOCK : 1;/*!< Set 1 to lock dma permission monitor Configuration Register.        */
            uint32_t            : 31;
    } bit;
  } DMA_APBPERI_PMS_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< dma permission monitor configuration register 1.                          */
    
    struct {
      __IOM uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_CLR : 1;/*!< Set 1 to clear dma_pms_monitor_violate interrupt             */
      __IOM uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_EN : 1;/*!< Set 1 to enable dma pms monitor, if dma access violated permission,
                                                     will trigger interrupt.                                                   */
            uint32_t            : 30;
    } bit;
  } DMA_APBPERI_PMS_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< dma permission monitor configuration register 2.                          */
    
    struct {
      __IM  uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_INTR : 1;/*!< recorded dma's interrupt status when dma access violated permission */
      __IM  uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_WORLD : 2;/*!< recorded dma's world status when dma access violated permission */
      __IM  uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_ADDR : 22;/*!< recorded dma's address bit[25:4] status when dma access violated
                                                     permission, real address is 0x3c00_0000+addr*16                           */
            uint32_t            : 7;
    } bit;
  } DMA_APBPERI_PMS_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< dma permission monitor configuration register 3.                          */
    
    struct {
      __IM  uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_WR : 1;/*!< recorded dma's write status when dma access violated permission,
                                                     1(write), 0(read)                                                         */
      __IM  uint32_t DMA_APBPERI_PMS_MONITOR_VIOLATE_STATUS_BYTEEN : 16;/*!< recorded dma's byte enable status when dma access violated permission */
            uint32_t            : 15;
    } bit;
  } DMA_APBPERI_PMS_MONITOR_3;
  
  union {
    __IOM uint32_t reg;                         /*!< sram split line configuration register 0                                  */
    
    struct {
      __IOM uint32_t CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock sram split configuration register */
            uint32_t            : 31;
    } bit;
  } CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< sram split line configuration register 1                                  */
    
    struct {
      __IOM uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_0 : 2;/*!< category0 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block0 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block0 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block0 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_1 : 2;/*!< category1 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block1 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block1 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block1 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_2 : 2;/*!< category2 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block2 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block2 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block2 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_3 : 2;/*!< category3 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block3 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block3 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block3 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_4 : 2;/*!< category4 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block4 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block4 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block4 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_5 : 2;/*!< category5 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block5 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block5 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block5 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_CATEGORY_6 : 2;/*!< category6 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block6 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block6 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block6 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_DRAM0_DMA_SRAM_SPLITADDR : 8;/*!< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit
                                                     of actual address                                                         */
            uint32_t            : 10;
    } bit;
  } CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< sram split line configuration register 1                                  */
    
    struct {
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_0 : 2;/*!< category0 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block0 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block0 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block0 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_1 : 2;/*!< category1 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block1 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block1 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block1 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_2 : 2;/*!< category2 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block2 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block2 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block2 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_3 : 2;/*!< category3 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block3 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block3 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block3 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_4 : 2;/*!< category4 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block4 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block4 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block4 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_5 : 2;/*!< category5 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block5 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block5 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block5 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_0_CATEGORY_6 : 2;/*!< category6 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block6 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block6 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block6 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_0_SPLITADDR : 8;/*!< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit
                                                     of actual address                                                         */
            uint32_t            : 10;
    } bit;
  } CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_2;
  
  union {
    __IOM uint32_t reg;                         /*!< sram split line configuration register 1                                  */
    
    struct {
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_0 : 2;/*!< category0 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block0 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block0 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block0 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_1 : 2;/*!< category1 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block1 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block1 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block1 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_2 : 2;/*!< category2 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block2 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block2 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block2 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_3 : 2;/*!< category3 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block3 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block3 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block3 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_4 : 2;/*!< category4 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block4 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block4 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block4 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_5 : 2;/*!< category5 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block5 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block5 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block5 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_1_CATEGORY_6 : 2;/*!< category6 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block6 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block6 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block6 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_IRAM0_SRAM_LINE_1_SPLITADDR : 8;/*!< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit
                                                     of actual address                                                         */
            uint32_t            : 10;
    } bit;
  } CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_3;
  
  union {
    __IOM uint32_t reg;                         /*!< sram split line configuration register 1                                  */
    
    struct {
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_0 : 2;/*!< category0 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block0 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block0 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block0 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_1 : 2;/*!< category1 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block1 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block1 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block1 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_2 : 2;/*!< category2 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block2 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block2 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block2 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_3 : 2;/*!< category3 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block3 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block3 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block3 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_4 : 2;/*!< category4 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block4 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block4 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block4 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_5 : 2;/*!< category5 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block5 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block5 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block5 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_CATEGORY_6 : 2;/*!< category6 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block6 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block6 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block6 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_0_SPLITADDR : 8;/*!< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit
                                                     of actual address                                                         */
            uint32_t            : 10;
    } bit;
  } CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_4;
  
  union {
    __IOM uint32_t reg;                         /*!< sram split line configuration register 1                                  */
    
    struct {
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_0 : 2;/*!< category0 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block0 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block0 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block0 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_1 : 2;/*!< category1 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block1 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block1 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block1 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_2 : 2;/*!< category2 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block2 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block2 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block2 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_3 : 2;/*!< category3 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block3 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block3 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block3 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_4 : 2;/*!< category4 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block4 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block4 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block4 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_5 : 2;/*!< category5 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block5 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block5 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block5 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_CATEGORY_6 : 2;/*!< category6 of core_x_iram0_dram_dma_line, if the splitaddress
                                                     in block6 of SRAM, configured as 0x10, else if the splitaddress
                                                     below block6 of SRAM, configured as 0x11, else if splitaddress
                                                     higher than block6 of SRAM, configured as 0x00                            */
      __IOM uint32_t CORE_X_DRAM0_DMA_SRAM_LINE_1_SPLITADDR : 8;/*!< splitaddr of core_x_iram0_dram_dma_line, configured as [15:8]bit
                                                     of actual address                                                         */
            uint32_t            : 10;
    } bit;
  } CORE_X_IRAM0_DRAM0_DMA_SPLIT_LINE_CONSTRAIN_5;
  
  union {
    __IOM uint32_t reg;                         /*!< corex iram0 permission configuration register 0                           */
    
    struct {
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock corex iram0 permission configuration register      */
            uint32_t            : 31;
    } bit;
  } CORE_X_IRAM0_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< corex iram0 permission configuration register 0                           */
    
    struct {
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 : 3;/*!< core0/core1's permission of instruction region0 of SRAM in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 : 3;/*!< core0/core1's permission of instruction region1 of SRAM in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 : 3;/*!< core0/core1's permission of instruction region2 of SRAM in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 : 3;/*!< core0/core1's permission of instruction region3 of SRAM in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_0 : 3;/*!< core0/core1's permission of icache data sram block0 in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_1 : 3;/*!< core0/core1's permission of icache data sram block1 in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_ROM_WORLD_1_PMS : 3;/*!< core0/core1's permission of rom in world1             */
            uint32_t            : 11;
    } bit;
  } CORE_X_IRAM0_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< corex iram0 permission configuration register 1                           */
    
    struct {
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 : 3;/*!< core0/core1's permission of instruction region0 of SRAM in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 : 3;/*!< core0/core1's permission of instruction region1 of SRAM in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 : 3;/*!< core0/core1's permission of instruction region2 of SRAM in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 : 3;/*!< core0/core1's permission of instruction region3 of SRAM in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0 : 3;/*!< core0/core1's permission of icache data sram block0 in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1 : 3;/*!< core0/core1's permission of icache data sram block1 in world1 */
      __IOM uint32_t CORE_X_IRAM0_PMS_CONSTRAIN_ROM_WORLD_0_PMS : 3;/*!< core0/core1's permission of rom in world1             */
            uint32_t            : 11;
    } bit;
  } CORE_X_IRAM0_PMS_CONSTRAIN_2;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 iram0 permission monitor configuration register 0                   */
    
    struct {
      __IOM uint32_t CORE_0_IRAM0_PMS_MONITOR_LOCK : 1;/*!< Set 1 to lock core0 iram0 permission monitor register              */
            uint32_t            : 31;
    } bit;
  } CORE_0_IRAM0_PMS_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 iram0 permission monitor configuration register 1                   */
    
    struct {
      __IOM uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_CLR : 1;/*!< Set 1 to clear core0 iram0 permission violated interrupt    */
      __IOM uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_EN : 1;/*!< Set 1 to enable core0 iram0 permission monitor, when core0_iram
                                                     violated permission, will trigger interrupt                               */
            uint32_t            : 30;
    } bit;
  } CORE_0_IRAM0_PMS_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 iram0 permission monitor configuration register 2                   */
    
    struct {
      __IM  uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_INTR : 1;/*!< recorded core0 iram0 pms monitor interrupt status.         */
      __IM  uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WR : 1;/*!< recorded core0 iram0 wr status, only if loadstore is 1 have
                                                     meaning, 1(store), 0(load).                                               */
      __IM  uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_LOADSTORE : 1;/*!< recorded core0 iram0 loadstore status, indicated the type of
                                                     operation, 0(fetch), 1(load/store).                                       */
      __IM  uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD : 2;/*!< recorded core0 iram0 world status, 0x01 means world0, 0x10 means
                                                     world1.                                                                   */
      __IM  uint32_t CORE_0_IRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR : 24;/*!< recorded core0 iram0 address [25:2] status when core0 iram0
                                                     violated permission, the real address is 0x40000000+addr*4                */
            uint32_t            : 3;
    } bit;
  } CORE_0_IRAM0_PMS_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 iram0 permission monitor configuration register 0                   */
    
    struct {
      __IOM uint32_t CORE_1_IRAM0_PMS_MONITOR_LOCK : 1;/*!< Set 1 to lock core1 iram0 permission monitor register              */
            uint32_t            : 31;
    } bit;
  } CORE_1_IRAM0_PMS_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 iram0 permission monitor configuration register 1                   */
    
    struct {
      __IOM uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_CLR : 1;/*!< Set 1 to clear core1 iram0 permission violated interrupt    */
      __IOM uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_EN : 1;/*!< Set 1 to enable core1 iram0 permission monitor, when core1_iram
                                                     violated permission, will trigger interrupt                               */
            uint32_t            : 30;
    } bit;
  } CORE_1_IRAM0_PMS_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 iram0 permission monitor configuration register 2                   */
    
    struct {
      __IM  uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_INTR : 1;/*!< recorded core1 iram0 pms monitor interrupt status.         */
      __IM  uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WR : 1;/*!< recorded core1 iram0 wr status, only if loadstore is 1 have
                                                     meaning, 1(store), 0(load).                                               */
      __IM  uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_STATUS_LOADSTORE : 1;/*!< recorded core1 iram0 loadstore status, indicated the type of
                                                     operation, 0(fetch), 1(load/store).                                       */
      __IM  uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD : 2;/*!< recorded core1 iram0 world status, 0x01 means world0, 0x10 means
                                                     world1.                                                                   */
      __IM  uint32_t CORE_1_IRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR : 24;/*!< recorded core1 iram0 address [25:2] status when core1 iram0
                                                     violated permission, the real address is 0x40000000+addr*4                */
            uint32_t            : 3;
    } bit;
  } CORE_1_IRAM0_PMS_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< corex dram0 permission configuration register 0                           */
    
    struct {
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock corex dram0 permission configuration register      */
            uint32_t            : 31;
    } bit;
  } CORE_X_DRAM0_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< corex dram0 permission configuration register 1                           */
    
    struct {
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_0 : 2;/*!< core0/core1's permission of data region0 of SRAM in world0. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_1 : 2;/*!< core0/core1's permission of data region1 of SRAM in world0. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_2 : 2;/*!< core0/core1's permission of data region2 of SRAM in world0. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_PMS_3 : 2;/*!< core0/core1's permission of data region3 of SRAM in world0. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_0 : 2;/*!< core0/core1's permission of dcache data sram block0 in world0. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_0_CACHEDATAARRAY_PMS_1 : 2;/*!< core0/core1's permission of dcache data sram block1 in world0. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_0 : 2;/*!< core0/core1's permission of data region0 of SRAM in world1. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_1 : 2;/*!< core0/core1's permission of data region1 of SRAM in world1. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_2 : 2;/*!< core0/core1's permission of data region2 of SRAM in world1. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_PMS_3 : 2;/*!< core0/core1's permission of data region3 of SRAM in world1. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_0 : 2;/*!< core0/core1's permission of dcache data sram block0 in world1. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_SRAM_WORLD_1_CACHEDATAARRAY_PMS_1 : 2;/*!< core0/core1's permission of dcache data sram block1 in world1. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_ROM_WORLD_0_PMS : 2;/*!< core0/core1's permission(sotre,load) of rom in world0. */
      __IOM uint32_t CORE_X_DRAM0_PMS_CONSTRAIN_ROM_WORLD_1_PMS : 2;/*!< core0/core1's permission(sotre,load) of rom in world1. */
            uint32_t            : 4;
    } bit;
  } CORE_X_DRAM0_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 dram0 permission monitor configuration register 0                   */
    
    struct {
      __IOM uint32_t CORE_0_DRAM0_PMS_MONITOR_LOCK : 1;/*!< Set 1 to lock core0 dram0 permission monitor configuration register. */
            uint32_t            : 31;
    } bit;
  } CORE_0_DRAM0_PMS_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 dram0 permission monitor configuration register 1                   */
    
    struct {
      __IOM uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_CLR : 1;/*!< Set 1 to clear core0 dram0 permission monior interrupt.     */
      __IOM uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_EN : 1;/*!< Set 1 to enable core0 dram0 permission monitor interrupt.    */
            uint32_t            : 30;
    } bit;
  } CORE_0_DRAM0_PMS_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 dram0 permission monitor configuration register 2.                  */
    
    struct {
      __IM  uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_INTR : 1;/*!< recorded core0 dram0 permission monitor interrupt status.  */
      __IM  uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_LOCK : 1;/*!< recorded core0 dram0 lock status, 1 means s32c1i access. */
      __IM  uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD : 2;/*!< recorded core0 dram0 world status, 0x1 means world0, 0x2 means
                                                     world1.                                                                   */
      __IM  uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR : 22;/*!< recorded core0 dram0 address[25:4] status when core0 dram0 violated
                                                     permission,the real address is 0x3c000000+addr*16                         */
            uint32_t            : 6;
    } bit;
  } CORE_0_DRAM0_PMS_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 dram0 permission monitor configuration register 3.                  */
    
    struct {
      __IM  uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WR : 1;/*!< recorded core0 dram0 wr status, 1 means store, 0 means load. */
      __IM  uint32_t CORE_0_DRAM0_PMS_MONITOR_VIOLATE_STATUS_BYTEEN : 16;/*!< recorded core0 dram0 byteen status.              */
            uint32_t            : 15;
    } bit;
  } CORE_0_DRAM0_PMS_MONITOR_3;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 dram0 permission monitor configuration register 0                   */
    
    struct {
      __IOM uint32_t CORE_1_DRAM0_PMS_MONITOR_LOCK : 1;/*!< Set 1 to lock core1 dram0 permission monitor configuration register. */
            uint32_t            : 31;
    } bit;
  } CORE_1_DRAM0_PMS_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 dram0 permission monitor configuration register 1                   */
    
    struct {
      __IOM uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_CLR : 1;/*!< Set 1 to clear core1 dram0 permission monior interrupt.     */
      __IOM uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_EN : 1;/*!< Set 1 to enable core1 dram0 permission monitor interrupt.    */
            uint32_t            : 30;
    } bit;
  } CORE_1_DRAM0_PMS_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 dram0 permission monitor configuration register 2.                  */
    
    struct {
      __IM  uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_INTR : 1;/*!< recorded core1 dram0 permission monitor interrupt status.  */
      __IM  uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_LOCK : 1;/*!< recorded core1 dram0 lock status, 1 means s32c1i access. */
      __IM  uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WORLD : 2;/*!< recorded core1 dram0 world status, 0x1 means world0, 0x2 means
                                                     world1.                                                                   */
      __IM  uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_ADDR : 22;/*!< recorded core1 dram0 address[25:4] status when core1 dram0 violated
                                                     permission,the real address is 0x3c000000+addr*16                         */
            uint32_t            : 6;
    } bit;
  } CORE_1_DRAM0_PMS_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 dram0 permission monitor configuration register 3.                  */
    
    struct {
      __IM  uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_WR : 1;/*!< recorded core1 dram0 wr status, 1 means store, 0 means load. */
      __IM  uint32_t CORE_1_DRAM0_PMS_MONITOR_VIOLATE_STATUS_BYTEEN : 16;/*!< recorded core1 dram0 byteen status.              */
            uint32_t            : 15;
    } bit;
  } CORE_1_DRAM0_PMS_MONITOR_3;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 0.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock core0 access peripherals permission Configuration
                                                     Register.                                                                 */
            uint32_t            : 31;
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 1.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART : 2;/*!< Core0 access uart permission in world0.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_1 : 2;/*!< Core0 access g0spi_1 permission in world0.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_0 : 2;/*!< Core0 access g0spi_0 permission in world0.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_GPIO : 2;/*!< Core0 access gpio permission in world0.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_FE2 : 2;/*!< Core0 access fe2 permission in world0.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_FE : 2;/*!< Core0 access fe permission in world0.                        */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RTC : 2;/*!< Core0 access rtc permission in world0.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_IO_MUX : 2;/*!< Core0 access io_mux permission in world0.                */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_HINF : 2;/*!< Core0 access hinf permission in world0.                    */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_MISC : 2;/*!< Core0 access misc permission in world0.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C : 2;/*!< Core0 access i2c permission in world0.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2S0 : 2;/*!< Core0 access i2s0 permission in world0.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART1 : 2;/*!< Core0 access uart1 permission in world0.                  */
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 2.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BT : 2;/*!< Core0 access bt permission in world0.                        */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT0 : 2;/*!< Core0 access i2c_ext0 permission in world0.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UHCI0 : 2;/*!< Core0 access uhci0 permission in world0.                  */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SLCHOST : 2;/*!< Core0 access slchost permission in world0.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RMT : 2;/*!< Core0 access rmt permission in world0.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PCNT : 2;/*!< Core0 access pcnt permission in world0.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SLC : 2;/*!< Core0 access slc permission in world0.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_LEDC : 2;/*!< Core0 access ledc permission in world0.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BACKUP : 2;/*!< Core0 access backup permission in world0.                */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BB : 2;/*!< Core0 access bb permission in world0.                        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PWM0 : 2;/*!< Core0 access pwm0 permission in world0.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP : 2;/*!< Core0 access timergroup permission in world0.        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP1 : 2;/*!< Core0 access timergroup1 permission in world0.      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SYSTIMER : 2;/*!< Core0 access systimer permission in world0.            */
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_2;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 3.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SPI_2 : 2;/*!< Core0 access spi_2 permission in world0.                  */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SPI_3 : 2;/*!< Core0 access spi_3 permission in world0.                  */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_APB_CTRL : 2;/*!< Core0 access apb_ctrl permission in world0.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT1 : 2;/*!< Core0 access i2c_ext1 permission in world0.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SDIO_HOST : 2;/*!< Core0 access sdio_host permission in world0.          */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CAN : 2;/*!< Core0 access can permission in world0.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PWM1 : 2;/*!< Core0 access pwm1 permission in world0.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_I2S1 : 2;/*!< Core0 access i2s1 permission in world0.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_UART2 : 2;/*!< Core0 access uart2 permission in world0.                  */
            uint32_t            : 4;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_RWBT : 2;/*!< Core0 access rwbt permission in world0.                    */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WIFIMAC : 2;/*!< Core0 access wifimac permission in world0.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_PWR : 2;/*!< Core0 access pwr permission in world0.                      */
            uint32_t            : 2;
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_3;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 4.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB_DEVICE : 2;/*!< Core0 access usb_device permission in world0.        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB_WRAP : 2;/*!< Core0 access usb_wrap permission in world0.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_PERI : 2;/*!< Core0 access crypto_peri permission in world0.      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_DMA : 2;/*!< Core0 access crypto_dma permission in world0.        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_APB_ADC : 2;/*!< Core0 access apb_adc permission in world0.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_LCD_CAM : 2;/*!< Core0 access lcd_cam permission in world0.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_BT_PWR : 2;/*!< Core0 access bt_pwr permission in world0.                */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_USB : 2;/*!< Core0 access usb permission in world0.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SYSTEM : 2;/*!< Core0 access system permission in world0.                */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_SENSITIVE : 2;/*!< Core0 access sensitive permission in world0.          */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_INTERRUPT : 2;/*!< Core0 access interrupt permission in world0.          */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_DMA_COPY : 2;/*!< Core0 access dma_copy permission in world0.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_CACHE_CONFIG : 2;/*!< Core0 access cache_config permission in world0.    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_AD : 2;/*!< Core0 access ad permission in world0.                        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_DIO : 2;/*!< Core0 access dio permission in world0.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_0_WORLD_CONTROLLER : 2;/*!< Core0 access world_controller permission in world0. */
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_4;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 5.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART : 2;/*!< Core0 access uart permission in world1.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_1 : 2;/*!< Core0 access g0spi_1 permission in world1.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_0 : 2;/*!< Core0 access g0spi_0 permission in world1.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_GPIO : 2;/*!< Core0 access gpio permission in world1.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_FE2 : 2;/*!< Core0 access fe2 permission in world1.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_FE : 2;/*!< Core0 access fe permission in world1.                        */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RTC : 2;/*!< Core0 access rtc permission in world1.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_IO_MUX : 2;/*!< Core0 access io_mux permission in world1.                */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_HINF : 2;/*!< Core0 access hinf permission in world1.                    */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_MISC : 2;/*!< Core0 access misc permission in world1.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C : 2;/*!< Core0 access i2c permission in world1.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2S0 : 2;/*!< Core0 access i2s0 permission in world1.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART1 : 2;/*!< Core0 access uart1 permission in world1.                  */
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_5;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 6.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BT : 2;/*!< Core0 access bt permission in world1.                        */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT0 : 2;/*!< Core0 access i2c_ext0 permission in world1.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UHCI0 : 2;/*!< Core0 access uhci0 permission in world1.                  */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SLCHOST : 2;/*!< Core0 access slchost permission in world1.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RMT : 2;/*!< Core0 access rmt permission in world1.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PCNT : 2;/*!< Core0 access pcnt permission in world1.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SLC : 2;/*!< Core0 access slc permission in world1.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_LEDC : 2;/*!< Core0 access ledc permission in world1.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BACKUP : 2;/*!< Core0 access backup permission in world1.                */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BB : 2;/*!< Core0 access bb permission in world1.                        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PWM0 : 2;/*!< Core0 access pwm0 permission in world1.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP : 2;/*!< Core0 access timergroup permission in world1.        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP1 : 2;/*!< Core0 access timergroup1 permission in world1.      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SYSTIMER : 2;/*!< Core0 access systimer permission in world1.            */
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_6;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 7.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SPI_2 : 2;/*!< Core0 access spi_2 permission in world1.                  */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SPI_3 : 2;/*!< Core0 access spi_3 permission in world1.                  */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_APB_CTRL : 2;/*!< Core0 access apb_ctrl permission in world1.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT1 : 2;/*!< Core0 access i2c_ext1 permission in world1.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SDIO_HOST : 2;/*!< Core0 access sdio_host permission in world1.          */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CAN : 2;/*!< Core0 access can permission in world1.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PWM1 : 2;/*!< Core0 access pwm1 permission in world1.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_I2S1 : 2;/*!< Core0 access i2s1 permission in world1.                    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_UART2 : 2;/*!< Core0 access uart2 permission in world1.                  */
            uint32_t            : 4;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_RWBT : 2;/*!< Core0 access rwbt permission in world1.                    */
            uint32_t            : 2;
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WIFIMAC : 2;/*!< Core0 access wifimac permission in world1.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_PWR : 2;/*!< Core0 access pwr permission in world1.                      */
            uint32_t            : 2;
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_7;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 8.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB_DEVICE : 2;/*!< Core0 access usb_device permission in world1.        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB_WRAP : 2;/*!< Core0 access usb_wrap permission in world1.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_PERI : 2;/*!< Core0 access crypto_peri permission in world1.      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_DMA : 2;/*!< Core0 access crypto_dma permission in world1.        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_APB_ADC : 2;/*!< Core0 access apb_adc permission in world1.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_LCD_CAM : 2;/*!< Core0 access lcd_cam permission in world1.              */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_BT_PWR : 2;/*!< Core0 access bt_pwr permission in world1.                */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_USB : 2;/*!< Core0 access usb permission in world1.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SYSTEM : 2;/*!< Core0 access system permission in world1.                */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_SENSITIVE : 2;/*!< Core0 access sensitive permission in world1.          */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_INTERRUPT : 2;/*!< Core0 access interrupt permission in world1.          */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_DMA_COPY : 2;/*!< Core0 access dma_copy permission in world1.            */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_CACHE_CONFIG : 2;/*!< Core0 access cache_config permission in world1.    */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_AD : 2;/*!< Core0 access ad permission in world1.                        */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_DIO : 2;/*!< Core0 access dio permission in world1.                      */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_WORLD_1_WORLD_CONTROLLER : 2;/*!< Core0 access world_controller permission in world1. */
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_8;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 9.             */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0 : 11;/*!< RTCFast memory split address in world 0 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1 : 11;/*!< RTCFast memory split address in world 1 for core0. */
            uint32_t            : 10;
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_9;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 10.            */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L : 3;/*!< RTCFast memory low region permission in world 0 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H : 3;/*!< RTCFast memory high region permission in world 0 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L : 3;/*!< RTCFast memory low region permission in world 1 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H : 3;/*!< RTCFast memory high region permission in world 1 for core0. */
            uint32_t            : 20;
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_10;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 11.            */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_SPLTADDR_WORLD_0 : 11;/*!< RTCSlow_0 memory split address in world 0 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_SPLTADDR_WORLD_1 : 11;/*!< RTCSlow_0 memory split address in world 1 for core0. */
            uint32_t            : 10;
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_11;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 12.            */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_0_L : 3;/*!< RTCSlow_0 memory low region permission in world 0 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_0_H : 3;/*!< RTCSlow_0 memory high region permission in world 0 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_1_L : 3;/*!< RTCSlow_0 memory low region permission in world 1 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_1_H : 3;/*!< RTCSlow_0 memory high region permission in world 1 for core0. */
            uint32_t            : 20;
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_12;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 13.            */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_SPLTADDR_WORLD_0 : 11;/*!< RTCSlow_1 memory split address in world 0 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_SPLTADDR_WORLD_1 : 11;/*!< RTCSlow_1 memory split address in world 1 for core0. */
            uint32_t            : 10;
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_13;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 access peripherals permission configuration register 14.            */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_0_L : 3;/*!< RTCSlow_1 memory low region permission in world 0 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_0_H : 3;/*!< RTCSlow_1 memory high region permission in world 0 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_1_L : 3;/*!< RTCSlow_1 memory low region permission in world 1 for core0. */
      __IOM uint32_t CORE_0_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_1_H : 3;/*!< RTCSlow_1 memory high region permission in world 1 for core0. */
            uint32_t            : 20;
    } bit;
  } CORE_0_PIF_PMS_CONSTRAIN_14;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 0.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock core0 region permission registers.                */
            uint32_t            : 31;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 1.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_0 : 2;/*!< Region 0 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_1 : 2;/*!< Region 1 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_2 : 2;/*!< Region 2 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_3 : 2;/*!< Region 3 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_4 : 2;/*!< Region 4 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_5 : 2;/*!< Region 5 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_6 : 2;/*!< Region 6 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_7 : 2;/*!< Region 7 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_8 : 2;/*!< Region 8 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_9 : 2;/*!< Region 9 permission in world 0 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_0_AREA_10 : 2;/*!< Region 10 permission in world 0 for core0.           */
            uint32_t            : 10;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 2.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_0 : 2;/*!< Region 0 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_1 : 2;/*!< Region 1 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_2 : 2;/*!< Region 2 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_3 : 2;/*!< Region 3 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_4 : 2;/*!< Region 4 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_5 : 2;/*!< Region 5 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_6 : 2;/*!< Region 6 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_7 : 2;/*!< Region 7 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_8 : 2;/*!< Region 8 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_9 : 2;/*!< Region 9 permission in world 1 for core0.             */
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_WORLD_1_AREA_10 : 2;/*!< Region 10 permission in world 1 for core0.           */
            uint32_t            : 10;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_2;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 3.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_0 : 30;/*!< Region 0 start address for core0.                            */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_3;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 4.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_1 : 30;/*!< Region 0 end address and Region 1 start address for core0.   */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_4;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 5.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_2 : 30;/*!< Region 1 end address and Region 2 start address for core0.   */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_5;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 6.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_3 : 30;/*!< Region 2 end address and Region 3 start address for core0.   */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_6;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 7.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_4 : 30;/*!< Region 3 end address and Region 4 start address for core0.   */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_7;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 8.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_5 : 30;/*!< Region 4 end address and Region 5 start address for core0.   */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_8;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 9.                                       */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_6 : 30;/*!< Region 5 end address and Region 6 start address for core0.   */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_9;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 10.                                      */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_7 : 30;/*!< Region 6 end address and Region 7 start address for core0.   */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_10;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 11.                                      */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_8 : 30;/*!< Region 7 end address and Region 8 start address for core0.   */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_11;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 12.                                      */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_9 : 30;/*!< Region 8 end address and Region 9 start address for core0.   */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_12;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 13.                                      */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_10 : 30;/*!< Region 9 end address and Region 10 start address for core0. */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_13;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 region permission register 14.                                      */
    
    struct {
      __IOM uint32_t CORE_0_REGION_PMS_CONSTRAIN_ADDR_11 : 30;/*!< Region 10 end address for core0.                            */
            uint32_t            : 2;
    } bit;
  } CORE_0_REGION_PMS_CONSTRAIN_14;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 permission report register 0.                                       */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_MONITOR_LOCK : 1;/*!< Set 1 to lock core0 permission report registers.                     */
            uint32_t            : 31;
    } bit;
  } CORE_0_PIF_PMS_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 permission report register 1.                                       */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_CLR : 1;/*!< Set 1 to clear interrupt that core0 initiate illegal PIF bus
                                                     access.                                                                   */
      __IOM uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_EN : 1;/*!< Set 1 to enable interrupt that core0 initiate illegal PIF bus
                                                     access.                                                                   */
            uint32_t            : 30;
    } bit;
  } CORE_0_PIF_PMS_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 permission report register 2.                                       */
    
    struct {
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_INTR : 1;/*!< Record core0 illegal access interrupt state.                 */
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HPORT_0 : 1;/*!< Record hport information when core0 initiate illegal access. */
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HSIZE : 3;/*!< Record access type when core0 initate illegal access. */
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HWRITE : 1;/*!< Record access direction when core0 initiate illegal access. */
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HWORLD : 2;/*!< Record world information when core0 initiate illegal access. */
            uint32_t            : 24;
    } bit;
  } CORE_0_PIF_PMS_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 permission report register 3.                                       */
    
    struct {
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_VIOLATE_STATUS_HADDR : 32;/*!< Record address information when core0 initiate illegal access. */
    } bit;
  } CORE_0_PIF_PMS_MONITOR_3;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 permission report register 4.                                       */
    
    struct {
      __IOM uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_CLR : 1;/*!< Set 1 to clear interrupt that core0 initiate unsupported access
                                                     type.                                                                     */
      __IOM uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_EN : 1;/*!< Set 1 to enable interrupt that core0 initiate unsupported access
                                                     type.                                                                     */
            uint32_t            : 30;
    } bit;
  } CORE_0_PIF_PMS_MONITOR_4;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 permission report register 5.                                       */
    
    struct {
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_INTR : 1;/*!< Record core0 unsupported access type interrupt state. */
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HSIZE : 2;/*!< Record access type when core0 initiate unsupported access type. */
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HWORLD : 2;/*!< Record world information when core0 initiate unsupported access
                                                     type.                                                                     */
            uint32_t            : 27;
    } bit;
  } CORE_0_PIF_PMS_MONITOR_5;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 permission report register 6.                                       */
    
    struct {
      __IM  uint32_t CORE_0_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HADDR : 32;/*!< Record address information when core0 initiate unsupported access
                                                     type.                                                                     */
    } bit;
  } CORE_0_PIF_PMS_MONITOR_6;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 vecbase override configuration register 0                           */
    
    struct {
      __IOM uint32_t CORE_0_VECBASE_OVERRIDE_LOCK : 1;/*!< Set 1 to lock core0 vecbase configuration register                  */
            uint32_t            : 31;
    } bit;
  } CORE_0_VECBASE_OVERRIDE_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 vecbase override configuration register 0                           */
    
    struct {
      __IOM uint32_t CORE_0_VECBASE_WORLD_MASK : 1;/*!< Set 1 to mask world, then only world0_value will work.                 */
            uint32_t            : 31;
    } bit;
  } CORE_0_VECBASE_OVERRIDE_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 vecbase override configuration register 1                           */
    
    struct {
      __IOM uint32_t CORE_0_VECBASE_OVERRIDE_WORLD0_VALUE : 22;/*!< world0 vecbase_override register, when core0 in world0 use this
                                                     register to override vecbase register.                                    */
      __IOM uint32_t CORE_0_VECBASE_OVERRIDE_SEL : 2;/*!< Set 0x3 to sel vecbase_override to override vecbase register.        */
            uint32_t            : 8;
    } bit;
  } CORE_0_VECBASE_OVERRIDE_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 vecbase override configuration register 1                           */
    
    struct {
      __IOM uint32_t CORE_0_VECBASE_OVERRIDE_WORLD1_VALUE : 22;/*!< world1 vecbase_override register, when core0 in world1 use this
                                                     register to override vecbase register.                                    */
            uint32_t            : 10;
    } bit;
  } CORE_0_VECBASE_OVERRIDE_2;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 toomanyexception override configuration register 0.                 */
    
    struct {
      __IOM uint32_t CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE_LOCK : 1;/*!< Set 1 to lock core0 toomanyexception override configuration
                                                     register                                                                  */
            uint32_t            : 31;
    } bit;
  } CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core0 toomanyexception override configuration register 1.                 */
    
    struct {
      __IOM uint32_t CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE : 1;/*!< Set 1 to mask toomanyexception.                              */
            uint32_t            : 31;
    } bit;
  } CORE_0_TOOMANYEXCEPTIONS_M_OVERRIDE_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 0.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock core1 pif permission configuration register.         */
            uint32_t            : 31;
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 1.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_UART : 2;/*!< Core1 access uart permission in world0.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_1 : 2;/*!< Core1 access g0spi_1 permission in world0.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_G0SPI_0 : 2;/*!< Core1 access g0spi_0 permission in world0.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_GPIO : 2;/*!< Core1 access gpio permission in world0.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_FE2 : 2;/*!< Core1 access fe2 permission in world0.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_FE : 2;/*!< Core1 access fe permission in world0.                        */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_RTC : 2;/*!< Core1 access rtc permission in world0.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_IO_MUX : 2;/*!< Core1 access io_mux permission in world0.                */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_HINF : 2;/*!< Core1 access hinf permission in world0.                    */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_MISC : 2;/*!< Core1 access misc permission in world0.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2C : 2;/*!< Core1 access i2c permission in world0.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2S0 : 2;/*!< Core1 access i2s0 permission in world0.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_UART1 : 2;/*!< Core1 access uart1 permission in world0.                  */
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 2.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_BT : 2;/*!< Core1 access bt permission in world0.                        */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT0 : 2;/*!< Core1 access i2c_ext0 permission in world0.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_UHCI0 : 2;/*!< Core1 access uhci0 permission in world0.                  */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SLCHOST : 2;/*!< Core1 access slchost permission in world0.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_RMT : 2;/*!< Core1 access rmt permission in world0.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_PCNT : 2;/*!< Core1 access pcnt permission in world0.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SLC : 2;/*!< Core1 access slc permission in world0.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_LEDC : 2;/*!< Core1 access ledc permission in world0.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_BACKUP : 2;/*!< Core1 access backup permission in world0.                */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_BB : 2;/*!< Core1 access bb permission in world0.                        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_PWM0 : 2;/*!< Core1 access pwm0 permission in world0.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP : 2;/*!< Core1 access timergroup permission in world0.        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_TIMERGROUP1 : 2;/*!< Core1 access timergroup1 permission in world0.      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SYSTIMER : 2;/*!< Core1 access systimer permission in world0.            */
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_2;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 3.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SPI_2 : 2;/*!< Core1 access spi_2 permission in world0.                  */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SPI_3 : 2;/*!< Core1 access spi_3 permission in world0.                  */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_APB_CTRL : 2;/*!< Core1 access apb_ctrl permission in world0.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2C_EXT1 : 2;/*!< Core1 access i2c_ext1 permission in world0.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SDIO_HOST : 2;/*!< Core1 access sdio_host permission in world0.          */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_CAN : 2;/*!< Core1 access can permission in world0.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_PWM1 : 2;/*!< Core1 access pwm1 permission in world0.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_I2S1 : 2;/*!< Core1 access i2s1 permission in world0.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_UART2 : 2;/*!< Core1 access uart2 permission in world0.                  */
            uint32_t            : 4;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_RWBT : 2;/*!< Core1 access rwbt permission in world0.                    */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_WIFIMAC : 2;/*!< Core1 access wifimac permission in world0.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_PWR : 2;/*!< Core1 access pwr permission in world0.                      */
            uint32_t            : 2;
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_3;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 4.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_USB_DEVICE : 2;/*!< Core1 access usb_device permission in world0.        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_USB_WRAP : 2;/*!< Core1 access usb_wrap permission in world0.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_PERI : 2;/*!< Core1 access crypto_peri permission in world0.      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_CRYPTO_DMA : 2;/*!< Core1 access crypto_dma permission in world0.        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_APB_ADC : 2;/*!< Core1 access apb_adc permission in world0.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_LCD_CAM : 2;/*!< Core1 access lcd_cam permission in world0.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_BT_PWR : 2;/*!< Core1 access bt_pwr permission in world0.                */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_USB : 2;/*!< Core1 access usb permission in world0.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SYSTEM : 2;/*!< Core1 access system permission in world0.                */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_SENSITIVE : 2;/*!< Core1 access sensitive permission in world0.          */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_INTERRUPT : 2;/*!< Core1 access interrupt permission in world0.          */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_DMA_COPY : 2;/*!< Core1 access dma_copy permission in world0.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_CACHE_CONFIG : 2;/*!< Core1 access cache_config permission in world0.    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_AD : 2;/*!< Core1 access ad permission in world0.                        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_DIO : 2;/*!< Core1 access dio permission in world0.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_0_WORLD_CONTROLLER : 2;/*!< Core1 access world_controller permission in world0. */
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_4;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 5.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_UART : 2;/*!< Core1 access uart permission in world1.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_1 : 2;/*!< Core1 access g0spi_1 permission in world1.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_G0SPI_0 : 2;/*!< Core1 access g0spi_0 permission in world1.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_GPIO : 2;/*!< Core1 access gpio permission in world1.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_FE2 : 2;/*!< Core1 access fe2 permission in world1.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_FE : 2;/*!< Core1 access fe permission in world1.                        */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_RTC : 2;/*!< Core1 access rtc permission in world1.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_IO_MUX : 2;/*!< Core1 access io_mux permission in world1.                */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_HINF : 2;/*!< Core1 access hinf permission in world1.                    */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_MISC : 2;/*!< Core1 access misc permission in world1.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2C : 2;/*!< Core1 access i2c permission in world1.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2S0 : 2;/*!< Core1 access i2s0 permission in world1.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_UART1 : 2;/*!< Core1 access uart1 permission in world1.                  */
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_5;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 6.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_BT : 2;/*!< Core1 access bt permission in world1.                        */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT0 : 2;/*!< Core1 access i2c_ext0 permission in world1.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_UHCI0 : 2;/*!< Core1 access uhci0 permission in world1.                  */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SLCHOST : 2;/*!< Core1 access slchost permission in world1.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_RMT : 2;/*!< Core1 access rmt permission in world1.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_PCNT : 2;/*!< Core1 access pcnt permission in world1.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SLC : 2;/*!< Core1 access slc permission in world1.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_LEDC : 2;/*!< Core1 access ledc permission in world1.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_BACKUP : 2;/*!< Core1 access backup permission in world1.                */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_BB : 2;/*!< Core1 access bb permission in world1.                        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_PWM0 : 2;/*!< Core1 access pwm0 permission in world1.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP : 2;/*!< Core1 access timergroup permission in world1.        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_TIMERGROUP1 : 2;/*!< Core1 access timergroup1 permission in world1.      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SYSTIMER : 2;/*!< Core1 access systimer permission in world1.            */
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_6;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 7.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SPI_2 : 2;/*!< Core1 access spi_2 permission in world1.                  */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SPI_3 : 2;/*!< Core1 access spi_3 permission in world1.                  */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_APB_CTRL : 2;/*!< Core1 access apb_ctrl permission in world1.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2C_EXT1 : 2;/*!< Core1 access i2c_ext1 permission in world1.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SDIO_HOST : 2;/*!< Core1 access sdio_host permission in world1.          */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_CAN : 2;/*!< Core1 access can permission in world1.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_PWM1 : 2;/*!< Core1 access pwm1 permission in world1.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_I2S1 : 2;/*!< Core1 access i2s1 permission in world1.                    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_UART2 : 2;/*!< Core1 access uart2 permission in world1.                  */
            uint32_t            : 4;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_RWBT : 2;/*!< Core1 access rwbt permission in world1.                    */
            uint32_t            : 2;
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_WIFIMAC : 2;/*!< Core1 access wifimac permission in world1.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_PWR : 2;/*!< Core1 access pwr permission in world1.                      */
            uint32_t            : 2;
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_7;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 8.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_USB_DEVICE : 2;/*!< Core1 access usb_device permission in world1.        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_USB_WRAP : 2;/*!< Core1 access usb_wrap permission in world1.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_PERI : 2;/*!< Core1 access crypto_peri permission in world1.      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_CRYPTO_DMA : 2;/*!< Core1 access crypto_dma permission in world1.        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_APB_ADC : 2;/*!< Core1 access apb_adc permission in world1.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_LCD_CAM : 2;/*!< Core1 access lcd_cam permission in world1.              */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_BT_PWR : 2;/*!< Core1 access bt_pwr permission in world1.                */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_USB : 2;/*!< Core1 access usb permission in world1.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SYSTEM : 2;/*!< Core1 access system permission in world1.                */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_SENSITIVE : 2;/*!< Core1 access sensitive permission in world1.          */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_INTERRUPT : 2;/*!< Core1 access interrupt permission in world1.          */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_DMA_COPY : 2;/*!< Core1 access dma_copy permission in world1.            */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_CACHE_CONFIG : 2;/*!< Core1 access cache_config permission in world1.    */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_AD : 2;/*!< Core1 access ad permission in world1.                        */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_DIO : 2;/*!< Core1 access dio permission in world1.                      */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_WORLD_1_WORLD_CONTROLLER : 2;/*!< Core1 access world_controller permission in world1. */
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_8;
  
  union {
    __IOM uint32_t reg;                         /*!< Core1 access peripherals permission configuration register 9.             */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_0 : 11;/*!< RTCFast memory split address in world 0 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_SPLTADDR_WORLD_1 : 11;/*!< RTCFast memory split address in world 1 for core1. */
            uint32_t            : 10;
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_9;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 access peripherals permission configuration register 10.            */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_L : 3;/*!< RTCFast memory low region permission in world 0 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_0_H : 3;/*!< RTCFast memory high region permission in world 0 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_L : 3;/*!< RTCFast memory low region permission in world 1 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCFAST_WORLD_1_H : 3;/*!< RTCFast memory high region permission in world 1 for core1. */
            uint32_t            : 20;
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_10;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 access peripherals permission configuration register 11.            */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_SPLTADDR_WORLD_0 : 11;/*!< RTCSlow_0 memory split address in world 0 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_SPLTADDR_WORLD_1 : 11;/*!< RTCSlow_0 memory split address in world 1 for core1. */
            uint32_t            : 10;
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_11;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 access peripherals permission configuration register 12.            */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_0_L : 3;/*!< RTCSlow_0 memory low region permission in world 0 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_0_H : 3;/*!< RTCSlow_0 memory high region permission in world 0 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_1_L : 3;/*!< RTCSlow_0 memory low region permission in world 1 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_0_WORLD_1_H : 3;/*!< RTCSlow_0 memory high region permission in world 1 for core1. */
            uint32_t            : 20;
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_12;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 access peripherals permission configuration register 13.            */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_SPLTADDR_WORLD_0 : 11;/*!< RTCSlow_1 memory split address in world 0 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_SPLTADDR_WORLD_1 : 11;/*!< RTCSlow_1 memory split address in world 1 for core1. */
            uint32_t            : 10;
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_13;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 access peripherals permission configuration register 14.            */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_0_L : 3;/*!< RTCSlow_1 memory low region permission in world 0 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_0_H : 3;/*!< RTCSlow_1 memory high region permission in world 0 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_1_L : 3;/*!< RTCSlow_1 memory low region permission in world 1 for core1. */
      __IOM uint32_t CORE_1_PIF_PMS_CONSTRAIN_RTCSLOW_1_WORLD_1_H : 3;/*!< RTCSlow_1 memory high region permission in world 1 for core1. */
            uint32_t            : 20;
    } bit;
  } CORE_1_PIF_PMS_CONSTRAIN_14;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 0.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock core1 region permission registers.                */
            uint32_t            : 31;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 1.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_0 : 2;/*!< Region 0 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_1 : 2;/*!< Region 1 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_2 : 2;/*!< Region 2 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_3 : 2;/*!< Region 3 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_4 : 2;/*!< Region 4 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_5 : 2;/*!< Region 5 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_6 : 2;/*!< Region 6 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_7 : 2;/*!< Region 7 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_8 : 2;/*!< Region 8 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_9 : 2;/*!< Region 9 permission in world 0 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_0_AREA_10 : 2;/*!< Region 10 permission in world 0 for core1.           */
            uint32_t            : 10;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 2.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_0 : 2;/*!< Region 0 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_1 : 2;/*!< Region 1 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_2 : 2;/*!< Region 2 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_3 : 2;/*!< Region 3 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_4 : 2;/*!< Region 4 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_5 : 2;/*!< Region 5 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_6 : 2;/*!< Region 6 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_7 : 2;/*!< Region 7 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_8 : 2;/*!< Region 8 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_9 : 2;/*!< Region 9 permission in world 1 for core1.             */
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_WORLD_1_AREA_10 : 2;/*!< Region 10 permission in world 1 for core1.           */
            uint32_t            : 10;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_2;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 3.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_0 : 30;/*!< Region 0 start address for core1.                            */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_3;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 4.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_1 : 30;/*!< Region 0 end address and Region 1 start address for core1.   */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_4;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 5.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_2 : 30;/*!< Region 1 end address and Region 2 start address for core1.   */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_5;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 6.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_3 : 30;/*!< Region 2 end address and Region 3 start address for core1.   */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_6;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 7.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_4 : 30;/*!< Region 3 end address and Region 4 start address for core1.   */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_7;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 8.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_5 : 30;/*!< Region 4 end address and Region 5 start address for core1.   */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_8;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 9.                                       */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_6 : 30;/*!< Region 5 end address and Region 6 start address for core1.   */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_9;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 10.                                      */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_7 : 30;/*!< Region 6 end address and Region 7 start address for core1.   */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_10;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 11.                                      */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_8 : 30;/*!< Region 7 end address and Region 8 start address for core1.   */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_11;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 12.                                      */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_9 : 30;/*!< Region 8 end address and Region 9 start address for core1.   */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_12;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 13.                                      */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_10 : 30;/*!< Region 9 end address and Region 10 start address for core1. */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_13;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 region permission register 14.                                      */
    
    struct {
      __IOM uint32_t CORE_1_REGION_PMS_CONSTRAIN_ADDR_11 : 30;/*!< Region 10 end address for core1.                            */
            uint32_t            : 2;
    } bit;
  } CORE_1_REGION_PMS_CONSTRAIN_14;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 permission report register 0.                                       */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_MONITOR_LOCK : 1;/*!< Set 1 to lock core1 permission report registers.                     */
            uint32_t            : 31;
    } bit;
  } CORE_1_PIF_PMS_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 permission report register 1.                                       */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_CLR : 1;/*!< Set 1 to clear interrupt that core1 initiate illegal PIF bus
                                                     access.                                                                   */
      __IOM uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_EN : 1;/*!< Set 1 to enable interrupt that core1 initiate illegal PIF bus
                                                     access.                                                                   */
            uint32_t            : 30;
    } bit;
  } CORE_1_PIF_PMS_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 permission report register 2.                                       */
    
    struct {
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_INTR : 1;/*!< Record core1 illegal access interrupt state.                 */
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HPORT_0 : 1;/*!< Record hport information when core1 initiate illegal access. */
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HSIZE : 3;/*!< Record access type when core1 initate illegal access. */
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HWRITE : 1;/*!< Record access direction when core1 initiate illegal access. */
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HWORLD : 2;/*!< Record world information when core1 initiate illegal access. */
            uint32_t            : 24;
    } bit;
  } CORE_1_PIF_PMS_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 permission report register 3.                                       */
    
    struct {
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_VIOLATE_STATUS_HADDR : 32;/*!< Record address information when core1 initiate illegal access. */
    } bit;
  } CORE_1_PIF_PMS_MONITOR_3;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 permission report register 4.                                       */
    
    struct {
      __IOM uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_CLR : 1;/*!< Set 1 to clear interrupt that core1 initiate unsupported access
                                                     type.                                                                     */
      __IOM uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_EN : 1;/*!< Set 1 to enable interrupt that core1 initiate unsupported access
                                                     type.                                                                     */
            uint32_t            : 30;
    } bit;
  } CORE_1_PIF_PMS_MONITOR_4;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 permission report register 5.                                       */
    
    struct {
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_INTR : 1;/*!< Record core1 unsupported access type interrupt state. */
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HSIZE : 2;/*!< Record access type when core1 initiate unsupported access type. */
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HWORLD : 2;/*!< Record world information when core1 initiate unsupported access
                                                     type.                                                                     */
            uint32_t            : 27;
    } bit;
  } CORE_1_PIF_PMS_MONITOR_5;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 permission report register 6.                                       */
    
    struct {
      __IM  uint32_t CORE_1_PIF_PMS_MONITOR_NONWORD_VIOLATE_STATUS_HADDR : 32;/*!< Record address information when core1 initiate unsupported access
                                                     type.                                                                     */
    } bit;
  } CORE_1_PIF_PMS_MONITOR_6;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 vecbase override configuration register 0                           */
    
    struct {
      __IOM uint32_t CORE_1_VECBASE_OVERRIDE_LOCK : 1;/*!< Set 1 to lock core1 vecbase configuration register                  */
            uint32_t            : 31;
    } bit;
  } CORE_1_VECBASE_OVERRIDE_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 vecbase override configuration register 0                           */
    
    struct {
      __IOM uint32_t CORE_1_VECBASE_WORLD_MASK : 1;/*!< Set 1 to mask world, then only world0_value will work.                 */
            uint32_t            : 31;
    } bit;
  } CORE_1_VECBASE_OVERRIDE_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 vecbase override configuration register 1                           */
    
    struct {
      __IOM uint32_t CORE_1_VECBASE_OVERRIDE_WORLD0_VALUE : 22;/*!< world0 vecbase_override register, when core1 in world0 use this
                                                     register to override vecbase register.                                    */
      __IOM uint32_t CORE_1_VECBASE_OVERRIDE_SEL : 2;/*!< Set 0x3 to sel vecbase_override to override vecbase register.        */
            uint32_t            : 8;
    } bit;
  } CORE_1_VECBASE_OVERRIDE_1;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 vecbase override configuration register 1                           */
    
    struct {
      __IOM uint32_t CORE_1_VECBASE_OVERRIDE_WORLD1_VALUE : 22;/*!< world1 vecbase_override register, when core1 in world1 use this
                                                     register to override vecbase register.                                    */
            uint32_t            : 10;
    } bit;
  } CORE_1_VECBASE_OVERRIDE_2;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 toomanyexception override configuration register 0.                 */
    
    struct {
      __IOM uint32_t CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE_LOCK : 1;/*!< Set 1 to lock core1 toomanyexception override configuration
                                                     register                                                                  */
            uint32_t            : 31;
    } bit;
  } CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE_0;
  
  union {
    __IOM uint32_t reg;                         /*!< core1 toomanyexception override configuration register 1.                 */
    
    struct {
      __IOM uint32_t CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE : 1;/*!< Set 1 to mask toomanyexception.                              */
            uint32_t            : 31;
    } bit;
  } CORE_1_TOOMANYEXCEPTIONS_M_OVERRIDE_1;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp access peripherals permission configuration register
                                                     0.                                                                        */
    
    struct {
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_LOCK : 1;/*!< Set 1 to lock BackUp permission configuration registers.           */
            uint32_t            : 31;
    } bit;
  } BACKUP_BUS_PMS_CONSTRAIN_0;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp access peripherals permission configuration register
                                                     1.                                                                        */
    
    struct {
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_UART : 2;/*!< BackUp access uart permission.                                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_G0SPI_1 : 2;/*!< BackUp access g0spi_1 permission.                               */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_G0SPI_0 : 2;/*!< BackUp access g0spi_0 permission.                               */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_GPIO : 2;/*!< BackUp access gpio permission.                                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_FE2 : 2;/*!< BackUp access fe2 permission.                                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_FE : 2;/*!< BackUp access fe permission.                                         */
            uint32_t            : 2;
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_RTC : 2;/*!< BackUp access rtc permission.                                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_IO_MUX : 2;/*!< BackUp access io_mux permission.                                 */
            uint32_t            : 2;
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_HINF : 2;/*!< BackUp access hinf permission.                                     */
            uint32_t            : 2;
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_MISC : 2;/*!< BackUp access misc permission.                                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2C : 2;/*!< BackUp access i2c permission.                                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2S0 : 2;/*!< BackUp access i2s0 permission.                                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_UART1 : 2;/*!< BackUp access uart1 permission.                                   */
    } bit;
  } BACKUP_BUS_PMS_CONSTRAIN_1;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp access peripherals permission configuration register
                                                     2.                                                                        */
    
    struct {
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_BT : 2;/*!< BackUp access bt permission.                                         */
            uint32_t            : 2;
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2C_EXT0 : 2;/*!< BackUp access i2c_ext0 permission.                             */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_UHCI0 : 2;/*!< BackUp access uhci0 permission.                                   */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_SLCHOST : 2;/*!< BackUp access slchost permission.                               */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_RMT : 2;/*!< BackUp access rmt permission.                                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_PCNT : 2;/*!< BackUp access pcnt permission.                                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_SLC : 2;/*!< BackUp access slc permission.                                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_LEDC : 2;/*!< BackUp access ledc permission.                                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_BACKUP : 2;/*!< BackUp access backup permission.                                 */
            uint32_t            : 2;
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_BB : 2;/*!< BackUp access bb permission.                                         */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_PWM0 : 2;/*!< BackUp access pwm0 permission.                                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_TIMERGROUP : 2;/*!< BackUp access timergroup permission.                         */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_TIMERGROUP1 : 2;/*!< BackUp access timergroup1 permission.                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_SYSTIMER : 2;/*!< BackUp access systimer permission.                             */
    } bit;
  } BACKUP_BUS_PMS_CONSTRAIN_2;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp access peripherals permission configuration register
                                                     3.                                                                        */
    
    struct {
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_SPI_2 : 2;/*!< BackUp access spi_2 permission.                                   */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_SPI_3 : 2;/*!< BackUp access spi_3 permission.                                   */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_APB_CTRL : 2;/*!< BackUp access apb_ctrl permission.                             */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2C_EXT1 : 2;/*!< BackUp access i2c_ext1 permission.                             */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_SDIO_HOST : 2;/*!< BackUp access sdio_host permission.                           */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_CAN : 2;/*!< BackUp access can permission.                                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_PWM1 : 2;/*!< BackUp access pwm1 permission.                                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_I2S1 : 2;/*!< BackUp access i2s1 permission.                                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_UART2 : 2;/*!< BackUp access uart2 permission.                                   */
            uint32_t            : 4;
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_RWBT : 2;/*!< BackUp access rwbt permission.                                     */
            uint32_t            : 2;
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_WIFIMAC : 2;/*!< BackUp access wifimac permission.                               */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_PWR : 2;/*!< BackUp access pwr permission.                                       */
            uint32_t            : 2;
    } bit;
  } BACKUP_BUS_PMS_CONSTRAIN_3;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp access peripherals permission configuration register
                                                     4.                                                                        */
    
    struct {
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_USB_DEVICE : 2;/*!< BackUp access usb_device permission.                         */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_USB_WRAP : 2;/*!< BackUp access usb_wrap permission.                             */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_CRYPTO_PERI : 2;/*!< BackUp access crypto_peri permission.                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_CRYPTO_DMA : 2;/*!< BackUp access crypto_dma permission.                         */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_APB_ADC : 2;/*!< BackUp access apb_adc permission.                               */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_LCD_CAM : 2;/*!< BackUp access lcd_cam permission.                               */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_BT_PWR : 2;/*!< BackUp access bt_pwr permission.                                 */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_USB : 2;/*!< BackUp access usb permission.                                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_SYSTEM : 2;/*!< BackUp access system permission.                                 */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_SENSITIVE : 2;/*!< BackUp access sensitive permission.                           */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_INTERRUPT : 2;/*!< BackUp access interrupt permission.                           */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_DMA_COPY : 2;/*!< BackUp access dma_copy permission.                             */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_CACHE_CONFIG : 2;/*!< BackUp access cache_config permission.                     */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_AD : 2;/*!< BackUp access ad permission.                                         */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_DIO : 2;/*!< BackUp access dio permission.                                       */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_WORLD_CONTROLLER : 2;/*!< BackUp access world_controller permission.             */
    } bit;
  } BACKUP_BUS_PMS_CONSTRAIN_4;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp access peripherals permission configuration register
                                                     5.                                                                        */
    
    struct {
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_RTCFAST_SPLTADDR : 11;/*!< BackUp access rtcfast_spltaddr permission.            */
            uint32_t            : 21;
    } bit;
  } BACKUP_BUS_PMS_CONSTRAIN_5;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp access peripherals permission configuration register
                                                     6.                                                                        */
    
    struct {
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_RTCFAST_L : 3;/*!< BackUp access rtcfast_l permission.                           */
      __IOM uint32_t BACKUP_BUS_PMS_CONSTRAIN_RTCFAST_H : 3;/*!< BackUp access rtcfast_h permission.                           */
            uint32_t            : 26;
    } bit;
  } BACKUP_BUS_PMS_CONSTRAIN_6;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp permission report register 0.                                      */
    
    struct {
      __IOM uint32_t BACKUP_BUS_PMS_MONITOR_LOCK : 1;/*!< Set 1 to lock BackUp permission report registers.                    */
            uint32_t            : 31;
    } bit;
  } BACKUP_BUS_PMS_MONITOR_0;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp permission report register 1.                                      */
    
    struct {
      __IOM uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_CLR : 1;/*!< Set 1 to clear interrupt that BackUp initiate illegal access. */
      __IOM uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_EN : 1;/*!< Set 1 to enable interrupt that BackUp initiate illegal access. */
            uint32_t            : 30;
    } bit;
  } BACKUP_BUS_PMS_MONITOR_1;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp permission report register 2.                                      */
    
    struct {
      __IM  uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_INTR : 1;/*!< Record BackUp illegal access interrupt state.                */
      __IM  uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HTRANS : 2;/*!< Record htrans when BackUp initate illegal access.   */
      __IM  uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HSIZE : 3;/*!< Record access type when BackUp initate illegal access. */
      __IM  uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_STATUS_HWRITE : 1;/*!< Record access direction when BackUp initiate illegal access. */
            uint32_t            : 25;
    } bit;
  } BACKUP_BUS_PMS_MONITOR_2;
  
  union {
    __IOM uint32_t reg;                         /*!< BackUp permission report register 3.                                      */
    
    struct {
      __IM  uint32_t BACKUP_BUS_PMS_MONITOR_VIOLATE_HADDR : 32;/*!< Record address information when BackUp initiate illegal access. */
    } bit;
  } BACKUP_BUS_PMS_MONITOR_3;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA boundary lock register.                                              */
    
    struct {
      __IOM uint32_t EDMA_BOUNDARY_LOCK : 1;    /*!< Set 1 to lock EDMA boundary registers.                                    */
            uint32_t            : 31;
    } bit;
  } EDMA_BOUNDARY_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA boundary 0 configuration                                             */
    
    struct {
      __IOM uint32_t EDMA_BOUNDARY_0 : 14;      /*!< This field is used to configure the boundary 0 of external RAM.
                                                     The unit is 4K. For example, set this field to 0x80, then
                                                     the address boundary 0 would be 0x3C080000 (0x3C000000
                                                     + 0x80 * 4K).                                                             */
            uint32_t            : 18;
    } bit;
  } EDMA_BOUNDARY_0;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA boundary 1 configuration                                             */
    
    struct {
      __IOM uint32_t EDMA_BOUNDARY_1 : 14;      /*!< This field is used to configure the boundary 1 of external RAM.
                                                     The unit is 4K. For example, set this field to 0x80, then
                                                     the address boundary 0 would be 0x3C080000 (0x3C000000
                                                     + 0x80 * 4K).                                                             */
            uint32_t            : 18;
    } bit;
  } EDMA_BOUNDARY_1;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA boundary 2 configuration                                             */
    
    struct {
      __IOM uint32_t EDMA_BOUNDARY_2 : 14;      /*!< This field is used to configure the boundary 2 of external RAM.
                                                     The unit is 4K. For example, set this field to 0x80, then
                                                     the address boundary 0 would be 0x3C080000 (0x3C000000
                                                     + 0x80 * 4K).                                                             */
            uint32_t            : 18;
    } bit;
  } EDMA_BOUNDARY_2;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-SPI2 permission lock register.                                       */
    
    struct {
      __IOM uint32_t EDMA_PMS_SPI2_LOCK : 1;    /*!< Set 1 to lock EDMA-SPI2 permission control registers.                     */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_SPI2_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-SPI2 permission control register.                                    */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of SPI2 accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of SPI2 accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_SPI2;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-SPI3 permission lock register.                                       */
    
    struct {
      __IOM uint32_t EDMA_PMS_SPI3_LOCK : 1;    /*!< Set 1 to lock EDMA-SPI3 permission control registers.                     */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_SPI3_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-SPI3 permission control register.                                    */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of SPI3 accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of SPI3 accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_SPI3;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-UHCI0 permission lock register.                                      */
    
    struct {
      __IOM uint32_t EDMA_PMS_UHCI0_LOCK : 1;   /*!< Set 1 to lock EDMA-UHCI0 permission control registers.                    */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_UHCI0_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-UHCI0 permission control register.                                   */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of UHCI0 accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of UHCI0 accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_UHCI0;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-I2S0 permission lock register.                                       */
    
    struct {
      __IOM uint32_t EDMA_PMS_I2S0_LOCK : 1;    /*!< Set 1 to lock EDMA-I2S0 permission control registers.                     */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_I2S0_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-I2S0 permission control register.                                    */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of I2S0 accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of I2S0 accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_I2S0;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-I2S1 permission lock register.                                       */
    
    struct {
      __IOM uint32_t EDMA_PMS_I2S1_LOCK : 1;    /*!< Set 1 to lock EDMA-I2S1 permission control registers.                     */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_I2S1_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-I2S1 permission control register.                                    */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of I2S1 accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of I2S1 accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_I2S1;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-LCD/CAM permission lock register.                                    */
    
    struct {
      __IOM uint32_t EDMA_PMS_LCD_CAM_LOCK : 1; /*!< Set 1 to lock EDMA-LCD/CAM permission control registers.                  */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_LCD_CAM_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-LCD/CAM permission control register.                                 */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of LCD/CAM accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of LCD/CAM accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_LCD_CAM;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-AES permission lock register.                                        */
    
    struct {
      __IOM uint32_t EDMA_PMS_AES_LOCK : 1;     /*!< Set 1 to lock EDMA-AES permission control registers.                      */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_AES_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-AES permission control register.                                     */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of AES accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of AES accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_AES;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-SHA permission lock register.                                        */
    
    struct {
      __IOM uint32_t EDMA_PMS_SHA_LOCK : 1;     /*!< Set 1 to lock EDMA-SHA permission control registers.                      */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_SHA_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-SHA permission control register.                                     */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of SHA accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of SHA accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_SHA;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-ADC/DAC permission lock register.                                    */
    
    struct {
      __IOM uint32_t EDMA_PMS_ADC_DAC_LOCK : 1; /*!< Set 1 to lock EDMA-ADC/DAC permission control registers.                  */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_ADC_DAC_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-ADC/DAC permission control register.                                 */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of ADC/DAC accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of ADC/DAC accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_ADC_DAC;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-RMT permission lock register.                                        */
    
    struct {
      __IOM uint32_t EDMA_PMS_RMT_LOCK : 1;     /*!< Set 1 to lock EDMA-RMT permission control registers.                      */
            uint32_t            : 31;
    } bit;
  } EDMA_PMS_RMT_LOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA-RMT permission control register.                                     */
    
    struct {
      __IOM uint32_t ATTR1      : 2;            /*!< This field is used to configure the permission of RMT accessing
                                                     address, which is larger than boundary 0 and less than
                                                     boundary 1, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
      __IOM uint32_t ATTR2      : 2;            /*!< This field is used to configure the permission of RMT accessing
                                                     address, which is larger than boundary 1 and less than
                                                     boundary 2, through EDMA. Bit 0: set this bit to enable
                                                     read permission. Bit 1: set this bit to enable write permission.          */
            uint32_t            : 28;
    } bit;
  } EDMA_PMS_RMT;
  
  union {
    __IOM uint32_t reg;                         /*!< Sensitive module clock gate configuration register.                       */
    
    struct {
      __IOM uint32_t REG_CLK_EN : 1;            /*!< Set 1 to enable clock gate function.                                      */
            uint32_t            : 31;
    } bit;
  } CLOCK_GATE;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC coprocessor permission register.                                      */
    
    struct {
      __IOM uint32_t DIS_RTC_CPU : 1;           /*!< Set 1 to disable rtc coprocessor.                                         */
            uint32_t            : 31;
    } bit;
  } RTC_PMS;
  __IM  uint32_t  RESERVED[827];
  
  union {
    __IOM uint32_t reg;                         /*!< Sensitive version register.                                               */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< Sensitive Date register.                                                  */
            uint32_t            : 4;
    } bit;
  } DATE;
} SENSITIVE_Type;                               /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            SHA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SHA (Secure Hash Algorithm) Accelerator (SHA)
  */

typedef struct {                                /*!< SHA Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Initial configuration register.                                           */
    
    struct {
      __IOM uint32_t MODE       : 3;            /*!< sha mode                                                                  */
            uint32_t            : 29;
    } bit;
  } MODE;
  
  union {
    __IOM uint32_t reg;                         /*!< SHA 512/t configuration register 0.                                       */
    
    struct {
      __IOM uint32_t T_STRING   : 32;           /*!< sha t_string(used if and only if mode == sha_256/t)                       */
    } bit;
  } T_STRING;
  
  union {
    __IOM uint32_t reg;                         /*!< SHA 512/t configuration register 1.                                       */
    
    struct {
      __IOM uint32_t T_LENGTH   : 6;            /*!< sha t_length(used if and only if mode == sha_256/t)                       */
            uint32_t            : 26;
    } bit;
  } T_LENGTH;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA configuration register 0.                                             */
    
    struct {
      __IOM uint32_t DMA_BLOCK_NUM : 6;         /*!< dma-sha block number                                                      */
            uint32_t            : 26;
    } bit;
  } DMA_BLOCK_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< Typical SHA configuration register 0.                                     */
    
    struct {
            uint32_t            : 1;
      __OM  uint32_t START      : 31;           /*!< reserved.                                                                 */
    } bit;
  } START;
  
  union {
    __IOM uint32_t reg;                         /*!< Typical SHA configuration register 1.                                     */
    
    struct {
            uint32_t            : 1;
      __OM  uint32_t CONTINUE   : 31;           /*!< reserved.                                                                 */
    } bit;
  } CONTINUE;
  
  union {
    __IOM uint32_t reg;                         /*!< Busy register.                                                            */
    
    struct {
      __IM  uint32_t STATE      : 1;            /*!< sha busy state. 1'b0: idle 1'b1: busy                                     */
            uint32_t            : 31;
    } bit;
  } BUSY;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA configuration register 1.                                             */
    
    struct {
      __OM  uint32_t DMA_START  : 1;            /*!< start dma-sha                                                             */
            uint32_t            : 31;
    } bit;
  } DMA_START;
  
  union {
    __IOM uint32_t reg;                         /*!< DMA configuration register 2.                                             */
    
    struct {
      __OM  uint32_t DMA_CONTINUE : 1;          /*!< continue dma-sha                                                          */
            uint32_t            : 31;
    } bit;
  } DMA_CONTINUE;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear register.                                                 */
    
    struct {
      __OM  uint32_t CLEAR_INTERRUPT : 1;       /*!< clear sha interrupt                                                       */
            uint32_t            : 31;
    } bit;
  } CLEAR_IRQ;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable register.                                                */
    
    struct {
      __IOM uint32_t INTERRUPT_ENA : 1;         /*!< sha interrupt enable register. 1'b0: disable(default) 1'b1:
                                                     enable                                                                    */
            uint32_t            : 31;
    } bit;
  } IRQ_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Date register.                                                            */
    
    struct {
      __IOM uint32_t DATE       : 30;           /*!< sha date information/ sha version information                             */
            uint32_t            : 2;
    } bit;
  } DATE;
  __IM  uint32_t  RESERVED[4];
  __IOM uint32_t  H_MEM[16];                    /*!< Sha H memory which contains intermediate hash or finial hash.             */
  __IOM uint32_t  M_MEM[16];                    /*!< Sha M memory which contains message.                                      */
} SHA_Type;                                     /*!< Size = 192 (0xc0)                                                         */



/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI (Serial Peripheral Interface) Controller 0 (SPI0)
  */

typedef struct {                                /*!< SPI0 Structure                                                            */
  __IM  uint32_t  RESERVED[2];
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 control register.                                                    */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t FDUMMY_OUT : 1;            /*!< In the DUMMY phase the signal level of SPI bus is output by
                                                     the SPI0 controller.                                                      */
      __IOM uint32_t FDOUT_OCT  : 1;            /*!< Set this bit to enable 8-bit-mode(8-bm) in DOUT phase.                    */
      __IOM uint32_t FDIN_OCT   : 1;            /*!< Set this bit to enable 8-bit-mode(8-bm) in DIN phase.                     */
      __IOM uint32_t FADDR_OCT  : 1;            /*!< Set this bit to enable 8-bit-mode(8-bm) in ADDR phase.                    */
      __IOM uint32_t FCMD_DUAL  : 1;            /*!< Set this bit to enable 2-bit-mode(2-bm) in CMD phase.                     */
      __IOM uint32_t FCMD_QUAD  : 1;            /*!< Set this bit to enable 4-bit-mode(4-bm) in CMD phase.                     */
      __IOM uint32_t FCMD_OCT   : 1;            /*!< Set this bit to enable 8-bit-mode(8-bm) in CMD phase.                     */
            uint32_t            : 3;
      __IOM uint32_t FASTRD_MODE : 1;           /*!< This bit should be set when SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO,
                                                     SPI_MEM_FREAD_QUAD or SPI_MEM_FREAD_DUAL is set.                          */
      __IOM uint32_t FREAD_DUAL : 1;            /*!< In hardware 0x3B read operation, DIN phase apply 2 signals.
                                                     1: enable 0: disable.                                                     */
            uint32_t            : 3;
      __IOM uint32_t Q_POL      : 1;            /*!< The bit is used to set MISO line polarity, 1: high 0, low                 */
      __IOM uint32_t D_POL      : 1;            /*!< The bit is used to set MOSI line polarity, 1: high 0, low                 */
      __IOM uint32_t FREAD_QUAD : 1;            /*!< In hardware 0x6B read operation, DIN phase apply 4 signals(4-bit-mode).
                                                     1: enable 0: disable.                                                     */
      __IOM uint32_t WP         : 1;            /*!< Write protect signal output when SPI is idle. 1: output high,
                                                     0: output low.                                                            */
            uint32_t            : 1;
      __IOM uint32_t FREAD_DIO  : 1;            /*!< In hardware 0xBB read operation, ADDR phase and DIN phase apply
                                                     2 signals(2-bit-mode). 1: enable 0: disable.                              */
      __IOM uint32_t FREAD_QIO  : 1;            /*!< In hardware 0xEB read operation, ADDR phase and DIN phase apply
                                                     4 signals(4-bit-mode). 1: enable 0: disable.                              */
            uint32_t            : 7;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 control 1 register.                                                  */
    
    struct {
      __IOM uint32_t CLK_MODE   : 2;            /*!< SPI Bus clock (SPI_CLK) mode bits. 0: SPI Bus clock (SPI_CLK)
                                                     is off when CS inactive 1: SPI_CLK is delayed one cycle
                                                     after SPI_CS inactive 2: SPI_CLK is delayed two cycles
                                                     after SPI_CS inactive 3: SPI_CLK is always on.                            */
            uint32_t            : 28;
      __IOM uint32_t RXFIFO_RST : 1;            /*!< SPI0 RX FIFO reset signal. Set this bit and clear it before
                                                     SPI0 transfer starts.                                                     */
            uint32_t            : 1;
    } bit;
  } CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 control 2 register.                                                  */
    
    struct {
      __IOM uint32_t CS_SETUP_TIME : 5;         /*!< (cycles-1) of PREP phase by SPI_CLK, which is the SPI_CS setup
                                                     time. These bits are combined with SPI_MEM_CS_SETUP bit.                  */
      __IOM uint32_t CS_HOLD_TIME : 5;          /*!< SPI Bus CS (SPI_CS) signal is delayed to inactive by SPI Bus
                                                     clock (SPI_CLK), which is the SPI_CS hold time in non-ECC
                                                     mode. These bits are combined with SPI_MEM_CS_HOLD bit.                   */
      __IOM uint32_t ECC_CS_HOLD_TIME : 3;      /*!< SPI_MEM_CS_HOLD_TIME + SPI_MEM_ECC_CS_HOLD_TIME is the SPI_CS
                                                     hold cycle in ECC mode when accessed flash.                               */
      __IOM uint32_t ECC_SKIP_PAGE_CORNER : 1;  /*!< 1: MSPI skips page corner when accesses flash. 0: Not skip page
                                                     corner when accesses flash.                                               */
      __IOM uint32_t ECC_16TO18_BYTE_EN : 1;    /*!< Set this bit to enable MSPI ECC 16 bytes data with 2 ECC bytes
                                                     mode when accesses flash.                                                 */
            uint32_t            : 10;
      __IOM uint32_t CS_HOLD_DELAY : 6;         /*!< These bits are used to set the minimum CS high time tSHSL between
                                                     SPI burst transfer when accesses to flash. tSHSL is (SPI_MEM_CS_HOLD_DELA
                                                     [5:0] + 1) MSPI core clock cycles.                                        */
      __IOM uint32_t SYNC_RESET : 1;            /*!< The FSM will be reset.                                                    */
    } bit;
  } CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI_CLK clock division register when SPI0 accesses to flash.              */
    
    struct {
      __IOM uint32_t CLKCNT_L   : 8;            /*!< It must equal to the value of SPI_MEM_CLKCNT_N.                           */
      __IOM uint32_t CLKCNT_H   : 8;            /*!< It must be a floor value of ((SPI_MEM_CLKCNT_N+1)/2-1).                   */
      __IOM uint32_t CLKCNT_N   : 8;            /*!< When SPI0 accesses flash, f_SPI_CLK = f_MSPI_CORE_CLK/(SPI_MEM_CLKCNT_N+1) */
            uint32_t            : 7;
      __IOM uint32_t CLK_EQU_SYSCLK : 1;        /*!< When SPI0 accesses flash, set this bit in 1-division mode, f_SPI_CLK
                                                     = f_MSPI_CORE_CLK.                                                        */
    } bit;
  } CLOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 user register.                                                       */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t CS_HOLD    : 1;            /*!< Set this bit to keep SPI_CS low when MSPI is in DONE state.               */
      __IOM uint32_t CS_SETUP   : 1;            /*!< Set this bit to keep SPI_CS low when MSPI is in PREP state.               */
            uint32_t            : 1;
      __IOM uint32_t CK_OUT_EDGE : 1;           /*!< This bit, combined with SPI_MEM_CK_IDLE_EDGE bit, is used to
                                                     change the clock mode 0~3 of SPI_CLK.                                     */
            uint32_t            : 16;
      __IOM uint32_t USR_DUMMY_IDLE : 1;        /*!< SPI_CLK is disabled(No clock edges) in DUMMY phase when the
                                                     bit is enable.                                                            */
            uint32_t            : 2;
      __IOM uint32_t USR_DUMMY  : 1;            /*!< This bit enable the DUMMY phase of an SPI transfer.                       */
            uint32_t            : 2;
    } bit;
  } USER;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 user1 register.                                                      */
    
    struct {
      __IOM uint32_t USR_DUMMY_CYCLELEN : 6;    /*!< The SPI_CLK cycle length minus 1 of DUMMY phase.                          */
            uint32_t            : 20;
      __IOM uint32_t USR_ADDR_BITLEN : 6;       /*!< The length in bits of ADDR phase. The register value shall be
                                                     (bit_num-1).                                                              */
    } bit;
  } USER1;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 user2 register.                                                      */
    
    struct {
      __IOM uint32_t USR_COMMAND_VALUE : 16;    /*!< The value of user defined(USR) command.                                   */
            uint32_t            : 12;
      __IOM uint32_t USR_COMMAND_BITLEN : 4;    /*!< The length in bits of CMD phase. The register value shall be
                                                     (bit_num-1)                                                               */
    } bit;
  } USER2;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 read control register.                                               */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t WB_MODE    : 8;            /*!< Mode bits in the flash fast read mode it is combined with SPI_MEM_FASTRD_MODE
                                                     bit.                                                                      */
            uint32_t            : 8;
    } bit;
  } RD_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 extended address register.                                           */
    
    struct {
      __IOM uint32_t EXT_ADDR   : 32;           /*!< The register are the higher 32bits in the 64 bits address mode.           */
    } bit;
  } EXT_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 misc register                                                        */
    
    struct {
            uint32_t            : 7;
      __IOM uint32_t FSUB_PIN   : 1;            /*!< Flash is connected to SPI SUBPIN bus.                                     */
      __IOM uint32_t SSUB_PIN   : 1;            /*!< Ext_RAM is connected to SPI SUBPIN bus.                                   */
      __IOM uint32_t CK_IDLE_EDGE : 1;          /*!< 1: SPI_CLK line is high when idle. 0: SPI_CLK line is low when
                                                     idle                                                                      */
      __IOM uint32_t CS_KEEP_ACTIVE : 1;        /*!< SPI_CS line keep low when the bit is set.                                 */
            uint32_t            : 21;
    } bit;
  } MISC;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 external RAM bit mode control register.                              */
    
    struct {
      __IOM uint32_t CACHE_REQ_EN : 1;          /*!< Set this bit to enable Cache's access and SPI0's transfer.                */
      __IOM uint32_t CACHE_USR_CMD_4BYTE : 1;   /*!< Set this bit to enable SPI0 read flash with 32 bits address.
                                                     The value of SPI_MEM_USR_ADDR_BITLEN should be 31.                        */
      __IOM uint32_t CACHE_FLASH_USR_CMD : 1;   /*!< 1: The command value of SPI0 reads flash is SPI_MEM_USR_COMMAND_VALUE.
                                                     0: Hardware read command value, controlled by SPI_MEM_FREAD_QIO,
                                                     SPI_MEM_FREAD_DIO, SPI_MEM_FREAD_QUAD, SPI_MEM_FREAD_DUAL
                                                     and SPI_MEM_FASTRD_MODE bits.                                             */
      __IOM uint32_t FDIN_DUAL  : 1;            /*!< When SPI0 accesses to flash, set this bit to enable 2-bm in
                                                     DIN phase.                                                                */
      __IOM uint32_t FDOUT_DUAL : 1;            /*!< When SPI0 accesses to flash, set this bit to enable 2-bm in
                                                     DOUT phase.                                                               */
      __IOM uint32_t FADDR_DUAL : 1;            /*!< When SPI0 accesses to flash, set this bit to enable 2-bm in
                                                     ADDR phase.                                                               */
      __IOM uint32_t FDIN_QUAD  : 1;            /*!< When SPI0 accesses to flash, set this bit to enable 4-bm in
                                                     DIN phase.                                                                */
      __IOM uint32_t FDOUT_QUAD : 1;            /*!< When SPI0 accesses to flash, set this bit to enable 4-bm in
                                                     DOUT phase.                                                               */
      __IOM uint32_t FADDR_QUAD : 1;            /*!< When SPI0 accesses to flash, set this bit to enable 4-bm in
                                                     ADDR phase.                                                               */
            uint32_t            : 23;
    } bit;
  } CACHE_FCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 external RAM control register                                        */
    
    struct {
      __IOM uint32_t CACHE_USR_SCMD_4BYTE : 1;  /*!< Set this bit to enable SPI0 read Ext_RAM with 32 bits address.
                                                     The value of SPI_MEM_SRAM_ADDR_BITLEN should be 31.                       */
      __IOM uint32_t USR_SRAM_DIO : 1;          /*!< Set the bit to enable 2-bm in all the phases of SPI0 Ext_RAM
                                                     transfer.                                                                 */
      __IOM uint32_t USR_SRAM_QIO : 1;          /*!< Set the bit to enable QPI mode in all SPI0 Ext_RAM transfer.              */
      __IOM uint32_t USR_WR_SRAM_DUMMY : 1;     /*!< When SPI0 accesses to Ext_RAM, set this bit to enable DUMMY
                                                     phase in write operations.                                                */
      __IOM uint32_t USR_RD_SRAM_DUMMY : 1;     /*!< When SPI0 accesses to Ext_RAM, set this bit to enable DUMMY
                                                     phase in read operations.                                                 */
      __IOM uint32_t CACHE_SRAM_USR_RCMD : 1;   /*!< 1: The command value of SPI0 read Ext_RAM is SPI_MEM_CACHE_SRAM_USR_WR_CMD_VAL
                                                     E. 0: The value is 0x2.                                                   */
      __IOM uint32_t SRAM_RDUMMY_CYCLELEN : 6;  /*!< When SPI0 accesses to Ext_RAM, it is the SPI_CLK cycles minus
                                                     1 of DUMMY phase in read data transfer.                                   */
            uint32_t            : 2;
      __IOM uint32_t SRAM_ADDR_BITLEN : 6;      /*!< When SPI0 accesses to Ext_RAM, it is the length in bits of ADDR
                                                     phase. The register value shall be (bit_num-1).                           */
      __IOM uint32_t CACHE_SRAM_USR_WCMD : 1;   /*!< 1: The command value of SPI0 write Ext_RAM is SPI_MEM_CACHE_SRAM_USR_RD_CMD_VA
                                                     UE. 0: The value is 0x3.                                                  */
      __IOM uint32_t SRAM_OCT   : 1;            /*!< Set the bit to enable OPI mode in all SPI0 Ext_RAM transfer.              */
      __IOM uint32_t SRAM_WDUMMY_CYCLELEN : 6;  /*!< When SPI0 accesses to Ext_RAM, it is the SPI_CLK cycles minus
                                                     1 of DUMMY phase in write data transfer.                                  */
            uint32_t            : 4;
    } bit;
  } CACHE_SCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 external RAM mode control register                                   */
    
    struct {
      __IOM uint32_t SCLK_MODE  : 2;            /*!< SPI_CLK mode bits when SPI0 accesses to Ext_RAM. 0: SPI_CLK
                                                     is off when CS inactive 1: SPI_CLK is delayed one cycle
                                                     after CS inactive 2: SPI_CLK is delayed two cycles after
                                                     CS inactive 3: SPI_CLK is always on.                                      */
      __IOM uint32_t SWB_MODE   : 8;            /*!< Mode bits when SPI0 accesses to Ext_RAM.                                  */
      __IOM uint32_t SDIN_DUAL  : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 2-bm in
                                                     DIN phase.                                                                */
      __IOM uint32_t SDOUT_DUAL : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 2-bm in
                                                     DOUT phase.                                                               */
      __IOM uint32_t SADDR_DUAL : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 2-bm in
                                                     ADDR phase.                                                               */
      __IOM uint32_t SCMD_DUAL  : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 2-bm in
                                                     CMD phase.                                                                */
      __IOM uint32_t SDIN_QUAD  : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 4-bm in
                                                     DIN phase.                                                                */
      __IOM uint32_t SDOUT_QUAD : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 4-bm in
                                                     DOUT phase.                                                               */
      __IOM uint32_t SADDR_QUAD : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 4-bm in
                                                     ADDR phase.                                                               */
      __IOM uint32_t SCMD_QUAD  : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 4-bm in
                                                     CMD phase.                                                                */
      __IOM uint32_t SDIN_OCT   : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 8-bm in
                                                     DIN phase.                                                                */
      __IOM uint32_t SDOUT_OCT  : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 8-bm in
                                                     DOUT phase.                                                               */
      __IOM uint32_t SADDR_OCT  : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 8-bm in
                                                     ADDR phase.                                                               */
      __IOM uint32_t SCMD_OCT   : 1;            /*!< When SPI0 accesses to Ext_RAM, set this bit to enable 8-bm in
                                                     CMD phase.                                                                */
      __IOM uint32_t SDUMMY_OUT : 1;            /*!< When SPI0 accesses to Ext_RAM, in the DUMMY phase the signal
                                                     level of SPI bus is output by the SPI0 controller.                        */
            uint32_t            : 9;
    } bit;
  } SRAM_CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 external RAM DDR read command control register                       */
    
    struct {
      __IOM uint32_t CACHE_SRAM_USR_RD_CMD_VALUE : 16;/*!< When SPI0 reads Ext_RAM, it is the command value of CMD phase.      */
            uint32_t            : 12;
      __IOM uint32_t CACHE_SRAM_USR_RD_CMD_BITLEN : 4;/*!< When SPI0 reads Ext_RAM, it is the length in bits of CMD phase.
                                                     The register value shall be (bit_num-1).                                  */
    } bit;
  } SRAM_DRD_CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 external RAM DDR write command control register                      */
    
    struct {
      __IOM uint32_t CACHE_SRAM_USR_WR_CMD_VALUE : 16;/*!< When SPI0 writes Ext_RAM, it is the command value of CMD phase.     */
            uint32_t            : 12;
      __IOM uint32_t CACHE_SRAM_USR_WR_CMD_BITLEN : 4;/*!< When SPI0 writes Ext_RAM, it is the length in bits of CMD phase.
                                                     The register value shall be (bit_num-1).                                  */
    } bit;
  } SRAM_DWR_CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI_CLK clock division register when SPI0 accesses to Ext_RAM.            */
    
    struct {
      __IOM uint32_t SCLKCNT_L  : 8;            /*!< It must equal to the value of SPI_MEM_SCLKCNT_N.                          */
      __IOM uint32_t SCLKCNT_H  : 8;            /*!< It must be a floor value of ((SPI_MEM_SCLKCNT_N+1)/2-1).                  */
      __IOM uint32_t SCLKCNT_N  : 8;            /*!< When SPI0 accesses to Ext_RAM, f_SPI_CLK = f_MSPI_CORE_CLK/(SPI_MEM_SCLKCNT_N+
                                                     )                                                                         */
            uint32_t            : 7;
      __IOM uint32_t SCLK_EQU_SYSCLK : 1;       /*!< When SPI0 accesses to Ext_RAM, set this bit in 1-division mode,
                                                     f_SPI_CLK = f_MSPI_CORE_CLK.                                              */
    } bit;
  } SRAM_CLK;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 state machine(FSM) status register.                                  */
    
    struct {
      __IM  uint32_t ST         : 3;            /*!< The status of SPI0 state machine. 0: idle state(IDLE), 1: preparation
                                                     state(PREP), 2: send command state(CMD), 3: send address
                                                     state(ADDR), 4: red data state(DIN), 5:write data state(DOUT),
                                                     6: wait state(DUMMY), 7: done state(DONE).                                */
            uint32_t            : 29;
    } bit;
  } FSM;
  __IM  uint32_t  RESERVED3[20];
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 timing compensation register when accesses to flash.                 */
    
    struct {
      __IOM uint32_t TIMING_CLK_ENA : 1;        /*!< Set this bit to power on HCLK. When PLL is powered on, the frequency
                                                     of HCLK equals to that of PLL. Otherwise, the frequency
                                                     equals to that of XTAL.                                                   */
      __IOM uint32_t TIMING_CALI : 1;           /*!< Set this bit to add extra SPI_CLK cycles in DUMMY phase for
                                                     all reading operations.                                                   */
      __IOM uint32_t EXTRA_DUMMY_CYCLELEN : 3;  /*!< Extra SPI_CLK cycles added in DUMMY phase for timing compensation,
                                                     when SPI0 accesses to flash. Active when SPI_MEM_TIMING_CALI
                                                     bit is set.                                                               */
            uint32_t            : 27;
    } bit;
  } TIMING_CALI;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI input timing delay mode control register when accesses
                                                     to flash.                                                                 */
    
    struct {
      __IOM uint32_t DIN0_MODE  : 3;            /*!< SPI_D input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN0_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN0_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_MEM_DIN0_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_MEM_DIN0_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_MEM_DIN0_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t DIN1_MODE  : 3;            /*!< SPI_Q input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN3_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN3_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_MEM_DIN3_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_MEM_DIN3_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_MEM_DIN3_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t DIN2_MODE  : 3;            /*!< SPI_WP input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN6_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN6_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_MEM_DIN6_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_MEM_DIN6_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_MEM_DIN6_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t DIN3_MODE  : 3;            /*!< SPI_HD input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN9_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN9_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_MEM_DIN9_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_MEM_DIN9_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_MEM_DIN9_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t DIN4_MODE  : 3;            /*!< SPI_IO4 input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN12_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN12_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_MEM_DIN12_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_MEM_DIN12_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_MEM_DIN12_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t DIN5_MODE  : 3;            /*!< SPI_IO5 input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN15_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN15_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_MEM_DIN15_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_MEM_DIN15_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_MEM_DIN15_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t DIN6_MODE  : 3;            /*!< SPI_IO6 input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN18_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN18_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_MEM_DIN18_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_MEM_DIN18_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_MEM_DIN18_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t DIN7_MODE  : 3;            /*!< SPI_IO7 input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DIN21_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DIN21_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_MEM_DIN21_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_MEM_DIN21_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_MEM_DIN21_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t DINS_MODE  : 3;            /*!< SPI_DQS input delay mode. 0: No delay. 1: Delay for (SPI_MEM_DINS_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_MEM_DINS_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_MEM_DINS_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_MEM_DINS_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_MEM_DINS_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
            uint32_t            : 5;
    } bit;
  } DIN_MODE;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI input timing delay number control register when accesses
                                                     to flash.                                                                 */
    
    struct {
      __IOM uint32_t DIN0_NUM   : 2;            /*!< SPI_D input delay number.                                                 */
      __IOM uint32_t DIN1_NUM   : 2;            /*!< SPI_Q input delay number.                                                 */
      __IOM uint32_t DIN2_NUM   : 2;            /*!< SPI_WP input delay number.                                                */
      __IOM uint32_t DIN3_NUM   : 2;            /*!< SPI_HD input delay number.                                                */
      __IOM uint32_t DIN4_NUM   : 2;            /*!< SPI_IO4 input delay number.                                               */
      __IOM uint32_t DIN5_NUM   : 2;            /*!< SPI_IO5 input delay number.                                               */
      __IOM uint32_t DIN6_NUM   : 2;            /*!< SPI_IO6 input delay number.                                               */
      __IOM uint32_t DIN7_NUM   : 2;            /*!< SPI_IO7 input delay number.                                               */
      __IOM uint32_t DINS_NUM   : 2;            /*!< SPI_DQS input delay number.                                               */
            uint32_t            : 14;
    } bit;
  } DIN_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI output timing delay mode control register when accesses
                                                     to flash.                                                                 */
    
    struct {
      __IOM uint32_t DOUT0_MODE : 1;            /*!< SPI_D output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t DOUT1_MODE : 1;            /*!< SPI_Q output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t DOUT2_MODE : 1;            /*!< SPI_WP output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t DOUT3_MODE : 1;            /*!< SPI_HD output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t DOUT4_MODE : 1;            /*!< SPI_IO4 output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t DOUT5_MODE : 1;            /*!< SPI_IO5 output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t DOUT6_MODE : 1;            /*!< SPI_IO6 output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t DOUT7_MODE : 1;            /*!< SPI_IO7 output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t DOUTS_MODE : 1;            /*!< SPI_DQS output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
            uint32_t            : 23;
    } bit;
  } DOUT_MODE;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 Ext_RAM timing compensation register.                                */
    
    struct {
      __IOM uint32_t SPI_SMEM_TIMING_CLK_ENA : 1;/*!< Set this bit to power on HCLK. When PLL is powered on, the frequency
                                                     of HCLK equals to that of PLL. Otherwise, the frequency
                                                     equals to that of XTAL.                                                   */
      __IOM uint32_t SPI_SMEM_TIMING_CALI : 1;  /*!< Set this bit to add extra SPI_CLK cycles in DUMMY phase for
                                                     all reading operations.                                                   */
      __IOM uint32_t SPI_SMEM_EXTRA_DUMMY_CYCLELEN : 3;/*!< Extra SPI_CLK cycles added in DUMMY phase for timing compensation,
                                                     when SPI0 accesses to Ext_RAM. Active when SPI_SMEM_TIMING_CALI
                                                     bit is set.                                                               */
            uint32_t            : 27;
    } bit;
  } SPI_SMEM_TIMING_CALI;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI input timing delay mode control register when accesses
                                                     to Ext_RAM.                                                               */
    
    struct {
      __IOM uint32_t SPI_SMEM_DIN0_MODE : 3;    /*!< SPI_D input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN0_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN0_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_SMEM_DIN0_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_SMEM_DIN0_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_SMEM_DIN0_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t SPI_SMEM_DIN1_MODE : 3;    /*!< SPI_Q input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN3_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN3_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_SMEM_DIN3_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_SMEM_DIN3_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_SMEM_DIN3_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t SPI_SMEM_DIN2_MODE : 3;    /*!< SPI_WP input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN6_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN6_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_SMEM_DIN6_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_SMEM_DIN6_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_SMEM_DIN6_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t SPI_SMEM_DIN3_MODE : 3;    /*!< SPI_HD input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN9_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN9_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_SMEM_DIN9_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_SMEM_DIN9_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_SMEM_DIN9_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t SPI_SMEM_DIN4_MODE : 3;    /*!< SPI_IO4 input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN12_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN12_NUM+1
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_SMEM_DIN12_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_SMEM_DIN12_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_SMEM_DIN12_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t SPI_SMEM_DIN5_MODE : 3;    /*!< SPI_IO5 input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN15_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN15_NUM+1
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_SMEM_DIN15_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_SMEM_DIN15_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_SMEM_DIN15_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t SPI_SMEM_DIN6_MODE : 3;    /*!< SPI_IO6 input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN18_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN18_NUM+1
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_SMEM_DIN18_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_SMEM_DIN18_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_SMEM_DIN18_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t SPI_SMEM_DIN7_MODE : 3;    /*!< SPI_IO7 input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DIN21_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DIN21_NUM+1
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_SMEM_DIN21_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_SMEM_DIN21_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_SMEM_DIN21_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
      __IOM uint32_t SPI_SMEM_DINS_MODE : 3;    /*!< SPI_DQS input delay mode. 0: No delay. 1: Delay for (SPI_SMEM_DINS_NUM+1)
                                                     cycles at MSPI_CORE_CLK negative edge. 2: Delay for (SPI_SMEM_DINS_NUM+1)
                                                     cycles at HCLK positive edge and one cycle at MSPI_CORE_CLK
                                                     positive edge. 3: Delay for (SPI_SMEM_DINS_NUM+1) cycles
                                                     at HCLK positive edge and one cycle at MSPI_CORE_CLK negative
                                                     edge. 4: Delay for (SPI_SMEM_DINS_NUM+1) cycles at HCLK
                                                     negative edge and one cycle at MSPI_CORE_CLK positive edge.
                                                     5: Delay for (SPI_SMEM_DINS_NUM+1) cycles at HCLK negative
                                                     edge and one cycle at MSPI_CORE_CLK negative edge.                        */
            uint32_t            : 5;
    } bit;
  } SPI_SMEM_DIN_MODE;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI input timing delay number control register when accesses
                                                     to Ext_RAM.                                                               */
    
    struct {
      __IOM uint32_t SPI_SMEM_DIN0_NUM : 2;     /*!< SPI_D input delay number.                                                 */
      __IOM uint32_t SPI_SMEM_DIN1_NUM : 2;     /*!< SPI_Q input delay number.                                                 */
      __IOM uint32_t SPI_SMEM_DIN2_NUM : 2;     /*!< SPI_WP input delay number.                                                */
      __IOM uint32_t SPI_SMEM_DIN3_NUM : 2;     /*!< SPI_HD input delay number.                                                */
      __IOM uint32_t SPI_SMEM_DIN4_NUM : 2;     /*!< SPI_IO4 input delay number.                                               */
      __IOM uint32_t SPI_SMEM_DIN5_NUM : 2;     /*!< SPI_IO5 input delay number.                                               */
      __IOM uint32_t SPI_SMEM_DIN6_NUM : 2;     /*!< SPI_IO6 input delay number.                                               */
      __IOM uint32_t SPI_SMEM_DIN7_NUM : 2;     /*!< SPI_IO7 input delay number.                                               */
      __IOM uint32_t SPI_SMEM_DINS_NUM : 2;     /*!< SPI_DQS input delay number.                                               */
            uint32_t            : 14;
    } bit;
  } SPI_SMEM_DIN_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI output timing delay mode control register when accesses
                                                     to Ext_RAM.                                                               */
    
    struct {
      __IOM uint32_t SPI_SMEM_DOUT0_MODE : 1;   /*!< SPI_D output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t SPI_SMEM_DOUT1_MODE : 1;   /*!< SPI_Q output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t SPI_SMEM_DOUT2_MODE : 1;   /*!< SPI_WP output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t SPI_SMEM_DOUT3_MODE : 1;   /*!< SPI_HD output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t SPI_SMEM_DOUT4_MODE : 1;   /*!< SPI_IO4 output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t SPI_SMEM_DOUT5_MODE : 1;   /*!< SPI_IO5 output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t SPI_SMEM_DOUT6_MODE : 1;   /*!< SPI_IO6 output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t SPI_SMEM_DOUT7_MODE : 1;   /*!< SPI_IO7 output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
      __IOM uint32_t SPI_SMEM_DOUTS_MODE : 1;   /*!< SPI_DQS output delay mode. 0: No delay. 1: Delay one cycle at
                                                     MSPI_CORE_CLK negative edge.                                              */
            uint32_t            : 23;
    } bit;
  } SPI_SMEM_DOUT_MODE;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI ECC control register                                                 */
    
    struct {
      __IOM uint32_t ECC_ERR_INT_NUM : 8;       /*!< Set the error times of MSPI ECC read to generate MSPI SPI_MEM_ECC_ERR_INT
                                                     interrupt.                                                                */
      __IOM uint32_t SPI_FMEM_ECC_ERR_INT_EN : 1;/*!< Set this bit to calculate the error times of MSPI ECC read when
                                                     accesses to flash.                                                        */
            uint32_t            : 23;
    } bit;
  } ECC_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI ECC error address register                                           */
    
    struct {
      __IM  uint32_t ECC_ERR_ADDR : 32;         /*!< These bits show the first MSPI ECC error address when SPI_FMEM_ECC_ERR_INT_EN/
                                                     PI_SMEM_ECC_ERR_INT_EN is set and accessed to flash/Ext_RAM,
                                                     including ECC byte error and data error. It is cleared
                                                     by when SPI_MEM_ECC_ERR_INT_CLR bit is set.                               */
    } bit;
  } ECC_ERR_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI ECC error bits register                                              */
    
    struct {
            uint32_t            : 6;
      __IM  uint32_t ECC_DATA_ERR_BIT : 7;      /*!< It records the first ECC data error bit number when SPI_FMEM_ECC_ERR_INT_EN/SP
                                                     _SMEM_ECC_ERR_INT_EN is set and accessed to flash/Ext_RAM.
                                                     The value ranges from 0~127, corresponding to the bit number
                                                     in 16 data bytes. It is cleared by SPI_MEM_ECC_ERR_INT_CLR
                                                     bit.                                                                      */
      __IM  uint32_t ECC_CHK_ERR_BIT : 3;       /*!< When SPI_MEM_ECC_BYTE_ERR is set, these bits show the error
                                                     bit number of ECC byte.                                                   */
      __IM  uint32_t ECC_BYTE_ERR : 1;          /*!< It records the first ECC byte error when SPI_FMEM_ECC_ERR_INT_EN/SPI_SMEM_ECC_
                                                     RR_INT_EN is set and accessed to flash/Ext_RAM. It is cleared
                                                     by SPI_MEM_ECC_ERR_INT_CLR bit.                                           */
      __IM  uint32_t ECC_ERR_CNT : 8;           /*!< This bits show the error times of MSPI ECC read, including ECC
                                                     byte error and data byte error. It is cleared by when SPI_MEM_ECC_ERR_INT
                                                     CLR bit is set.                                                           */
            uint32_t            : 7;
    } bit;
  } ECC_ERR_BIT;
  __IM  uint32_t  RESERVED5;
  
  union {
    __IOM uint32_t reg;                         /*!< MSPI external RAM ECC and SPI CS timing control register                  */
    
    struct {
      __IOM uint32_t SPI_SMEM_CS_SETUP : 1;     /*!< Set this bit to keep SPI_CS low when MSPI is in PREP state.               */
      __IOM uint32_t SPI_SMEM_CS_HOLD : 1;      /*!< Set this bit to keep SPI_CS low when MSPI is in DONE state.               */
      __IOM uint32_t SPI_SMEM_CS_SETUP_TIME : 5;/*!< (cycles-1) of PREP phase by SPI_CLK, which is the SPI_CS setup
                                                     time. These bits are combined with SPI_MEM_CS_SETUP bit.                  */
      __IOM uint32_t SPI_SMEM_CS_HOLD_TIME : 5; /*!< SPI Bus CS (SPI_CS) signal is delayed to inactive by SPI Bus
                                                     clock (SPI_CLK), which is the SPI_CS hold time in non-ECC
                                                     mode. These bits are combined with SPI_MEM_CS_HOLD bit.                   */
      __IOM uint32_t SPI_SMEM_ECC_CS_HOLD_TIME : 3;/*!< SPI_SMEM_CS_HOLD_TIME + SPI_SMEM_ECC_CS_HOLD_TIME is the MSPI
                                                     CS hold cycles in ECC mode when accesses to external RAM.                 */
      __IOM uint32_t SPI_SMEM_ECC_SKIP_PAGE_CORNER : 1;/*!< 1: MSPI skips page corner when accesses to external RAM. 0:
                                                     Not skip page corner when accesses to external RAM.                       */
      __IOM uint32_t SPI_SMEM_ECC_16TO18_BYTE_EN : 1;/*!< Set this bit to enable MSPI ECC 16 bytes data with 2 ECC bytes
                                                     mode when accesses to external RAM.                                       */
            uint32_t            : 7;
      __IOM uint32_t SPI_SMEM_ECC_ERR_INT_EN : 1;/*!< Set this bit to calculate the error times of MSPI ECC read when
                                                     accesses to external RAM.                                                 */
      __IOM uint32_t SPI_SMEM_CS_HOLD_DELAY : 6;/*!< These bits are used to set the minimum CS high time tSHSL between
                                                     SPI burst transfer when accesses to external RAM. tSHSL
                                                     is (SPI_SMEM_CS_HOLD_DELAY[5:0] + 1) MSPI core clock cycles.              */
            uint32_t            : 1;
    } bit;
  } SPI_SMEM_AC;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 flash DDR mode control register                                      */
    
    struct {
      __IOM uint32_t SPI_FMEM_DDR_EN : 1;       /*!< 1: in ddr mode, 0 in sdr mode                                             */
      __IOM uint32_t SPI_FMEM_VAR_DUMMY : 1;    /*!< Set the bit to enable variable dummy cycle in DDR mode.                   */
      __IOM uint32_t SPI_FMEM_DDR_RDAT_SWP : 1; /*!< Set the bit to reorder RX data of the word in DDR mode.                   */
      __IOM uint32_t SPI_FMEM_DDR_WDAT_SWP : 1; /*!< Set the bit to swap TX data of a word in DDR mode.                        */
      __IOM uint32_t SPI_FMEM_DDR_CMD_DIS : 1;  /*!< the bit is used to disable dual edge in CMD phase when ddr mode.          */
      __IOM uint32_t SPI_FMEM_OUTMINBYTELEN : 7;/*!< It is the minimum output data length in the panda device.                 */
      __IOM uint32_t SPI_FMEM_TX_DDR_MSK_EN : 1;/*!< Set this bit to mask the first or the last byte in MSPI ECC
                                                     DDR write mode, when accesses to flash.                                   */
      __IOM uint32_t SPI_FMEM_RX_DDR_MSK_EN : 1;/*!< Set this bit to mask the first or the last byte in MSPI ECC
                                                     DDR read mode, when accesses to flash.                                    */
      __IOM uint32_t SPI_FMEM_USR_DDR_DQS_THD : 7;/*!< The delay number of data strobe which from memory based on SPI_CLK.     */
      __IOM uint32_t SPI_FMEM_DDR_DQS_LOOP : 1; /*!< 1: Use internal signal as data strobe, the strobe can not be
                                                     delayed by input timing module. 0: Use input SPI_DQS signal
                                                     from PAD as data strobe, the strobe can be delayed by input
                                                     timing module                                                             */
      __IOM uint32_t SPI_FMEM_DDR_DQS_LOOP_MODE : 1;/*!< When SPI_FMEM_DDR_DQS_LOOP and SPI_FMEM_DDR_EN are set, 1: Use
                                                     internal SPI_CLK as data strobe. 0: Use internal ~SPI_CLK
                                                     as data strobe. Otherwise this bit is not active.                         */
            uint32_t            : 1;
      __IOM uint32_t SPI_FMEM_CLK_DIFF_EN : 1;  /*!< Set this bit to enable the differential SPI_CLK#.                         */
      __IOM uint32_t SPI_FMEM_HYPERBUS_MODE : 1;/*!< Set this bit to enable the SPI HyperBus mode.                             */
      __IOM uint32_t SPI_FMEM_DQS_CA_IN : 1;    /*!< Set this bit to enable the input of SPI_DQS signal in SPI phases
                                                     of CMD and ADDR.                                                          */
      __IOM uint32_t SPI_FMEM_HYPERBUS_DUMMY_2X : 1;/*!< Set this bit to enable the vary dummy function in SPI HyperBus
                                                     mode, when SPI0 accesses to flash or SPI1 accesses flash
                                                     or sram.                                                                  */
      __IOM uint32_t SPI_FMEM_CLK_DIFF_INV : 1; /*!< Set this bit to invert SPI_DIFF when accesses to flash. .                 */
      __IOM uint32_t SPI_FMEM_OCTA_RAM_ADDR : 1;/*!< Set this bit to enable octa_ram address out when accesses to
                                                     flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4],
                                                     6'd0, spi_usr_addr_value[3:1], 1'b0}.                                     */
      __IOM uint32_t SPI_FMEM_HYPERBUS_CA : 1;  /*!< Set this bit to enable HyperRAM address out when accesses to
                                                     flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4],
                                                     13'd0, spi_usr_addr_value[3:1]}.                                          */
            uint32_t            : 1;
    } bit;
  } DDR;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 external RAM DDR mode control register                               */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< 1: in ddr mode, 0 in sdr mode                                             */
      __IOM uint32_t SPI_SMEM_VAR_DUMMY : 1;    /*!< Set the bit to enable variable dummy cycle in spi ddr mode.               */
      __IOM uint32_t RDAT_SWP   : 1;            /*!< Set the bit to reorder rx data of the word in spi ddr mode.               */
      __IOM uint32_t WDAT_SWP   : 1;            /*!< Set the bit to reorder tx data of the word in spi ddr mode.               */
      __IOM uint32_t CMD_DIS    : 1;            /*!< the bit is used to disable dual edge in CMD phase when ddr mode.          */
      __IOM uint32_t SPI_SMEM_OUTMINBYTELEN : 7;/*!< It is the minimum output data length in the ddr psram.                    */
      __IOM uint32_t SPI_SMEM_TX_DDR_MSK_EN : 1;/*!< Set this bit to mask the first or the last byte in MSPI ECC
                                                     DDR write mode, when accesses to external RAM.                            */
      __IOM uint32_t SPI_SMEM_RX_DDR_MSK_EN : 1;/*!< Set this bit to mask the first or the last byte in MSPI ECC
                                                     DDR read mode, when accesses to external RAM.                             */
      __IOM uint32_t SPI_SMEM_USR_DDR_DQS_THD : 7;/*!< The delay number of data strobe which from memory based on SPI_CLK.     */
      __IOM uint32_t DQS_LOOP   : 1;            /*!< 1: Use internal signal as data strobe, the strobe can not be
                                                     delayed by input timing module. 0: Use input SPI_DQS signal
                                                     from PAD as data strobe, the strobe can be delayed by input
                                                     timing module                                                             */
      __IOM uint32_t DQS_LOOP_MODE : 1;         /*!< When SPI_SMEM_DDR_DQS_LOOP and SPI_SMEM_DDR_EN are set, 1: Use
                                                     internal SPI_CLK as data strobe. 0: Use internal ~SPI_CLK
                                                     as data strobe. Otherwise this bit is not active.                         */
            uint32_t            : 1;
      __IOM uint32_t SPI_SMEM_CLK_DIFF_EN : 1;  /*!< Set this bit to enable the differential SPI_CLK#.                         */
      __IOM uint32_t SPI_SMEM_HYPERBUS_MODE : 1;/*!< Set this bit to enable the SPI HyperBus mode.                             */
      __IOM uint32_t SPI_SMEM_DQS_CA_IN : 1;    /*!< Set this bit to enable the input of SPI_DQS signal in SPI phases
                                                     of CMD and ADDR.                                                          */
      __IOM uint32_t SPI_SMEM_HYPERBUS_DUMMY_2X : 1;/*!< Set this bit to enable the vary dummy function in SPI HyperBus
                                                     mode, when SPI0 accesses to flash or SPI1 accesses flash
                                                     or sram.                                                                  */
      __IOM uint32_t SPI_SMEM_CLK_DIFF_INV : 1; /*!< Set this bit to invert SPI_DIFF when accesses to external RAM.
                                                     .                                                                         */
      __IOM uint32_t SPI_SMEM_OCTA_RAM_ADDR : 1;/*!< Set this bit to enable octa_ram address out when accesses to
                                                     external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4],
                                                     6'd0, spi_usr_addr_value[3:1], 1'b0}.                                     */
      __IOM uint32_t SPI_SMEM_HYPERBUS_CA : 1;  /*!< Set this bit to enable HyperRAM address out when accesses to
                                                     external RAM, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4],
                                                     13'd0, spi_usr_addr_value[3:1]}.                                          */
            uint32_t            : 1;
    } bit;
  } SPI_SMEM_DDR;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 clk_gate register                                                    */
    
    struct {
      __IOM uint32_t CLK_EN     : 1;            /*!< Register clock gate enable signal. 1: Enable. 0: Disable.                 */
            uint32_t            : 31;
    } bit;
  } CLOCK_GATE;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 module clock select register                                         */
    
    struct {
      __IOM uint32_t CORE_CLK_SEL : 2;          /*!< When the digital system clock selects PLL clock and the frequency
                                                     of PLL clock is 480MHz, the value of SPI_MEM_CORE_CLK_SEL:
                                                     0: SPI0/1 module clock (MSPI_CORE_CLK) is 80MHz. 1: MSPI_CORE_CLK
                                                     is 120MHz. 2: MSPI_CORE_CLK is 160MHz. 3: MSPI_CORE_CLK
                                                     is 240MHz. When the digital system clock selects PLL clock
                                                     and the frequency of PLL clock is 320MHz, the value of
                                                     SPI_MEM_CORE_CLK_SEL: 0: MSPI_CORE_CLK is 80MHz. 1: MSPI_CORE_CLK
                                                     is 80MHz. 2: MSPI_CORE_CLK 160MHz. 3: Not used.                           */
            uint32_t            : 30;
    } bit;
  } CORE_CLK_SEL;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 interrupt enable register                                            */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t TOTAL_TRANS_END_INT_ENA : 1;/*!< The enable bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt.                */
            uint32_t            : 1;
      __IOM uint32_t ECC_ERR_INT_ENA : 1;       /*!< The enable bit for SPI_MEM_ECC_ERR_INT interrupt.                         */
            uint32_t            : 27;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 interrupt clear register                                             */
    
    struct {
            uint32_t            : 2;
      __OM  uint32_t TOTAL_TRANS_END_INT_CLR : 1;/*!< The clear bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt.                 */
            uint32_t            : 1;
      __OM  uint32_t ECC_ERR_INT_CLR : 1;       /*!< The clear bit for SPI_MEM_ECC_ERR_INT interrupt. SPI_MEM_ECC_ERR_ADDR
                                                     and SPI_MEM_ECC_ERR_CNT will be cleared by the pulse of
                                                     this bit.                                                                 */
            uint32_t            : 27;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 interrupt raw register                                               */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t TOTAL_TRANS_END_INT_RAW : 1;/*!< The raw bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt. 1: Triggered
                                                     when SPI1 transfer is done and flash is already idle. When
                                                     WRSR/PP/SE/BE/CE is sent and PES/PER command is sent, this
                                                     bit is set when WRSR/PP/SE/BE/CE is success. 0: Others.                   */
            uint32_t            : 1;
      __IOM uint32_t ECC_ERR_INT_RAW : 1;       /*!< The raw bit for SPI_MEM_ECC_ERR_INT interrupt. When APB_CTRL_FECC_ERR_INT_EN
                                                     is set and APB_CTRL_SECC_ERR_INT_EN is cleared, this bit
                                                     is triggered when the error times of SPI0/1 ECC read flash
                                                     are equal or bigger than APB_CTRL_ECC_ERR_INT_NUM. When
                                                     APB_CTRL_FECC_ERR_INT_EN is cleared and APB_CTRL_SECC_ERR_INT_EN
                                                     is set, this bit is triggered when the error times of SPI0/1
                                                     ECC read external RAM are equal or bigger than APB_CTRL_ECC_ERR_INT_NUM.
                                                     When APB_CTRL_FECC_ERR_INT_EN and APB_CTRL_SECC_ERR_INT_EN
                                                     are set, this bit is triggered when the total error times
                                                     of SPI0/1 ECC read external RAM and flash are equal or
                                                     bigger than APB_CTRL_ECC_ERR_INT_NUM. When APB_CTRL_FECC_ERR_INT_EN
                                                     and APB_CTRL_SECC_ERR_INT_EN are cleared, this bit will
                                                     not be triggered.                                                         */
            uint32_t            : 27;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 interrupt status register                                            */
    
    struct {
            uint32_t            : 2;
      __IM  uint32_t TOTAL_TRANS_END_INT_ST : 1;/*!< The status bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt.                 */
            uint32_t            : 1;
      __IM  uint32_t ECC_ERR_INT_ST : 1;        /*!< The status bit for SPI_MEM_ECC_ERR_INT interrupt.                         */
            uint32_t            : 27;
    } bit;
  } INT_ST;
  __IM  uint32_t  RESERVED6[191];
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 version control register                                             */
    
    struct {
      __IOM uint32_t SPI_SMEM_SPICLK_FUN_DRV : 2;/*!< The driver of SPI_CLK PAD is controlled by the bits SPI_SMEM_SPICLK_FUN_DRV[1:
                                                     ] when the bit SPI_SPICLK_PAD_DRV_CTL_EN is set and MSPI
                                                     accesses to external RAM.                                                 */
      __IOM uint32_t SPI_FMEM_SPICLK_FUN_DRV : 2;/*!< The driver of SPI_CLK PAD is controlled by the bits SPI_FMEM_SPICLK_FUN_DRV[1:
                                                     ] when the bit SPI_SPICLK_PAD_DRV_CTL_EN is set and MSPI
                                                     accesses to flash.                                                        */
      __IOM uint32_t SPI_SPICLK_PAD_DRV_CTL_EN : 1;/*!< SPI_CLK PAD driver control signal. 1: The driver of SPI_CLK
                                                     PAD is controlled by the bits SPI_FMEM_SPICLK_FUN_DRV[1:0]
                                                     and SPI_SMEM_SPICLK_FUN_DRV[1:0]. 0: The driver of SPI_CLK
                                                     PAD is controlled by the bits IO_MUX_FUNC_DRV[1:0] of SPICLK
                                                     PAD.                                                                      */
      __IOM uint32_t DATE       : 23;           /*!< SPI register version.                                                     */
            uint32_t            : 4;
    } bit;
  } DATE;
} SPI0_Type;                                    /*!< Size = 1024 (0x400)                                                       */



/* =========================================================================================================================== */
/* ================                                           SPI1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI (Serial Peripheral Interface) Controller 1 (SPI1)
  */

typedef struct {                                /*!< SPI1 Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory command register                                              */
    
    struct {
            uint32_t            : 17;
      __IOM uint32_t FLASH_PE   : 1;            /*!< In user mode, it is set to indicate that program/erase operation
                                                     will be triggered. The bit is combined with SPI_MEM_USR
                                                     bit. The bit will be cleared once the operation done.1:
                                                     enable 0: disable.                                                        */
      __IOM uint32_t USR        : 1;            /*!< User define command enable. An operation will be triggered when
                                                     the bit is set. The bit will be cleared once the operation
                                                     done.1: enable 0: disable.                                                */
      __IOM uint32_t FLASH_HPM  : 1;            /*!< Drive Flash into high performance mode. The bit will be cleared
                                                     once the operation done.1: enable 0: disable.                             */
      __IOM uint32_t FLASH_RES  : 1;            /*!< This bit combined with SPI_MEM_RESANDRES bit releases Flash
                                                     from the power-down state or high performance mode and
                                                     obtains the devices ID. The bit will be cleared once the
                                                     operation done.1: enable 0: disable.                                      */
      __IOM uint32_t FLASH_DP   : 1;            /*!< Drive Flash into power down. An operation will be triggered
                                                     when the bit is set. The bit will be cleared once the operation
                                                     done.1: enable 0: disable.                                                */
      __IOM uint32_t FLASH_CE   : 1;            /*!< Chip erase enable. Chip erase operation will be triggered when
                                                     the bit is set. The bit will be cleared once the operation
                                                     done.1: enable 0: disable.                                                */
      __IOM uint32_t FLASH_BE   : 1;            /*!< Block erase enable(32KB) . Block erase operation will be triggered
                                                     when the bit is set. The bit will be cleared once the operation
                                                     done.1: enable 0: disable.                                                */
      __IOM uint32_t FLASH_SE   : 1;            /*!< Sector erase enable(4KB). Sector erase operation will be triggered
                                                     when the bit is set. The bit will be cleared once the operation
                                                     done.1: enable 0: disable.                                                */
      __IOM uint32_t FLASH_PP   : 1;            /*!< Page program enable(1 byte ~64 bytes data to be programmed).
                                                     Page program operation will be triggered when the bit is
                                                     set. The bit will be cleared once the operation done .1:
                                                     enable 0: disable.                                                        */
      __IOM uint32_t FLASH_WRSR : 1;            /*!< Write status register enable. Write status operation will be
                                                     triggered when the bit is set. The bit will be cleared
                                                     once the operation done.1: enable 0: disable.                             */
      __IOM uint32_t FLASH_RDSR : 1;            /*!< Read status register-1. Read status operation will be triggered
                                                     when the bit is set. The bit will be cleared once the operation
                                                     done.1: enable 0: disable.                                                */
      __IOM uint32_t FLASH_RDID : 1;            /*!< Read JEDEC ID . Read ID command will be sent when the bit is
                                                     set. The bit will be cleared once the operation done. 1:
                                                     enable 0: disable.                                                        */
      __IOM uint32_t FLASH_WRDI : 1;            /*!< Write flash disable. Write disable command will be sent when
                                                     the bit is set. The bit will be cleared once the operation
                                                     done. 1: enable 0: disable.                                               */
      __IOM uint32_t FLASH_WREN : 1;            /*!< Write flash enable. Write enable command will be sent when the
                                                     bit is set. The bit will be cleared once the operation
                                                     done. 1: enable 0: disable.                                               */
      __IOM uint32_t FLASH_READ : 1;            /*!< Read flash enable. Read flash operation will be triggered when
                                                     the bit is set. The bit will be cleared once the operation
                                                     done. 1: enable 0: disable.                                               */
    } bit;
  } CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 address register                                                     */
    
    struct {
      __IOM uint32_t USR_ADDR_VALUE : 32;       /*!< In user mode, it is the memory address. other then the bit0-bit23
                                                     is the memory address, the bit24-bit31 are the byte length
                                                     of a transfer.                                                            */
    } bit;
  } ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 control register                                                     */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t FDUMMY_OUT : 1;            /*!< In the DUMMY phase the signal level of SPI bus is output by
                                                     the SPI0 controller.                                                      */
      __IOM uint32_t FDOUT_OCT  : 1;            /*!< Set this bit to enable 8-bit-mode(8-bm) in DOUT phase.                    */
      __IOM uint32_t FDIN_OCT   : 1;            /*!< Set this bit to enable 8-bit-mode(8-bm) in DIN phase.                     */
      __IOM uint32_t FADDR_OCT  : 1;            /*!< Set this bit to enable 8-bit-mode(8-bm) in ADDR phase.                    */
      __IOM uint32_t FCMD_DUAL  : 1;            /*!< Set this bit to enable 2-bit-mode(2-bm) in CMD phase.                     */
      __IOM uint32_t FCMD_QUAD  : 1;            /*!< Set this bit to enable 4-bit-mode(4-bm) in CMD phase.                     */
      __IOM uint32_t FCMD_OCT   : 1;            /*!< Set this bit to enable 8-bit-mode(8-bm) in CMD phase.                     */
      __IOM uint32_t FCS_CRC_EN : 1;            /*!< For SPI1, initialize crc32 module before writing encrypted data
                                                     to flash. Active low.                                                     */
      __IOM uint32_t TX_CRC_EN  : 1;            /*!< For SPI1, enable crc32 when writing encrypted data to flash.
                                                     1: enable 0:disable                                                       */
            uint32_t            : 1;
      __IOM uint32_t FASTRD_MODE : 1;           /*!< This bit should be set when SPI_MEM_FREAD_QIO, SPI_MEM_FREAD_DIO,
                                                     SPI_MEM_FREAD_QUAD or SPI_MEM_FREAD_DUAL is set.                          */
      __IOM uint32_t FREAD_DUAL : 1;            /*!< In hardware 0x3B read operation, DIN phase apply 2 signals.
                                                     1: enable 0: disable.                                                     */
      __IOM uint32_t RESANDRES  : 1;            /*!< The Device ID is read out to SPI_MEM_RD_STATUS register, this
                                                     bit combine with spi_mem_flash_res bit. 1: enable 0: disable.             */
            uint32_t            : 2;
      __IOM uint32_t Q_POL      : 1;            /*!< The bit is used to set MISO line polarity, 1: high 0, low                 */
      __IOM uint32_t D_POL      : 1;            /*!< The bit is used to set MOSI line polarity, 1: high 0, low                 */
      __IOM uint32_t FREAD_QUAD : 1;            /*!< In hardware 0x6B read operation, DIN phase apply 4 signals(4-bit-mode).
                                                     1: enable 0: disable.                                                     */
      __IOM uint32_t WP         : 1;            /*!< Write protect signal output when SPI is idle. 1: output high,
                                                     0: output low.                                                            */
      __IOM uint32_t WRSR_2B    : 1;            /*!< Two bytes data will be written to status register when it is
                                                     set. 1: enable 0: disable.                                                */
      __IOM uint32_t FREAD_DIO  : 1;            /*!< In hardware 0xBB read operation, ADDR phase and DIN phase apply
                                                     2 signals(2-bit-mode). 1: enable 0: disable.                              */
      __IOM uint32_t FREAD_QIO  : 1;            /*!< In hardware 0xEB read operation, ADDR phase and DIN phase apply
                                                     4 signals(4-bit-mode). 1: enable 0: disable.                              */
            uint32_t            : 7;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 control1 register                                                    */
    
    struct {
      __IOM uint32_t CLK_MODE   : 2;            /*!< SPI Bus clock (SPI_CLK) mode bits. 0: SPI Bus clock (SPI_CLK)
                                                     is off when CS inactive 1: SPI_CLK is delayed one cycle
                                                     after SPI_CS inactive 2: SPI_CLK is delayed two cycles
                                                     after SPI_CS inactive 3: SPI_CLK is always on.                            */
      __IOM uint32_t CS_HOLD_DLY_RES : 10;      /*!< After RES/DP/HPM/PES/PER command is sent, SPI1 may waits (SPI_MEM_CS_HOLD_DELA
                                                     _RES[9:0] * 4 or * 256) SPI_CLK cycles.                                   */
            uint32_t            : 20;
    } bit;
  } CTRL1;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 control2 register                                                    */
    
    struct {
            uint32_t            : 31;
      __IOM uint32_t SYNC_RESET : 1;            /*!< The FSM will be reset.                                                    */
    } bit;
  } CTRL2;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI_CLK clock division register when SPI1 accesses to flash
                                                     or Ext_RAM.                                                               */
    
    struct {
      __IOM uint32_t CLKCNT_L   : 8;            /*!< It must equal to the value of SPI_MEM_CLKCNT_N.                           */
      __IOM uint32_t CLKCNT_H   : 8;            /*!< It must be a floor value of ((SPI_MEM_CLKCNT_N+1)/2-1).                   */
      __IOM uint32_t CLKCNT_N   : 8;            /*!< When SPI1 accesses to flash or Ext_RAM, f_SPI_CLK = f_MSPI_CORE_CLK/(SPI_MEM_C
                                                     KCNT_N+1)                                                                 */
            uint32_t            : 7;
      __IOM uint32_t CLK_EQU_SYSCLK : 1;        /*!< When SPI1 access to flash or Ext_RAM, set this bit in 1-division
                                                     mode, f_SPI_CLK = f_MSPI_CORE_CLK.                                        */
    } bit;
  } CLOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 user register.                                                       */
    
    struct {
            uint32_t            : 9;
      __IOM uint32_t CK_OUT_EDGE : 1;           /*!< This bit, combined with SPI_MEM_CK_IDLE_EDGE bit, is used to
                                                     change the clock mode 0~3 of SPI_CLK.                                     */
            uint32_t            : 2;
      __IOM uint32_t FWRITE_DUAL : 1;           /*!< Set this bit to enable 2-bm in DOUT phase in SPI1 write operation.        */
      __IOM uint32_t FWRITE_QUAD : 1;           /*!< Set this bit to enable 4-bm in DOUT phase in SPI1 write operation.        */
      __IOM uint32_t FWRITE_DIO : 1;            /*!< Set this bit to enable 2-bm in ADDR and DOUT phase in SPI1 write
                                                     operation.                                                                */
      __IOM uint32_t FWRITE_QIO : 1;            /*!< Set this bit to enable 4-bit-mode(4-bm) in ADDR and DOUT phase
                                                     in SPI1 write operation.                                                  */
            uint32_t            : 8;
      __IOM uint32_t USR_MISO_HIGHPART : 1;     /*!< DIN phase only access to high-part of the buffer SPI_MEM_W8_REG~SPI_MEM_W15_RE
                                                     . 1: enable 0: disable.                                                   */
      __IOM uint32_t USR_MOSI_HIGHPART : 1;     /*!< DOUT phase only access to high-part of the buffer SPI_MEM_W8_REG~SPI_MEM_W15_R
                                                     G. 1: enable 0: disable.                                                  */
      __IOM uint32_t USR_DUMMY_IDLE : 1;        /*!< SPI_CLK is disabled(No clock edges) in DUMMY phase when the
                                                     bit is enable.                                                            */
      __IOM uint32_t USR_MOSI   : 1;            /*!< Set this bit to enable the DOUT phase of an write-data operation.         */
      __IOM uint32_t USR_MISO   : 1;            /*!< Set this bit to enable enable the DIN phase of a read-data operation.     */
      __IOM uint32_t USR_DUMMY  : 1;            /*!< Set this bit to enable enable the DUMMY phase of an operation.            */
      __IOM uint32_t USR_ADDR   : 1;            /*!< Set this bit to enable enable the ADDR phase of an operation.             */
      __IOM uint32_t USR_COMMAND : 1;           /*!< Set this bit to enable enable the CMD phase of an operation.              */
    } bit;
  } USER;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 user1 register.                                                      */
    
    struct {
      __IOM uint32_t USR_DUMMY_CYCLELEN : 6;    /*!< The SPI_CLK cycle length minus 1 of DUMMY phase.                          */
            uint32_t            : 20;
      __IOM uint32_t USR_ADDR_BITLEN : 6;       /*!< The length in bits of ADDR phase. The register value shall be
                                                     (bit_num-1).                                                              */
    } bit;
  } USER1;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 user2 register.                                                      */
    
    struct {
      __IOM uint32_t USR_COMMAND_VALUE : 16;    /*!< The value of user defined(USR) command.                                   */
            uint32_t            : 12;
      __IOM uint32_t USR_COMMAND_BITLEN : 4;    /*!< The length in bits of CMD phase. The register value shall be
                                                     (bit_num-1)                                                               */
    } bit;
  } USER2;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 write-data bit length register.                                      */
    
    struct {
      __IOM uint32_t USR_MOSI_DBITLEN : 10;     /*!< The length in bits of DOUT phase. The register value shall be
                                                     (bit_num-1).                                                              */
            uint32_t            : 22;
    } bit;
  } MOSI_DLEN;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 read-data bit length register.                                       */
    
    struct {
      __IOM uint32_t USR_MISO_DBITLEN : 10;     /*!< The length in bits of DIN phase. The register value shall be
                                                     (bit_num-1).                                                              */
            uint32_t            : 22;
    } bit;
  } MISO_DLEN;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 read control register.                                               */
    
    struct {
      __IOM uint32_t STATUS     : 16;           /*!< The value is stored when set SPI_MEM_FLASH_RDSR bit and SPI_MEM_FLASH_RES
                                                     bit.                                                                      */
      __IOM uint32_t WB_MODE    : 8;            /*!< Mode bits in the flash fast read mode it is combined with SPI_MEM_FASTRD_MODE
                                                     bit.                                                                      */
            uint32_t            : 8;
    } bit;
  } RD_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 extended address register.                                           */
    
    struct {
      __IOM uint32_t EXT_ADDR   : 32;           /*!< The register are the higher 32bits in the 64 bits address mode.           */
    } bit;
  } EXT_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 misc register.                                                       */
    
    struct {
      __IOM uint32_t CS0_DIS    : 1;            /*!< Set this bit to raise high SPI_CS pin, which means that the
                                                     SPI device(flash) connected to SPI_CS is in low level when
                                                     SPI1 transfer starts.                                                     */
      __IOM uint32_t CS1_DIS    : 1;            /*!< Set this bit to raise high SPI_CS1 pin, which means that the
                                                     SPI device(Ext_RAM) connected to SPI_CS1 is in low level
                                                     when SPI1 transfer starts.                                                */
            uint32_t            : 7;
      __IOM uint32_t CK_IDLE_EDGE : 1;          /*!< 1: SPI_CLK line is high when MSPI is idle. 0: SPI_CLK line is
                                                     low when MSPI is idle.                                                    */
      __IOM uint32_t CS_KEEP_ACTIVE : 1;        /*!< SPI_CS line keep low when the bit is set.                                 */
      __IOM uint32_t AUTO_PER   : 1;            /*!< Set this bit to enable auto PER function. Hardware will sent
                                                     out PER command if PES command is sent.                                   */
            uint32_t            : 20;
    } bit;
  } MISC;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 CRC data register.                                                   */
    
    struct {
      __IM  uint32_t DATA       : 32;           /*!< For SPI1, the value of crc32.                                             */
    } bit;
  } TX_CRC;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 bit mode control register.                                           */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CACHE_USR_CMD_4BYTE : 1;   /*!< Set this bit to enable SPI1 transfer with 32 bits address. The
                                                     value of SPI_MEM_USR_ADDR_BITLEN should be 31.                            */
            uint32_t            : 1;
      __IOM uint32_t FDIN_DUAL  : 1;            /*!< When SPI1 accesses to flash or Ext_RAM, set this bit to enable
                                                     2-bm in DIN phase.                                                        */
      __IOM uint32_t FDOUT_DUAL : 1;            /*!< When SPI1 accesses to flash or Ext_RAM, set this bit to enable
                                                     2-bm in DOUT phase.                                                       */
      __IOM uint32_t FADDR_DUAL : 1;            /*!< When SPI1 accesses to flash or Ext_RAM, set this bit to enable
                                                     2-bm in ADDR phase.                                                       */
      __IOM uint32_t FDIN_QUAD  : 1;            /*!< When SPI1 accesses to flash or Ext_RAM, set this bit to enable
                                                     4-bm in DIN phase.                                                        */
      __IOM uint32_t FDOUT_QUAD : 1;            /*!< When SPI1 accesses to flash or Ext_RAM, set this bit to enable
                                                     4-bm in DOUT phase.                                                       */
      __IOM uint32_t FADDR_QUAD : 1;            /*!< When SPI1 accesses to flash or Ext_RAM, set this bit to enable
                                                     4-bm in ADDR phase.                                                       */
            uint32_t            : 23;
    } bit;
  } CACHE_FCTRL;
  __IM  uint32_t  RESERVED[5];
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 state machine(FSM) status register.                                  */
    
    struct {
      __IM  uint32_t ST         : 3;            /*!< The status of SPI1 state machine. 0: idle state(IDLE), 1: preparation
                                                     state(PREP), 2: send command state(CMD), 3: send address
                                                     state(ADDR), 4: red data state(DIN), 5:write data state(DOUT),
                                                     6: wait state(DUMMY), 7: done state(DONE).                                */
            uint32_t            : 29;
    } bit;
  } FSM;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer0                                                  */
    
    struct {
      __IOM uint32_t BUF0       : 32;           /*!< data buffer                                                               */
    } bit;
  } W0;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer1                                                  */
    
    struct {
      __IOM uint32_t BUF1       : 32;           /*!< data buffer                                                               */
    } bit;
  } W1;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer2                                                  */
    
    struct {
      __IOM uint32_t BUF2       : 32;           /*!< data buffer                                                               */
    } bit;
  } W2;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer3                                                  */
    
    struct {
      __IOM uint32_t BUF3       : 32;           /*!< data buffer                                                               */
    } bit;
  } W3;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer4                                                  */
    
    struct {
      __IOM uint32_t BUF4       : 32;           /*!< data buffer                                                               */
    } bit;
  } W4;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer5                                                  */
    
    struct {
      __IOM uint32_t BUF5       : 32;           /*!< data buffer                                                               */
    } bit;
  } W5;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer6                                                  */
    
    struct {
      __IOM uint32_t BUF6       : 32;           /*!< data buffer                                                               */
    } bit;
  } W6;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer7                                                  */
    
    struct {
      __IOM uint32_t BUF7       : 32;           /*!< data buffer                                                               */
    } bit;
  } W7;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer8                                                  */
    
    struct {
      __IOM uint32_t BUF8       : 32;           /*!< data buffer                                                               */
    } bit;
  } W8;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer9                                                  */
    
    struct {
      __IOM uint32_t BUF9       : 32;           /*!< data buffer                                                               */
    } bit;
  } W9;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer10                                                 */
    
    struct {
      __IOM uint32_t BUF10      : 32;           /*!< data buffer                                                               */
    } bit;
  } W10;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer11                                                 */
    
    struct {
      __IOM uint32_t BUF11      : 32;           /*!< data buffer                                                               */
    } bit;
  } W11;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer12                                                 */
    
    struct {
      __IOM uint32_t BUF12      : 32;           /*!< data buffer                                                               */
    } bit;
  } W12;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer13                                                 */
    
    struct {
      __IOM uint32_t BUF13      : 32;           /*!< data buffer                                                               */
    } bit;
  } W13;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer14                                                 */
    
    struct {
      __IOM uint32_t BUF14      : 32;           /*!< data buffer                                                               */
    } bit;
  } W14;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 memory data buffer15                                                 */
    
    struct {
      __IOM uint32_t BUF15      : 32;           /*!< data buffer                                                               */
    } bit;
  } W15;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 wait idle control register                                           */
    
    struct {
      __IOM uint32_t WAITI_EN   : 1;            /*!< Set this bit to enable auto-waiting flash idle operation when
                                                     PP/SE/BE/CE/WRSR/PES command is sent.                                     */
      __IOM uint32_t WAITI_DUMMY : 1;           /*!< Set this bit to enable DUMMY phase in auto wait flash idle transfer(RDSR). */
      __IOM uint32_t WAITI_CMD  : 8;            /*!< The command value of auto wait flash idle transfer(RDSR).                 */
      __IOM uint32_t WAITI_DUMMY_CYCLELEN : 6;  /*!< The dummy cycle length when wait flash idle(RDSR).                        */
            uint32_t            : 16;
    } bit;
  } FLASH_WAITI_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 flash suspend control register                                       */
    
    struct {
      __IOM uint32_t FLASH_PER  : 1;            /*!< program erase resume bit, program erase suspend operation will
                                                     be triggered when the bit is set. The bit will be cleared
                                                     once the operation done.1: enable 0: disable.                             */
      __IOM uint32_t FLASH_PES  : 1;            /*!< program erase suspend bit, program erase suspend operation will
                                                     be triggered when the bit is set. The bit will be cleared
                                                     once the operation done.1: enable 0: disable.                             */
      __IOM uint32_t FLASH_PER_WAIT_EN : 1;     /*!< Set this bit to add delay time after program erase resume(PER)
                                                     is sent.                                                                  */
      __IOM uint32_t FLASH_PES_WAIT_EN : 1;     /*!< Set this bit to add delay time after program erase suspend(PES)
                                                     command is sent.                                                          */
      __IOM uint32_t PES_PER_EN : 1;            /*!< Set this bit to enable PES transfer trigger PES transfer option.          */
      __IOM uint32_t PESR_IDLE_EN : 1;          /*!< 1: Separate PER flash wait idle and PES flash wait idle. 0:
                                                     Not separate.                                                             */
            uint32_t            : 26;
    } bit;
  } FLASH_SUS_CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 flash suspend command register                                       */
    
    struct {
      __IOM uint32_t FLASH_PES_EN : 1;          /*!< Set this bit to enable auto-suspend function.                             */
      __IOM uint32_t FLASH_PER_COMMAND : 8;     /*!< Program/Erase resume command value.                                       */
      __IOM uint32_t FLASH_PES_COMMAND : 8;     /*!< Program/Erase suspend command value.                                      */
            uint32_t            : 15;
    } bit;
  } FLASH_SUS_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 flash suspend status register                                        */
    
    struct {
      __IOM uint32_t FLASH_SUS  : 1;            /*!< The status of flash suspend. This bit is set when PES command
                                                     is sent, and cleared when PER is sent. Only used in SPI1.                 */
            uint32_t            : 1;
      __IOM uint32_t FLASH_HPM_DLY_256 : 1;     /*!< 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 256) SPI_CLK
                                                     cycles after HPM command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RE
                                                     [9:0] * 4) SPI_CLK cycles after HPM command is sent.                      */
      __IOM uint32_t FLASH_RES_DLY_256 : 1;     /*!< 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 256) SPI_CLK
                                                     cycles after RES command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RE
                                                     [9:0] * 4) SPI_CLK cycles after RES command is sent.                      */
      __IOM uint32_t FLASH_DP_DLY_256 : 1;      /*!< 1: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 256) SPI_CLK
                                                     cycles after DP command is sent. 0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES
                                                     9:0] * 4) SPI_CLK cycles after DP command is sent.                        */
      __IOM uint32_t FLASH_PER_DLY_256 : 1;     /*!< Valid when SPI_MEM_FLASH_PER_WAIT_EN is 1. 1: SPI1 waits (SPI_MEM_CS_HOLD_DELA
                                                     _RES[9:0] * 256) SPI_CLK cycles after PER command is sent.
                                                     0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK
                                                     cycles after PER command is sent.                                         */
      __IOM uint32_t FLASH_PES_DLY_256 : 1;     /*!< Valid when SPI_MEM_FLASH_PES_WAIT_EN is 1. 1: SPI1 waits (SPI_MEM_CS_HOLD_DELA
                                                     _RES[9:0] * 256) SPI_CLK cycles after PES command is sent.
                                                     0: SPI1 waits (SPI_MEM_CS_HOLD_DELAY_RES[9:0] * 4) SPI_CLK
                                                     cycles after PES command is sent.                                         */
            uint32_t            : 25;
    } bit;
  } SUS_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 timing compensation register when accesses to flash or
                                                     Ext_RAM.                                                                  */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t TIMING_CALI : 1;           /*!< Set this bit to add extra SPI_CLK cycles in DUMMY phase for
                                                     all reading operations.                                                   */
      __IOM uint32_t EXTRA_DUMMY_CYCLELEN : 3;  /*!< Extra SPI_CLK cycles added in DUMMY phase for timing compensation.
                                                     Active when SPI_MEM_TIMING_CALI bit is set.                               */
            uint32_t            : 27;
    } bit;
  } TIMING_CALI;
  __IM  uint32_t  RESERVED1[13];
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 DDR control register                                                 */
    
    struct {
      __IOM uint32_t SPI_FMEM_DDR_EN : 1;       /*!< 1: in DDR mode, 0: in SDR mode.                                           */
      __IOM uint32_t SPI_FMEM_VAR_DUMMY : 1;    /*!< Set the bit to enable variable dummy cycle in DDRmode.                    */
      __IOM uint32_t SPI_FMEM_DDR_RDAT_SWP : 1; /*!< Set the bit to reorder RX data of the word in DDR mode.                   */
      __IOM uint32_t SPI_FMEM_DDR_WDAT_SWP : 1; /*!< Set the bit to reorder TX data of the word in DDR mode.                   */
      __IOM uint32_t SPI_FMEM_DDR_CMD_DIS : 1;  /*!< the bit is used to disable dual edge in command phase when DDR
                                                     mode.                                                                     */
      __IOM uint32_t SPI_FMEM_OUTMINBYTELEN : 7;/*!< It is the minimum output data length in the panda device.                 */
            uint32_t            : 2;
      __IOM uint32_t SPI_FMEM_USR_DDR_DQS_THD : 7;/*!< The delay number of data strobe which from memory based on SPI_CLK.     */
      __IOM uint32_t SPI_FMEM_DDR_DQS_LOOP : 1; /*!< 1: Use internal signal as data strobe, the strobe can not be
                                                     delayed by input timing module. 0: Use input SPI_DQS signal
                                                     from PAD as data strobe, the strobe can be delayed by input
                                                     timing module                                                             */
      __IOM uint32_t SPI_FMEM_DDR_DQS_LOOP_MODE : 1;/*!< When SPI_FMEM_DDR_DQS_LOOP and SPI_FMEM_DDR_EN are set, 1: Use
                                                     internal SPI_CLK as data strobe. 0: Use internal ~SPI_CLK
                                                     as data strobe. Otherwise this bit is not active.                         */
            uint32_t            : 1;
      __IOM uint32_t SPI_FMEM_CLK_DIFF_EN : 1;  /*!< Set this bit to enable the differential SPI_CLK#.                         */
      __IOM uint32_t SPI_FMEM_HYPERBUS_MODE : 1;/*!< Set this bit to enable the SPI HyperBus mode.                             */
      __IOM uint32_t SPI_FMEM_DQS_CA_IN : 1;    /*!< Set this bit to enable the input of SPI_DQS signal in SPI phases
                                                     of CMD and ADDR.                                                          */
      __IOM uint32_t SPI_FMEM_HYPERBUS_DUMMY_2X : 1;/*!< Set this bit to enable the vary dummy function in SPI HyperBus
                                                     mode, when SPI0 accesses flash or SPI1 accesses flash or
                                                     sram.                                                                     */
      __IOM uint32_t SPI_FMEM_CLK_DIFF_INV : 1; /*!< Set this bit to invert SPI_DIFF when accesses to flash. .                 */
      __IOM uint32_t SPI_FMEM_OCTA_RAM_ADDR : 1;/*!< Set this bit to enable octa_ram address out when accesses to
                                                     flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[25:4],
                                                     6'd0, spi_usr_addr_value[3:1], 1'b0}.                                     */
      __IOM uint32_t SPI_FMEM_HYPERBUS_CA : 1;  /*!< Set this bit to enable HyperRAM address out when accesses to
                                                     flash, which means ADDR_OUT[31:0] = {spi_usr_addr_value[19:4],
                                                     13'd0, spi_usr_addr_value[3:1]}.                                          */
            uint32_t            : 1;
    } bit;
  } DDR;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 clk_gate register                                                    */
    
    struct {
      __IOM uint32_t CLK_EN     : 1;            /*!< Register clock gate enable signal. 1: Enable. 0: Disable.                 */
            uint32_t            : 31;
    } bit;
  } CLOCK_GATE;
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 interrupt enable register                                            */
    
    struct {
      __IOM uint32_t PER_END_INT_ENA : 1;       /*!< The enable bit for SPI_MEM_PER_END_INT interrupt.                         */
      __IOM uint32_t PES_END_INT_ENA : 1;       /*!< The enable bit for SPI_MEM_PES_END_INT interrupt.                         */
      __IOM uint32_t TOTAL_TRANS_END_INT_ENA : 1;/*!< The enable bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt.                */
      __IOM uint32_t BROWN_OUT_INT_ENA : 1;     /*!< The enable bit for SPI_MEM_BROWN_OUT_INT interrupt.                       */
            uint32_t            : 28;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 interrupt clear register                                             */
    
    struct {
      __OM  uint32_t PER_END_INT_CLR : 1;       /*!< The clear bit for SPI_MEM_PER_END_INT interrupt.                          */
      __OM  uint32_t PES_END_INT_CLR : 1;       /*!< The clear bit for SPI_MEM_PES_END_INT interrupt.                          */
      __OM  uint32_t TOTAL_TRANS_END_INT_CLR : 1;/*!< The clear bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt.                 */
      __OM  uint32_t BROWN_OUT_INT_CLR : 1;     /*!< The status bit for SPI_MEM_BROWN_OUT_INT interrupt.                       */
            uint32_t            : 28;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 interrupt raw register                                               */
    
    struct {
      __IOM uint32_t PER_END_INT_RAW : 1;       /*!< The raw bit for SPI_MEM_PER_END_INT interrupt. 1: Triggered
                                                     when Auto Resume command (0x7A) is sent and flash is resumed
                                                     successfully. 0: Others.                                                  */
      __IOM uint32_t PES_END_INT_RAW : 1;       /*!< The raw bit for SPI_MEM_PES_END_INT interrupt.1: Triggered when
                                                     Auto Suspend command (0x75) is sent and flash is suspended
                                                     successfully. 0: Others.                                                  */
      __IOM uint32_t TOTAL_TRANS_END_INT_RAW : 1;/*!< The raw bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt. 1: Triggered
                                                     when SPI1 transfer is done and flash is already idle. When
                                                     WRSR/PP/SE/BE/CE is sent and PES/PER command is sent, this
                                                     bit is set when WRSR/PP/SE/BE/CE is success. 0: Others.                   */
      __IOM uint32_t BROWN_OUT_INT_RAW : 1;     /*!< The raw bit for SPI_MEM_BROWN_OUT_INT interrupt. 1: Triggered
                                                     condition is that chip is loosing power and RTC module
                                                     sends out brown out close flash request to SPI1. After
                                                     SPI1 sends out suspend command to flash, this interrupt
                                                     is triggered and MSPI returns to idle state. 0: Others.                   */
            uint32_t            : 28;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI1 interrupt status register                                            */
    
    struct {
      __IM  uint32_t PER_END_INT_ST : 1;        /*!< The status bit for SPI_MEM_PER_END_INT interrupt.                         */
      __IM  uint32_t PES_END_INT_ST : 1;        /*!< The status bit for SPI_MEM_PES_END_INT interrupt.                         */
      __IM  uint32_t TOTAL_TRANS_END_INT_ST : 1;/*!< The status bit for SPI_MEM_TOTAL_TRANS_END_INT interrupt.                 */
      __IM  uint32_t BROWN_OUT_INT_ST : 1;      /*!< The status bit for SPI_MEM_BROWN_OUT_INT interrupt.                       */
            uint32_t            : 28;
    } bit;
  } INT_ST;
  __IM  uint32_t  RESERVED4[191];
  
  union {
    __IOM uint32_t reg;                         /*!< SPI0 version control register                                             */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< SPI register version.                                                     */
            uint32_t            : 4;
    } bit;
  } DATE;
} SPI1_Type;                                    /*!< Size = 1024 (0x400)                                                       */



/* =========================================================================================================================== */
/* ================                                           SPI2                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI (Serial Peripheral Interface) Controller 2 (SPI2)
  */

typedef struct {                                /*!< SPI2 Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< Command control register                                                  */
    
    struct {
      __IOM uint32_t CONF_BITLEN : 18;          /*!< Define the APB cycles of SPI_CONF state. Can be configured in
                                                     CONF state.                                                               */
            uint32_t            : 5;
      __IOM uint32_t UPDATE     : 1;            /*!< Set this bit to synchronize SPI registers from APB clock domain
                                                     into SPI module clock domain, which is only used in SPI
                                                     master mode.                                                              */
      __IOM uint32_t USR        : 1;            /*!< User define command enable. An operation will be triggered when
                                                     the bit is set. The bit will be cleared once the operation
                                                     done.1: enable 0: disable. Can not be changed by CONF_buf.                */
            uint32_t            : 7;
    } bit;
  } CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< Address value register                                                    */
    
    struct {
      __IOM uint32_t USR_ADDR_VALUE : 32;       /*!< Address to slave. Can be configured in CONF state.                        */
    } bit;
  } ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI control register                                                      */
    
    struct {
            uint32_t            : 3;
      __IOM uint32_t DUMMY_OUT  : 1;            /*!< 0: In the dummy phase, the FSPI bus signals are not output.
                                                     1: In the dummy phase, the FSPI bus signals are output.
                                                     Can be configured in CONF state.                                          */
            uint32_t            : 1;
      __IOM uint32_t FADDR_DUAL : 1;            /*!< Apply 2 signals during addr phase 1:enable 0: disable. Can be
                                                     configured in CONF state.                                                 */
      __IOM uint32_t FADDR_QUAD : 1;            /*!< Apply 4 signals during addr phase 1:enable 0: disable. Can be
                                                     configured in CONF state.                                                 */
      __IOM uint32_t FADDR_OCT  : 1;            /*!< Apply 8 signals during addr phase 1:enable 0: disable. Can be
                                                     configured in CONF state.                                                 */
      __IOM uint32_t FCMD_DUAL  : 1;            /*!< Apply 2 signals during command phase 1:enable 0: disable. Can
                                                     be configured in CONF state.                                              */
      __IOM uint32_t FCMD_QUAD  : 1;            /*!< Apply 4 signals during command phase 1:enable 0: disable. Can
                                                     be configured in CONF state.                                              */
      __IOM uint32_t FCMD_OCT   : 1;            /*!< Apply 8 signals during command phase 1:enable 0: disable. Can
                                                     be configured in CONF state.                                              */
            uint32_t            : 3;
      __IOM uint32_t FREAD_DUAL : 1;            /*!< In the read operations, read-data phase apply 2 signals. 1:
                                                     enable 0: disable. Can be configured in CONF state.                       */
      __IOM uint32_t FREAD_QUAD : 1;            /*!< In the read operations read-data phase apply 4 signals. 1: enable
                                                     0: disable. Can be configured in CONF state.                              */
      __IOM uint32_t FREAD_OCT  : 1;            /*!< In the read operations read-data phase apply 8 signals. 1: enable
                                                     0: disable. Can be configured in CONF state.                              */
            uint32_t            : 1;
      __IOM uint32_t Q_POL      : 1;            /*!< The bit is used to set MISO line polarity, 1: high 0, low. Can
                                                     be configured in CONF state.                                              */
      __IOM uint32_t D_POL      : 1;            /*!< The bit is used to set MOSI line polarity, 1: high 0, low. Can
                                                     be configured in CONF state.                                              */
      __IOM uint32_t HOLD_POL   : 1;            /*!< SPI_HOLD output value when SPI is idle. 1: output high, 0: output
                                                     low. Can be configured in CONF state.                                     */
      __IOM uint32_t WP_POL     : 1;            /*!< Write protect signal output when SPI is idle. 1: output high,
                                                     0: output low. Can be configured in CONF state.                           */
            uint32_t            : 1;
      __IOM uint32_t RD_BIT_ORDER : 2;          /*!< In read-data (MISO) phase 1: LSB first 0: MSB first. Can be
                                                     configured in CONF state.                                                 */
      __IOM uint32_t WR_BIT_ORDER : 2;          /*!< In command address write-data (MOSI) phases 1: LSB firs 0: MSB
                                                     first. Can be configured in CONF state.                                   */
            uint32_t            : 5;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI clock control register                                                */
    
    struct {
      __IOM uint32_t CLKCNT_L   : 6;            /*!< In the master mode it must be equal to spi_clkcnt_N. In the
                                                     slave mode it must be 0. Can be configured in CONF state.                 */
      __IOM uint32_t CLKCNT_H   : 6;            /*!< In the master mode it must be floor((spi_clkcnt_N+1)/2-1). In
                                                     the slave mode it must be 0. Can be configured in CONF
                                                     state.                                                                    */
      __IOM uint32_t CLKCNT_N   : 6;            /*!< In the master mode it is the divider of spi_clk. So spi_clk
                                                     frequency is system/(spi_clkdiv_pre+1)/(spi_clkcnt_N+1).
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t CLKDIV_PRE : 4;            /*!< In the master mode it is pre-divider of spi_clk. Can be configured
                                                     in CONF state.                                                            */
            uint32_t            : 9;
      __IOM uint32_t CLK_EQU_SYSCLK : 1;        /*!< In the master mode 1: spi_clk is eqaul to system 0: spi_clk
                                                     is divided from system clock. Can be configured in CONF
                                                     state.                                                                    */
    } bit;
  } CLOCK;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI USER control register                                                 */
    
    struct {
      __IOM uint32_t DOUTDIN    : 1;            /*!< Set the bit to enable full duplex communication. 1: enable 0:
                                                     disable. Can be configured in CONF state.                                 */
            uint32_t            : 2;
      __IOM uint32_t QPI_MODE   : 1;            /*!< Both for master mode and slave mode. 1: spi controller is in
                                                     QPI mode. 0: others. Can be configured in CONF state.                     */
      __IOM uint32_t OPI_MODE   : 1;            /*!< Just for master mode. 1: spi controller is in OPI mode (all
                                                     in 8-b-m). 0: others. Can be configured in CONF state.                    */
      __IOM uint32_t TSCK_I_EDGE : 1;           /*!< In the slave mode, this bit can be used to change the polarity
                                                     of tsck. 0: tsck = spi_ck_i. 1:tsck = !spi_ck_i.                          */
      __IOM uint32_t CS_HOLD    : 1;            /*!< spi cs keep low when spi is in done phase. 1: enable 0: disable.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t CS_SETUP   : 1;            /*!< spi cs is enable when spi is in prepare phase. 1: enable 0:
                                                     disable. Can be configured in CONF state.                                 */
      __IOM uint32_t RSCK_I_EDGE : 1;           /*!< In the slave mode, this bit can be used to change the polarity
                                                     of rsck. 0: rsck = !spi_ck_i. 1:rsck = spi_ck_i.                          */
      __IOM uint32_t CK_OUT_EDGE : 1;           /*!< the bit combined with spi_mosi_delay_mode bits to set mosi signal
                                                     delay mode. Can be configured in CONF state.                              */
            uint32_t            : 2;
      __IOM uint32_t FWRITE_DUAL : 1;           /*!< In the write operations read-data phase apply 2 signals. Can
                                                     be configured in CONF state.                                              */
      __IOM uint32_t FWRITE_QUAD : 1;           /*!< In the write operations read-data phase apply 4 signals. Can
                                                     be configured in CONF state.                                              */
      __IOM uint32_t FWRITE_OCT : 1;            /*!< In the write operations read-data phase apply 8 signals. Can
                                                     be configured in CONF state.                                              */
      __IOM uint32_t USR_CONF_NXT : 1;          /*!< 1: Enable the DMA CONF phase of next seg-trans operation, which
                                                     means seg-trans will continue. 0: The seg-trans will end
                                                     after the current SPI seg-trans or this is not seg-trans
                                                     mode. Can be configured in CONF state.                                    */
            uint32_t            : 1;
      __IOM uint32_t SIO        : 1;            /*!< Set the bit to enable 3-line half duplex communication mosi
                                                     and miso signals share the same pin. 1: enable 0: disable.
                                                     Can be configured in CONF state.                                          */
            uint32_t            : 6;
      __IOM uint32_t USR_MISO_HIGHPART : 1;     /*!< read-data phase only access to high-part of the buffer spi_w8~spi_w15.
                                                     1: enable 0: disable. Can be configured in CONF state.                    */
      __IOM uint32_t USR_MOSI_HIGHPART : 1;     /*!< write-data phase only access to high-part of the buffer spi_w8~spi_w15.
                                                     1: enable 0: disable. Can be configured in CONF state.                    */
      __IOM uint32_t USR_DUMMY_IDLE : 1;        /*!< spi clock is disable in dummy phase when the bit is enable.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t USR_MOSI   : 1;            /*!< This bit enable the write-data phase of an operation. Can be
                                                     configured in CONF state.                                                 */
      __IOM uint32_t USR_MISO   : 1;            /*!< This bit enable the read-data phase of an operation. Can be
                                                     configured in CONF state.                                                 */
      __IOM uint32_t USR_DUMMY  : 1;            /*!< This bit enable the dummy phase of an operation. Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t USR_ADDR   : 1;            /*!< This bit enable the address phase of an operation. Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t USR_COMMAND : 1;           /*!< This bit enable the command phase of an operation. Can be configured
                                                     in CONF state.                                                            */
    } bit;
  } USER;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI USER control register 1                                               */
    
    struct {
      __IOM uint32_t USR_DUMMY_CYCLELEN : 8;    /*!< The length in spi_clk cycles of dummy phase. The register value
                                                     shall be (cycle_num-1). Can be configured in CONF state.                  */
            uint32_t            : 8;
      __IOM uint32_t MST_WFULL_ERR_END_EN : 1;  /*!< 1: SPI transfer is ended when SPI RX AFIFO wfull error is valid
                                                     in GP-SPI master FD/HD-mode. 0: SPI transfer is not ended
                                                     when SPI RX AFIFO wfull error is valid in GP-SPI master
                                                     FD/HD-mode.                                                               */
      __IOM uint32_t CS_SETUP_TIME : 5;         /*!< (cycles+1) of prepare phase by spi clock this bits are combined
                                                     with spi_cs_setup bit. Can be configured in CONF state.                   */
      __IOM uint32_t CS_HOLD_TIME : 5;          /*!< delay cycles of cs pin by spi clock this bits are combined with
                                                     spi_cs_hold bit. Can be configured in CONF state.                         */
      __IOM uint32_t USR_ADDR_BITLEN : 5;       /*!< The length in bits of address phase. The register value shall
                                                     be (bit_num-1). Can be configured in CONF state.                          */
    } bit;
  } USER1;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI USER control register 2                                               */
    
    struct {
      __IOM uint32_t USR_COMMAND_VALUE : 16;    /*!< The value of command. Can be configured in CONF state.                    */
            uint32_t            : 11;
      __IOM uint32_t MST_REMPTY_ERR_END_EN : 1; /*!< 1: SPI transfer is ended when SPI TX AFIFO read empty error
                                                     is valid in GP-SPI master FD/HD-mode. 0: SPI transfer is
                                                     not ended when SPI TX AFIFO read empty error is valid in
                                                     GP-SPI master FD/HD-mode.                                                 */
      __IOM uint32_t USR_COMMAND_BITLEN : 4;    /*!< The length in bits of command phase. The register value shall
                                                     be (bit_num-1). Can be configured in CONF state.                          */
    } bit;
  } USER2;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI data bit length control register                                      */
    
    struct {
      __IOM uint32_t MS_DATA_BITLEN : 18;       /*!< The value of these bits is the configured SPI transmission data
                                                     bit length in master mode DMA controlled transfer or CPU
                                                     controlled transfer. The value is also the configured bit
                                                     length in slave mode DMA RX controlled transfer. The register
                                                     value shall be (bit_num-1). Can be configured in CONF state.              */
            uint32_t            : 14;
    } bit;
  } MS_DLEN;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI misc register                                                         */
    
    struct {
      __IOM uint32_t CS0_DIS    : 1;            /*!< SPI CS0 pin enable, 1: disable CS0, 0: spi_cs0 signal is from/to
                                                     CS0 pin. Can be configured in CONF state.                                 */
      __IOM uint32_t CS1_DIS    : 1;            /*!< SPI CS1 pin enable, 1: disable CS1, 0: spi_cs1 signal is from/to
                                                     CS1 pin. Can be configured in CONF state.                                 */
      __IOM uint32_t CS2_DIS    : 1;            /*!< SPI CS2 pin enable, 1: disable CS2, 0: spi_cs2 signal is from/to
                                                     CS2 pin. Can be configured in CONF state.                                 */
      __IOM uint32_t CS3_DIS    : 1;            /*!< SPI CS3 pin enable, 1: disable CS3, 0: spi_cs3 signal is from/to
                                                     CS3 pin. Can be configured in CONF state.                                 */
      __IOM uint32_t CS4_DIS    : 1;            /*!< SPI CS4 pin enable, 1: disable CS4, 0: spi_cs4 signal is from/to
                                                     CS4 pin. Can be configured in CONF state.                                 */
      __IOM uint32_t CS5_DIS    : 1;            /*!< SPI CS5 pin enable, 1: disable CS5, 0: spi_cs5 signal is from/to
                                                     CS5 pin. Can be configured in CONF state.                                 */
      __IOM uint32_t CK_DIS     : 1;            /*!< 1: spi clk out disable, 0: spi clk out enable. Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t MASTER_CS_POL : 6;         /*!< In the master mode the bits are the polarity of spi cs line,
                                                     the value is equivalent to spi_cs ^ spi_master_cs_pol.
                                                     Can be configured in CONF state.                                          */
            uint32_t            : 3;
      __IOM uint32_t CLK_DATA_DTR_EN : 1;       /*!< 1: SPI master DTR mode is applied to SPI clk, data and spi_dqs.
                                                     0: SPI master DTR mode is only applied to spi_dqs. This
                                                     bit should be used with bit 17/18/19.                                     */
      __IOM uint32_t DATA_DTR_EN : 1;           /*!< 1: SPI clk and data of SPI_DOUT and SPI_DIN state are in DTR
                                                     mode, including master 1/2/4/8-bm. 0: SPI clk and data
                                                     of SPI_DOUT and SPI_DIN state are in STR mode. Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t ADDR_DTR_EN : 1;           /*!< 1: SPI clk and data of SPI_SEND_ADDR state are in DTR mode,
                                                     including master 1/2/4/8-bm. 0: SPI clk and data of SPI_SEND_ADDR
                                                     state are in STR mode. Can be configured in CONF state.                   */
      __IOM uint32_t CMD_DTR_EN : 1;            /*!< 1: SPI clk and data of SPI_SEND_CMD state are in DTR mode, including
                                                     master 1/2/4/8-bm. 0: SPI clk and data of SPI_SEND_CMD
                                                     state are in STR mode. Can be configured in CONF state.                   */
            uint32_t            : 3;
      __IOM uint32_t SLAVE_CS_POL : 1;          /*!< spi slave input cs polarity select. 1: inv 0: not change. Can
                                                     be configured in CONF state.                                              */
      __IOM uint32_t DQS_IDLE_EDGE : 1;         /*!< The default value of spi_dqs. Can be configured in CONF state.            */
            uint32_t            : 4;
      __IOM uint32_t CK_IDLE_EDGE : 1;          /*!< 1: spi clk line is high when idle 0: spi clk line is low when
                                                     idle. Can be configured in CONF state.                                    */
      __IOM uint32_t CS_KEEP_ACTIVE : 1;        /*!< spi cs line keep low when the bit is set. Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t QUAD_DIN_PIN_SWAP : 1;     /*!< 1: SPI quad input swap enable, swap FSPID with FSPIQ, swap FSPIWP
                                                     with FSPIHD. 0: spi quad input swap disable. Can be configured
                                                     in CONF state.                                                            */
    } bit;
  } MISC;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI input delay mode configuration                                        */
    
    struct {
      __IOM uint32_t DIN0_MODE  : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     input without delayed, 1: input with the posedge of clk_apb,2
                                                     input with the negedge of clk_apb, 3: input with the spi_clk.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t DIN1_MODE  : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     input without delayed, 1: input with the posedge of clk_apb,2
                                                     input with the negedge of clk_apb, 3: input with the spi_clk.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t DIN2_MODE  : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     input without delayed, 1: input with the posedge of clk_apb,2
                                                     input with the negedge of clk_apb, 3: input with the spi_clk.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t DIN3_MODE  : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     input without delayed, 1: input with the posedge of clk_apb,2
                                                     input with the negedge of clk_apb, 3: input with the spi_clk.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t DIN4_MODE  : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     input without delayed, 1: input with the posedge of clk_apb,2
                                                     input with the negedge of clk_apb, 3: input with the spi_clk.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t DIN5_MODE  : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     input without delayed, 1: input with the posedge of clk_apb,2
                                                     input with the negedge of clk_apb, 3: input with the spi_clk.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t DIN6_MODE  : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     input without delayed, 1: input with the posedge of clk_apb,2
                                                     input with the negedge of clk_apb, 3: input with the spi_clk.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t DIN7_MODE  : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     input without delayed, 1: input with the posedge of clk_apb,2
                                                     input with the negedge of clk_apb, 3: input with the spi_clk.
                                                     Can be configured in CONF state.                                          */
      __IOM uint32_t TIMING_HCLK_ACTIVE : 1;    /*!< 1:enable hclk in SPI input timing module. 0: disable it. Can
                                                     be configured in CONF state.                                              */
            uint32_t            : 15;
    } bit;
  } DIN_MODE;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI input delay number configuration                                      */
    
    struct {
      __IOM uint32_t DIN0_NUM   : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t DIN1_NUM   : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t DIN2_NUM   : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t DIN3_NUM   : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t DIN4_NUM   : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t DIN5_NUM   : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t DIN6_NUM   : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured
                                                     in CONF state.                                                            */
      __IOM uint32_t DIN7_NUM   : 2;            /*!< the input signals are delayed by SPI module clock cycles, 0:
                                                     delayed by 1 cycle, 1: delayed by 2 cycles,... Can be configured
                                                     in CONF state.                                                            */
            uint32_t            : 16;
    } bit;
  } DIN_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI output delay mode configuration                                       */
    
    struct {
      __IOM uint32_t DOUT0_MODE : 1;            /*!< The output signal 0 is delayed by the SPI module clock, 0: output
                                                     without delayed, 1: output delay for a SPI module clock
                                                     cycle at its negative edge. Can be configured in CONF state.              */
      __IOM uint32_t DOUT1_MODE : 1;            /*!< The output signal 1 is delayed by the SPI module clock, 0: output
                                                     without delayed, 1: output delay for a SPI module clock
                                                     cycle at its negative edge. Can be configured in CONF state.              */
      __IOM uint32_t DOUT2_MODE : 1;            /*!< The output signal 2 is delayed by the SPI module clock, 0: output
                                                     without delayed, 1: output delay for a SPI module clock
                                                     cycle at its negative edge. Can be configured in CONF state.              */
      __IOM uint32_t DOUT3_MODE : 1;            /*!< The output signal 3 is delayed by the SPI module clock, 0: output
                                                     without delayed, 1: output delay for a SPI module clock
                                                     cycle at its negative edge. Can be configured in CONF state.              */
      __IOM uint32_t DOUT4_MODE : 1;            /*!< The output signal 4 is delayed by the SPI module clock, 0: output
                                                     without delayed, 1: output delay for a SPI module clock
                                                     cycle at its negative edge. Can be configured in CONF state.              */
      __IOM uint32_t DOUT5_MODE : 1;            /*!< The output signal 5 is delayed by the SPI module clock, 0: output
                                                     without delayed, 1: output delay for a SPI module clock
                                                     cycle at its negative edge. Can be configured in CONF state.              */
      __IOM uint32_t DOUT6_MODE : 1;            /*!< The output signal 6 is delayed by the SPI module clock, 0: output
                                                     without delayed, 1: output delay for a SPI module clock
                                                     cycle at its negative edge. Can be configured in CONF state.              */
      __IOM uint32_t DOUT7_MODE : 1;            /*!< The output signal 7 is delayed by the SPI module clock, 0: output
                                                     without delayed, 1: output delay for a SPI module clock
                                                     cycle at its negative edge. Can be configured in CONF state.              */
      __IOM uint32_t D_DQS_MODE : 1;            /*!< The output signal SPI_DQS is delayed by the SPI module clock,
                                                     0: output without delayed, 1: output delay for a SPI module
                                                     clock cycle at its negative edge. Can be configured in
                                                     CONF state.                                                               */
            uint32_t            : 23;
    } bit;
  } DOUT_MODE;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI DMA control register                                                  */
    
    struct {
      __IM  uint32_t DMA_OUTFIFO_EMPTY : 1;     /*!< Records the status of DMA TX FIFO. 1: DMA TX FIFO is not ready
                                                     for sending data. 0: DMA TX FIFO is ready for sending data.               */
      __IM  uint32_t DMA_INFIFO_FULL : 1;       /*!< Records the status of DMA RX FIFO. 1: DMA RX FIFO is not ready
                                                     for receiving data. 0: DMA RX FIFO is ready for receiving
                                                     data.                                                                     */
            uint32_t            : 16;
      __IOM uint32_t DMA_SLV_SEG_TRANS_EN : 1;  /*!< Enable dma segment transfer in spi dma half slave mode. 1: enable.
                                                     0: disable.                                                               */
      __IOM uint32_t SLV_RX_SEG_TRANS_CLR_EN : 1;/*!< 1: spi_dma_infifo_full_vld is cleared by spi slave cmd 5. 0:
                                                     spi_dma_infifo_full_vld is cleared by spi_trans_done.                     */
      __IOM uint32_t SLV_TX_SEG_TRANS_CLR_EN : 1;/*!< 1: spi_dma_outfifo_empty_vld is cleared by spi slave cmd 6.
                                                     0: spi_dma_outfifo_empty_vld is cleared by spi_trans_done.                */
      __IOM uint32_t RX_EOF_EN  : 1;            /*!< 1: spi_dma_inlink_eof is set when the number of dma pushed data
                                                     bytes is equal to the value of spi_slv/mst_dma_rd_bytelen[19:0]
                                                     in spi dma transition. 0: spi_dma_inlink_eof is set by
                                                     spi_trans_done in non-seg-trans or spi_dma_seg_trans_done
                                                     in seg-trans.                                                             */
            uint32_t            : 5;
      __IOM uint32_t DMA_RX_ENA : 1;            /*!< Set this bit to enable SPI DMA controlled receive data mode.              */
      __IOM uint32_t DMA_TX_ENA : 1;            /*!< Set this bit to enable SPI DMA controlled send data mode.                 */
      __OM  uint32_t RX_AFIFO_RST : 1;          /*!< Set this bit to reset RX AFIFO, which is used to receive data
                                                     in SPI master and slave mode transfer.                                    */
      __OM  uint32_t BUF_AFIFO_RST : 1;         /*!< Set this bit to reset BUF TX AFIFO, which is used send data
                                                     out in SPI slave CPU controlled mode transfer and master
                                                     mode transfer.                                                            */
      __OM  uint32_t DMA_AFIFO_RST : 1;         /*!< Set this bit to reset DMA TX AFIFO, which is used to send data
                                                     out in SPI slave DMA controlled mode transfer.                            */
    } bit;
  } DMA_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI interrupt enable register                                             */
    
    struct {
      __IOM uint32_t DMA_INFIFO_FULL_ERR_INT_ENA : 1;/*!< The enable bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.            */
      __IOM uint32_t DMA_OUTFIFO_EMPTY_ERR_INT_ENA : 1;/*!< The enable bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.        */
      __IOM uint32_t SLV_EX_QPI_INT_ENA : 1;    /*!< The enable bit for SPI slave Ex_QPI interrupt.                            */
      __IOM uint32_t SLV_EN_QPI_INT_ENA : 1;    /*!< The enable bit for SPI slave En_QPI interrupt.                            */
      __IOM uint32_t SLV_CMD7_INT_ENA : 1;      /*!< The enable bit for SPI slave CMD7 interrupt.                              */
      __IOM uint32_t SLV_CMD8_INT_ENA : 1;      /*!< The enable bit for SPI slave CMD8 interrupt.                              */
      __IOM uint32_t SLV_CMD9_INT_ENA : 1;      /*!< The enable bit for SPI slave CMD9 interrupt.                              */
      __IOM uint32_t SLV_CMDA_INT_ENA : 1;      /*!< The enable bit for SPI slave CMDA interrupt.                              */
      __IOM uint32_t SLV_RD_DMA_DONE_INT_ENA : 1;/*!< The enable bit for SPI_SLV_RD_DMA_DONE_INT interrupt.                    */
      __IOM uint32_t SLV_WR_DMA_DONE_INT_ENA : 1;/*!< The enable bit for SPI_SLV_WR_DMA_DONE_INT interrupt.                    */
      __IOM uint32_t SLV_RD_BUF_DONE_INT_ENA : 1;/*!< The enable bit for SPI_SLV_RD_BUF_DONE_INT interrupt.                    */
      __IOM uint32_t SLV_WR_BUF_DONE_INT_ENA : 1;/*!< The enable bit for SPI_SLV_WR_BUF_DONE_INT interrupt.                    */
      __IOM uint32_t TRANS_DONE_INT_ENA : 1;    /*!< The enable bit for SPI_TRANS_DONE_INT interrupt.                          */
      __IOM uint32_t DMA_SEG_TRANS_DONE_INT_ENA : 1;/*!< The enable bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.              */
      __IOM uint32_t SEG_MAGIC_ERR_INT_ENA : 1; /*!< The enable bit for SPI_SEG_MAGIC_ERR_INT interrupt.                       */
      __IOM uint32_t SLV_BUF_ADDR_ERR_INT_ENA : 1;/*!< The enable bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.                  */
      __IOM uint32_t SLV_CMD_ERR_INT_ENA : 1;   /*!< The enable bit for SPI_SLV_CMD_ERR_INT interrupt.                         */
      __IOM uint32_t MST_RX_AFIFO_WFULL_ERR_INT_ENA : 1;/*!< The enable bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.      */
      __IOM uint32_t MST_TX_AFIFO_REMPTY_ERR_INT_ENA : 1;/*!< The enable bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.    */
      __IOM uint32_t APP2_INT_ENA : 1;          /*!< The enable bit for SPI_APP2_INT interrupt.                                */
      __IOM uint32_t APP1_INT_ENA : 1;          /*!< The enable bit for SPI_APP1_INT interrupt.                                */
            uint32_t            : 11;
    } bit;
  } DMA_INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI interrupt clear register                                              */
    
    struct {
      __OM  uint32_t DMA_INFIFO_FULL_ERR_INT_CLR : 1;/*!< The clear bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.             */
      __OM  uint32_t DMA_OUTFIFO_EMPTY_ERR_INT_CLR : 1;/*!< The clear bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.         */
      __OM  uint32_t SLV_EX_QPI_INT_CLR : 1;    /*!< The clear bit for SPI slave Ex_QPI interrupt.                             */
      __OM  uint32_t SLV_EN_QPI_INT_CLR : 1;    /*!< The clear bit for SPI slave En_QPI interrupt.                             */
      __OM  uint32_t SLV_CMD7_INT_CLR : 1;      /*!< The clear bit for SPI slave CMD7 interrupt.                               */
      __OM  uint32_t SLV_CMD8_INT_CLR : 1;      /*!< The clear bit for SPI slave CMD8 interrupt.                               */
      __OM  uint32_t SLV_CMD9_INT_CLR : 1;      /*!< The clear bit for SPI slave CMD9 interrupt.                               */
      __OM  uint32_t SLV_CMDA_INT_CLR : 1;      /*!< The clear bit for SPI slave CMDA interrupt.                               */
      __OM  uint32_t SLV_RD_DMA_DONE_INT_CLR : 1;/*!< The clear bit for SPI_SLV_RD_DMA_DONE_INT interrupt.                     */
      __OM  uint32_t SLV_WR_DMA_DONE_INT_CLR : 1;/*!< The clear bit for SPI_SLV_WR_DMA_DONE_INT interrupt.                     */
      __OM  uint32_t SLV_RD_BUF_DONE_INT_CLR : 1;/*!< The clear bit for SPI_SLV_RD_BUF_DONE_INT interrupt.                     */
      __OM  uint32_t SLV_WR_BUF_DONE_INT_CLR : 1;/*!< The clear bit for SPI_SLV_WR_BUF_DONE_INT interrupt.                     */
      __OM  uint32_t TRANS_DONE_INT_CLR : 1;    /*!< The clear bit for SPI_TRANS_DONE_INT interrupt.                           */
      __OM  uint32_t DMA_SEG_TRANS_DONE_INT_CLR : 1;/*!< The clear bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.               */
      __OM  uint32_t SEG_MAGIC_ERR_INT_CLR : 1; /*!< The clear bit for SPI_SEG_MAGIC_ERR_INT interrupt.                        */
      __OM  uint32_t SLV_BUF_ADDR_ERR_INT_CLR : 1;/*!< The clear bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.                   */
      __OM  uint32_t SLV_CMD_ERR_INT_CLR : 1;   /*!< The clear bit for SPI_SLV_CMD_ERR_INT interrupt.                          */
      __OM  uint32_t MST_RX_AFIFO_WFULL_ERR_INT_CLR : 1;/*!< The clear bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.       */
      __OM  uint32_t MST_TX_AFIFO_REMPTY_ERR_INT_CLR : 1;/*!< The clear bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.     */
      __OM  uint32_t APP2_INT_CLR : 1;          /*!< The clear bit for SPI_APP2_INT interrupt.                                 */
      __OM  uint32_t APP1_INT_CLR : 1;          /*!< The clear bit for SPI_APP1_INT interrupt.                                 */
            uint32_t            : 11;
    } bit;
  } DMA_INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI interrupt raw register                                                */
    
    struct {
      __IOM uint32_t DMA_INFIFO_FULL_ERR_INT_RAW : 1;/*!< 1: The current data rate of DMA Rx is smaller than that of SPI,
                                                     which will lose the receive data. 0: Others.                              */
      __IOM uint32_t DMA_OUTFIFO_EMPTY_ERR_INT_RAW : 1;/*!< 1: The current data rate of DMA TX is smaller than that of SPI.
                                                     SPI will stop in master mode and send out all 0 in slave
                                                     mode. 0: Others.                                                          */
      __IOM uint32_t SLV_EX_QPI_INT_RAW : 1;    /*!< The raw bit for SPI slave Ex_QPI interrupt. 1: SPI slave mode
                                                     Ex_QPI transmission is ended. 0: Others.                                  */
      __IOM uint32_t SLV_EN_QPI_INT_RAW : 1;    /*!< The raw bit for SPI slave En_QPI interrupt. 1: SPI slave mode
                                                     En_QPI transmission is ended. 0: Others.                                  */
      __IOM uint32_t SLV_CMD7_INT_RAW : 1;      /*!< The raw bit for SPI slave CMD7 interrupt. 1: SPI slave mode
                                                     CMD7 transmission is ended. 0: Others.                                    */
      __IOM uint32_t SLV_CMD8_INT_RAW : 1;      /*!< The raw bit for SPI slave CMD8 interrupt. 1: SPI slave mode
                                                     CMD8 transmission is ended. 0: Others.                                    */
      __IOM uint32_t SLV_CMD9_INT_RAW : 1;      /*!< The raw bit for SPI slave CMD9 interrupt. 1: SPI slave mode
                                                     CMD9 transmission is ended. 0: Others.                                    */
      __IOM uint32_t SLV_CMDA_INT_RAW : 1;      /*!< The raw bit for SPI slave CMDA interrupt. 1: SPI slave mode
                                                     CMDA transmission is ended. 0: Others.                                    */
      __IOM uint32_t SLV_RD_DMA_DONE_INT_RAW : 1;/*!< The raw bit for SPI_SLV_RD_DMA_DONE_INT interrupt. 1: SPI slave
                                                     mode Rd_DMA transmission is ended. 0: Others.                             */
      __IOM uint32_t SLV_WR_DMA_DONE_INT_RAW : 1;/*!< The raw bit for SPI_SLV_WR_DMA_DONE_INT interrupt. 1: SPI slave
                                                     mode Wr_DMA transmission is ended. 0: Others.                             */
      __IOM uint32_t SLV_RD_BUF_DONE_INT_RAW : 1;/*!< The raw bit for SPI_SLV_RD_BUF_DONE_INT interrupt. 1: SPI slave
                                                     mode Rd_BUF transmission is ended. 0: Others.                             */
      __IOM uint32_t SLV_WR_BUF_DONE_INT_RAW : 1;/*!< The raw bit for SPI_SLV_WR_BUF_DONE_INT interrupt. 1: SPI slave
                                                     mode Wr_BUF transmission is ended. 0: Others.                             */
      __IOM uint32_t TRANS_DONE_INT_RAW : 1;    /*!< The raw bit for SPI_TRANS_DONE_INT interrupt. 1: SPI master
                                                     mode transmission is ended. 0: others.                                    */
      __IOM uint32_t DMA_SEG_TRANS_DONE_INT_RAW : 1;/*!< The raw bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt. 1: spi
                                                     master DMA full-duplex/half-duplex seg-conf-trans ends
                                                     or slave half-duplex seg-trans ends. And data has been
                                                     pushed to corresponding memory. 0: seg-conf-trans or seg-trans
                                                     is not ended or not occurred.                                             */
      __IOM uint32_t SEG_MAGIC_ERR_INT_RAW : 1; /*!< The raw bit for SPI_SEG_MAGIC_ERR_INT interrupt. 1: The magic
                                                     value in CONF buffer is error in the DMA seg-conf-trans.
                                                     0: others.                                                                */
      __IOM uint32_t SLV_BUF_ADDR_ERR_INT_RAW : 1;/*!< The raw bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt. 1: The accessing
                                                     data address of the current SPI slave mode CPU controlled
                                                     FD, Wr_BUF or Rd_BUF transmission is bigger than 63. 0:
                                                     Others.                                                                   */
      __IOM uint32_t SLV_CMD_ERR_INT_RAW : 1;   /*!< The raw bit for SPI_SLV_CMD_ERR_INT interrupt. 1: The slave
                                                     command value in the current SPI slave HD mode transmission
                                                     is not supported. 0: Others.                                              */
      __IOM uint32_t MST_RX_AFIFO_WFULL_ERR_INT_RAW : 1;/*!< The raw bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt. 1:
                                                     There is a RX AFIFO write-full error when SPI inputs data
                                                     in master mode. 0: Others.                                                */
      __IOM uint32_t MST_TX_AFIFO_REMPTY_ERR_INT_RAW : 1;/*!< The raw bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt. 1:
                                                     There is a TX BUF AFIFO read-empty error when SPI outputs
                                                     data in master mode. 0: Others.                                           */
      __IOM uint32_t APP2_INT_RAW : 1;          /*!< The raw bit for SPI_APP2_INT interrupt. The value is only controlled
                                                     by software.                                                              */
      __IOM uint32_t APP1_INT_RAW : 1;          /*!< The raw bit for SPI_APP1_INT interrupt. The value is only controlled
                                                     by software.                                                              */
            uint32_t            : 11;
    } bit;
  } DMA_INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI interrupt status register                                             */
    
    struct {
      __IM  uint32_t DMA_INFIFO_FULL_ERR_INT_ST : 1;/*!< The status bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.             */
      __IM  uint32_t DMA_OUTFIFO_EMPTY_ERR_INT_ST : 1;/*!< The status bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.         */
      __IM  uint32_t SLV_EX_QPI_INT_ST : 1;     /*!< The status bit for SPI slave Ex_QPI interrupt.                            */
      __IM  uint32_t SLV_EN_QPI_INT_ST : 1;     /*!< The status bit for SPI slave En_QPI interrupt.                            */
      __IM  uint32_t SLV_CMD7_INT_ST : 1;       /*!< The status bit for SPI slave CMD7 interrupt.                              */
      __IM  uint32_t SLV_CMD8_INT_ST : 1;       /*!< The status bit for SPI slave CMD8 interrupt.                              */
      __IM  uint32_t SLV_CMD9_INT_ST : 1;       /*!< The status bit for SPI slave CMD9 interrupt.                              */
      __IM  uint32_t SLV_CMDA_INT_ST : 1;       /*!< The status bit for SPI slave CMDA interrupt.                              */
      __IM  uint32_t SLV_RD_DMA_DONE_INT_ST : 1;/*!< The status bit for SPI_SLV_RD_DMA_DONE_INT interrupt.                     */
      __IM  uint32_t SLV_WR_DMA_DONE_INT_ST : 1;/*!< The status bit for SPI_SLV_WR_DMA_DONE_INT interrupt.                     */
      __IM  uint32_t SLV_RD_BUF_DONE_INT_ST : 1;/*!< The status bit for SPI_SLV_RD_BUF_DONE_INT interrupt.                     */
      __IM  uint32_t SLV_WR_BUF_DONE_INT_ST : 1;/*!< The status bit for SPI_SLV_WR_BUF_DONE_INT interrupt.                     */
      __IM  uint32_t TRANS_DONE_INT_ST : 1;     /*!< The status bit for SPI_TRANS_DONE_INT interrupt.                          */
      __IM  uint32_t DMA_SEG_TRANS_DONE_INT_ST : 1;/*!< The status bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.               */
      __IM  uint32_t SEG_MAGIC_ERR_INT_ST : 1;  /*!< The status bit for SPI_SEG_MAGIC_ERR_INT interrupt.                       */
      __IM  uint32_t SLV_BUF_ADDR_ERR_INT_ST : 1;/*!< The status bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.                   */
      __IM  uint32_t SLV_CMD_ERR_INT_ST : 1;    /*!< The status bit for SPI_SLV_CMD_ERR_INT interrupt.                         */
      __IM  uint32_t MST_RX_AFIFO_WFULL_ERR_INT_ST : 1;/*!< The status bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt.       */
      __IM  uint32_t MST_TX_AFIFO_REMPTY_ERR_INT_ST : 1;/*!< The status bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt.     */
      __IM  uint32_t APP2_INT_ST : 1;           /*!< The status bit for SPI_APP2_INT interrupt.                                */
      __IM  uint32_t APP1_INT_ST : 1;           /*!< The status bit for SPI_APP1_INT interrupt.                                */
            uint32_t            : 11;
    } bit;
  } DMA_INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI interrupt software set register                                       */
    
    struct {
      __OM  uint32_t DMA_INFIFO_FULL_ERR_INT_SET : 1;/*!< The software set bit for SPI_DMA_INFIFO_FULL_ERR_INT interrupt.      */
      __OM  uint32_t DMA_OUTFIFO_EMPTY_ERR_INT_SET : 1;/*!< The software set bit for SPI_DMA_OUTFIFO_EMPTY_ERR_INT interrupt.  */
      __OM  uint32_t SLV_EX_QPI_INT_SET : 1;    /*!< The software set bit for SPI slave Ex_QPI interrupt.                      */
      __OM  uint32_t SLV_EN_QPI_INT_SET : 1;    /*!< The software set bit for SPI slave En_QPI interrupt.                      */
      __OM  uint32_t SLV_CMD7_INT_SET : 1;      /*!< The software set bit for SPI slave CMD7 interrupt.                        */
      __OM  uint32_t SLV_CMD8_INT_SET : 1;      /*!< The software set bit for SPI slave CMD8 interrupt.                        */
      __OM  uint32_t SLV_CMD9_INT_SET : 1;      /*!< The software set bit for SPI slave CMD9 interrupt.                        */
      __OM  uint32_t SLV_CMDA_INT_SET : 1;      /*!< The software set bit for SPI slave CMDA interrupt.                        */
      __OM  uint32_t SLV_RD_DMA_DONE_INT_SET : 1;/*!< The software set bit for SPI_SLV_RD_DMA_DONE_INT interrupt.              */
      __OM  uint32_t SLV_WR_DMA_DONE_INT_SET : 1;/*!< The software set bit for SPI_SLV_WR_DMA_DONE_INT interrupt.              */
      __OM  uint32_t SLV_RD_BUF_DONE_INT_SET : 1;/*!< The software set bit for SPI_SLV_RD_BUF_DONE_INT interrupt.              */
      __OM  uint32_t SLV_WR_BUF_DONE_INT_SET : 1;/*!< The software set bit for SPI_SLV_WR_BUF_DONE_INT interrupt.              */
      __OM  uint32_t TRANS_DONE_INT_SET : 1;    /*!< The software set bit for SPI_TRANS_DONE_INT interrupt.                    */
      __OM  uint32_t DMA_SEG_TRANS_DONE_INT_SET : 1;/*!< The software set bit for SPI_DMA_SEG_TRANS_DONE_INT interrupt.        */
      __OM  uint32_t SEG_MAGIC_ERR_INT_SET : 1; /*!< The software set bit for SPI_SEG_MAGIC_ERR_INT interrupt.                 */
      __OM  uint32_t SLV_BUF_ADDR_ERR_INT_SET : 1;/*!< The software set bit for SPI_SLV_BUF_ADDR_ERR_INT interrupt.            */
      __OM  uint32_t SLV_CMD_ERR_INT_SET : 1;   /*!< The software set bit for SPI_SLV_CMD_ERR_INT interrupt.                   */
      __OM  uint32_t MST_RX_AFIFO_WFULL_ERR_INT_SET : 1;/*!< The software set bit for SPI_MST_RX_AFIFO_WFULL_ERR_INT interrupt. */
      __OM  uint32_t MST_TX_AFIFO_REMPTY_ERR_INT_SET : 1;/*!< The software set bit for SPI_MST_TX_AFIFO_REMPTY_ERR_INT interrupt. */
      __OM  uint32_t APP2_INT_SET : 1;          /*!< The software set bit for SPI_APP2_INT interrupt.                          */
      __OM  uint32_t APP1_INT_SET : 1;          /*!< The software set bit for SPI_APP1_INT interrupt.                          */
            uint32_t            : 11;
    } bit;
  } DMA_INT_SET;
  __IM  uint32_t  RESERVED[20];
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer0                                                */
    
    struct {
      __IOM uint32_t BUF0       : 32;           /*!< data buffer                                                               */
    } bit;
  } W0;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer1                                                */
    
    struct {
      __IOM uint32_t BUF1       : 32;           /*!< data buffer                                                               */
    } bit;
  } W1;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer2                                                */
    
    struct {
      __IOM uint32_t BUF2       : 32;           /*!< data buffer                                                               */
    } bit;
  } W2;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer3                                                */
    
    struct {
      __IOM uint32_t BUF3       : 32;           /*!< data buffer                                                               */
    } bit;
  } W3;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer4                                                */
    
    struct {
      __IOM uint32_t BUF4       : 32;           /*!< data buffer                                                               */
    } bit;
  } W4;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer5                                                */
    
    struct {
      __IOM uint32_t BUF5       : 32;           /*!< data buffer                                                               */
    } bit;
  } W5;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer6                                                */
    
    struct {
      __IOM uint32_t BUF6       : 32;           /*!< data buffer                                                               */
    } bit;
  } W6;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer7                                                */
    
    struct {
      __IOM uint32_t BUF7       : 32;           /*!< data buffer                                                               */
    } bit;
  } W7;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer8                                                */
    
    struct {
      __IOM uint32_t BUF8       : 32;           /*!< data buffer                                                               */
    } bit;
  } W8;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer9                                                */
    
    struct {
      __IOM uint32_t BUF9       : 32;           /*!< data buffer                                                               */
    } bit;
  } W9;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer10                                               */
    
    struct {
      __IOM uint32_t BUF10      : 32;           /*!< data buffer                                                               */
    } bit;
  } W10;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer11                                               */
    
    struct {
      __IOM uint32_t BUF11      : 32;           /*!< data buffer                                                               */
    } bit;
  } W11;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer12                                               */
    
    struct {
      __IOM uint32_t BUF12      : 32;           /*!< data buffer                                                               */
    } bit;
  } W12;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer13                                               */
    
    struct {
      __IOM uint32_t BUF13      : 32;           /*!< data buffer                                                               */
    } bit;
  } W13;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer14                                               */
    
    struct {
      __IOM uint32_t BUF14      : 32;           /*!< data buffer                                                               */
    } bit;
  } W14;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI CPU-controlled buffer15                                               */
    
    struct {
      __IOM uint32_t BUF15      : 32;           /*!< data buffer                                                               */
    } bit;
  } W15;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t reg;                         /*!< SPI slave control register                                                */
    
    struct {
      __IOM uint32_t CLK_MODE   : 2;            /*!< SPI clock mode bits. 0: SPI clock is off when CS inactive 1:
                                                     SPI clock is delayed one cycle after CS inactive 2: SPI
                                                     clock is delayed two cycles after CS inactive 3: SPI clock
                                                     is alwasy on. Can be configured in CONF state.                            */
      __IOM uint32_t CLK_MODE_13 : 1;           /*!< {CPOL, CPHA},1: support spi clk mode 1 and 3, first edge output
                                                     data B[0]/B[7]. 0: support spi clk mode 0 and 2, first
                                                     edge output data B[1]/B[6].                                               */
      __IOM uint32_t RSCK_DATA_OUT : 1;         /*!< It saves half a cycle when tsck is the same as rsck. 1: output
                                                     data at rsck posedge 0: output data at tsck posedge                       */
            uint32_t            : 4;
      __IOM uint32_t SLV_RDDMA_BITLEN_EN : 1;   /*!< 1: SPI_SLV_DATA_BITLEN stores data bit length of master-read-slave
                                                     data length in DMA controlled mode(Rd_DMA). 0: others                     */
      __IOM uint32_t SLV_WRDMA_BITLEN_EN : 1;   /*!< 1: SPI_SLV_DATA_BITLEN stores data bit length of master-write-to-slave
                                                     data length in DMA controlled mode(Wr_DMA). 0: others                     */
      __IOM uint32_t SLV_RDBUF_BITLEN_EN : 1;   /*!< 1: SPI_SLV_DATA_BITLEN stores data bit length of master-read-slave
                                                     data length in CPU controlled mode(Rd_BUF). 0: others                     */
      __IOM uint32_t SLV_WRBUF_BITLEN_EN : 1;   /*!< 1: SPI_SLV_DATA_BITLEN stores data bit length of master-write-to-slave
                                                     data length in CPU controlled mode(Wr_BUF). 0: others                     */
            uint32_t            : 10;
      __IOM uint32_t DMA_SEG_MAGIC_VALUE : 4;   /*!< The magic value of BM table in master DMA seg-trans.                      */
      __IOM uint32_t MODE       : 1;            /*!< Set SPI work mode. 1: slave mode 0: master mode.                          */
      __OM  uint32_t SOFT_RESET : 1;            /*!< Software reset enable, reset the spi clock line cs line and
                                                     data lines. Can be configured in CONF state.                              */
      __IOM uint32_t USR_CONF   : 1;            /*!< 1: Enable the DMA CONF phase of current seg-trans operation,
                                                     which means seg-trans will start. 0: This is not seg-trans
                                                     mode.                                                                     */
            uint32_t            : 3;
    } bit;
  } SLAVE;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI slave control register 1                                              */
    
    struct {
      __IOM uint32_t SLV_DATA_BITLEN : 18;      /*!< The transferred data bit length in SPI slave FD and HD mode.              */
      __IOM uint32_t SLV_LAST_COMMAND : 8;      /*!< In the slave mode it is the value of command.                             */
      __IOM uint32_t SLV_LAST_ADDR : 6;         /*!< In the slave mode it is the value of address.                             */
    } bit;
  } SLAVE1;
  
  union {
    __IOM uint32_t reg;                         /*!< SPI module clock and register clock control                               */
    
    struct {
      __IOM uint32_t CLK_EN     : 1;            /*!< Set this bit to enable clk gate                                           */
      __IOM uint32_t MST_CLK_ACTIVE : 1;        /*!< Set this bit to power on the SPI module clock.                            */
      __IOM uint32_t MST_CLK_SEL : 1;           /*!< This bit is used to select SPI module clock source in master
                                                     mode. 1: PLL_CLK_80M. 0: XTAL CLK.                                        */
            uint32_t            : 29;
    } bit;
  } CLK_GATE;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< Version control                                                           */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< SPI register version.                                                     */
            uint32_t            : 4;
    } bit;
  } DATE;
} SPI2_Type;                                    /*!< Size = 244 (0xf4)                                                         */



/* =========================================================================================================================== */
/* ================                                          SYSTEM                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief System Configuration Registers (SYSTEM)
  */

typedef struct {                                /*!< SYSTEM Structure                                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 control regiter 0                                                   */
    
    struct {
      __IOM uint32_t CONTROL_CORE_1_RUNSTALL : 1;/*!< Set 1 to stall core1                                                     */
      __IOM uint32_t CONTROL_CORE_1_CLKGATE_EN : 1;/*!< Set 1 to open core1 clock                                              */
      __IOM uint32_t CONTROL_CORE_1_RESETING : 1;/*!< Set 1 to let core1 reset                                                 */
            uint32_t            : 29;
    } bit;
  } CORE_1_CONTROL_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Core0 control regiter 1                                                   */
    
    struct {
      __IOM uint32_t CONTROL_CORE_1_MESSAGE : 32;/*!< it's only a R/W register, no function, software can write any
                                                     value                                                                     */
    } bit;
  } CORE_1_CONTROL_1;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_peripheral clock configuration register                               */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t CLK_EN_ASSIST_DEBUG : 1;   /*!< Set 1 to open assist_debug module clock                                   */
      __IOM uint32_t CLK_EN_DEDICATED_GPIO : 1; /*!< Set 1 to open dedicated_gpio module clk                                   */
            uint32_t            : 24;
    } bit;
  } CPU_PERI_CLK_EN;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu_peripheral reset configuration regsiter                               */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t RST_EN_ASSIST_DEBUG : 1;   /*!< Set 1 to let assist_debug module reset                                    */
      __IOM uint32_t RST_EN_DEDICATED_GPIO : 1; /*!< Set 1 to let dedicated_gpio module reset                                  */
            uint32_t            : 24;
    } bit;
  } CPU_PERI_RST_EN;
  
  union {
    __IOM uint32_t reg;                         /*!< cpu peripheral clock configuration register                               */
    
    struct {
      __IOM uint32_t CPUPERIOD_SEL : 2;         /*!< This field used to sel cpu clock frequent.                                */
      __IOM uint32_t PLL_FREQ_SEL : 1;          /*!< This field used to sel pll frequent.                                      */
      __IOM uint32_t CPU_WAIT_MODE_FORCE_ON : 1;/*!< Set 1 to force cpu_waiti_clk enable.                                      */
      __IOM uint32_t CPU_WAITI_DELAY_NUM : 4;   /*!< This field used to set delay cycle when cpu enter waiti mode,
                                                     after delay waiti_clk will close                                          */
            uint32_t            : 24;
    } bit;
  } CPU_PER_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< memory power down mask configuration register                             */
    
    struct {
      __IOM uint32_t LSLP_MEM_PD_MASK : 1;      /*!< Set 1 to mask memory power down.                                          */
            uint32_t            : 31;
    } bit;
  } MEM_PD_MASK;
  
  union {
    __IOM uint32_t reg;                         /*!< peripheral clock configuration regsiter 0                                 */
    
    struct {
      __IOM uint32_t TIMERS_CLK_EN : 1;         /*!< Set 1 to enable TIMERS clock                                              */
      __IOM uint32_t SPI01_CLK_EN : 1;          /*!< Set 1 to enable SPI01 clock                                               */
      __IOM uint32_t UART_CLK_EN : 1;           /*!< Set 1 to enable UART clock                                                */
      __IOM uint32_t WDG_CLK_EN : 1;            /*!< Set 1 to enable WDG clock                                                 */
      __IOM uint32_t I2S0_CLK_EN : 1;           /*!< Set 1 to enable I2S0 clock                                                */
      __IOM uint32_t UART1_CLK_EN : 1;          /*!< Set 1 to enable UART1 clock                                               */
      __IOM uint32_t SPI2_CLK_EN : 1;           /*!< Set 1 to enable SPI2 clock                                                */
      __IOM uint32_t I2C_EXT0_CLK_EN : 1;       /*!< Set 1 to enable I2C_EXT0 clock                                            */
      __IOM uint32_t UHCI0_CLK_EN : 1;          /*!< Set 1 to enable UHCI0 clock                                               */
      __IOM uint32_t RMT_CLK_EN : 1;            /*!< Set 1 to enable RMT clock                                                 */
      __IOM uint32_t PCNT_CLK_EN : 1;           /*!< Set 1 to enable PCNT clock                                                */
      __IOM uint32_t LEDC_CLK_EN : 1;           /*!< Set 1 to enable LEDC clock                                                */
      __IOM uint32_t UHCI1_CLK_EN : 1;          /*!< Set 1 to enable UHCI1 clock                                               */
      __IOM uint32_t TIMERGROUP_CLK_EN : 1;     /*!< Set 1 to enable TIMERGROUP clock                                          */
      __IOM uint32_t EFUSE_CLK_EN : 1;          /*!< Set 1 to enable EFUSE clock                                               */
      __IOM uint32_t TIMERGROUP1_CLK_EN : 1;    /*!< Set 1 to enable TIMERGROUP1 clock                                         */
      __IOM uint32_t SPI3_CLK_EN : 1;           /*!< Set 1 to enable SPI3 clock                                                */
      __IOM uint32_t PWM0_CLK_EN : 1;           /*!< Set 1 to enable PWM0 clock                                                */
      __IOM uint32_t I2C_EXT1_CLK_EN : 1;       /*!< Set 1 to enable I2C_EXT1 clock                                            */
      __IOM uint32_t TWAI_CLK_EN : 1;           /*!< Set 1 to enable CAN clock                                                 */
      __IOM uint32_t PWM1_CLK_EN : 1;           /*!< Set 1 to enable PWM1 clock                                                */
      __IOM uint32_t I2S1_CLK_EN : 1;           /*!< Set 1 to enable I2S1 clock                                                */
      __IOM uint32_t SPI2_DMA_CLK_EN : 1;       /*!< Set 1 to enable SPI2_DMA clock                                            */
      __IOM uint32_t USB_CLK_EN : 1;            /*!< Set 1 to enable USB clock                                                 */
      __IOM uint32_t UART_MEM_CLK_EN : 1;       /*!< Set 1 to enable UART_MEM clock                                            */
      __IOM uint32_t PWM2_CLK_EN : 1;           /*!< Set 1 to enable PWM2 clock                                                */
      __IOM uint32_t PWM3_CLK_EN : 1;           /*!< Set 1 to enable PWM3 clock                                                */
      __IOM uint32_t SPI3_DMA_CLK_EN : 1;       /*!< Set 1 to enable SPI4 clock                                                */
      __IOM uint32_t APB_SARADC_CLK_EN : 1;     /*!< Set 1 to enable APB_SARADC clock                                          */
      __IOM uint32_t SYSTIMER_CLK_EN : 1;       /*!< Set 1 to enable SYSTEMTIMER clock                                         */
      __IOM uint32_t ADC2_ARB_CLK_EN : 1;       /*!< Set 1 to enable ADC2_ARB clock                                            */
      __IOM uint32_t SPI4_CLK_EN : 1;           /*!< Set 1 to enable SPI4 clock                                                */
    } bit;
  } PERIP_CLK_EN0;
  
  union {
    __IOM uint32_t reg;                         /*!< peripheral clock configuration regsiter 1                                 */
    
    struct {
      __IOM uint32_t PERI_BACKUP_CLK_EN : 1;    /*!< Set 1 to enable BACKUP clock                                              */
      __IOM uint32_t CRYPTO_AES_CLK_EN : 1;     /*!< Set 1 to enable AES clock                                                 */
      __IOM uint32_t CRYPTO_SHA_CLK_EN : 1;     /*!< Set 1 to enable SHA clock                                                 */
      __IOM uint32_t CRYPTO_RSA_CLK_EN : 1;     /*!< Set 1 to enable RSA clock                                                 */
      __IOM uint32_t CRYPTO_DS_CLK_EN : 1;      /*!< Set 1 to enable DS clock                                                  */
      __IOM uint32_t CRYPTO_HMAC_CLK_EN : 1;    /*!< Set 1 to enable HMAC clock                                                */
      __IOM uint32_t DMA_CLK_EN : 1;            /*!< Set 1 to enable DMA clock                                                 */
      __IOM uint32_t SDIO_HOST_CLK_EN : 1;      /*!< Set 1 to enable SDIO_HOST clock                                           */
      __IOM uint32_t LCD_CAM_CLK_EN : 1;        /*!< Set 1 to enable LCD_CAM clock                                             */
      __IOM uint32_t UART2_CLK_EN : 1;          /*!< Set 1 to enable UART2 clock                                               */
      __IOM uint32_t USB_DEVICE_CLK_EN : 1;     /*!< Set 1 to enable USB_DEVICE clock                                          */
            uint32_t            : 21;
    } bit;
  } PERIP_CLK_EN1;
  
  union {
    __IOM uint32_t reg;                         /*!< peripheral reset configuration register0                                  */
    
    struct {
      __IOM uint32_t TIMERS_RST : 1;            /*!< Set 1 to let TIMERS reset                                                 */
      __IOM uint32_t SPI01_RST  : 1;            /*!< Set 1 to let SPI01 reset                                                  */
      __IOM uint32_t UART_RST   : 1;            /*!< Set 1 to let UART reset                                                   */
      __IOM uint32_t WDG_RST    : 1;            /*!< Set 1 to let WDG reset                                                    */
      __IOM uint32_t I2S0_RST   : 1;            /*!< Set 1 to let I2S0 reset                                                   */
      __IOM uint32_t UART1_RST  : 1;            /*!< Set 1 to let UART1 reset                                                  */
      __IOM uint32_t SPI2_RST   : 1;            /*!< Set 1 to let SPI2 reset                                                   */
      __IOM uint32_t I2C_EXT0_RST : 1;          /*!< Set 1 to let I2C_EXT0 reset                                               */
      __IOM uint32_t UHCI0_RST  : 1;            /*!< Set 1 to let UHCI0 reset                                                  */
      __IOM uint32_t RMT_RST    : 1;            /*!< Set 1 to let RMT reset                                                    */
      __IOM uint32_t PCNT_RST   : 1;            /*!< Set 1 to let PCNT reset                                                   */
      __IOM uint32_t LEDC_RST   : 1;            /*!< Set 1 to let LEDC reset                                                   */
      __IOM uint32_t UHCI1_RST  : 1;            /*!< Set 1 to let UHCI1 reset                                                  */
      __IOM uint32_t TIMERGROUP_RST : 1;        /*!< Set 1 to let TIMERGROUP reset                                             */
      __IOM uint32_t EFUSE_RST  : 1;            /*!< Set 1 to let EFUSE reset                                                  */
      __IOM uint32_t TIMERGROUP1_RST : 1;       /*!< Set 1 to let TIMERGROUP1 reset                                            */
      __IOM uint32_t SPI3_RST   : 1;            /*!< Set 1 to let SPI3 reset                                                   */
      __IOM uint32_t PWM0_RST   : 1;            /*!< Set 1 to let PWM0 reset                                                   */
      __IOM uint32_t I2C_EXT1_RST : 1;          /*!< Set 1 to let I2C_EXT1 reset                                               */
      __IOM uint32_t TWAI_RST   : 1;            /*!< Set 1 to let CAN reset                                                    */
      __IOM uint32_t PWM1_RST   : 1;            /*!< Set 1 to let PWM1 reset                                                   */
      __IOM uint32_t I2S1_RST   : 1;            /*!< Set 1 to let I2S1 reset                                                   */
      __IOM uint32_t SPI2_DMA_RST : 1;          /*!< Set 1 to let SPI2 reset                                                   */
      __IOM uint32_t USB_RST    : 1;            /*!< Set 1 to let USB reset                                                    */
      __IOM uint32_t UART_MEM_RST : 1;          /*!< Set 1 to let UART_MEM reset                                               */
      __IOM uint32_t PWM2_RST   : 1;            /*!< Set 1 to let PWM2 reset                                                   */
      __IOM uint32_t PWM3_RST   : 1;            /*!< Set 1 to let PWM3 reset                                                   */
      __IOM uint32_t SPI3_DMA_RST : 1;          /*!< Set 1 to let SPI3 reset                                                   */
      __IOM uint32_t APB_SARADC_RST : 1;        /*!< Set 1 to let APB_SARADC reset                                             */
      __IOM uint32_t SYSTIMER_RST : 1;          /*!< Set 1 to let SYSTIMER reset                                               */
      __IOM uint32_t ADC2_ARB_RST : 1;          /*!< Set 1 to let ADC2_ARB reset                                               */
      __IOM uint32_t SPI4_RST   : 1;            /*!< Set 1 to let SPI4 reset                                                   */
    } bit;
  } PERIP_RST_EN0;
  
  union {
    __IOM uint32_t reg;                         /*!< peripheral reset configuration regsiter 1                                 */
    
    struct {
      __IOM uint32_t PERI_BACKUP_RST : 1;       /*!< Set 1 to let BACKUP reset                                                 */
      __IOM uint32_t CRYPTO_AES_RST : 1;        /*!< Set 1 to let CRYPTO_AES reset                                             */
      __IOM uint32_t CRYPTO_SHA_RST : 1;        /*!< Set 1 to let CRYPTO_SHA reset                                             */
      __IOM uint32_t CRYPTO_RSA_RST : 1;        /*!< Set 1 to let CRYPTO_RSA reset                                             */
      __IOM uint32_t CRYPTO_DS_RST : 1;         /*!< Set 1 to let CRYPTO_DS reset                                              */
      __IOM uint32_t CRYPTO_HMAC_RST : 1;       /*!< Set 1 to let CRYPTO_HMAC reset                                            */
      __IOM uint32_t DMA_RST    : 1;            /*!< Set 1 to let DMA reset                                                    */
      __IOM uint32_t SDIO_HOST_RST : 1;         /*!< Set 1 to let SDIO_HOST reset                                              */
      __IOM uint32_t LCD_CAM_RST : 1;           /*!< Set 1 to let LCD_CAM reset                                                */
      __IOM uint32_t UART2_RST  : 1;            /*!< Set 1 to let UART2 reset                                                  */
      __IOM uint32_t USB_DEVICE_RST : 1;        /*!< Set 1 to let USB_DEVICE reset                                             */
            uint32_t            : 21;
    } bit;
  } PERIP_RST_EN1;
  
  union {
    __IOM uint32_t reg;                         /*!< low power clock frequent division factor configuration regsiter           */
    
    struct {
      __IOM uint32_t BT_LPCK_DIV_NUM : 12;      /*!< This field is lower power clock frequent division factor                  */
            uint32_t            : 20;
    } bit;
  } BT_LPCK_DIV_INT;
  
  union {
    __IOM uint32_t reg;                         /*!< low power clock configuration register                                    */
    
    struct {
      __IOM uint32_t BT_LPCK_DIV_B : 12;        /*!< This field is lower power clock frequent division factor b                */
      __IOM uint32_t BT_LPCK_DIV_A : 12;        /*!< This field is lower power clock frequent division factor a                */
      __IOM uint32_t LPCLK_SEL_RTC_SLOW : 1;    /*!< Set 1 to select rtc-slow clock as rtc low power clock                     */
      __IOM uint32_t LPCLK_SEL_8M : 1;          /*!< Set 1 to select 8m clock as rtc low power clock                           */
      __IOM uint32_t LPCLK_SEL_XTAL : 1;        /*!< Set 1 to select xtal clock as rtc low power clock                         */
      __IOM uint32_t LPCLK_SEL_XTAL32K : 1;     /*!< Set 1 to select xtal32k clock as low power clock                          */
      __IOM uint32_t LPCLK_RTC_EN : 1;          /*!< Set 1 to enable RTC low power clock                                       */
            uint32_t            : 3;
    } bit;
  } BT_LPCK_DIV_FRAC;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt source register 0                                               */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_0 : 1;   /*!< Set 1 to generate cpu interrupt 0                                         */
            uint32_t            : 31;
    } bit;
  } CPU_INTR_FROM_CPU_0;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt source register 1                                               */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_1 : 1;   /*!< Set 1 to generate cpu interrupt 1                                         */
            uint32_t            : 31;
    } bit;
  } CPU_INTR_FROM_CPU_1;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt source register 2                                               */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_2 : 1;   /*!< Set 1 to generate cpu interrupt 2                                         */
            uint32_t            : 31;
    } bit;
  } CPU_INTR_FROM_CPU_2;
  
  union {
    __IOM uint32_t reg;                         /*!< interrupt source register 3                                               */
    
    struct {
      __IOM uint32_t CPU_INTR_FROM_CPU_3 : 1;   /*!< Set 1 to generate cpu interrupt 3                                         */
            uint32_t            : 31;
    } bit;
  } CPU_INTR_FROM_CPU_3;
  
  union {
    __IOM uint32_t reg;                         /*!< rsa memory power control register                                         */
    
    struct {
      __IOM uint32_t RSA_MEM_PD : 1;            /*!< Set 1 to power down RSA memory. This bit has the lowest priority.When
                                                     Digital Signature occupies the RSA, this bit is invalid.                  */
      __IOM uint32_t RSA_MEM_FORCE_PU : 1;      /*!< Set 1 to force power up RSA memory, this bit has the second
                                                     highest priority.                                                         */
      __IOM uint32_t RSA_MEM_FORCE_PD : 1;      /*!< Set 1 to force power down RSA memory,this bit has the highest
                                                     priority.                                                                 */
            uint32_t            : 29;
    } bit;
  } RSA_PD_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< EDMA control register                                                     */
    
    struct {
      __IOM uint32_t EDMA_CLK_ON : 1;           /*!< Set 1 to enable EDMA clock.                                               */
      __IOM uint32_t EDMA_RESET : 1;            /*!< Set 1 to let EDMA reset                                                   */
            uint32_t            : 30;
    } bit;
  } EDMA_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< Cache control register                                                    */
    
    struct {
      __IOM uint32_t ICACHE_CLK_ON : 1;         /*!< Set 1 to enable icache clock                                              */
      __IOM uint32_t ICACHE_RESET : 1;          /*!< Set 1 to let icache reset                                                 */
      __IOM uint32_t DCACHE_CLK_ON : 1;         /*!< Set 1 to enable dcache clock                                              */
      __IOM uint32_t DCACHE_RESET : 1;          /*!< Set 1 to let dcache reset                                                 */
            uint32_t            : 28;
    } bit;
  } CACHE_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< External memory encrypt and decrypt control register                      */
    
    struct {
      __IOM uint32_t ENABLE_SPI_MANUAL_ENCRYPT : 1;/*!< Set 1 to enable the SPI manual encrypt.                                */
      __IOM uint32_t ENABLE_DOWNLOAD_DB_ENCRYPT : 1;/*!< Set 1 to enable download DB encrypt.                                  */
      __IOM uint32_t ENABLE_DOWNLOAD_G0CB_DECRYPT : 1;/*!< Set 1 to enable download G0CB decrypt                               */
      __IOM uint32_t ENABLE_DOWNLOAD_MANUAL_ENCRYPT : 1;/*!< Set 1 to enable download manual encrypt                           */
            uint32_t            : 28;
    } bit;
  } EXTERNAL_DEVICE_ENCRYPT_DECRYPT_CONTROL;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC fast memory configuration register                                    */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t RTC_MEM_CRC_START : 1;     /*!< Set 1 to start the CRC of RTC memory                                      */
      __IOM uint32_t RTC_MEM_CRC_ADDR : 11;     /*!< This field is used to set address of RTC memory for CRC.                  */
      __IOM uint32_t RTC_MEM_CRC_LEN : 11;      /*!< This field is used to set length of RTC memory for CRC based
                                                     on start address.                                                         */
      __IM  uint32_t RTC_MEM_CRC_FINISH : 1;    /*!< This bit stores the status of RTC memory CRC.1 means finished.            */
    } bit;
  } RTC_FASTMEM_CONFIG;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC fast memory CRC control register                                      */
    
    struct {
      __IM  uint32_t RTC_MEM_CRC_RES : 32;      /*!< This field stores the CRC result of RTC memory.                           */
    } bit;
  } RTC_FASTMEM_CRC;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t REDUNDANT_ECO_DRIVE : 1;   /*!< ******* Description ***********                                           */
      __IM  uint32_t REDUNDANT_ECO_RESULT : 1;  /*!< ******* Description ***********                                           */
            uint32_t            : 30;
    } bit;
  } REDUNDANT_ECO_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t CLK_EN     : 1;            /*!< ******* Description ***********                                           */
            uint32_t            : 31;
    } bit;
  } CLOCK_GATE;
  
  union {
    __IOM uint32_t reg;                         /*!< System clock configuration register.                                      */
    
    struct {
      __IOM uint32_t PRE_DIV_CNT : 10;          /*!< This field is used to set the count of prescaler of XTAL_CLK.             */
      __IOM uint32_t SOC_CLK_SEL : 2;           /*!< This field is used to select soc clock.                                   */
      __IM  uint32_t CLK_XTAL_FREQ : 7;         /*!< This field is used to read xtal frequency in MHz.                         */
      __IM  uint32_t CLK_DIV_EN : 1;            /*!< Reserved.                                                                 */
            uint32_t            : 12;
    } bit;
  } SYSCLK_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t MEM_PATH_LEN : 4;          /*!< ******* Description ***********                                           */
      __OM  uint32_t MEM_ERR_CNT_CLR : 1;       /*!< ******* Description ***********                                           */
      __IOM uint32_t MONITOR_EN : 1;            /*!< ******* Description ***********                                           */
      __IM  uint32_t MEM_TIMING_ERR_CNT : 16;   /*!< ******* Description ***********                                           */
      __IOM uint32_t MEM_VT_SEL : 2;            /*!< ******* Description ***********                                           */
            uint32_t            : 8;
    } bit;
  } MEM_PVT;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t COMB_PATH_LEN_LVT : 5;     /*!< ******* Description ***********                                           */
      __OM  uint32_t COMB_ERR_CNT_CLR_LVT : 1;  /*!< ******* Description ***********                                           */
      __IOM uint32_t COMB_PVT_MONITOR_EN_LVT : 1;/*!< ******* Description ***********                                          */
            uint32_t            : 25;
    } bit;
  } COMB_PVT_LVT_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t COMB_PATH_LEN_NVT : 5;     /*!< ******* Description ***********                                           */
      __OM  uint32_t COMB_ERR_CNT_CLR_NVT : 1;  /*!< ******* Description ***********                                           */
      __IOM uint32_t COMB_PVT_MONITOR_EN_NVT : 1;/*!< ******* Description ***********                                          */
            uint32_t            : 25;
    } bit;
  } COMB_PVT_NVT_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IOM uint32_t COMB_PATH_LEN_HVT : 5;     /*!< ******* Description ***********                                           */
      __OM  uint32_t COMB_ERR_CNT_CLR_HVT : 1;  /*!< ******* Description ***********                                           */
      __IOM uint32_t COMB_PVT_MONITOR_EN_HVT : 1;/*!< ******* Description ***********                                          */
            uint32_t            : 25;
    } bit;
  } COMB_PVT_HVT_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_LVT_SITE0 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_LVT_SITE0;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_NVT_SITE0 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_NVT_SITE0;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_HVT_SITE0 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_HVT_SITE0;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_LVT_SITE1 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_LVT_SITE1;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_NVT_SITE1 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_NVT_SITE1;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_HVT_SITE1 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_HVT_SITE1;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_LVT_SITE2 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_LVT_SITE2;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_NVT_SITE2 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_NVT_SITE2;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_HVT_SITE2 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_HVT_SITE2;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_LVT_SITE3 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_LVT_SITE3;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_NVT_SITE3 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_NVT_SITE3;
  
  union {
    __IOM uint32_t reg;                         /*!< ******* Description ***********                                           */
    
    struct {
      __IM  uint32_t COMB_TIMING_ERR_CNT_HVT_SITE3 : 16;/*!< ******* Description ***********                                   */
            uint32_t            : 16;
    } bit;
  } COMB_PVT_ERR_HVT_SITE3;
  __IM  uint32_t  RESERVED[982];
  
  union {
    __IOM uint32_t reg;                         /*!< version register                                                          */
    
    struct {
      __IOM uint32_t DATE       : 28;           /*!< version register                                                          */
            uint32_t            : 4;
    } bit;
  } DATE;
} SYSTEM_Type;                                  /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                         SYSTIMER                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief System Timer (SYSTIMER)
  */

typedef struct {                                /*!< SYSTIMER Structure                                                        */
  
  union {
    __IOM uint32_t reg;                         /*!< Configure system timer clock                                              */
    
    struct {
      __IOM uint32_t SYSTIMER_CLK_FO : 1;       /*!< systimer clock force on                                                   */
            uint32_t            : 21;
      __IOM uint32_t TARGET2_WORK_EN : 1;       /*!< target2 work enable                                                       */
      __IOM uint32_t TARGET1_WORK_EN : 1;       /*!< target1 work enable                                                       */
      __IOM uint32_t TARGET0_WORK_EN : 1;       /*!< target0 work enable                                                       */
      __IOM uint32_t TIMER_UNIT1_CORE1_STALL_EN : 1;/*!< If timer unit1 is stalled when core1 stalled                          */
      __IOM uint32_t TIMER_UNIT1_CORE0_STALL_EN : 1;/*!< If timer unit1 is stalled when core0 stalled                          */
      __IOM uint32_t TIMER_UNIT0_CORE1_STALL_EN : 1;/*!< If timer unit0 is stalled when core1 stalled                          */
      __IOM uint32_t TIMER_UNIT0_CORE0_STALL_EN : 1;/*!< If timer unit0 is stalled when core0 stalled                          */
      __IOM uint32_t TIMER_UNIT1_WORK_EN : 1;   /*!< timer unit1 work enable                                                   */
      __IOM uint32_t TIMER_UNIT0_WORK_EN : 1;   /*!< timer unit0 work enable                                                   */
      __IOM uint32_t CLK_EN     : 1;            /*!< register file clk gating                                                  */
    } bit;
  } CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit0 value update register                                  */
    
    struct {
            uint32_t            : 29;
      __IM  uint32_t TIMER_UNIT0_VALUE_VALID : 1;/*!< timer value is sync and valid                                            */
      __OM  uint32_t TIMER_UNIT0_UPDATE : 1;    /*!< update timer_unit0                                                        */
            uint32_t            : 1;
    } bit;
  } UNIT0_OP;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit1 value update register                                  */
    
    struct {
            uint32_t            : 29;
      __IM  uint32_t TIMER_UNIT1_VALUE_VALID : 1;/*!< timer value is sync and valid                                            */
      __OM  uint32_t TIMER_UNIT1_UPDATE : 1;    /*!< update timer unit1                                                        */
            uint32_t            : 1;
    } bit;
  } UNIT1_OP;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit0 value high load register                               */
    
    struct {
      __IOM uint32_t TIMER_UNIT0_LOAD_HI : 20;  /*!< timer unit0 load high 20 bits                                             */
            uint32_t            : 12;
    } bit;
  } UNIT0_LOAD_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit0 value low load register                                */
    
    struct {
      __IOM uint32_t TIMER_UNIT0_LOAD_LO : 32;  /*!< timer unit0 load low 32 bits                                              */
    } bit;
  } UNIT0_LOAD_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit1 value high load register                               */
    
    struct {
      __IOM uint32_t TIMER_UNIT1_LOAD_HI : 20;  /*!< timer unit1 load high 20 bits                                             */
            uint32_t            : 12;
    } bit;
  } UNIT1_LOAD_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit1 value low load register                                */
    
    struct {
      __IOM uint32_t TIMER_UNIT1_LOAD_LO : 32;  /*!< timer unit1 load low 32 bits                                              */
    } bit;
  } UNIT1_LOAD_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp0 value high register                                    */
    
    struct {
      __IOM uint32_t TIMER_TARGET0_HI : 20;     /*!< timer taget0 high 20 bits                                                 */
            uint32_t            : 12;
    } bit;
  } TARGET0_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp0 value low register                                     */
    
    struct {
      __IOM uint32_t TIMER_TARGET0_LO : 32;     /*!< timer taget0 low 32 bits                                                  */
    } bit;
  } TARGET0_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp1 value high register                                    */
    
    struct {
      __IOM uint32_t TIMER_TARGET1_HI : 20;     /*!< timer taget1 high 20 bits                                                 */
            uint32_t            : 12;
    } bit;
  } TARGET1_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp1 value low register                                     */
    
    struct {
      __IOM uint32_t TIMER_TARGET1_LO : 32;     /*!< timer taget1 low 32 bits                                                  */
    } bit;
  } TARGET1_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp2 value high register                                    */
    
    struct {
      __IOM uint32_t TIMER_TARGET2_HI : 20;     /*!< timer taget2 high 20 bits                                                 */
            uint32_t            : 12;
    } bit;
  } TARGET2_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp2 value low register                                     */
    
    struct {
      __IOM uint32_t TIMER_TARGET2_LO : 32;     /*!< timer taget2 low 32 bits                                                  */
    } bit;
  } TARGET2_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp0 target mode register                                   */
    
    struct {
      __IOM uint32_t TARGET0_PERIOD : 26;       /*!< target0 period                                                            */
            uint32_t            : 4;
      __IOM uint32_t TARGET0_PERIOD_MODE : 1;   /*!< Set target0 to period mode                                                */
      __IOM uint32_t TARGET0_TIMER_UNIT_SEL : 1;/*!< select which unit to compare                                              */
    } bit;
  } TARGET0_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp1 target mode register                                   */
    
    struct {
      __IOM uint32_t TARGET1_PERIOD : 26;       /*!< target1 period                                                            */
            uint32_t            : 4;
      __IOM uint32_t TARGET1_PERIOD_MODE : 1;   /*!< Set target1 to period mode                                                */
      __IOM uint32_t TARGET1_TIMER_UNIT_SEL : 1;/*!< select which unit to compare                                              */
    } bit;
  } TARGET1_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp2 target mode register                                   */
    
    struct {
      __IOM uint32_t TARGET2_PERIOD : 26;       /*!< target2 period                                                            */
            uint32_t            : 4;
      __IOM uint32_t TARGET2_PERIOD_MODE : 1;   /*!< Set target2 to period mode                                                */
      __IOM uint32_t TARGET2_TIMER_UNIT_SEL : 1;/*!< select which unit to compare                                              */
    } bit;
  } TARGET2_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit0 value high register                                    */
    
    struct {
      __IM  uint32_t TIMER_UNIT0_VALUE_HI : 20; /*!< timer read value high 20bits                                              */
            uint32_t            : 12;
    } bit;
  } UNIT0_VALUE_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit0 value low register                                     */
    
    struct {
      __IM  uint32_t TIMER_UNIT0_VALUE_LO : 32; /*!< timer read value low 32bits                                               */
    } bit;
  } UNIT0_VALUE_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit1 value high register                                    */
    
    struct {
      __IM  uint32_t TIMER_UNIT1_VALUE_HI : 20; /*!< timer read value high 20bits                                              */
            uint32_t            : 12;
    } bit;
  } UNIT1_VALUE_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit1 value low register                                     */
    
    struct {
      __IM  uint32_t TIMER_UNIT1_VALUE_LO : 32; /*!< timer read value low 32bits                                               */
    } bit;
  } UNIT1_VALUE_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp0 conf sync register                                     */
    
    struct {
      __OM  uint32_t TIMER_COMP0_LOAD : 1;      /*!< timer comp0 sync enable signal                                            */
            uint32_t            : 31;
    } bit;
  } COMP0_LOAD;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp1 conf sync register                                     */
    
    struct {
      __OM  uint32_t TIMER_COMP1_LOAD : 1;      /*!< timer comp1 sync enable signal                                            */
            uint32_t            : 31;
    } bit;
  } COMP1_LOAD;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp2 conf sync register                                     */
    
    struct {
      __OM  uint32_t TIMER_COMP2_LOAD : 1;      /*!< timer comp2 sync enable signal                                            */
            uint32_t            : 31;
    } bit;
  } COMP2_LOAD;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit0 conf sync register                                     */
    
    struct {
      __OM  uint32_t TIMER_UNIT0_LOAD : 1;      /*!< timer unit0 sync enable signal                                            */
            uint32_t            : 31;
    } bit;
  } UNIT0_LOAD;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer unit1 conf sync register                                     */
    
    struct {
      __OM  uint32_t TIMER_UNIT1_LOAD : 1;      /*!< timer unit1 sync enable signal                                            */
            uint32_t            : 31;
    } bit;
  } UNIT1_LOAD;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer interrupt enable register                                        */
    
    struct {
      __IOM uint32_t TARGET0_INT_ENA : 1;       /*!< interupt0 enable                                                          */
      __IOM uint32_t TARGET1_INT_ENA : 1;       /*!< interupt1 enable                                                          */
      __IOM uint32_t TARGET2_INT_ENA : 1;       /*!< interupt2 enable                                                          */
            uint32_t            : 29;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer interrupt raw register                                           */
    
    struct {
      __IOM uint32_t TARGET0_INT_RAW : 1;       /*!< interupt0 raw                                                             */
      __IOM uint32_t TARGET1_INT_RAW : 1;       /*!< interupt1 raw                                                             */
      __IOM uint32_t TARGET2_INT_RAW : 1;       /*!< interupt2 raw                                                             */
            uint32_t            : 29;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer interrupt clear register                                         */
    
    struct {
      __OM  uint32_t TARGET0_INT_CLR : 1;       /*!< interupt0 clear                                                           */
      __OM  uint32_t TARGET1_INT_CLR : 1;       /*!< interupt1 clear                                                           */
      __OM  uint32_t TARGET2_INT_CLR : 1;       /*!< interupt2 clear                                                           */
            uint32_t            : 29;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< systimer interrupt status register                                        */
    
    struct {
      __IM  uint32_t TARGET0_INT_ST : 1;        /*!< interupt0 status                                                          */
      __IM  uint32_t TARGET1_INT_ST : 1;        /*!< interupt1 status                                                          */
      __IM  uint32_t TARGET2_INT_ST : 1;        /*!< interupt2 status                                                          */
            uint32_t            : 29;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp0 actual target value low register                       */
    
    struct {
      __IM  uint32_t TARGET0_LO_RO : 32;        /*!< actual target value value low 32bits                                      */
    } bit;
  } REAL_TARGET0_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp0 actual target value high register                      */
    
    struct {
      __IM  uint32_t TARGET0_HI_RO : 20;        /*!< actual target value value high 20bits                                     */
            uint32_t            : 12;
    } bit;
  } REAL_TARGET0_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp1 actual target value low register                       */
    
    struct {
      __IM  uint32_t TARGET1_LO_RO : 32;        /*!< actual target value value low 32bits                                      */
    } bit;
  } REAL_TARGET1_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp1 actual target value high register                      */
    
    struct {
      __IM  uint32_t TARGET1_HI_RO : 20;        /*!< actual target value value high 20bits                                     */
            uint32_t            : 12;
    } bit;
  } REAL_TARGET1_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp2 actual target value low register                       */
    
    struct {
      __IM  uint32_t TARGET2_LO_RO : 32;        /*!< actual target value value low 32bits                                      */
    } bit;
  } REAL_TARGET2_LO;
  
  union {
    __IOM uint32_t reg;                         /*!< system timer comp2 actual target value high register                      */
    
    struct {
      __IM  uint32_t TARGET2_HI_RO : 20;        /*!< actual target value value high 20bits                                     */
            uint32_t            : 12;
    } bit;
  } REAL_TARGET2_HI;
  __IM  uint32_t  RESERVED[28];
  
  union {
    __IOM uint32_t reg;                         /*!< system timer version control register                                     */
    
    struct {
      __IOM uint32_t DATE       : 32;           /*!< systimer register version                                                 */
    } bit;
  } DATE;
} SYSTIMER_Type;                                /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                           TIMG0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer Group 0 (TIMG0)
  */

typedef struct {                                /*!< TIMG0 Structure                                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< Timer 0 configuration register                                            */
    
    struct {
            uint32_t            : 9;
      __IOM uint32_t USE_XTAL   : 1;            /*!< 1: Use XTAL_CLK as the source clock of timer group. 0: Use APB_CLK
                                                     as the source clock of timer group.                                       */
      __IOM uint32_t ALARM_EN   : 1;            /*!< When set, the alarm is enabled. This bit is automatically cleared
                                                     once analarm occurs.                                                      */
            uint32_t            : 21;
    } bit;
  } T0CONFIG;
  __IOM uint32_t  T0LO;                         /*!< Timer 0 current value, low 32 bits                                        */
  __IOM uint32_t  T0HI;                         /*!< Timer 0 current value, high 22 bits                                       */
  __IOM uint32_t  T0UPDATE;                     /*!< Write to copy current timer value to TIMGn_T0_(LO/HI)_REG                 */
  __IOM uint32_t  T0ALARMLO;                    /*!< Timer 0 alarm value, low 32 bits                                          */
  __IOM uint32_t  T0ALARMHI;                    /*!< Timer 0 alarm value, high bits                                            */
  __IOM uint32_t  T0LOADLO;                     /*!< Timer 0 reload value, low 32 bits                                         */
  __IOM uint32_t  T0LOADHI;                     /*!< Timer 0 reload value, high 22 bits                                        */
  __IOM uint32_t  T0LOAD;                       /*!< Write to reload timer from TIMG_T0_(LOADLOLOADHI)_REG                     */
  __IM  uint32_t  RESERVED[9];
  
  union {
    __IOM uint32_t reg;                         /*!< Watchdog timer configuration register                                     */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t WDT_APPCPU_RESET_EN : 1;   /*!< Reserved                                                                  */
      __IOM uint32_t WDT_PROCPU_RESET_EN : 1;   /*!< WDT reset CPU enable.                                                     */
      __IOM uint32_t WDT_FLASHBOOT_MOD_EN : 1;  /*!< When set, Flash boot protection is enabled.                               */
      __IOM uint32_t WDT_SYS_RESET_LENGTH : 3;  /*!< System reset signal length selection. 0: 100 ns, 1: 200 ns,2:
                                                     300 ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7:
                                                     3.2 us.                                                                   */
      __IOM uint32_t WDT_CPU_RESET_LENGTH : 3;  /*!< CPU reset signal length selection. 0: 100 ns, 1: 200 ns,2: 300
                                                     ns, 3: 400 ns, 4: 500 ns, 5: 800 ns, 6: 1.6 us, 7: 3.2
                                                     us.                                                                       */
            uint32_t            : 2;
      __IOM uint32_t WDT_STG3   : 2;            /*!< Stage 3 configuration. 0: off, 1: interrupt, 2: reset CPU, 3:
                                                     reset system.                                                             */
      __IOM uint32_t WDT_STG2   : 2;            /*!< Stage 2 configuration. 0: off, 1: interrupt, 2: reset CPU, 3:
                                                     reset system.                                                             */
      __IOM uint32_t WDT_STG1   : 2;            /*!< Stage 1 configuration. 0: off, 1: interrupt, 2: reset CPU, 3:
                                                     reset system.                                                             */
      __IOM uint32_t WDT_STG0   : 2;            /*!< Stage 0 configuration. 0: off, 1: interrupt, 2: reset CPU, 3:
                                                     reset system.                                                             */
      __IOM uint32_t WDT_EN     : 1;            /*!< When set, MWDT is enabled.                                                */
    } bit;
  } WDTCONFIG0;
  
  union {
    __IOM uint32_t reg;                         /*!< Watchdog timer prescaler register                                         */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t WDT_CLK_PRESCALE : 16;     /*!< MWDT clock prescaler value. MWDT clock period = 12.5 ns *TIMG_WDT_CLK_PRESCALE
                                                                                                                               */
    } bit;
  } WDTCONFIG1;
  
  union {
    __IOM uint32_t reg;                         /*!< Watchdog timer stage 0 timeout value                                      */
    
    struct {
      __IOM uint32_t WDT_STG0_HOLD : 32;        /*!< Stage 0 timeout value, in MWDT clock cycles.                              */
    } bit;
  } WDTCONFIG2;
  
  union {
    __IOM uint32_t reg;                         /*!< Watchdog timer stage 1 timeout value                                      */
    
    struct {
      __IOM uint32_t WDT_STG1_HOLD : 32;        /*!< Stage 1 timeout value, in MWDT clock cycles.                              */
    } bit;
  } WDTCONFIG3;
  
  union {
    __IOM uint32_t reg;                         /*!< Watchdog timer stage 2 timeout value                                      */
    
    struct {
      __IOM uint32_t WDT_STG2_HOLD : 32;        /*!< Stage 2 timeout value, in MWDT clock cycles.                              */
    } bit;
  } WDTCONFIG4;
  
  union {
    __IOM uint32_t reg;                         /*!< Watchdog timer stage 3 timeout value                                      */
    
    struct {
      __IOM uint32_t WDT_STG3_HOLD : 32;        /*!< Stage 3 timeout value, in MWDT clock cycles.                              */
    } bit;
  } WDTCONFIG5;
  
  union {
    __IOM uint32_t reg;                         /*!< Write to feed the watchdog timer                                          */
    
    struct {
      __OM  uint32_t WDT_FEED   : 32;           /*!< Write any value to feed the MWDT. (WO)                                    */
    } bit;
  } WDTFEED;
  
  union {
    __IOM uint32_t reg;                         /*!< Watchdog write protect register                                           */
    
    struct {
      __IOM uint32_t WDT_WKEY   : 32;           /*!< If the register contains a different value than its reset value,
                                                     writeprotection is enabled.                                               */
    } bit;
  } WDTWPROTECT;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC calibration configure register                                        */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t RTC_CALI_START_CYCLING : 1;/*!< Reserved                                                                  */
      __IOM uint32_t RTC_CALI_CLK_SEL : 2;      /*!< 0:rtc slow clock. 1:clk_80m. 2:xtal_32k.                                  */
      __IM  uint32_t RTC_CALI_RDY : 1;          /*!< Reserved                                                                  */
      __IOM uint32_t RTC_CALI_MAX : 15;         /*!< Reserved                                                                  */
      __IOM uint32_t RTC_CALI_START : 1;        /*!< Reserved                                                                  */
    } bit;
  } RTCCALICFG;
  
  union {
    __IOM uint32_t reg;                         /*!< RTC calibration configure1 register                                       */
    
    struct {
      __IM  uint32_t RTC_CALI_CYCLING_DATA_VLD : 1;/*!< Reserved                                                               */
            uint32_t            : 6;
      __IM  uint32_t RTC_CALI_VALUE : 25;       /*!< Reserved                                                                  */
    } bit;
  } RTCCALICFG1;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits                                                     */
    
    struct {
      __IOM uint32_t T0_INT_ENA : 1;            /*!< The interrupt enable bit for the TIMG_T0_INT interrupt.                   */
      __IOM uint32_t T1_INT_ENA : 1;            /*!< The interrupt enable bit for the TIMG_T1_INT interrupt.                   */
      __IOM uint32_t WDT_INT_ENA : 1;           /*!< The interrupt enable bit for the TIMG_WDT_INT interrupt.                  */
            uint32_t            : 29;
    } bit;
  } INT_ENA_TIMERS;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw interrupt status                                                      */
    
    struct {
      __IOM uint32_t T0_INT_RAW : 1;            /*!< The raw interrupt status bit for the TIMG_T0_INT interrupt.               */
      __IOM uint32_t T1_INT_RAW : 1;            /*!< The raw interrupt status bit for the TIMG_T1_INT interrupt.               */
      __IOM uint32_t WDT_INT_RAW : 1;           /*!< The raw interrupt status bit for the TIMG_WDT_INT interrupt.              */
            uint32_t            : 29;
    } bit;
  } INT_RAW_TIMERS;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt status                                                   */
    
    struct {
      __IM  uint32_t T0_INT_ST  : 1;            /*!< The masked interrupt status bit for the TIMG_T0_INT interrupt.            */
      __IM  uint32_t T1_INT_ST  : 1;            /*!< The masked interrupt status bit for the TIMG_T1_INT interrupt.            */
      __IM  uint32_t WDT_INT_ST : 1;            /*!< The masked interrupt status bit for the TIMG_WDT_INT interrupt.           */
            uint32_t            : 29;
    } bit;
  } INT_ST_TIMERS;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits                                                      */
    
    struct {
      __OM  uint32_t T0_INT_CLR : 1;            /*!< Set this bit to clear the TIMG_T0_INT interrupt.                          */
      __OM  uint32_t T1_INT_CLR : 1;            /*!< Set this bit to clear the TIMG_T1_INT interrupt.                          */
      __OM  uint32_t WDT_INT_CLR : 1;           /*!< Set this bit to clear the TIMG_WDT_INT interrupt.                         */
            uint32_t            : 29;
    } bit;
  } INT_CLR_TIMERS;
  
  union {
    __IOM uint32_t reg;                         /*!< Timer group calibration register                                          */
    
    struct {
      __IM  uint32_t RTC_CALI_TIMEOUT : 1;      /*!< RTC calibration timeout indicator                                         */
            uint32_t            : 2;
      __IOM uint32_t RTC_CALI_TIMEOUT_RST_CNT : 4;/*!< Cycles that release calibration timeout reset                           */
      __IOM uint32_t RTC_CALI_TIMEOUT_THRES : 25;/*!< Threshold value for the RTC calibration timer. If the calibration
                                                     timer's value exceeds this threshold, a timeout is triggered.             */
    } bit;
  } RTCCALICFG2;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Timer 1 configuration register                                            */
    
    struct {
            uint32_t            : 9;
      __IOM uint32_t USE_XTAL   : 1;            /*!< 1: Use XTAL_CLK as the source clock of timer group. 0: Use APB_CLK
                                                     as the source clock of timer group.                                       */
      __IOM uint32_t ALARM_EN   : 1;            /*!< When set, the alarm is enabled. This bit is automatically cleared
                                                     once analarm occurs.                                                      */
            uint32_t            : 21;
    } bit;
  } T1CONFIG;
  __IOM uint32_t  T1LO;                         /*!< Timer 1 current value, low 32 bits                                        */
  __IOM uint32_t  T1HI;                         /*!< Timer 1 current value, high 22 bits                                       */
  __IOM uint32_t  T1UPDATE;                     /*!< Write to copy current timer value to TIMGn_T1_(LO/HI)_REG                 */
  __IOM uint32_t  T1ALARMLO;                    /*!< Timer 1 alarm value, low 32 bits                                          */
  __IOM uint32_t  T1ALARMHI;                    /*!< Timer 1 alarm value, high bits                                            */
  __IOM uint32_t  T1LOADLO;                     /*!< Timer 1 reload value, low 32 bits                                         */
  __IOM uint32_t  T1LOADHI;                     /*!< Timer 1 reload value, high 22 bits                                        */
  __IOM uint32_t  T1LOAD;                       /*!< Write to reload timer from TIMG_T1_(LOADLOLOADHI)_REG                     */
  __IM  uint32_t  RESERVED2[17];
  
  union {
    __IOM uint32_t reg;                         /*!< Timer version control register                                            */
    
    struct {
      __IOM uint32_t NTIMERS_DATE : 28;         /*!< Timer version control register                                            */
            uint32_t            : 4;
    } bit;
  } NTIMERS_DATE;
  
  union {
    __IOM uint32_t reg;                         /*!< Timer group clock gate register                                           */
    
    struct {
            uint32_t            : 31;
      __IOM uint32_t CLK_EN     : 1;            /*!< Register clock gate signal. 1: The clock for software to read
                                                     and write registers is always on. 0: The clock for software
                                                     to read and write registers only exits when the operation
                                                     happens.                                                                  */
    } bit;
  } REGCLK;
} TIMG0_Type;                                   /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                           TWAI0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Two-Wire Automotive Interface (TWAI0)
  */

typedef struct {                                /*!< TWAI0 Structure                                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< Mode Register                                                             */
    
    struct {
      __IOM uint32_t RESET_MODE : 1;            /*!< This bit is used to configure the operating mode of the TWAI
                                                     Controller. 1: Reset mode; 0: Operating mode.                             */
      __IOM uint32_t LISTEN_ONLY_MODE : 1;      /*!< 1: Listen only mode. In this mode the nodes will only receive
                                                     messages from the bus, without generating the acknowledge
                                                     signal nor updating the RX error counter.                                 */
      __IOM uint32_t SELF_TEST_MODE : 1;        /*!< 1: Self test mode. In this mode the TX nodes can perform a successful
                                                     transmission without receiving the acknowledge signal.
                                                     This mode is often used to test a single node with the
                                                     self reception request command.                                           */
      __IOM uint32_t RX_FILTER_MODE : 1;        /*!< This bit is used to configure the filter mode. 0: Dual filter
                                                     mode; 1: Single filter mode.                                              */
            uint32_t            : 28;
    } bit;
  } MODE;
  
  union {
    __IOM uint32_t reg;                         /*!< Command Register                                                          */
    
    struct {
      __OM  uint32_t TX_REQ     : 1;            /*!< Set the bit to 1 to allow the driving nodes start transmission.           */
      __OM  uint32_t ABORT_TX   : 1;            /*!< Set the bit to 1 to cancel a pending transmission request.                */
      __OM  uint32_t RELEASE_BUF : 1;           /*!< Set the bit to 1 to release the RX buffer.                                */
      __OM  uint32_t CLR_OVERRUN : 1;           /*!< Set the bit to 1 to clear the data overrun status bit.                    */
      __OM  uint32_t SELF_RX_REQ : 1;           /*!< Self reception request command. Set the bit to 1 to allow a
                                                     message be transmitted and received simultaneously.                       */
            uint32_t            : 27;
    } bit;
  } CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register                                                           */
    
    struct {
      __IM  uint32_t RX_BUF_ST  : 1;            /*!< 1: The data in the RX buffer is not empty, with at least one
                                                     received data packet.                                                     */
      __IM  uint32_t OVERRUN_ST : 1;            /*!< 1: The RX FIFO is full and data overrun has occurred.                     */
      __IM  uint32_t TX_BUF_ST  : 1;            /*!< 1: The TX buffer is empty, the CPU may write a message into
                                                     it.                                                                       */
      __IM  uint32_t TX_COMPLETE : 1;           /*!< 1: The TWAI controller has successfully received a packet from
                                                     the bus.                                                                  */
      __IM  uint32_t RX_ST      : 1;            /*!< 1: The TWAI Controller is receiving a message from the bus.               */
      __IM  uint32_t TX_ST      : 1;            /*!< 1: The TWAI Controller is transmitting a message to the bus.              */
      __IM  uint32_t ERR_ST     : 1;            /*!< 1: At least one of the RX/TX error counter has reached or exceeded
                                                     the value set in register TWAI_ERR_WARNING_LIMIT_REG.                     */
      __IM  uint32_t BUS_OFF_ST : 1;            /*!< 1: In bus-off status, the TWAI Controller is no longer involved
                                                     in bus activities.                                                        */
      __IM  uint32_t MISS_ST    : 1;            /*!< This bit reflects whether the data packet in the RX FIFO is
                                                     complete. 1: The current packet is missing; 0: The current
                                                     packet is complete                                                        */
            uint32_t            : 23;
    } bit;
  } STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Register                                                        */
    
    struct {
      __IM  uint32_t RX_INT_ST  : 1;            /*!< Receive interrupt. If this bit is set to 1, it indicates there
                                                     are messages to be handled in the RX FIFO.                                */
      __IM  uint32_t TX_INT_ST  : 1;            /*!< Transmit interrupt. If this bit is set to 1, it indicates the
                                                     message transmitting mis- sion is finished and a new transmission
                                                     is able to execute.                                                       */
      __IM  uint32_t ERR_WARN_INT_ST : 1;       /*!< Error warning interrupt. If this bit is set to 1, it indicates
                                                     the error status signal and the bus-off status signal of
                                                     Status register have changed (e.g., switched from 0 to
                                                     1 or from 1 to 0).                                                        */
      __IM  uint32_t OVERRUN_INT_ST : 1;        /*!< Data overrun interrupt. If this bit is set to 1, it indicates
                                                     a data overrun interrupt is generated in the RX FIFO.                     */
            uint32_t            : 1;
      __IM  uint32_t ERR_PASSIVE_INT_ST : 1;    /*!< Error passive interrupt. If this bit is set to 1, it indicates
                                                     the TWAI Controller is switched between error active status
                                                     and error passive status due to the change of error counters.             */
      __IM  uint32_t ARB_LOST_INT_ST : 1;       /*!< Arbitration lost interrupt. If this bit is set to 1, it indicates
                                                     an arbitration lost interrupt is generated.                               */
      __IM  uint32_t BUS_ERR_INT_ST : 1;        /*!< Error interrupt. If this bit is set to 1, it indicates an error
                                                     is detected on the bus.                                                   */
            uint32_t            : 24;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt Enable Register                                                 */
    
    struct {
      __IOM uint32_t RX_INT_ENA : 1;            /*!< Set this bit to 1 to enable receive interrupt.                            */
      __IOM uint32_t TX_INT_ENA : 1;            /*!< Set this bit to 1 to enable transmit interrupt.                           */
      __IOM uint32_t ERR_WARN_INT_ENA : 1;      /*!< Set this bit to 1 to enable error warning interrupt.                      */
      __IOM uint32_t OVERRUN_INT_ENA : 1;       /*!< Set this bit to 1 to enable data overrun interrupt.                       */
            uint32_t            : 1;
      __IOM uint32_t ERR_PASSIVE_INT_ENA : 1;   /*!< Set this bit to 1 to enable error passive interrupt.                      */
      __IOM uint32_t ARB_LOST_INT_ENA : 1;      /*!< Set this bit to 1 to enable arbitration lost interrupt.                   */
      __IOM uint32_t BUS_ERR_INT_ENA : 1;       /*!< Set this bit to 1 to enable error interrupt.                              */
            uint32_t            : 24;
    } bit;
  } INT_ENA;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus Timing Register 0                                                     */
    
    struct {
      __IOM uint32_t BAUD_PRESC : 14;           /*!< Baud Rate Prescaler, determines the frequency dividing ratio.             */
      __IOM uint32_t SYNC_JUMP_WIDTH : 2;       /*!< Synchronization Jump Width (SJW), 1 \verb+~+ 14 Tq wide.                  */
            uint32_t            : 16;
    } bit;
  } BUS_TIMING_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Bus Timing Register 1                                                     */
    
    struct {
      __IOM uint32_t TIME_SEG1  : 4;            /*!< The width of PBS1.                                                        */
      __IOM uint32_t TIME_SEG2  : 3;            /*!< The width of PBS2.                                                        */
      __IOM uint32_t TIME_SAMP  : 1;            /*!< The number of sample points. 0: the bus is sampled once; 1:
                                                     the bus is sampled three times                                            */
            uint32_t            : 24;
    } bit;
  } BUS_TIMING_1;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Arbitration Lost Capture Register                                         */
    
    struct {
      __IM  uint32_t ARB_LOST_CAP : 5;          /*!< This register contains information about the bit position of
                                                     lost arbitration.                                                         */
            uint32_t            : 27;
    } bit;
  } ARB_LOST_CAP;
  
  union {
    __IOM uint32_t reg;                         /*!< Error Code Capture Register                                               */
    
    struct {
      __IM  uint32_t ECC_SEGMENT : 5;           /*!< This register contains information about the location of errors,
                                                     see Table 181 for details.                                                */
      __IM  uint32_t ECC_DIRECTION : 1;         /*!< This register contains information about transmission direction
                                                     of the node when error occurs. 1: Error occurs when receiving
                                                     a message; 0: Error occurs when transmitting a message                    */
      __IM  uint32_t ECC_TYPE   : 2;            /*!< This register contains information about error types: 00: bit
                                                     error; 01: form error; 10: stuff error; 11: other type
                                                     of error                                                                  */
            uint32_t            : 24;
    } bit;
  } ERR_CODE_CAP;
  
  union {
    __IOM uint32_t reg;                         /*!< Error Warning Limit Register                                              */
    
    struct {
      __IOM uint32_t ERR_WARNING_LIMIT : 8;     /*!< Error warning threshold. In the case when any of a error counter
                                                     value exceeds the threshold, or all the error counter values
                                                     are below the threshold, an error warning interrupt will
                                                     be triggered (given the enable signal is valid).                          */
            uint32_t            : 24;
    } bit;
  } ERR_WARNING_LIMIT;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive Error Counter Register                                            */
    
    struct {
      __IOM uint32_t RX_ERR_CNT : 8;            /*!< The RX error counter register, reflects value changes under
                                                     reception status.                                                         */
            uint32_t            : 24;
    } bit;
  } RX_ERR_CNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Transmit Error Counter Register                                           */
    
    struct {
      __IOM uint32_t TX_ERR_CNT : 8;            /*!< The TX error counter register, reflects value changes under
                                                     transmission status.                                                      */
            uint32_t            : 24;
    } bit;
  } TX_ERR_CNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 0                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_0  : 8;            /*!< In reset mode, it is acceptance code register 0 with R/W Permission.
                                                     In operation mode, it stores the 0th byte information of
                                                     the data to be transmitted under operating mode.                          */
            uint32_t            : 24;
    } bit;
  } DATA_0;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 1                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_1  : 8;            /*!< In reset mode, it is acceptance code register 1 with R/W Permission.
                                                     In operation mode, it stores the 1st byte information of
                                                     the data to be transmitted under operating mode.                          */
            uint32_t            : 24;
    } bit;
  } DATA_1;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 2                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_2  : 8;            /*!< In reset mode, it is acceptance code register 2 with R/W Permission.
                                                     In operation mode, it stores the 2nd byte information of
                                                     the data to be transmitted under operating mode.                          */
            uint32_t            : 24;
    } bit;
  } DATA_2;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 3                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_3  : 8;            /*!< In reset mode, it is acceptance code register 3 with R/W Permission.
                                                     In operation mode, it stores the 3rd byte information of
                                                     the data to be transmitted under operating mode.                          */
            uint32_t            : 24;
    } bit;
  } DATA_3;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 4                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_4  : 8;            /*!< In reset mode, it is acceptance mask register 0 with R/W Permission.
                                                     In operation mode, it stores the 4th byte information of
                                                     the data to be transmitted under operating mode.                          */
            uint32_t            : 24;
    } bit;
  } DATA_4;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 5                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_5  : 8;            /*!< In reset mode, it is acceptance mask register 1 with R/W Permission.
                                                     In operation mode, it stores the 5th byte information of
                                                     the data to be transmitted under operating mode.                          */
            uint32_t            : 24;
    } bit;
  } DATA_5;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 6                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_6  : 8;            /*!< In reset mode, it is acceptance mask register 2 with R/W Permission.
                                                     In operation mode, it stores the 6th byte information of
                                                     the data to be transmitted under operating mode.                          */
            uint32_t            : 24;
    } bit;
  } DATA_6;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 7                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_7  : 8;            /*!< In reset mode, it is acceptance mask register 3 with R/W Permission.
                                                     In operation mode, it stores the 7th byte information of
                                                     the data to be transmitted under operating mode.                          */
            uint32_t            : 24;
    } bit;
  } DATA_7;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 8                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_8  : 8;            /*!< Stored the 8th byte information of the data to be transmitted
                                                     under operating mode.                                                     */
            uint32_t            : 24;
    } bit;
  } DATA_8;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 9                                                           */
    
    struct {
      __IOM uint32_t TX_BYTE_9  : 8;            /*!< Stored the 9th byte information of the data to be transmitted
                                                     under operating mode.                                                     */
            uint32_t            : 24;
    } bit;
  } DATA_9;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 10                                                          */
    
    struct {
      __IOM uint32_t TX_BYTE_10 : 8;            /*!< Stored the 10th byte information of the data to be transmitted
                                                     under operating mode.                                                     */
            uint32_t            : 24;
    } bit;
  } DATA_10;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 11                                                          */
    
    struct {
      __IOM uint32_t TX_BYTE_11 : 8;            /*!< Stored the 11th byte information of the data to be transmitted
                                                     under operating mode.                                                     */
            uint32_t            : 24;
    } bit;
  } DATA_11;
  
  union {
    __IOM uint32_t reg;                         /*!< Data register 12                                                          */
    
    struct {
      __IOM uint32_t TX_BYTE_12 : 8;            /*!< Stored the 12th byte information of the data to be transmitted
                                                     under operating mode.                                                     */
            uint32_t            : 24;
    } bit;
  } DATA_12;
  
  union {
    __IOM uint32_t reg;                         /*!< Receive Message Counter Register                                          */
    
    struct {
      __IM  uint32_t RX_MESSAGE_COUNTER : 7;    /*!< This register reflects the number of messages available within
                                                     the RX FIFO.                                                              */
            uint32_t            : 25;
    } bit;
  } RX_MESSAGE_CNT;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock Divider register                                                    */
    
    struct {
      __IOM uint32_t CD         : 8;            /*!< These bits are used to configure frequency dividing coefficients
                                                     of the external CLKOUT pin.                                               */
      __IOM uint32_t CLOCK_OFF  : 1;            /*!< This bit can be configured under reset mode. 1: Disable the
                                                     external CLKOUT pin; 0: Enable the external CLKOUT pin                    */
            uint32_t            : 23;
    } bit;
  } CLOCK_DIVIDER;
} TWAI0_Type;                                   /*!< Size = 128 (0x80)                                                         */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART (Universal Asynchronous Receiver-Transmitter) Controller 0 (UART0)
  */

typedef struct {                                /*!< UART0 Structure                                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< FIFO data register                                                        */
    
    struct {
      __IOM uint32_t RXFIFO_RD_BYTE : 8;        /*!< UART 0 accesses FIFO via this register.                                   */
            uint32_t            : 24;
    } bit;
  } FIFO;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw interrupt status                                                      */
    
    struct {
      __IOM uint32_t RXFIFO_FULL_INT_RAW : 1;   /*!< This interrupt raw bit turns to high level when receiver receives
                                                     more data than what rxfifo_full_thrhd specifies.                          */
      __IOM uint32_t TXFIFO_EMPTY_INT_RAW : 1;  /*!< This interrupt raw bit turns to high level when the amount of
                                                     data in Tx-FIFO is less than what txfifo_empty_thrhd specifies
                                                     .                                                                         */
      __IOM uint32_t PARITY_ERR_INT_RAW : 1;    /*!< This interrupt raw bit turns to high level when receiver detects
                                                     a parity error in the data.                                               */
      __IOM uint32_t FRM_ERR_INT_RAW : 1;       /*!< This interrupt raw bit turns to high level when receiver detects
                                                     a data frame error .                                                      */
      __IOM uint32_t RXFIFO_OVF_INT_RAW : 1;    /*!< This interrupt raw bit turns to high level when receiver receives
                                                     more data than the FIFO can store.                                        */
      __IOM uint32_t DSR_CHG_INT_RAW : 1;       /*!< This interrupt raw bit turns to high level when receiver detects
                                                     the edge change of DSRn signal.                                           */
      __IOM uint32_t CTS_CHG_INT_RAW : 1;       /*!< This interrupt raw bit turns to high level when receiver detects
                                                     the edge change of CTSn signal.                                           */
      __IOM uint32_t BRK_DET_INT_RAW : 1;       /*!< This interrupt raw bit turns to high level when receiver detects
                                                     a 0 after the stop bit.                                                   */
      __IOM uint32_t RXFIFO_TOUT_INT_RAW : 1;   /*!< This interrupt raw bit turns to high level when receiver takes
                                                     more time than rx_tout_thrhd to receive a byte.                           */
      __IOM uint32_t SW_XON_INT_RAW : 1;        /*!< This interrupt raw bit turns to high level when receiver recevies
                                                     Xon char when uart_sw_flow_con_en is set to 1.                            */
      __IOM uint32_t SW_XOFF_INT_RAW : 1;       /*!< This interrupt raw bit turns to high level when receiver receives
                                                     Xoff char when uart_sw_flow_con_en is set to 1.                           */
      __IOM uint32_t GLITCH_DET_INT_RAW : 1;    /*!< This interrupt raw bit turns to high level when receiver detects
                                                     a glitch in the middle of a start bit.                                    */
      __IOM uint32_t TX_BRK_DONE_INT_RAW : 1;   /*!< This interrupt raw bit turns to high level when transmitter
                                                     completes sending NULL characters, after all data in Tx-FIFO
                                                     are sent.                                                                 */
      __IOM uint32_t TX_BRK_IDLE_DONE_INT_RAW : 1;/*!< This interrupt raw bit turns to high level when transmitter
                                                     has kept the shortest duration after sending the last data.               */
      __IOM uint32_t TX_DONE_INT_RAW : 1;       /*!< This interrupt raw bit turns to high level when transmitter
                                                     has send out all data in FIFO.                                            */
      __IOM uint32_t RS485_PARITY_ERR_INT_RAW : 1;/*!< This interrupt raw bit turns to high level when receiver detects
                                                     a parity error from the echo of transmitter in rs485 mode.                */
      __IOM uint32_t RS485_FRM_ERR_INT_RAW : 1; /*!< This interrupt raw bit turns to high level when receiver detects
                                                     a data frame error from the echo of transmitter in rs485
                                                     mode.                                                                     */
      __IOM uint32_t RS485_CLASH_INT_RAW : 1;   /*!< This interrupt raw bit turns to high level when detects a clash
                                                     between transmitter and receiver in rs485 mode.                           */
      __IOM uint32_t AT_CMD_CHAR_DET_INT_RAW : 1;/*!< This interrupt raw bit turns to high level when receiver detects
                                                     the configured at_cmd char.                                               */
      __IOM uint32_t WAKEUP_INT_RAW : 1;        /*!< This interrupt raw bit turns to high level when input rxd edge
                                                     changes more times than what reg_active_threshold specifies
                                                     in light sleeping mode.                                                   */
            uint32_t            : 12;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt status                                                   */
    
    struct {
      __IM  uint32_t RXFIFO_FULL_INT_ST : 1;    /*!< This is the status bit for rxfifo_full_int_raw when rxfifo_full_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t TXFIFO_EMPTY_INT_ST : 1;   /*!< This is the status bit for txfifo_empty_int_raw when txfifo_empty_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t PARITY_ERR_INT_ST : 1;     /*!< This is the status bit for parity_err_int_raw when parity_err_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t FRM_ERR_INT_ST : 1;        /*!< This is the status bit for frm_err_int_raw when frm_err_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t RXFIFO_OVF_INT_ST : 1;     /*!< This is the status bit for rxfifo_ovf_int_raw when rxfifo_ovf_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t DSR_CHG_INT_ST : 1;        /*!< This is the status bit for dsr_chg_int_raw when dsr_chg_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t CTS_CHG_INT_ST : 1;        /*!< This is the status bit for cts_chg_int_raw when cts_chg_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t BRK_DET_INT_ST : 1;        /*!< This is the status bit for brk_det_int_raw when brk_det_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t RXFIFO_TOUT_INT_ST : 1;    /*!< This is the status bit for rxfifo_tout_int_raw when rxfifo_tout_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t SW_XON_INT_ST : 1;         /*!< This is the status bit for sw_xon_int_raw when sw_xon_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t SW_XOFF_INT_ST : 1;        /*!< This is the status bit for sw_xoff_int_raw when sw_xoff_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t GLITCH_DET_INT_ST : 1;     /*!< This is the status bit for glitch_det_int_raw when glitch_det_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t TX_BRK_DONE_INT_ST : 1;    /*!< This is the status bit for tx_brk_done_int_raw when tx_brk_done_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t TX_BRK_IDLE_DONE_INT_ST : 1;/*!< This is the stauts bit for tx_brk_idle_done_int_raw when tx_brk_idle_done_int_
                                                     na is set to 1.                                                           */
      __IM  uint32_t TX_DONE_INT_ST : 1;        /*!< This is the status bit for tx_done_int_raw when tx_done_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t RS485_PARITY_ERR_INT_ST : 1;/*!< This is the status bit for rs485_parity_err_int_raw when rs485_parity_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t RS485_FRM_ERR_INT_ST : 1;  /*!< This is the status bit for rs485_frm_err_int_raw when rs485_fm_err_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t RS485_CLASH_INT_ST : 1;    /*!< This is the status bit for rs485_clash_int_raw when rs485_clash_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t AT_CMD_CHAR_DET_INT_ST : 1;/*!< This is the status bit for at_cmd_det_int_raw when at_cmd_char_det_int_ena
                                                     is set to 1.                                                              */
      __IM  uint32_t WAKEUP_INT_ST : 1;         /*!< This is the status bit for uart_wakeup_int_raw when uart_wakeup_int_ena
                                                     is set to 1.                                                              */
            uint32_t            : 12;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits                                                     */
    
    struct {
      __IOM uint32_t RXFIFO_FULL_INT_ENA : 1;   /*!< This is the enable bit for rxfifo_full_int_st register.                   */
      __IOM uint32_t TXFIFO_EMPTY_INT_ENA : 1;  /*!< This is the enable bit for txfifo_empty_int_st register.                  */
      __IOM uint32_t PARITY_ERR_INT_ENA : 1;    /*!< This is the enable bit for parity_err_int_st register.                    */
      __IOM uint32_t FRM_ERR_INT_ENA : 1;       /*!< This is the enable bit for frm_err_int_st register.                       */
      __IOM uint32_t RXFIFO_OVF_INT_ENA : 1;    /*!< This is the enable bit for rxfifo_ovf_int_st register.                    */
      __IOM uint32_t DSR_CHG_INT_ENA : 1;       /*!< This is the enable bit for dsr_chg_int_st register.                       */
      __IOM uint32_t CTS_CHG_INT_ENA : 1;       /*!< This is the enable bit for cts_chg_int_st register.                       */
      __IOM uint32_t BRK_DET_INT_ENA : 1;       /*!< This is the enable bit for brk_det_int_st register.                       */
      __IOM uint32_t RXFIFO_TOUT_INT_ENA : 1;   /*!< This is the enable bit for rxfifo_tout_int_st register.                   */
      __IOM uint32_t SW_XON_INT_ENA : 1;        /*!< This is the enable bit for sw_xon_int_st register.                        */
      __IOM uint32_t SW_XOFF_INT_ENA : 1;       /*!< This is the enable bit for sw_xoff_int_st register.                       */
      __IOM uint32_t GLITCH_DET_INT_ENA : 1;    /*!< This is the enable bit for glitch_det_int_st register.                    */
      __IOM uint32_t TX_BRK_DONE_INT_ENA : 1;   /*!< This is the enable bit for tx_brk_done_int_st register.                   */
      __IOM uint32_t TX_BRK_IDLE_DONE_INT_ENA : 1;/*!< This is the enable bit for tx_brk_idle_done_int_st register.            */
      __IOM uint32_t TX_DONE_INT_ENA : 1;       /*!< This is the enable bit for tx_done_int_st register.                       */
      __IOM uint32_t RS485_PARITY_ERR_INT_ENA : 1;/*!< This is the enable bit for rs485_parity_err_int_st register.            */
      __IOM uint32_t RS485_FRM_ERR_INT_ENA : 1; /*!< This is the enable bit for rs485_parity_err_int_st register.              */
      __IOM uint32_t RS485_CLASH_INT_ENA : 1;   /*!< This is the enable bit for rs485_clash_int_st register.                   */
      __IOM uint32_t AT_CMD_CHAR_DET_INT_ENA : 1;/*!< This is the enable bit for at_cmd_char_det_int_st register.              */
      __IOM uint32_t WAKEUP_INT_ENA : 1;        /*!< This is the enable bit for uart_wakeup_int_st register.                   */
            uint32_t            : 12;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits                                                      */
    
    struct {
      __OM  uint32_t RXFIFO_FULL_INT_CLR : 1;   /*!< Set this bit to clear the rxfifo_full_int_raw interrupt.                  */
      __OM  uint32_t TXFIFO_EMPTY_INT_CLR : 1;  /*!< Set this bit to clear txfifo_empty_int_raw interrupt.                     */
      __OM  uint32_t PARITY_ERR_INT_CLR : 1;    /*!< Set this bit to clear parity_err_int_raw interrupt.                       */
      __OM  uint32_t FRM_ERR_INT_CLR : 1;       /*!< Set this bit to clear frm_err_int_raw interrupt.                          */
      __OM  uint32_t RXFIFO_OVF_INT_CLR : 1;    /*!< Set this bit to clear rxfifo_ovf_int_raw interrupt.                       */
      __OM  uint32_t DSR_CHG_INT_CLR : 1;       /*!< Set this bit to clear the dsr_chg_int_raw interrupt.                      */
      __OM  uint32_t CTS_CHG_INT_CLR : 1;       /*!< Set this bit to clear the cts_chg_int_raw interrupt.                      */
      __OM  uint32_t BRK_DET_INT_CLR : 1;       /*!< Set this bit to clear the brk_det_int_raw interrupt.                      */
      __OM  uint32_t RXFIFO_TOUT_INT_CLR : 1;   /*!< Set this bit to clear the rxfifo_tout_int_raw interrupt.                  */
      __OM  uint32_t SW_XON_INT_CLR : 1;        /*!< Set this bit to clear the sw_xon_int_raw interrupt.                       */
      __OM  uint32_t SW_XOFF_INT_CLR : 1;       /*!< Set this bit to clear the sw_xoff_int_raw interrupt.                      */
      __OM  uint32_t GLITCH_DET_INT_CLR : 1;    /*!< Set this bit to clear the glitch_det_int_raw interrupt.                   */
      __OM  uint32_t TX_BRK_DONE_INT_CLR : 1;   /*!< Set this bit to clear the tx_brk_done_int_raw interrupt..                 */
      __OM  uint32_t TX_BRK_IDLE_DONE_INT_CLR : 1;/*!< Set this bit to clear the tx_brk_idle_done_int_raw interrupt.           */
      __OM  uint32_t TX_DONE_INT_CLR : 1;       /*!< Set this bit to clear the tx_done_int_raw interrupt.                      */
      __OM  uint32_t RS485_PARITY_ERR_INT_CLR : 1;/*!< Set this bit to clear the rs485_parity_err_int_raw interrupt.           */
      __OM  uint32_t RS485_FRM_ERR_INT_CLR : 1; /*!< Set this bit to clear the rs485_frm_err_int_raw interrupt.                */
      __OM  uint32_t RS485_CLASH_INT_CLR : 1;   /*!< Set this bit to clear the rs485_clash_int_raw interrupt.                  */
      __OM  uint32_t AT_CMD_CHAR_DET_INT_CLR : 1;/*!< Set this bit to clear the at_cmd_char_det_int_raw interrupt.             */
      __OM  uint32_t WAKEUP_INT_CLR : 1;        /*!< Set this bit to clear the uart_wakeup_int_raw interrupt.                  */
            uint32_t            : 12;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Clock divider configuration                                               */
    
    struct {
      __IOM uint32_t CLKDIV     : 12;           /*!< The integral part of the frequency divider factor.                        */
            uint32_t            : 8;
      __IOM uint32_t FRAG       : 4;            /*!< The decimal part of the frequency divider factor.                         */
            uint32_t            : 8;
    } bit;
  } CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< Rx Filter configuration                                                   */
    
    struct {
      __IOM uint32_t GLITCH_FILT : 8;           /*!< when input pulse width is lower than this value, the pulse is
                                                     ignored.                                                                  */
      __IOM uint32_t GLITCH_FILT_EN : 1;        /*!< Set this bit to enable Rx signal filter.                                  */
            uint32_t            : 23;
    } bit;
  } RX_FILT;
  
  union {
    __IOM uint32_t reg;                         /*!< UART status register                                                      */
    
    struct {
      __IM  uint32_t RXFIFO_CNT : 10;           /*!< Stores the byte number of valid data in Rx-FIFO.                          */
            uint32_t            : 3;
      __IM  uint32_t DSRN       : 1;            /*!< The register represent the level value of the internal uart
                                                     dsr signal.                                                               */
      __IM  uint32_t CTSN       : 1;            /*!< This register represent the level value of the internal uart
                                                     cts signal.                                                               */
      __IM  uint32_t RXD        : 1;            /*!< This register represent the level value of the internal uart
                                                     rxd signal.                                                               */
      __IM  uint32_t TXFIFO_CNT : 10;           /*!< Stores the byte number of data in Tx-FIFO.                                */
            uint32_t            : 3;
      __IM  uint32_t DTRN       : 1;            /*!< This bit represents the level of the internal uart dtr signal.            */
      __IM  uint32_t RTSN       : 1;            /*!< This bit represents the level of the internal uart rts signal.            */
      __IM  uint32_t TXD        : 1;            /*!< This bit represents the level of the internal uart txd signal.            */
    } bit;
  } STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< a                                                                         */
    
    struct {
      __IOM uint32_t PARITY     : 1;            /*!< This register is used to configure the parity check mode.                 */
      __IOM uint32_t PARITY_EN  : 1;            /*!< Set this bit to enable uart parity check.                                 */
      __IOM uint32_t BIT_NUM    : 2;            /*!< This register is used to set the length of data.                          */
      __IOM uint32_t STOP_BIT_NUM : 2;          /*!< This register is used to set the length of stop bit.                      */
      __IOM uint32_t SW_RTS     : 1;            /*!< This register is used to configure the software rts signal which
                                                     is used in software flow control.                                         */
      __IOM uint32_t SW_DTR     : 1;            /*!< This register is used to configure the software dtr signal which
                                                     is used in software flow control.                                         */
      __IOM uint32_t TXD_BRK    : 1;            /*!< Set this bit to enbale transmitter to send NULL when the process
                                                     of sending data is done.                                                  */
      __IOM uint32_t IRDA_DPLX  : 1;            /*!< Set this bit to enable IrDA loopback mode.                                */
      __IOM uint32_t IRDA_TX_EN : 1;            /*!< This is the start enable bit for IrDA transmitter.                        */
      __IOM uint32_t IRDA_WCTL  : 1;            /*!< 1'h1: The IrDA transmitter's 11th bit is the same as 10th bit.
                                                     1'h0: Set IrDA transmitter's 11th bit to 0.                               */
      __IOM uint32_t IRDA_TX_INV : 1;           /*!< Set this bit to invert the level of IrDA transmitter.                     */
      __IOM uint32_t IRDA_RX_INV : 1;           /*!< Set this bit to invert the level of IrDA receiver.                        */
      __IOM uint32_t LOOPBACK   : 1;            /*!< Set this bit to enable uart loopback test mode.                           */
      __IOM uint32_t TX_FLOW_EN : 1;            /*!< Set this bit to enable flow control function for transmitter.             */
      __IOM uint32_t IRDA_EN    : 1;            /*!< Set this bit to enable IrDA protocol.                                     */
      __IOM uint32_t RXFIFO_RST : 1;            /*!< Set this bit to reset the uart receive-FIFO.                              */
      __IOM uint32_t TXFIFO_RST : 1;            /*!< Set this bit to reset the uart transmit-FIFO.                             */
      __IOM uint32_t RXD_INV    : 1;            /*!< Set this bit to inverse the level value of uart rxd signal.               */
      __IOM uint32_t CTS_INV    : 1;            /*!< Set this bit to inverse the level value of uart cts signal.               */
      __IOM uint32_t DSR_INV    : 1;            /*!< Set this bit to inverse the level value of uart dsr signal.               */
      __IOM uint32_t TXD_INV    : 1;            /*!< Set this bit to inverse the level value of uart txd signal.               */
      __IOM uint32_t RTS_INV    : 1;            /*!< Set this bit to inverse the level value of uart rts signal.               */
      __IOM uint32_t DTR_INV    : 1;            /*!< Set this bit to inverse the level value of uart dtr signal.               */
      __IOM uint32_t CLK_EN     : 1;            /*!< 1'h1: Force clock on for register. 1'h0: Support clock only
                                                     when application writes registers.                                        */
      __IOM uint32_t ERR_WR_MASK : 1;           /*!< 1'h1: Receiver stops storing data into FIFO when data is wrong.
                                                     1'h0: Receiver stores the data even if the received data
                                                     is wrong.                                                                 */
      __IOM uint32_t AUTOBAUD_EN : 1;           /*!< This is the enable bit for detecting baudrate.                            */
      __IOM uint32_t MEM_CLK_EN : 1;            /*!< UART memory clock gate enable signal.                                     */
            uint32_t            : 3;
    } bit;
  } CONF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Configuration register 1                                                  */
    
    struct {
      __IOM uint32_t RXFIFO_FULL_THRHD : 10;    /*!< It will produce rxfifo_full_int interrupt when receiver receives
                                                     more data than this register value.                                       */
      __IOM uint32_t TXFIFO_EMPTY_THRHD : 10;   /*!< It will produce txfifo_empty_int interrupt when the data amount
                                                     in Tx-FIFO is less than this register value.                              */
      __IOM uint32_t DIS_RX_DAT_OVF : 1;        /*!< Disable UART Rx data overflow detect.                                     */
      __IOM uint32_t RX_TOUT_FLOW_DIS : 1;      /*!< Set this bit to stop accumulating idle_cnt when hardware flow
                                                     control works.                                                            */
      __IOM uint32_t RX_FLOW_EN : 1;            /*!< This is the flow enable bit for UART receiver.                            */
      __IOM uint32_t RX_TOUT_EN : 1;            /*!< This is the enble bit for uart receiver's timeout function.               */
            uint32_t            : 8;
    } bit;
  } CONF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Autobaud minimum low pulse duration register                              */
    
    struct {
      __IM  uint32_t MIN_CNT    : 12;           /*!< This register stores the value of the minimum duration time
                                                     of the low level pulse. It is used in baud rate-detect
                                                     process.                                                                  */
            uint32_t            : 20;
    } bit;
  } LOWPULSE;
  
  union {
    __IOM uint32_t reg;                         /*!< Autobaud minimum high pulse duration register                             */
    
    struct {
      __IM  uint32_t MIN_CNT    : 12;           /*!< This register stores the value of the maxinum duration time
                                                     for the high level pulse. It is used in baud rate-detect
                                                     process.                                                                  */
            uint32_t            : 20;
    } bit;
  } HIGHPULSE;
  
  union {
    __IOM uint32_t reg;                         /*!< Autobaud edge change count register                                       */
    
    struct {
      __IM  uint32_t RXD_EDGE_CNT : 10;         /*!< This register stores the count of rxd edge change. It is used
                                                     in baud rate-detect process.                                              */
            uint32_t            : 22;
    } bit;
  } RXD_CNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Software flow-control configuration                                       */
    
    struct {
      __IOM uint32_t SW_FLOW_CON_EN : 1;        /*!< Set this bit to enable software flow control. It is used with
                                                     register sw_xon or sw_xoff.                                               */
      __IOM uint32_t XONOFF_DEL : 1;            /*!< Set this bit to remove flow control char from the received data.          */
      __IOM uint32_t FORCE_XON  : 1;            /*!< Set this bit to enable the transmitter to go on sending data.             */
      __IOM uint32_t FORCE_XOFF : 1;            /*!< Set this bit to stop the transmitter from sending data.                   */
      __IOM uint32_t SEND_XON   : 1;            /*!< Set this bit to send Xon char. It is cleared by hardware automatically.   */
      __IOM uint32_t SEND_XOFF  : 1;            /*!< Set this bit to send Xoff char. It is cleared by hardware automatically.  */
            uint32_t            : 26;
    } bit;
  } FLOW_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Sleep-mode configuration                                                  */
    
    struct {
      __IOM uint32_t ACTIVE_THRESHOLD : 10;     /*!< The uart is activated from light sleeping mode when the input
                                                     rxd edge changes more times than this register value.                     */
            uint32_t            : 22;
    } bit;
  } SLEEP_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Software flow-control character configuration                             */
    
    struct {
      __IOM uint32_t XOFF_THRESHOLD : 10;       /*!< When the data amount in Rx-FIFO is more than this register value
                                                     with uart_sw_flow_con_en set to 1, it will send a Xoff
                                                     char.                                                                     */
      __IOM uint32_t XOFF_CHAR  : 8;            /*!< This register stores the Xoff flow control char.                          */
            uint32_t            : 14;
    } bit;
  } SWFC_CONF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Software flow-control character configuration                             */
    
    struct {
      __IOM uint32_t XON_THRESHOLD : 10;        /*!< When the data amount in Rx-FIFO is less than this register value
                                                     with uart_sw_flow_con_en set to 1, it will send a Xon char.               */
      __IOM uint32_t XON_CHAR   : 8;            /*!< This register stores the Xon flow control char.                           */
            uint32_t            : 14;
    } bit;
  } SWFC_CONF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Tx Break character configuration                                          */
    
    struct {
      __IOM uint32_t TX_BRK_NUM : 8;            /*!< This register is used to configure the number of 0 to be sent
                                                     after the process of sending data is done. It is active
                                                     when txd_brk is set to 1.                                                 */
            uint32_t            : 24;
    } bit;
  } TXBRK_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Frame-end idle configuration                                              */
    
    struct {
      __IOM uint32_t RX_IDLE_THRHD : 10;        /*!< It will produce frame end signal when receiver takes more time
                                                     to receive one byte data than this register value.                        */
      __IOM uint32_t TX_IDLE_NUM : 10;          /*!< This register is used to configure the duration time between
                                                     transfers.                                                                */
            uint32_t            : 12;
    } bit;
  } IDLE_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< RS485 mode configuration                                                  */
    
    struct {
      __IOM uint32_t RS485_EN   : 1;            /*!< Set this bit to choose the rs485 mode.                                    */
      __IOM uint32_t DL0_EN     : 1;            /*!< Set this bit to delay the stop bit by 1 bit.                              */
      __IOM uint32_t DL1_EN     : 1;            /*!< Set this bit to delay the stop bit by 1 bit.                              */
      __IOM uint32_t RS485TX_RX_EN : 1;         /*!< Set this bit to enable receiver could receive data when the
                                                     transmitter is transmitting data in rs485 mode.                           */
      __IOM uint32_t RS485RXBY_TX_EN : 1;       /*!< 1'h1: enable rs485 transmitter to send data when rs485 receiver
                                                     line is busy.                                                             */
      __IOM uint32_t RS485_RX_DLY_NUM : 1;      /*!< This register is used to delay the receiver's internal data
                                                     signal.                                                                   */
      __IOM uint32_t RS485_TX_DLY_NUM : 4;      /*!< This register is used to delay the transmitter's internal data
                                                     signal.                                                                   */
            uint32_t            : 22;
    } bit;
  } RS485_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Pre-sequence timing configuration                                         */
    
    struct {
      __IOM uint32_t PRE_IDLE_NUM : 16;         /*!< This register is used to configure the idle duration time before
                                                     the first at_cmd is received by receiver.                                 */
            uint32_t            : 16;
    } bit;
  } AT_CMD_PRECNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Post-sequence timing configuration                                        */
    
    struct {
      __IOM uint32_t POST_IDLE_NUM : 16;        /*!< This register is used to configure the duration time between
                                                     the last at_cmd and the next data.                                        */
            uint32_t            : 16;
    } bit;
  } AT_CMD_POSTCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< Timeout configuration                                                     */
    
    struct {
      __IOM uint32_t RX_GAP_TOUT : 16;          /*!< This register is used to configure the duration time between
                                                     the at_cmd chars.                                                         */
            uint32_t            : 16;
    } bit;
  } AT_CMD_GAPTOUT;
  
  union {
    __IOM uint32_t reg;                         /*!< AT escape sequence detection configuration                                */
    
    struct {
      __IOM uint32_t AT_CMD_CHAR : 8;           /*!< This register is used to configure the content of at_cmd char.            */
      __IOM uint32_t CHAR_NUM   : 8;            /*!< This register is used to configure the num of continuous at_cmd
                                                     chars received by receiver.                                               */
            uint32_t            : 16;
    } bit;
  } AT_CMD_CHAR;
  
  union {
    __IOM uint32_t reg;                         /*!< UART threshold and allocation configuration                               */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t RX_SIZE    : 3;            /*!< This register is used to configure the amount of mem allocated
                                                     for receive-FIFO. The default number is 128 bytes.                        */
      __IOM uint32_t TX_SIZE    : 3;            /*!< This register is used to configure the amount of mem allocated
                                                     for transmit-FIFO. The default number is 128 bytes.                       */
      __IOM uint32_t RX_FLOW_THRHD : 10;        /*!< This register is used to configure the maximum amount of data
                                                     that can be received when hardware flow control works.                    */
      __IOM uint32_t RX_TOUT_THRHD : 10;        /*!< This register is used to configure the threshold time that receiver
                                                     takes to receive one byte. The rxfifo_tout_int interrupt
                                                     will be trigger when the receiver takes more time to receive
                                                     one byte with rx_tout_en set to 1.                                        */
      __IOM uint32_t MEM_FORCE_PD : 1;          /*!< Set this bit to force power down UART memory.                             */
      __IOM uint32_t MEM_FORCE_PU : 1;          /*!< Set this bit to force power up UART memory.                               */
            uint32_t            : 3;
    } bit;
  } MEM_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Tx-FIFO write and read offset address.                                    */
    
    struct {
      __IM  uint32_t APB_TX_WADDR : 10;         /*!< This register stores the offset address in Tx-FIFO when software
                                                     writes Tx-FIFO via APB.                                                   */
            uint32_t            : 1;
      __IM  uint32_t TX_RADDR   : 10;           /*!< This register stores the offset address in Tx-FIFO when Tx-FSM
                                                     reads data via Tx-FIFO_Ctrl.                                              */
            uint32_t            : 11;
    } bit;
  } MEM_TX_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Rx-FIFO write and read offset address.                                    */
    
    struct {
      __IM  uint32_t APB_RX_RADDR : 10;         /*!< This register stores the offset address in RX-FIFO when software
                                                     reads data from Rx-FIFO via APB. UART0 is 10'h200. UART1
                                                     is 10'h280. UART2 is 10'h300.                                             */
            uint32_t            : 1;
      __IM  uint32_t RX_WADDR   : 10;           /*!< This register stores the offset address in Rx-FIFO when Rx-FIFO_Ctrl
                                                     writes Rx-FIFO. UART0 is 10'h200. UART1 is 10'h280. UART2
                                                     is 10'h300.                                                               */
            uint32_t            : 11;
    } bit;
  } MEM_RX_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< UART transmit and receive status.                                         */
    
    struct {
      __IM  uint32_t ST_URX_OUT : 4;            /*!< This is the status register of receiver.                                  */
      __IM  uint32_t ST_UTX_OUT : 4;            /*!< This is the status register of transmitter.                               */
            uint32_t            : 24;
    } bit;
  } FSM_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< Autobaud high pulse register                                              */
    
    struct {
      __IM  uint32_t POSEDGE_MIN_CNT : 12;      /*!< This register stores the minimal input clock count between two
                                                     positive edges. It is used in boudrate-detect process.                    */
            uint32_t            : 20;
    } bit;
  } POSPULSE;
  
  union {
    __IOM uint32_t reg;                         /*!< Autobaud low pulse register                                               */
    
    struct {
      __IM  uint32_t NEGEDGE_MIN_CNT : 12;      /*!< This register stores the minimal input clock count between two
                                                     negative edges. It is used in boudrate-detect process.                    */
            uint32_t            : 20;
    } bit;
  } NEGPULSE;
  
  union {
    __IOM uint32_t reg;                         /*!< UART core clock configuration                                             */
    
    struct {
      __IOM uint32_t SCLK_DIV_B : 6;            /*!< The denominator of the frequency divider factor.                          */
      __IOM uint32_t SCLK_DIV_A : 6;            /*!< The numerator of the frequency divider factor.                            */
      __IOM uint32_t SCLK_DIV_NUM : 8;          /*!< The integral part of the frequency divider factor.                        */
      __IOM uint32_t SCLK_SEL   : 2;            /*!< UART clock source select. 1: 80Mhz, 2: 8Mhz, 3: XTAL.                     */
      __IOM uint32_t SCLK_EN    : 1;            /*!< Set this bit to enable UART Tx/Rx clock.                                  */
      __IOM uint32_t RST_CORE   : 1;            /*!< Write 1 then write 0 to this bit, reset UART Tx/Rx.                       */
      __IOM uint32_t TX_SCLK_EN : 1;            /*!< Set this bit to enable UART Tx clock.                                     */
      __IOM uint32_t RX_SCLK_EN : 1;            /*!< Set this bit to enable UART Rx clock.                                     */
      __IOM uint32_t TX_RST_CORE : 1;           /*!< Write 1 then write 0 to this bit, reset UART Tx.                          */
      __IOM uint32_t RX_RST_CORE : 1;           /*!< Write 1 then write 0 to this bit, reset UART Rx.                          */
            uint32_t            : 4;
    } bit;
  } CLK_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< UART Version register                                                     */
    
    struct {
      __IOM uint32_t DATE       : 32;           /*!< This is the version register.                                             */
    } bit;
  } DATE;
  
  union {
    __IOM uint32_t reg;                         /*!< UART ID register                                                          */
    
    struct {
      __IOM uint32_t ID         : 30;           /*!< This register is used to configure the uart_id.                           */
      __IOM uint32_t HIGH_SPEED : 1;            /*!< This bit used to select synchronize mode. 1: Registers are auto
                                                     synchronized into UART Core clock and UART core should
                                                     be keep the same with APB clock. 0: After configure registers,
                                                     software needs to write 1 to UART_REG_UPDATE to synchronize
                                                     registers.                                                                */
      __IOM uint32_t REG_UPDATE : 1;            /*!< Software write 1 would synchronize registers into UART Core
                                                     clock domain and would be cleared by hardware after synchronization
                                                     is done.                                                                  */
    } bit;
  } ID;
} UART0_Type;                                   /*!< Size = 132 (0x84)                                                         */



/* =========================================================================================================================== */
/* ================                                           UHCI0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal Host Controller Interface 0 (UHCI0)
  */

typedef struct {                                /*!< UHCI0 Structure                                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< UHCI configuration register                                               */
    
    struct {
      __IOM uint32_t TX_RST     : 1;            /*!< Write 1, then write 0 to this bit to reset decode state machine.          */
      __IOM uint32_t RX_RST     : 1;            /*!< Write 1, then write 0 to this bit to reset encode state machine.          */
      __IOM uint32_t UART0_CE   : 1;            /*!< Set this bit to link up HCI and UART0.                                    */
      __IOM uint32_t UART1_CE   : 1;            /*!< Set this bit to link up HCI and UART1.                                    */
      __IOM uint32_t UART2_CE   : 1;            /*!< Set this bit to link up HCI and UART2.                                    */
      __IOM uint32_t SEPER_EN   : 1;            /*!< Set this bit to separate the data frame using a special char.             */
      __IOM uint32_t HEAD_EN    : 1;            /*!< Set this bit to encode the data packet with a formatting header.          */
      __IOM uint32_t CRC_REC_EN : 1;            /*!< Set this bit to enable UHCI to receive the 16 bit CRC.                    */
      __IOM uint32_t UART_IDLE_EOF_EN : 1;      /*!< If this bit is set to 1, UHCI will end the payload receiving
                                                     process when UART has been in idle state.                                 */
      __IOM uint32_t LEN_EOF_EN : 1;            /*!< If this bit is set to 1, UHCI decoder receiving payload data
                                                     is end when the receiving byte count has reached the specified
                                                     value. The value is payload length indicated by UHCI packet
                                                     header when UHCI_HEAD_EN is 1 or the value is configuration
                                                     value when UHCI_HEAD_EN is 0. If this bit is set to 0,
                                                     UHCI decoder receiving payload data is end when 0xc0 is
                                                     received.                                                                 */
      __IOM uint32_t ENCODE_CRC_EN : 1;         /*!< Set this bit to enable data integrity checking by appending
                                                     a 16 bit CCITT-CRC to end of the payload.                                 */
      __IOM uint32_t CLK_EN     : 1;            /*!< 1'b1: Force clock on for register. 1'b0: Support clock only
                                                     when application writes registers.                                        */
      __IOM uint32_t UART_RX_BRK_EOF_EN : 1;    /*!< If this bit is set to 1, UHCI will end payload receive process
                                                     when NULL frame is received by UART.                                      */
            uint32_t            : 19;
    } bit;
  } CONF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw interrupt status                                                      */
    
    struct {
      __IOM uint32_t RX_START_INT_RAW : 1;      /*!< This is the interrupt raw bit. Triggered when a separator char
                                                     has been sent.                                                            */
      __IOM uint32_t TX_START_INT_RAW : 1;      /*!< This is the interrupt raw bit. Triggered when UHCI detects a
                                                     separator char.                                                           */
      __IOM uint32_t RX_HUNG_INT_RAW : 1;       /*!< This is the interrupt raw bit. Triggered when UHCI takes more
                                                     time to receive data than configure value.                                */
      __IOM uint32_t TX_HUNG_INT_RAW : 1;       /*!< This is the interrupt raw bit. Triggered when UHCI takes more
                                                     time to read data from RAM than the configured value.                     */
      __IOM uint32_t SEND_S_REG_Q_INT_RAW : 1;  /*!< This is the interrupt raw bit. Triggered when UHCI has sent
                                                     out a short packet using single_send registers.                           */
      __IOM uint32_t SEND_A_REG_Q_INT_RAW : 1;  /*!< This is the interrupt raw bit. Triggered when UHCI has sent
                                                     out a short packet using always_send registers.                           */
      __IOM uint32_t OUT_EOF_INT_RAW : 1;       /*!< This is the interrupt raw bit. Triggered when there are some
                                                     errors in EOF in the transmit data.                                       */
      __IOM uint32_t APP_CTRL0_INT_RAW : 1;     /*!< This is the interrupt raw bit. Triggered when set UHCI_APP_CTRL0_IN_SET.  */
      __IOM uint32_t APP_CTRL1_INT_RAW : 1;     /*!< This is the interrupt raw bit. Triggered when set UHCI_APP_CTRL1_IN_SET.  */
            uint32_t            : 23;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt status                                                   */
    
    struct {
      __IM  uint32_t RX_START_INT_ST : 1;       /*!< This is the masked interrupt bit for UHCI_RX_START_INT interrupt
                                                     when UHCI_RX_START_INT_ENA is set to 1.                                   */
      __IM  uint32_t TX_START_INT_ST : 1;       /*!< This is the masked interrupt bit for UHCI_TX_START_INT interrupt
                                                     when UHCI_TX_START_INT_ENA is set to 1.                                   */
      __IM  uint32_t RX_HUNG_INT_ST : 1;        /*!< This is the masked interrupt bit for UHCI_RX_HUNG_INT interrupt
                                                     when UHCI_RX_HUNG_INT_ENA is set to 1.                                    */
      __IM  uint32_t TX_HUNG_INT_ST : 1;        /*!< This is the masked interrupt bit for UHCI_TX_HUNG_INT interrupt
                                                     when UHCI_TX_HUNG_INT_ENA is set to 1.                                    */
      __IM  uint32_t SEND_S_REG_Q_INT_ST : 1;   /*!< This is the masked interrupt bit for UHCI_SEND_S_REQ_Q_INT interrupt
                                                     when UHCI_SEND_S_REQ_Q_INT_ENA is set to 1.                               */
      __IM  uint32_t SEND_A_REG_Q_INT_ST : 1;   /*!< This is the masked interrupt bit for UHCI_SEND_A_REQ_Q_INT interrupt
                                                     when UHCI_SEND_A_REQ_Q_INT_ENA is set to 1.                               */
      __IM  uint32_t OUTLINK_EOF_ERR_INT_ST : 1;/*!< This is the masked interrupt bit for UHCI_OUTLINK_EOF_ERR_INT
                                                     interrupt when UHCI_OUTLINK_EOF_ERR_INT_ENA is set to 1.                  */
      __IM  uint32_t APP_CTRL0_INT_ST : 1;      /*!< This is the masked interrupt bit for UHCI_APP_CTRL0_INT interrupt
                                                     when UHCI_APP_CTRL0_INT_ENA is set to 1.                                  */
      __IM  uint32_t APP_CTRL1_INT_ST : 1;      /*!< This is the masked interrupt bit for UHCI_APP_CTRL1_INT interrupt
                                                     when UHCI_APP_CTRL1_INT_ENA is set to 1.                                  */
            uint32_t            : 23;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits                                                     */
    
    struct {
      __IOM uint32_t RX_START_INT_ENA : 1;      /*!< This is the interrupt enable bit for UHCI_RX_START_INT interrupt.         */
      __IOM uint32_t TX_START_INT_ENA : 1;      /*!< This is the interrupt enable bit for UHCI_TX_START_INT interrupt.         */
      __IOM uint32_t RX_HUNG_INT_ENA : 1;       /*!< This is the interrupt enable bit for UHCI_RX_HUNG_INT interrupt.          */
      __IOM uint32_t TX_HUNG_INT_ENA : 1;       /*!< This is the interrupt enable bit for UHCI_TX_HUNG_INT interrupt.          */
      __IOM uint32_t SEND_S_REG_Q_INT_ENA : 1;  /*!< This is the interrupt enable bit for UHCI_SEND_S_REQ_Q_INT interrupt.     */
      __IOM uint32_t SEND_A_REG_Q_INT_ENA : 1;  /*!< This is the interrupt enable bit for UHCI_SEND_A_REQ_Q_INT interrupt.     */
      __IOM uint32_t OUTLINK_EOF_ERR_INT_ENA : 1;/*!< This is the interrupt enable bit for UHCI_OUTLINK_EOF_ERR_INT
                                                     interrupt.                                                                */
      __IOM uint32_t APP_CTRL0_INT_ENA : 1;     /*!< This is the interrupt enable bit for UHCI_APP_CTRL0_INT interrupt.        */
      __IOM uint32_t APP_CTRL1_INT_ENA : 1;     /*!< This is the interrupt enable bit for UHCI_APP_CTRL1_INT interrupt.        */
            uint32_t            : 23;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits                                                      */
    
    struct {
      __OM  uint32_t RX_START_INT_CLR : 1;      /*!< Set this bit to clear UHCI_RX_START_INT interrupt.                        */
      __OM  uint32_t TX_START_INT_CLR : 1;      /*!< Set this bit to clear UHCI_TX_START_INT interrupt.                        */
      __OM  uint32_t RX_HUNG_INT_CLR : 1;       /*!< Set this bit to clear UHCI_RX_HUNG_INT interrupt.                         */
      __OM  uint32_t TX_HUNG_INT_CLR : 1;       /*!< Set this bit to clear UHCI_TX_HUNG_INT interrupt.                         */
      __OM  uint32_t SEND_S_REG_Q_INT_CLR : 1;  /*!< Set this bit to clear UHCI_SEND_S_REQ_Q_INT interrupt.                    */
      __OM  uint32_t SEND_A_REG_Q_INT_CLR : 1;  /*!< Set this bit to clear UHCI_SEND_A_REQ_Q_INT interrupt.                    */
      __OM  uint32_t OUTLINK_EOF_ERR_INT_CLR : 1;/*!< Set this bit to clear UHCI_OUTLINK_EOF_ERR_INT interrupt.                */
      __OM  uint32_t APP_CTRL0_INT_CLR : 1;     /*!< Set this bit to clear UHCI_APP_CTRL0_INT interrupt.                       */
      __OM  uint32_t APP_CTRL1_INT_CLR : 1;     /*!< Set this bit to clear UHCI_APP_CTRL1_INT interrupt.                       */
            uint32_t            : 23;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Software interrupt trigger source                                         */
    
    struct {
      __OM  uint32_t APP_CTRL0_INT_SET : 1;     /*!< This bit is software interrupt trigger source of UHCI_APP_CTRL0_INT.      */
      __OM  uint32_t APP_CTRL1_INT_SET : 1;     /*!< This bit is software interrupt trigger source of UHCI_APP_CTRL1_INT.      */
            uint32_t            : 30;
    } bit;
  } APP_INT_SET;
  
  union {
    __IOM uint32_t reg;                         /*!< UHCI configuration register                                               */
    
    struct {
      __IOM uint32_t CHECK_SUM_EN : 1;          /*!< This is the enable bit to check header checksum when UHCI receives
                                                     a data packet.                                                            */
      __IOM uint32_t CHECK_SEQ_EN : 1;          /*!< This is the enable bit to check sequence number when UHCI receives
                                                     a data packet.                                                            */
      __IOM uint32_t CRC_DISABLE : 1;           /*!< Set this bit to support CRC calculation. Data Integrity Check
                                                     Present bit in UHCI packet frame should be 1.                             */
      __IOM uint32_t SAVE_HEAD  : 1;            /*!< Set this bit to save the packet header when HCI receives a data
                                                     packet.                                                                   */
      __IOM uint32_t TX_CHECK_SUM_RE : 1;       /*!< Set this bit to encode the data packet with a checksum.                   */
      __IOM uint32_t TX_ACK_NUM_RE : 1;         /*!< Set this bit to encode the data packet with an acknowledgment
                                                     when a reliable packet is to be transmit.                                 */
            uint32_t            : 1;
      __IOM uint32_t WAIT_SW_START : 1;         /*!< The uhci-encoder will jump to ST_SW_WAIT status if this register
                                                     is set to 1.                                                              */
      __IOM uint32_t SW_START   : 1;            /*!< If current UHCI_ENCODE_STATE is ST_SW_WAIT, the UHCI will start
                                                     to send data packet out when this bit is set to 1.                        */
            uint32_t            : 23;
    } bit;
  } CONF1;
  
  union {
    __IOM uint32_t reg;                         /*!< UHCI receive status                                                       */
    
    struct {
      __IM  uint32_t RX_ERR_CAUSE : 3;          /*!< This register indicates the error type when DMA has received
                                                     a packet with error. 3'b001: Checksum error in HCI packet.
                                                     3'b010: Sequence number error in HCI packet. 3'b011: CRC
                                                     bit error in HCI packet. 3'b100: 0xc0 is found but received
                                                     HCI packet is not end. 3'b101: 0xc0 is not found when receiving
                                                     HCI packet is end. 3'b110: CRC check error.                               */
      __IM  uint32_t DECODE_STATE : 3;          /*!< UHCI decoder status.                                                      */
            uint32_t            : 26;
    } bit;
  } STATE0;
  
  union {
    __IOM uint32_t reg;                         /*!< UHCI transmit status                                                      */
    
    struct {
      __IM  uint32_t ENCODE_STATE : 3;          /*!< UHCI encoder status.                                                      */
            uint32_t            : 29;
    } bit;
  } STATE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Escape character configuration                                            */
    
    struct {
      __IOM uint32_t TX_C0_ESC_EN : 1;          /*!< Set this bit to enable decoding char 0xc0 when DMA receives
                                                     data.                                                                     */
      __IOM uint32_t TX_DB_ESC_EN : 1;          /*!< Set this bit to enable decoding char 0xdb when DMA receives
                                                     data.                                                                     */
      __IOM uint32_t TX_11_ESC_EN : 1;          /*!< Set this bit to enable decoding flow control char 0x11 when
                                                     DMA receives data.                                                        */
      __IOM uint32_t TX_13_ESC_EN : 1;          /*!< Set this bit to enable decoding flow control char 0x13 when
                                                     DMA receives data.                                                        */
      __IOM uint32_t RX_C0_ESC_EN : 1;          /*!< Set this bit to enable replacing 0xc0 by special char when DMA
                                                     sends data.                                                               */
      __IOM uint32_t RX_DB_ESC_EN : 1;          /*!< Set this bit to enable replacing 0xdb by special char when DMA
                                                     sends data.                                                               */
      __IOM uint32_t RX_11_ESC_EN : 1;          /*!< Set this bit to enable replacing flow control char 0x11 by special
                                                     char when DMA sends data.                                                 */
      __IOM uint32_t RX_13_ESC_EN : 1;          /*!< Set this bit to enable replacing flow control char 0x13 by special
                                                     char when DMA sends data.                                                 */
            uint32_t            : 24;
    } bit;
  } ESCAPE_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Timeout configuration                                                     */
    
    struct {
      __IOM uint32_t TXFIFO_TIMEOUT : 8;        /*!< This register stores the timeout value. It will produce the
                                                     UHCI_TX_HUNG_INT interrupt when DMA takes more time to
                                                     receive data.                                                             */
      __IOM uint32_t TXFIFO_TIMEOUT_SHIFT : 3;  /*!< This register is used to configure the tick count maximum value.          */
      __IOM uint32_t TXFIFO_TIMEOUT_ENA : 1;    /*!< This is the enable bit for Tx-FIFO receive-data timeout.                  */
      __IOM uint32_t RXFIFO_TIMEOUT : 8;        /*!< This register stores the timeout value. It will produce the
                                                     UHCI_RX_HUNG_INT interrupt when DMA takes more time to
                                                     read data from RAM.                                                       */
      __IOM uint32_t RXFIFO_TIMEOUT_SHIFT : 3;  /*!< This register is used to configure the tick count maximum value.          */
      __IOM uint32_t RXFIFO_TIMEOUT_ENA : 1;    /*!< This is the enable bit for DMA send-data timeout.                         */
            uint32_t            : 8;
    } bit;
  } HUNG_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< UHCI ACK number configuration                                             */
    
    struct {
      __IOM uint32_t ACK_NUM    : 3;            /*!< This ACK number used in software flow control.                            */
      __OM  uint32_t LOAD       : 1;            /*!< Set this bit to 1, the value configured by UHCI_ACK_NUM would
                                                     be loaded.                                                                */
            uint32_t            : 28;
    } bit;
  } ACK_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< UHCI packet header register                                               */
    
    struct {
      __IM  uint32_t RX_HEAD    : 32;           /*!< This register stores the header of the current received packet.           */
    } bit;
  } RX_HEAD;
  
  union {
    __IOM uint32_t reg;                         /*!< UHCI quick send configuration register                                    */
    
    struct {
      __IOM uint32_t SINGLE_SEND_NUM : 3;       /*!< This register is used to specify the single_send register.                */
      __IOM uint32_t SINGLE_SEND_EN : 1;        /*!< Set this bit to enable single_send mode to send short packet.             */
      __IOM uint32_t ALWAYS_SEND_NUM : 3;       /*!< This register is used to specify the always_send register.                */
      __IOM uint32_t ALWAYS_SEND_EN : 1;        /*!< Set this bit to enable always_send mode to send short packet.             */
            uint32_t            : 24;
    } bit;
  } QUICK_SENT;
  
  union {
    __IOM uint32_t reg;                         /*!< Q0_WORD0 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q0_WORD0 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q0_WORD0;
  
  union {
    __IOM uint32_t reg;                         /*!< Q0_WORD1 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q0_WORD1 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q0_WORD1;
  
  union {
    __IOM uint32_t reg;                         /*!< Q1_WORD0 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q1_WORD0 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q1_WORD0;
  
  union {
    __IOM uint32_t reg;                         /*!< Q1_WORD1 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q1_WORD1 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q1_WORD1;
  
  union {
    __IOM uint32_t reg;                         /*!< Q2_WORD0 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q2_WORD0 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q2_WORD0;
  
  union {
    __IOM uint32_t reg;                         /*!< Q2_WORD1 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q2_WORD1 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q2_WORD1;
  
  union {
    __IOM uint32_t reg;                         /*!< Q3_WORD0 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q3_WORD0 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q3_WORD0;
  
  union {
    __IOM uint32_t reg;                         /*!< Q3_WORD1 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q3_WORD1 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q3_WORD1;
  
  union {
    __IOM uint32_t reg;                         /*!< Q4_WORD0 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q4_WORD0 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q4_WORD0;
  
  union {
    __IOM uint32_t reg;                         /*!< Q4_WORD1 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q4_WORD1 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q4_WORD1;
  
  union {
    __IOM uint32_t reg;                         /*!< Q5_WORD0 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q5_WORD0 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q5_WORD0;
  
  union {
    __IOM uint32_t reg;                         /*!< Q5_WORD1 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q5_WORD1 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q5_WORD1;
  
  union {
    __IOM uint32_t reg;                         /*!< Q6_WORD0 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q6_WORD0 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q6_WORD0;
  
  union {
    __IOM uint32_t reg;                         /*!< Q6_WORD1 quick_sent register                                              */
    
    struct {
      __IOM uint32_t SEND_Q6_WORD1 : 32;        /*!< This register is used as a quick_sent register when specified
                                                     by UHCI_ALWAYS_SEND_NUM or UHCI_SINGLE_SEND_NUM.                          */
    } bit;
  } REG_Q6_WORD1;
  
  union {
    __IOM uint32_t reg;                         /*!< Escape sequence configuration register 0                                  */
    
    struct {
      __IOM uint32_t SEPER_CHAR : 8;            /*!< This register is used to define the separate char that need
                                                     to be encoded, default is 0xc0.                                           */
      __IOM uint32_t SEPER_ESC_CHAR0 : 8;       /*!< This register is used to define the first char of slip escape
                                                     sequence when encoding the separate char, default is 0xdb.                */
      __IOM uint32_t SEPER_ESC_CHAR1 : 8;       /*!< This register is used to define the second char of slip escape
                                                     sequence when encoding the separate char, default is 0xdc.                */
            uint32_t            : 8;
    } bit;
  } ESC_CONF0;
  
  union {
    __IOM uint32_t reg;                         /*!< Escape sequence configuration register 1                                  */
    
    struct {
      __IOM uint32_t ESC_SEQ0   : 8;            /*!< This register is used to define a char that need to be encoded,
                                                     default is 0xdb that used as the first char of slip escape
                                                     sequence.                                                                 */
      __IOM uint32_t ESC_SEQ0_CHAR0 : 8;        /*!< This register is used to define the first char of slip escape
                                                     sequence when encoding the UHCI_ESC_SEQ0, default is 0xdb.                */
      __IOM uint32_t ESC_SEQ0_CHAR1 : 8;        /*!< This register is used to define the second char of slip escape
                                                     sequence when encoding the UHCI_ESC_SEQ0, default is 0xdd.                */
            uint32_t            : 8;
    } bit;
  } ESC_CONF1;
  
  union {
    __IOM uint32_t reg;                         /*!< Escape sequence configuration register 2                                  */
    
    struct {
      __IOM uint32_t ESC_SEQ1   : 8;            /*!< This register is used to define a char that need to be encoded,
                                                     default is 0x11 that used as flow control char.                           */
      __IOM uint32_t ESC_SEQ1_CHAR0 : 8;        /*!< This register is used to define the first char of slip escape
                                                     sequence when encoding the UHCI_ESC_SEQ1, default is 0xdb.                */
      __IOM uint32_t ESC_SEQ1_CHAR1 : 8;        /*!< This register is used to define the second char of slip escape
                                                     sequence when encoding the UHCI_ESC_SEQ1, default is 0xde.                */
            uint32_t            : 8;
    } bit;
  } ESC_CONF2;
  
  union {
    __IOM uint32_t reg;                         /*!< Escape sequence configuration register 3                                  */
    
    struct {
      __IOM uint32_t ESC_SEQ2   : 8;            /*!< This register is used to define a char that need to be decoded,
                                                     default is 0x13 that used as flow control char.                           */
      __IOM uint32_t ESC_SEQ2_CHAR0 : 8;        /*!< This register is used to define the first char of slip escape
                                                     sequence when encoding the UHCI_ESC_SEQ2, default is 0xdb.                */
      __IOM uint32_t ESC_SEQ2_CHAR1 : 8;        /*!< This register is used to define the second char of slip escape
                                                     sequence when encoding the UHCI_ESC_SEQ2, default is 0xdf.                */
            uint32_t            : 8;
    } bit;
  } ESC_CONF3;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure register for packet length                                      */
    
    struct {
      __IOM uint32_t PKT_THRS   : 13;           /*!< This register is used to configure the maximum value of the
                                                     packet length when UHCI_HEAD_EN is 0.                                     */
            uint32_t            : 19;
    } bit;
  } PKT_THRES;
  
  union {
    __IOM uint32_t reg;                         /*!< UHCI version control register                                             */
    
    struct {
      __IOM uint32_t DATE       : 32;           /*!< This is the version control register.                                     */
    } bit;
  } DATE;
} UHCI0_Type;                                   /*!< Size = 136 (0x88)                                                         */



/* =========================================================================================================================== */
/* ================                                           USB0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief USB OTG (On-The-Go) (USB0)
  */

typedef struct {                                /*!< USB0 Structure                                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< GOTGCTL                                                                   */
    
    struct {
      __IM  uint32_t SESREQSCS  : 1;            /*!< SESREQSCS                                                                 */
      __IOM uint32_t SESREQ     : 1;            /*!< SESREQ                                                                    */
      __IOM uint32_t VBVALIDOVEN : 1;           /*!< VBVALIDOVEN                                                               */
      __IOM uint32_t VBVALIDOVVAL : 1;          /*!< VBVALIDOVVAL                                                              */
      __IOM uint32_t AVALIDOVEN : 1;            /*!< AVALIDOVEN                                                                */
      __IOM uint32_t AVALIDOVVAL : 1;           /*!< AVALIDOVVAL                                                               */
      __IOM uint32_t BVALIDOVEN : 1;            /*!< BVALIDOVEN                                                                */
      __IOM uint32_t BVALIDOVVAL : 1;           /*!< BVALIDOVVAL                                                               */
      __IM  uint32_t HSTNEGSCS  : 1;            /*!< HSTNEGSCS                                                                 */
      __IOM uint32_t HNPREQ     : 1;            /*!< HNPREQ                                                                    */
      __IOM uint32_t HSTSETHNPEN : 1;           /*!< HSTSETHNPEN                                                               */
      __IOM uint32_t DEVHNPEN   : 1;            /*!< DEVHNPEN                                                                  */
      __IOM uint32_t EHEN       : 1;            /*!< EHEN                                                                      */
            uint32_t            : 2;
      __IOM uint32_t DBNCEFLTRBYPASS : 1;       /*!< DBNCEFLTRBYPASS                                                           */
      __IM  uint32_t CONIDSTS   : 1;            /*!< CONIDSTS                                                                  */
      __IM  uint32_t DBNCTIME   : 1;            /*!< DBNCTIME                                                                  */
      __IM  uint32_t ASESVLD    : 1;            /*!< ASESVLD                                                                   */
      __IM  uint32_t BSESVLD    : 1;            /*!< BSESVLD                                                                   */
      __IOM uint32_t OTGVER     : 1;            /*!< OTGVER                                                                    */
      __IM  uint32_t CURMOD     : 1;            /*!< CURMOD                                                                    */
            uint32_t            : 10;
    } bit;
  } GOTGCTL;
  
  union {
    __IOM uint32_t reg;                         /*!< GOTGINT                                                                   */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t SESENDDET  : 1;            /*!< SESENDDET                                                                 */
            uint32_t            : 5;
      __IOM uint32_t SESREQSUCSTSCHNG : 1;      /*!< SESREQSUCSTSCHNG                                                          */
      __IOM uint32_t HSTNEGSUCSTSCHNG : 1;      /*!< HSTNEGSUCSTSCHNG                                                          */
            uint32_t            : 7;
      __IOM uint32_t HSTNEGDET  : 1;            /*!< HSTNEGDET                                                                 */
      __IOM uint32_t ADEVTOUTCHG : 1;           /*!< ADEVTOUTCHG                                                               */
      __IOM uint32_t DBNCEDONE  : 1;            /*!< DBNCEDONE                                                                 */
            uint32_t            : 12;
    } bit;
  } GOTGINT;
  
  union {
    __IOM uint32_t reg;                         /*!< GAHBCFG                                                                   */
    
    struct {
      __IOM uint32_t GLBLLNTRMSK : 1;           /*!< GLBLLNTRMSK                                                               */
      __IOM uint32_t HBSTLEN    : 4;            /*!< HBSTLEN                                                                   */
      __IOM uint32_t DMAEN      : 1;            /*!< DMAEN                                                                     */
            uint32_t            : 1;
      __IOM uint32_t NPTXFEMPLVL : 1;           /*!< NPTXFEMPLVL                                                               */
      __IOM uint32_t PTXFEMPLVL : 1;            /*!< PTXFEMPLVL                                                                */
            uint32_t            : 12;
      __IOM uint32_t REMMEMSUPP : 1;            /*!< REMMEMSUPP                                                                */
      __IOM uint32_t NOTIALLDMAWRIT : 1;        /*!< NOTIALLDMAWRIT                                                            */
      __IOM uint32_t AHBSINGLE  : 1;            /*!< AHBSINGLE                                                                 */
      __IOM uint32_t INVDESCENDIANESS : 1;      /*!< INVDESCENDIANESS                                                          */
            uint32_t            : 7;
    } bit;
  } GAHBCFG;
  
  union {
    __IOM uint32_t reg;                         /*!< GUSBCFG                                                                   */
    
    struct {
      __IOM uint32_t TOUTCAL    : 3;            /*!< TOUTCAL                                                                   */
      __IOM uint32_t PHYIF      : 1;            /*!< PHYIF                                                                     */
      __IM  uint32_t ULPI_UTMI_SEL : 1;         /*!< ULPI_UTMI_SEL                                                             */
      __IOM uint32_t FSINTF     : 1;            /*!< FSINTF                                                                    */
      __IM  uint32_t PHYSEL     : 1;            /*!< PHYSEL                                                                    */
            uint32_t            : 1;
      __IOM uint32_t SRPCAP     : 1;            /*!< SRPCAP                                                                    */
      __IOM uint32_t HNPCAP     : 1;            /*!< HNPCAP                                                                    */
      __IOM uint32_t USBTRDTIM  : 4;            /*!< USBTRDTIM                                                                 */
            uint32_t            : 8;
      __IOM uint32_t TERMSELDLPULSE : 1;        /*!< TERMSELDLPULSE                                                            */
            uint32_t            : 5;
      __IOM uint32_t TXENDDELAY : 1;            /*!< TXENDDELAY                                                                */
      __IOM uint32_t FORCEHSTMODE : 1;          /*!< FORCEHSTMODE                                                              */
      __IOM uint32_t FORCEDEVMODE : 1;          /*!< FORCEDEVMODE                                                              */
      __IOM uint32_t CORRUPTTXPKT : 1;          /*!< CORRUPTTXPKT                                                              */
    } bit;
  } GUSBCFG;
  
  union {
    __IOM uint32_t reg;                         /*!< GRSTCTL                                                                   */
    
    struct {
      __IOM uint32_t CSFTRST    : 1;            /*!< CSFTRST                                                                   */
      __IOM uint32_t PIUFSSFTRST : 1;           /*!< PIUFSSFTRST                                                               */
      __IOM uint32_t FRMCNTRRST : 1;            /*!< FRMCNTRRST                                                                */
            uint32_t            : 1;
      __IOM uint32_t RXFFLSH    : 1;            /*!< RXFFLSH                                                                   */
      __IOM uint32_t TXFFLSH    : 1;            /*!< TXFFLSH                                                                   */
      __IOM uint32_t TXFNUM     : 5;            /*!< TXFNUM                                                                    */
            uint32_t            : 19;
      __IM  uint32_t DMAREQ     : 1;            /*!< DMAREQ                                                                    */
      __IM  uint32_t AHBIDLE    : 1;            /*!< AHBIDLE                                                                   */
    } bit;
  } GRSTCTL;
  
  union {
    __IOM uint32_t reg;                         /*!< GINTSTS                                                                   */
    
    struct {
      __IM  uint32_t CURMOD_INT : 1;            /*!< CURMOD_INT                                                                */
      __IOM uint32_t MODEMIS    : 1;            /*!< MODEMIS                                                                   */
      __IM  uint32_t OTGINT     : 1;            /*!< OTGINT                                                                    */
      __IOM uint32_t SOF        : 1;            /*!< SOF                                                                       */
      __IM  uint32_t RXFLVI     : 1;            /*!< RXFLVI                                                                    */
      __IM  uint32_t NPTXFEMP   : 1;            /*!< NPTXFEMP                                                                  */
      __IM  uint32_t GINNAKEFF  : 1;            /*!< GINNAKEFF                                                                 */
      __IM  uint32_t GOUTNAKEFF : 1;            /*!< GOUTNAKEFF                                                                */
            uint32_t            : 2;
      __IOM uint32_t ERLYSUSP   : 1;            /*!< ERLYSUSP                                                                  */
      __IOM uint32_t USBSUSP    : 1;            /*!< USBSUSP                                                                   */
      __IOM uint32_t USBRST     : 1;            /*!< USBRST                                                                    */
      __IOM uint32_t ENUMDONE   : 1;            /*!< ENUMDONE                                                                  */
      __IOM uint32_t ISOOUTDROP : 1;            /*!< ISOOUTDROP                                                                */
      __IOM uint32_t EOPF       : 1;            /*!< EOPF                                                                      */
            uint32_t            : 1;
      __IOM uint32_t EPMIS      : 1;            /*!< EPMIS                                                                     */
      __IM  uint32_t IEPINT     : 1;            /*!< IEPINT                                                                    */
      __IM  uint32_t OEPINT     : 1;            /*!< OEPINT                                                                    */
      __IOM uint32_t INCOMPISOIN : 1;           /*!< INCOMPISOIN                                                               */
      __IOM uint32_t INCOMPIP   : 1;            /*!< INCOMPIP                                                                  */
      __IOM uint32_t FETSUSP    : 1;            /*!< FETSUSP                                                                   */
      __IOM uint32_t RESETDET   : 1;            /*!< RESETDET                                                                  */
      __IM  uint32_t PRTLNT     : 1;            /*!< PRTLNT                                                                    */
      __IM  uint32_t HCHLNT     : 1;            /*!< HCHLNT                                                                    */
      __IM  uint32_t PTXFEMP    : 1;            /*!< PTXFEMP                                                                   */
            uint32_t            : 1;
      __IOM uint32_t CONIDSTSCHNG : 1;          /*!< CONIDSTSCHNG                                                              */
      __IOM uint32_t DISCONNINT : 1;            /*!< DISCONNINT                                                                */
      __IOM uint32_t SESSREQINT : 1;            /*!< SESSREQINT                                                                */
      __IOM uint32_t WKUPINT    : 1;            /*!< WKUPINT                                                                   */
    } bit;
  } GINTSTS;
  
  union {
    __IOM uint32_t reg;                         /*!< GINTMSK                                                                   */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t MODEMISMSK : 1;            /*!< MODEMISMSK                                                                */
      __IOM uint32_t OTGINTMSK  : 1;            /*!< OTGINTMSK                                                                 */
      __IOM uint32_t SOFMSK     : 1;            /*!< SOFMSK                                                                    */
      __IOM uint32_t RXFLVIMSK  : 1;            /*!< RXFLVIMSK                                                                 */
      __IOM uint32_t NPTXFEMPMSK : 1;           /*!< NPTXFEMPMSK                                                               */
      __IOM uint32_t GINNAKEFFMSK : 1;          /*!< GINNAKEFFMSK                                                              */
      __IOM uint32_t GOUTNACKEFFMSK : 1;        /*!< GOUTNACKEFFMSK                                                            */
            uint32_t            : 2;
      __IOM uint32_t ERLYSUSPMSK : 1;           /*!< ERLYSUSPMSK                                                               */
      __IOM uint32_t USBSUSPMSK : 1;            /*!< USBSUSPMSK                                                                */
      __IOM uint32_t USBRSTMSK  : 1;            /*!< USBRSTMSK                                                                 */
      __IOM uint32_t ENUMDONEMSK : 1;           /*!< ENUMDONEMSK                                                               */
      __IOM uint32_t ISOOUTDROPMSK : 1;         /*!< ISOOUTDROPMSK                                                             */
      __IOM uint32_t EOPFMSK    : 1;            /*!< EOPFMSK                                                                   */
            uint32_t            : 1;
      __IOM uint32_t EPMISMSK   : 1;            /*!< EPMISMSK                                                                  */
      __IOM uint32_t IEPINTMSK  : 1;            /*!< IEPINTMSK                                                                 */
      __IOM uint32_t OEPINTMSK  : 1;            /*!< OEPINTMSK                                                                 */
      __IOM uint32_t INCOMPISOINMSK : 1;        /*!< INCOMPISOINMSK                                                            */
      __IOM uint32_t INCOMPIPMSK : 1;           /*!< INCOMPIPMSK                                                               */
      __IOM uint32_t FETSUSPMSK : 1;            /*!< FETSUSPMSK                                                                */
      __IOM uint32_t RESETDETMSK : 1;           /*!< RESETDETMSK                                                               */
      __IOM uint32_t PRTLNTMSK  : 1;            /*!< PRTLNTMSK                                                                 */
      __IOM uint32_t HCHINTMSK  : 1;            /*!< HCHINTMSK                                                                 */
      __IOM uint32_t PTXFEMPMSK : 1;            /*!< PTXFEMPMSK                                                                */
            uint32_t            : 1;
      __IOM uint32_t CONIDSTSCHNGMSK : 1;       /*!< CONIDSTSCHNGMSK                                                           */
      __IOM uint32_t DISCONNINTMSK : 1;         /*!< DISCONNINTMSK                                                             */
      __IOM uint32_t SESSREQINTMSK : 1;         /*!< SESSREQINTMSK                                                             */
      __IOM uint32_t WKUPINTMSK : 1;            /*!< WKUPINTMSK                                                                */
    } bit;
  } GINTMSK;
  
  union {
    __IOM uint32_t reg;                         /*!< GRXSTSR                                                                   */
    
    struct {
      __IM  uint32_t G_CHNUM    : 4;            /*!< G_CHNUM                                                                   */
      __IM  uint32_t G_BCNT     : 11;           /*!< G_BCNT                                                                    */
      __IM  uint32_t G_DPID     : 2;            /*!< G_DPID                                                                    */
      __IM  uint32_t G_PKTSTS   : 4;            /*!< G_PKTSTS                                                                  */
      __IM  uint32_t G_FN       : 4;            /*!< G_FN                                                                      */
            uint32_t            : 7;
    } bit;
  } GRXSTSR;
  
  union {
    __IOM uint32_t reg;                         /*!< GRXSTSP                                                                   */
    
    struct {
      __IM  uint32_t CHNUM      : 4;            /*!< CHNUM                                                                     */
      __IM  uint32_t BCNT       : 11;           /*!< BCNT                                                                      */
      __IM  uint32_t DPID       : 2;            /*!< DPID                                                                      */
      __IM  uint32_t PKTSTS     : 4;            /*!< PKTSTS                                                                    */
      __IM  uint32_t FN         : 4;            /*!< FN                                                                        */
            uint32_t            : 7;
    } bit;
  } GRXSTSP;
  
  union {
    __IOM uint32_t reg;                         /*!< GRXFSIZ                                                                   */
    
    struct {
      __IOM uint32_t RXFDEP     : 16;           /*!< RXFDEP                                                                    */
            uint32_t            : 16;
    } bit;
  } GRXFSIZ;
  
  union {
    __IOM uint32_t reg;                         /*!< GNPTXFSIZ                                                                 */
    
    struct {
      __IOM uint32_t NPTXFSTADDR : 16;          /*!< NPTXFSTADDR                                                               */
      __IOM uint32_t NPTXFDEP   : 16;           /*!< NPTXFDEP                                                                  */
    } bit;
  } GNPTXFSIZ;
  
  union {
    __IOM uint32_t reg;                         /*!< GNPTXSTS                                                                  */
    
    struct {
      __IM  uint32_t NPTXFSPCAVAIL : 16;        /*!< NPTXFSPCAVAIL                                                             */
      __IM  uint32_t NPTXQSPCAVAIL : 4;         /*!< NPTXQSPCAVAIL                                                             */
            uint32_t            : 4;
      __IM  uint32_t NPTXQTOP   : 7;            /*!< NPTXQTOP                                                                  */
            uint32_t            : 1;
    } bit;
  } GNPTXSTS;
  __IM  uint32_t  RESERVED[4];
  
  union {
    __IOM uint32_t reg;                         /*!< GSNPSID                                                                   */
    
    struct {
      __IM  uint32_t SYNOPSYSID : 32;           /*!< SYNOPSYSID                                                                */
    } bit;
  } GSNPSID;
  
  union {
    __IOM uint32_t reg;                         /*!< GHWCFG1                                                                   */
    
    struct {
      __IM  uint32_t EPDIR      : 32;           /*!< EPDIR                                                                     */
    } bit;
  } GHWCFG1;
  
  union {
    __IOM uint32_t reg;                         /*!< GHWCFG2                                                                   */
    
    struct {
      __IM  uint32_t OTGMODE    : 3;            /*!< OTGMODE                                                                   */
      __IM  uint32_t OTGARCH    : 2;            /*!< OTGARCH                                                                   */
      __IM  uint32_t SINGPNT    : 1;            /*!< SINGPNT                                                                   */
      __IM  uint32_t HSPHYTYPE  : 2;            /*!< HSPHYTYPE                                                                 */
      __IM  uint32_t FSPHYTYPE  : 2;            /*!< FSPHYTYPE                                                                 */
      __IM  uint32_t NUMDEVEPS  : 4;            /*!< NUMDEVEPS                                                                 */
      __IM  uint32_t NUMHSTCHNL : 4;            /*!< NUMHSTCHNL                                                                */
      __IM  uint32_t PERIOSUPPORT : 1;          /*!< PERIOSUPPORT                                                              */
      __IM  uint32_t DYNFIFOSIZING : 1;         /*!< DYNFIFOSIZING                                                             */
      __IM  uint32_t MULTIPROCINTRPT : 1;       /*!< MULTIPROCINTRPT                                                           */
            uint32_t            : 1;
      __IM  uint32_t NPTXQDEPTH : 2;            /*!< NPTXQDEPTH                                                                */
      __IM  uint32_t PTXQDEPTH  : 2;            /*!< PTXQDEPTH                                                                 */
      __IM  uint32_t TKNQDEPTH  : 5;            /*!< TKNQDEPTH                                                                 */
      __IM  uint32_t OTG_ENABLE_IC_USB : 1;     /*!< OTG_ENABLE_IC_USB                                                         */
    } bit;
  } GHWCFG2;
  
  union {
    __IOM uint32_t reg;                         /*!< GHWCFG3                                                                   */
    
    struct {
      __IM  uint32_t XFERSIZEWIDTH : 4;         /*!< XFERSIZEWIDTH                                                             */
      __IM  uint32_t PKTSIZEWIDTH : 3;          /*!< PKTSIZEWIDTH                                                              */
      __IM  uint32_t OTGEN      : 1;            /*!< OTGEN                                                                     */
      __IM  uint32_t I2CINTSEL  : 1;            /*!< I2CINTSEL                                                                 */
      __IM  uint32_t VNDCTLSUPT : 1;            /*!< VNDCTLSUPT                                                                */
      __IM  uint32_t OPTFEATURE : 1;            /*!< OPTFEATURE                                                                */
      __IM  uint32_t RSTTYPE    : 1;            /*!< RSTTYPE                                                                   */
      __IM  uint32_t ADPSUPPORT : 1;            /*!< ADPSUPPORT                                                                */
      __IM  uint32_t HSICMODE   : 1;            /*!< HSICMODE                                                                  */
      __IM  uint32_t BCSUPPORT  : 1;            /*!< BCSUPPORT                                                                 */
      __IM  uint32_t LPMMODE    : 1;            /*!< LPMMODE                                                                   */
      __IM  uint32_t DFIFODEPTH : 16;           /*!< DFIFODEPTH                                                                */
    } bit;
  } GHWCFG3;
  
  union {
    __IOM uint32_t reg;                         /*!< GHWCFG4                                                                   */
    
    struct {
      __IM  uint32_t G_NUMDEVPERIOEPS : 4;      /*!< G_NUMDEVPERIOEPS                                                          */
      __IM  uint32_t G_PARTIALPWRDN : 1;        /*!< G_PARTIALPWRDN                                                            */
      __IM  uint32_t G_AHBFREQ  : 1;            /*!< G_AHBFREQ                                                                 */
      __IM  uint32_t G_HIBERNATION : 1;         /*!< G_HIBERNATION                                                             */
      __IM  uint32_t G_EXTENDEDHIBERNATION : 1; /*!< G_EXTENDEDHIBERNATION                                                     */
            uint32_t            : 4;
      __IM  uint32_t G_ACGSUPT  : 1;            /*!< G_ACGSUPT                                                                 */
      __IM  uint32_t G_ENHANCEDLPMSUPT : 1;     /*!< G_ENHANCEDLPMSUPT                                                         */
      __IM  uint32_t G_PHYDATAWIDTH : 2;        /*!< G_PHYDATAWIDTH                                                            */
      __IM  uint32_t G_NUMCTLEPS : 4;           /*!< G_NUMCTLEPS                                                               */
      __IM  uint32_t G_IDDQFLTR : 1;            /*!< G_IDDQFLTR                                                                */
      __IM  uint32_t G_VBUSVALIDFLTR : 1;       /*!< G_VBUSVALIDFLTR                                                           */
      __IM  uint32_t G_AVALIDFLTR : 1;          /*!< G_AVALIDFLTR                                                              */
      __IM  uint32_t G_BVALIDFLTR : 1;          /*!< G_BVALIDFLTR                                                              */
      __IM  uint32_t G_SESSENDFLTR : 1;         /*!< G_SESSENDFLTR                                                             */
      __IM  uint32_t G_DEDFIFOMODE : 1;         /*!< G_DEDFIFOMODE                                                             */
      __IM  uint32_t G_INEPS    : 4;            /*!< G_INEPS                                                                   */
      __IM  uint32_t G_DESCDMAENABLED : 1;      /*!< G_DESCDMAENABLED                                                          */
      __IM  uint32_t G_DESCDMA  : 1;            /*!< G_DESCDMA                                                                 */
    } bit;
  } GHWCFG4;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t reg;                         /*!< GDFIFOCFG                                                                 */
    
    struct {
      __IOM uint32_t GDFIFOCFG  : 16;           /*!< GDFIFOCFG                                                                 */
      __IOM uint32_t EPINFOBASEADDR : 16;       /*!< EPINFOBASEADDR                                                            */
    } bit;
  } GDFIFOCFG;
  __IM  uint32_t  RESERVED2[40];
  
  union {
    __IOM uint32_t reg;                         /*!< HPTXFSIZ                                                                  */
    
    struct {
      __IOM uint32_t PTXFSTADDR : 16;           /*!< PTXFSTADDR                                                                */
      __IOM uint32_t PTXFSIZE   : 16;           /*!< PTXFSIZE                                                                  */
    } bit;
  } HPTXFSIZ;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTXF1                                                                  */
    
    struct {
      __IOM uint32_t INEP1TXFSTADDR : 16;       /*!< INEP1TXFSTADDR                                                            */
      __IOM uint32_t INEP1TXFDEP : 16;          /*!< INEP1TXFDEP                                                               */
    } bit;
  } DIEPTXF1;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTXF2                                                                  */
    
    struct {
      __IOM uint32_t INEP2TXFSTADDR : 16;       /*!< INEP2TXFSTADDR                                                            */
      __IOM uint32_t INEP2TXFDEP : 16;          /*!< INEP2TXFDEP                                                               */
    } bit;
  } DIEPTXF2;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTXF3                                                                  */
    
    struct {
      __IOM uint32_t INEP3TXFSTADDR : 16;       /*!< INEP3TXFSTADDR                                                            */
      __IOM uint32_t INEP3TXFDEP : 16;          /*!< INEP3TXFDEP                                                               */
    } bit;
  } DIEPTXF3;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTXF4                                                                  */
    
    struct {
      __IOM uint32_t INEP4TXFSTADDR : 16;       /*!< INEP4TXFSTADDR                                                            */
      __IOM uint32_t INEP4TXFDEP : 16;          /*!< INEP4TXFDEP                                                               */
    } bit;
  } DIEPTXF4;
  __IM  uint32_t  RESERVED3[187];
  
  union {
    __IOM uint32_t reg;                         /*!< HCFG                                                                      */
    
    struct {
      __IOM uint32_t H_FSLSPCLKSEL : 2;         /*!< H_FSLSPCLKSEL                                                             */
      __IOM uint32_t H_FSLSSUPP : 1;            /*!< H_FSLSSUPP                                                                */
            uint32_t            : 4;
      __IOM uint32_t H_ENA32KHZS : 1;           /*!< H_ENA32KHZS                                                               */
            uint32_t            : 15;
      __IOM uint32_t H_DESCDMA  : 1;            /*!< H_DESCDMA                                                                 */
      __IOM uint32_t H_FRLISTEN : 2;            /*!< H_FRLISTEN                                                                */
      __IOM uint32_t H_PERSCHEDENA : 1;         /*!< H_PERSCHEDENA                                                             */
            uint32_t            : 4;
      __IOM uint32_t H_MODECHTIMEN : 1;         /*!< H_MODECHTIMEN                                                             */
    } bit;
  } HCFG;
  
  union {
    __IOM uint32_t reg;                         /*!< HFIR                                                                      */
    
    struct {
      __IOM uint32_t FRINT      : 16;           /*!< FRINT                                                                     */
      __IOM uint32_t HFIRRLDCTRL : 1;           /*!< HFIRRLDCTRL                                                               */
            uint32_t            : 15;
    } bit;
  } HFIR;
  
  union {
    __IOM uint32_t reg;                         /*!< HFNUM                                                                     */
    
    struct {
      __IM  uint32_t FRNUM      : 14;           /*!< FRNUM                                                                     */
            uint32_t            : 2;
      __IM  uint32_t FRREM      : 16;           /*!< FRREM                                                                     */
    } bit;
  } HFNUM;
  __IM  uint32_t  RESERVED4;
  
  union {
    __IOM uint32_t reg;                         /*!< HPTXSTS                                                                   */
    
    struct {
      __IM  uint32_t PTXFSPCAVAIL : 16;         /*!< PTXFSPCAVAIL                                                              */
      __IM  uint32_t PTXQSPCAVAIL : 5;          /*!< PTXQSPCAVAIL                                                              */
            uint32_t            : 3;
      __IM  uint32_t PTXQTOP    : 8;            /*!< PTXQTOP                                                                   */
    } bit;
  } HPTXSTS;
  
  union {
    __IOM uint32_t reg;                         /*!< HAINT                                                                     */
    
    struct {
      __IM  uint32_t HAINT      : 8;            /*!< HAINT                                                                     */
            uint32_t            : 24;
    } bit;
  } HAINT;
  
  union {
    __IOM uint32_t reg;                         /*!< HAINTMSK                                                                  */
    
    struct {
      __IOM uint32_t HAINTMSK   : 8;            /*!< HAINTMSK                                                                  */
            uint32_t            : 24;
    } bit;
  } HAINTMSK;
  
  union {
    __IOM uint32_t reg;                         /*!< HFLBADDR                                                                  */
    
    struct {
      __IOM uint32_t HFLBADDR   : 32;           /*!< HFLBADDR                                                                  */
    } bit;
  } HFLBADDR;
  __IM  uint32_t  RESERVED5[8];
  
  union {
    __IOM uint32_t reg;                         /*!< HPRT                                                                      */
    
    struct {
      __IM  uint32_t PRTCONNSTS : 1;            /*!< PRTCONNSTS                                                                */
      __IOM uint32_t PRTCONNDET : 1;            /*!< PRTCONNDET                                                                */
      __IOM uint32_t PRTENA     : 1;            /*!< PRTENA                                                                    */
      __IOM uint32_t PRTENCHNG  : 1;            /*!< PRTENCHNG                                                                 */
      __IM  uint32_t PRTOVRCURRACT : 1;         /*!< PRTOVRCURRACT                                                             */
      __IOM uint32_t PRTOVRCURRCHNG : 1;        /*!< PRTOVRCURRCHNG                                                            */
      __IOM uint32_t PRTRES     : 1;            /*!< PRTRES                                                                    */
      __IOM uint32_t PRTSUSP    : 1;            /*!< PRTSUSP                                                                   */
      __IOM uint32_t PRTRST     : 1;            /*!< PRTRST                                                                    */
            uint32_t            : 1;
      __IM  uint32_t PRTLNSTS   : 2;            /*!< PRTLNSTS                                                                  */
      __IOM uint32_t PRTPWR     : 1;            /*!< PRTPWR                                                                    */
      __IOM uint32_t PRTTSTCTL  : 4;            /*!< PRTTSTCTL                                                                 */
      __IM  uint32_t PRTSPD     : 2;            /*!< PRTSPD                                                                    */
            uint32_t            : 13;
    } bit;
  } HPRT;
  __IM  uint32_t  RESERVED6[47];
  
  union {
    __IOM uint32_t reg;                         /*!< HCCHAR0                                                                   */
    
    struct {
      __IOM uint32_t H_MPS0     : 11;           /*!< H_MPS0                                                                    */
      __IOM uint32_t H_EPNUM0   : 4;            /*!< H_EPNUM0                                                                  */
      __IOM uint32_t H_EPDIR0   : 1;            /*!< H_EPDIR0                                                                  */
            uint32_t            : 1;
      __IOM uint32_t H_LSPDDEV0 : 1;            /*!< H_LSPDDEV0                                                                */
      __IOM uint32_t H_EPTYPE0  : 2;            /*!< H_EPTYPE0                                                                 */
            uint32_t            : 1;
      __IOM uint32_t H_EC0      : 1;            /*!< H_EC0                                                                     */
      __IOM uint32_t H_DEVADDR0 : 7;            /*!< H_DEVADDR0                                                                */
      __IOM uint32_t H_ODDFRM0  : 1;            /*!< H_ODDFRM0                                                                 */
      __IOM uint32_t H_CHDIS0   : 1;            /*!< H_CHDIS0                                                                  */
      __IOM uint32_t H_CHENA0   : 1;            /*!< H_CHENA0                                                                  */
    } bit;
  } HCCHAR0;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINT0                                                                    */
    
    struct {
      __IOM uint32_t H_XFERCOMPL0 : 1;          /*!< H_XFERCOMPL0                                                              */
      __IOM uint32_t H_CHHLTD0  : 1;            /*!< H_CHHLTD0                                                                 */
      __IOM uint32_t H_AHBERR0  : 1;            /*!< H_AHBERR0                                                                 */
      __IOM uint32_t H_STALL0   : 1;            /*!< H_STALL0                                                                  */
      __IOM uint32_t H_NACK0    : 1;            /*!< H_NACK0                                                                   */
      __IOM uint32_t H_ACK0     : 1;            /*!< H_ACK0                                                                    */
      __IOM uint32_t H_NYET0    : 1;            /*!< H_NYET0                                                                   */
      __IOM uint32_t H_XACTERR0 : 1;            /*!< H_XACTERR0                                                                */
      __IOM uint32_t H_BBLERR0  : 1;            /*!< H_BBLERR0                                                                 */
      __IOM uint32_t H_FRMOVRUN0 : 1;           /*!< H_FRMOVRUN0                                                               */
      __IOM uint32_t H_DATATGLERR0 : 1;         /*!< H_DATATGLERR0                                                             */
      __IOM uint32_t H_BNAINTR0 : 1;            /*!< H_BNAINTR0                                                                */
      __IOM uint32_t H_XCS_XACT_ERR0 : 1;       /*!< H_XCS_XACT_ERR0                                                           */
      __IOM uint32_t H_DESC_LST_ROLLINTR0 : 1;  /*!< H_DESC_LST_ROLLINTR0                                                      */
            uint32_t            : 18;
    } bit;
  } HCINT0;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINTMSK0                                                                 */
    
    struct {
      __IOM uint32_t H_XFERCOMPLMSK0 : 1;       /*!< H_XFERCOMPLMSK0                                                           */
      __IOM uint32_t H_CHHLTDMSK0 : 1;          /*!< H_CHHLTDMSK0                                                              */
      __IOM uint32_t H_AHBERRMSK0 : 1;          /*!< H_AHBERRMSK0                                                              */
      __IOM uint32_t H_STALLMSK0 : 1;           /*!< H_STALLMSK0                                                               */
      __IOM uint32_t H_NAKMSK0  : 1;            /*!< H_NAKMSK0                                                                 */
      __IOM uint32_t H_ACKMSK0  : 1;            /*!< H_ACKMSK0                                                                 */
      __IOM uint32_t H_NYETMSK0 : 1;            /*!< H_NYETMSK0                                                                */
      __IOM uint32_t H_XACTERRMSK0 : 1;         /*!< H_XACTERRMSK0                                                             */
      __IOM uint32_t H_BBLERRMSK0 : 1;          /*!< H_BBLERRMSK0                                                              */
      __IOM uint32_t H_FRMOVRUNMSK0 : 1;        /*!< H_FRMOVRUNMSK0                                                            */
      __IOM uint32_t H_DATATGLERRMSK0 : 1;      /*!< H_DATATGLERRMSK0                                                          */
      __IOM uint32_t H_BNAINTRMSK0 : 1;         /*!< H_BNAINTRMSK0                                                             */
            uint32_t            : 1;
      __IOM uint32_t H_DESC_LST_ROLLINTRMSK0 : 1;/*!< H_DESC_LST_ROLLINTRMSK0                                                  */
            uint32_t            : 18;
    } bit;
  } HCINTMSK0;
  
  union {
    __IOM uint32_t reg;                         /*!< HCTSIZ0                                                                   */
    
    struct {
      __IOM uint32_t H_XFERSIZE0 : 19;          /*!< H_XFERSIZE0                                                               */
      __IOM uint32_t H_PKTCNT0  : 10;           /*!< H_PKTCNT0                                                                 */
      __IOM uint32_t H_PID0     : 2;            /*!< H_PID0                                                                    */
      __IOM uint32_t H_DOPNG0   : 1;            /*!< H_DOPNG0                                                                  */
    } bit;
  } HCTSIZ0;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMA0                                                                    */
    
    struct {
      __IOM uint32_t H_DMAADDR0 : 32;           /*!< H_DMAADDR0                                                                */
    } bit;
  } HCDMA0;
  __IM  uint32_t  RESERVED8;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMAB0                                                                   */
    
    struct {
      __IM  uint32_t H_HCDMAB0  : 32;           /*!< H_HCDMAB0                                                                 */
    } bit;
  } HCDMAB0;
  
  union {
    __IOM uint32_t reg;                         /*!< HCCHAR1                                                                   */
    
    struct {
      __IOM uint32_t H_MPS1     : 11;           /*!< H_MPS1                                                                    */
      __IOM uint32_t H_EPNUM1   : 4;            /*!< H_EPNUM1                                                                  */
      __IOM uint32_t H_EPDIR1   : 1;            /*!< H_EPDIR1                                                                  */
            uint32_t            : 1;
      __IOM uint32_t H_LSPDDEV1 : 1;            /*!< H_LSPDDEV1                                                                */
      __IOM uint32_t H_EPTYPE1  : 2;            /*!< H_EPTYPE1                                                                 */
            uint32_t            : 1;
      __IOM uint32_t H_EC1      : 1;            /*!< H_EC1                                                                     */
      __IOM uint32_t H_DEVADDR1 : 7;            /*!< H_DEVADDR1                                                                */
      __IOM uint32_t H_ODDFRM1  : 1;            /*!< H_ODDFRM1                                                                 */
      __IOM uint32_t H_CHDIS1   : 1;            /*!< H_CHDIS1                                                                  */
      __IOM uint32_t H_CHENA1   : 1;            /*!< H_CHENA1                                                                  */
    } bit;
  } HCCHAR1;
  __IM  uint32_t  RESERVED9;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINT1                                                                    */
    
    struct {
      __IOM uint32_t H_XFERCOMPL1 : 1;          /*!< H_XFERCOMPL1                                                              */
      __IOM uint32_t H_CHHLTD1  : 1;            /*!< H_CHHLTD1                                                                 */
      __IOM uint32_t H_AHBERR1  : 1;            /*!< H_AHBERR1                                                                 */
      __IOM uint32_t H_STALL1   : 1;            /*!< H_STALL1                                                                  */
      __IOM uint32_t H_NACK1    : 1;            /*!< H_NACK1                                                                   */
      __IOM uint32_t H_ACK1     : 1;            /*!< H_ACK1                                                                    */
      __IOM uint32_t H_NYET1    : 1;            /*!< H_NYET1                                                                   */
      __IOM uint32_t H_XACTERR1 : 1;            /*!< H_XACTERR1                                                                */
      __IOM uint32_t H_BBLERR1  : 1;            /*!< H_BBLERR1                                                                 */
      __IOM uint32_t H_FRMOVRUN1 : 1;           /*!< H_FRMOVRUN1                                                               */
      __IOM uint32_t H_DATATGLERR1 : 1;         /*!< H_DATATGLERR1                                                             */
      __IOM uint32_t H_BNAINTR1 : 1;            /*!< H_BNAINTR1                                                                */
      __IOM uint32_t H_XCS_XACT_ERR1 : 1;       /*!< H_XCS_XACT_ERR1                                                           */
      __IOM uint32_t H_DESC_LST_ROLLINTR1 : 1;  /*!< H_DESC_LST_ROLLINTR1                                                      */
            uint32_t            : 18;
    } bit;
  } HCINT1;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINTMSK1                                                                 */
    
    struct {
      __IOM uint32_t H_XFERCOMPLMSK1 : 1;       /*!< H_XFERCOMPLMSK1                                                           */
      __IOM uint32_t H_CHHLTDMSK1 : 1;          /*!< H_CHHLTDMSK1                                                              */
      __IOM uint32_t H_AHBERRMSK1 : 1;          /*!< H_AHBERRMSK1                                                              */
      __IOM uint32_t H_STALLMSK1 : 1;           /*!< H_STALLMSK1                                                               */
      __IOM uint32_t H_NAKMSK1  : 1;            /*!< H_NAKMSK1                                                                 */
      __IOM uint32_t H_ACKMSK1  : 1;            /*!< H_ACKMSK1                                                                 */
      __IOM uint32_t H_NYETMSK1 : 1;            /*!< H_NYETMSK1                                                                */
      __IOM uint32_t H_XACTERRMSK1 : 1;         /*!< H_XACTERRMSK1                                                             */
      __IOM uint32_t H_BBLERRMSK1 : 1;          /*!< H_BBLERRMSK1                                                              */
      __IOM uint32_t H_FRMOVRUNMSK1 : 1;        /*!< H_FRMOVRUNMSK1                                                            */
      __IOM uint32_t H_DATATGLERRMSK1 : 1;      /*!< H_DATATGLERRMSK1                                                          */
      __IOM uint32_t H_BNAINTRMSK1 : 1;         /*!< H_BNAINTRMSK1                                                             */
            uint32_t            : 1;
      __IOM uint32_t H_DESC_LST_ROLLINTRMSK1 : 1;/*!< H_DESC_LST_ROLLINTRMSK1                                                  */
            uint32_t            : 18;
    } bit;
  } HCINTMSK1;
  
  union {
    __IOM uint32_t reg;                         /*!< HCTSIZ1                                                                   */
    
    struct {
      __IOM uint32_t H_XFERSIZE1 : 19;          /*!< H_XFERSIZE1                                                               */
      __IOM uint32_t H_PKTCNT1  : 10;           /*!< H_PKTCNT1                                                                 */
      __IOM uint32_t H_PID1     : 2;            /*!< H_PID1                                                                    */
      __IOM uint32_t H_DOPNG1   : 1;            /*!< H_DOPNG1                                                                  */
    } bit;
  } HCTSIZ1;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMA1                                                                    */
    
    struct {
      __IOM uint32_t H_DMAADDR1 : 32;           /*!< H_DMAADDR1                                                                */
    } bit;
  } HCDMA1;
  __IM  uint32_t  RESERVED10;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMAB1                                                                   */
    
    struct {
      __IM  uint32_t H_HCDMAB1  : 32;           /*!< H_HCDMAB1                                                                 */
    } bit;
  } HCDMAB1;
  
  union {
    __IOM uint32_t reg;                         /*!< HCCHAR2                                                                   */
    
    struct {
      __IOM uint32_t H_MPS2     : 11;           /*!< H_MPS2                                                                    */
      __IOM uint32_t H_EPNUM2   : 4;            /*!< H_EPNUM2                                                                  */
      __IOM uint32_t H_EPDIR2   : 1;            /*!< H_EPDIR2                                                                  */
            uint32_t            : 1;
      __IOM uint32_t H_LSPDDEV2 : 1;            /*!< H_LSPDDEV2                                                                */
      __IOM uint32_t H_EPTYPE2  : 2;            /*!< H_EPTYPE2                                                                 */
            uint32_t            : 1;
      __IOM uint32_t H_EC2      : 1;            /*!< H_EC2                                                                     */
      __IOM uint32_t H_DEVADDR2 : 7;            /*!< H_DEVADDR2                                                                */
      __IOM uint32_t H_ODDFRM2  : 1;            /*!< H_ODDFRM2                                                                 */
      __IOM uint32_t H_CHDIS2   : 1;            /*!< H_CHDIS2                                                                  */
      __IOM uint32_t H_CHENA2   : 1;            /*!< H_CHENA2                                                                  */
    } bit;
  } HCCHAR2;
  __IM  uint32_t  RESERVED11;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINT2                                                                    */
    
    struct {
      __IOM uint32_t H_XFERCOMPL2 : 1;          /*!< H_XFERCOMPL2                                                              */
      __IOM uint32_t H_CHHLTD2  : 1;            /*!< H_CHHLTD2                                                                 */
      __IOM uint32_t H_AHBERR2  : 1;            /*!< H_AHBERR2                                                                 */
      __IOM uint32_t H_STALL2   : 1;            /*!< H_STALL2                                                                  */
      __IOM uint32_t H_NACK2    : 1;            /*!< H_NACK2                                                                   */
      __IOM uint32_t H_ACK2     : 1;            /*!< H_ACK2                                                                    */
      __IOM uint32_t H_NYET2    : 1;            /*!< H_NYET2                                                                   */
      __IOM uint32_t H_XACTERR2 : 1;            /*!< H_XACTERR2                                                                */
      __IOM uint32_t H_BBLERR2  : 1;            /*!< H_BBLERR2                                                                 */
      __IOM uint32_t H_FRMOVRUN2 : 1;           /*!< H_FRMOVRUN2                                                               */
      __IOM uint32_t H_DATATGLERR2 : 1;         /*!< H_DATATGLERR2                                                             */
      __IOM uint32_t H_BNAINTR2 : 1;            /*!< H_BNAINTR2                                                                */
      __IOM uint32_t H_XCS_XACT_ERR2 : 1;       /*!< H_XCS_XACT_ERR2                                                           */
      __IOM uint32_t H_DESC_LST_ROLLINTR2 : 1;  /*!< H_DESC_LST_ROLLINTR2                                                      */
            uint32_t            : 18;
    } bit;
  } HCINT2;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINTMSK2                                                                 */
    
    struct {
      __IOM uint32_t H_XFERCOMPLMSK2 : 1;       /*!< H_XFERCOMPLMSK2                                                           */
      __IOM uint32_t H_CHHLTDMSK2 : 1;          /*!< H_CHHLTDMSK2                                                              */
      __IOM uint32_t H_AHBERRMSK2 : 1;          /*!< H_AHBERRMSK2                                                              */
      __IOM uint32_t H_STALLMSK2 : 1;           /*!< H_STALLMSK2                                                               */
      __IOM uint32_t H_NAKMSK2  : 1;            /*!< H_NAKMSK2                                                                 */
      __IOM uint32_t H_ACKMSK2  : 1;            /*!< H_ACKMSK2                                                                 */
      __IOM uint32_t H_NYETMSK2 : 1;            /*!< H_NYETMSK2                                                                */
      __IOM uint32_t H_XACTERRMSK2 : 1;         /*!< H_XACTERRMSK2                                                             */
      __IOM uint32_t H_BBLERRMSK2 : 1;          /*!< H_BBLERRMSK2                                                              */
      __IOM uint32_t H_FRMOVRUNMSK2 : 1;        /*!< H_FRMOVRUNMSK2                                                            */
      __IOM uint32_t H_DATATGLERRMSK2 : 1;      /*!< H_DATATGLERRMSK2                                                          */
      __IOM uint32_t H_BNAINTRMSK2 : 1;         /*!< H_BNAINTRMSK2                                                             */
            uint32_t            : 1;
      __IOM uint32_t H_DESC_LST_ROLLINTRMSK2 : 1;/*!< H_DESC_LST_ROLLINTRMSK2                                                  */
            uint32_t            : 18;
    } bit;
  } HCINTMSK2;
  
  union {
    __IOM uint32_t reg;                         /*!< HCTSIZ2                                                                   */
    
    struct {
      __IOM uint32_t H_XFERSIZE2 : 19;          /*!< H_XFERSIZE2                                                               */
      __IOM uint32_t H_PKTCNT2  : 10;           /*!< H_PKTCNT2                                                                 */
      __IOM uint32_t H_PID2     : 2;            /*!< H_PID2                                                                    */
      __IOM uint32_t H_DOPNG2   : 1;            /*!< H_DOPNG2                                                                  */
    } bit;
  } HCTSIZ2;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMA2                                                                    */
    
    struct {
      __IOM uint32_t H_DMAADDR2 : 32;           /*!< H_DMAADDR2                                                                */
    } bit;
  } HCDMA2;
  __IM  uint32_t  RESERVED12;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMAB2                                                                   */
    
    struct {
      __IM  uint32_t H_HCDMAB2  : 32;           /*!< H_HCDMAB2                                                                 */
    } bit;
  } HCDMAB2;
  
  union {
    __IOM uint32_t reg;                         /*!< HCCHAR3                                                                   */
    
    struct {
      __IOM uint32_t H_MPS3     : 11;           /*!< H_MPS3                                                                    */
      __IOM uint32_t H_EPNUM3   : 4;            /*!< H_EPNUM3                                                                  */
      __IOM uint32_t H_EPDIR3   : 1;            /*!< H_EPDIR3                                                                  */
            uint32_t            : 1;
      __IOM uint32_t H_LSPDDEV3 : 1;            /*!< H_LSPDDEV3                                                                */
      __IOM uint32_t H_EPTYPE3  : 2;            /*!< H_EPTYPE3                                                                 */
            uint32_t            : 1;
      __IOM uint32_t H_EC3      : 1;            /*!< H_EC3                                                                     */
      __IOM uint32_t H_DEVADDR3 : 7;            /*!< H_DEVADDR3                                                                */
      __IOM uint32_t H_ODDFRM3  : 1;            /*!< H_ODDFRM3                                                                 */
      __IOM uint32_t H_CHDIS3   : 1;            /*!< H_CHDIS3                                                                  */
      __IOM uint32_t H_CHENA3   : 1;            /*!< H_CHENA3                                                                  */
    } bit;
  } HCCHAR3;
  __IM  uint32_t  RESERVED13;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINT3                                                                    */
    
    struct {
      __IOM uint32_t H_XFERCOMPL3 : 1;          /*!< H_XFERCOMPL3                                                              */
      __IOM uint32_t H_CHHLTD3  : 1;            /*!< H_CHHLTD3                                                                 */
      __IOM uint32_t H_AHBERR3  : 1;            /*!< H_AHBERR3                                                                 */
      __IOM uint32_t H_STALL3   : 1;            /*!< H_STALL3                                                                  */
      __IOM uint32_t H_NACK3    : 1;            /*!< H_NACK3                                                                   */
      __IOM uint32_t H_ACK3     : 1;            /*!< H_ACK3                                                                    */
      __IOM uint32_t H_NYET3    : 1;            /*!< H_NYET3                                                                   */
      __IOM uint32_t H_XACTERR3 : 1;            /*!< H_XACTERR3                                                                */
      __IOM uint32_t H_BBLERR3  : 1;            /*!< H_BBLERR3                                                                 */
      __IOM uint32_t H_FRMOVRUN3 : 1;           /*!< H_FRMOVRUN3                                                               */
      __IOM uint32_t H_DATATGLERR3 : 1;         /*!< H_DATATGLERR3                                                             */
      __IOM uint32_t H_BNAINTR3 : 1;            /*!< H_BNAINTR3                                                                */
      __IOM uint32_t H_XCS_XACT_ERR3 : 1;       /*!< H_XCS_XACT_ERR3                                                           */
      __IOM uint32_t H_DESC_LST_ROLLINTR3 : 1;  /*!< H_DESC_LST_ROLLINTR3                                                      */
            uint32_t            : 18;
    } bit;
  } HCINT3;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINTMSK3                                                                 */
    
    struct {
      __IOM uint32_t H_XFERCOMPLMSK3 : 1;       /*!< H_XFERCOMPLMSK3                                                           */
      __IOM uint32_t H_CHHLTDMSK3 : 1;          /*!< H_CHHLTDMSK3                                                              */
      __IOM uint32_t H_AHBERRMSK3 : 1;          /*!< H_AHBERRMSK3                                                              */
      __IOM uint32_t H_STALLMSK3 : 1;           /*!< H_STALLMSK3                                                               */
      __IOM uint32_t H_NAKMSK3  : 1;            /*!< H_NAKMSK3                                                                 */
      __IOM uint32_t H_ACKMSK3  : 1;            /*!< H_ACKMSK3                                                                 */
      __IOM uint32_t H_NYETMSK3 : 1;            /*!< H_NYETMSK3                                                                */
      __IOM uint32_t H_XACTERRMSK3 : 1;         /*!< H_XACTERRMSK3                                                             */
      __IOM uint32_t H_BBLERRMSK3 : 1;          /*!< H_BBLERRMSK3                                                              */
      __IOM uint32_t H_FRMOVRUNMSK3 : 1;        /*!< H_FRMOVRUNMSK3                                                            */
      __IOM uint32_t H_DATATGLERRMSK3 : 1;      /*!< H_DATATGLERRMSK3                                                          */
      __IOM uint32_t H_BNAINTRMSK3 : 1;         /*!< H_BNAINTRMSK3                                                             */
            uint32_t            : 1;
      __IOM uint32_t H_DESC_LST_ROLLINTRMSK3 : 1;/*!< H_DESC_LST_ROLLINTRMSK3                                                  */
            uint32_t            : 18;
    } bit;
  } HCINTMSK3;
  
  union {
    __IOM uint32_t reg;                         /*!< HCTSIZ3                                                                   */
    
    struct {
      __IOM uint32_t H_XFERSIZE3 : 19;          /*!< H_XFERSIZE3                                                               */
      __IOM uint32_t H_PKTCNT3  : 10;           /*!< H_PKTCNT3                                                                 */
      __IOM uint32_t H_PID3     : 2;            /*!< H_PID3                                                                    */
      __IOM uint32_t H_DOPNG3   : 1;            /*!< H_DOPNG3                                                                  */
    } bit;
  } HCTSIZ3;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMA3                                                                    */
    
    struct {
      __IOM uint32_t H_DMAADDR3 : 32;           /*!< H_DMAADDR3                                                                */
    } bit;
  } HCDMA3;
  __IM  uint32_t  RESERVED14;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMAB3                                                                   */
    
    struct {
      __IM  uint32_t H_HCDMAB3  : 32;           /*!< H_HCDMAB3                                                                 */
    } bit;
  } HCDMAB3;
  
  union {
    __IOM uint32_t reg;                         /*!< HCCHAR4                                                                   */
    
    struct {
      __IOM uint32_t H_MPS4     : 11;           /*!< H_MPS4                                                                    */
      __IOM uint32_t H_EPNUM4   : 4;            /*!< H_EPNUM4                                                                  */
      __IOM uint32_t H_EPDIR4   : 1;            /*!< H_EPDIR4                                                                  */
            uint32_t            : 1;
      __IOM uint32_t H_LSPDDEV4 : 1;            /*!< H_LSPDDEV4                                                                */
      __IOM uint32_t H_EPTYPE4  : 2;            /*!< H_EPTYPE4                                                                 */
            uint32_t            : 1;
      __IOM uint32_t H_EC4      : 1;            /*!< H_EC4                                                                     */
      __IOM uint32_t H_DEVADDR4 : 7;            /*!< H_DEVADDR4                                                                */
      __IOM uint32_t H_ODDFRM4  : 1;            /*!< H_ODDFRM4                                                                 */
      __IOM uint32_t H_CHDIS4   : 1;            /*!< H_CHDIS4                                                                  */
      __IOM uint32_t H_CHENA4   : 1;            /*!< H_CHENA4                                                                  */
    } bit;
  } HCCHAR4;
  __IM  uint32_t  RESERVED15;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINT4                                                                    */
    
    struct {
      __IOM uint32_t H_XFERCOMPL4 : 1;          /*!< H_XFERCOMPL4                                                              */
      __IOM uint32_t H_CHHLTD4  : 1;            /*!< H_CHHLTD4                                                                 */
      __IOM uint32_t H_AHBERR4  : 1;            /*!< H_AHBERR4                                                                 */
      __IOM uint32_t H_STALL4   : 1;            /*!< H_STALL4                                                                  */
      __IOM uint32_t H_NACK4    : 1;            /*!< H_NACK4                                                                   */
      __IOM uint32_t H_ACK4     : 1;            /*!< H_ACK4                                                                    */
      __IOM uint32_t H_NYET4    : 1;            /*!< H_NYET4                                                                   */
      __IOM uint32_t H_XACTERR4 : 1;            /*!< H_XACTERR4                                                                */
      __IOM uint32_t H_BBLERR4  : 1;            /*!< H_BBLERR4                                                                 */
      __IOM uint32_t H_FRMOVRUN4 : 1;           /*!< H_FRMOVRUN4                                                               */
      __IOM uint32_t H_DATATGLERR4 : 1;         /*!< H_DATATGLERR4                                                             */
      __IOM uint32_t H_BNAINTR4 : 1;            /*!< H_BNAINTR4                                                                */
      __IOM uint32_t H_XCS_XACT_ERR4 : 1;       /*!< H_XCS_XACT_ERR4                                                           */
      __IOM uint32_t H_DESC_LST_ROLLINTR4 : 1;  /*!< H_DESC_LST_ROLLINTR4                                                      */
            uint32_t            : 18;
    } bit;
  } HCINT4;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINTMSK4                                                                 */
    
    struct {
      __IOM uint32_t H_XFERCOMPLMSK4 : 1;       /*!< H_XFERCOMPLMSK4                                                           */
      __IOM uint32_t H_CHHLTDMSK4 : 1;          /*!< H_CHHLTDMSK4                                                              */
      __IOM uint32_t H_AHBERRMSK4 : 1;          /*!< H_AHBERRMSK4                                                              */
      __IOM uint32_t H_STALLMSK4 : 1;           /*!< H_STALLMSK4                                                               */
      __IOM uint32_t H_NAKMSK4  : 1;            /*!< H_NAKMSK4                                                                 */
      __IOM uint32_t H_ACKMSK4  : 1;            /*!< H_ACKMSK4                                                                 */
      __IOM uint32_t H_NYETMSK4 : 1;            /*!< H_NYETMSK4                                                                */
      __IOM uint32_t H_XACTERRMSK4 : 1;         /*!< H_XACTERRMSK4                                                             */
      __IOM uint32_t H_BBLERRMSK4 : 1;          /*!< H_BBLERRMSK4                                                              */
      __IOM uint32_t H_FRMOVRUNMSK4 : 1;        /*!< H_FRMOVRUNMSK4                                                            */
      __IOM uint32_t H_DATATGLERRMSK4 : 1;      /*!< H_DATATGLERRMSK4                                                          */
      __IOM uint32_t H_BNAINTRMSK4 : 1;         /*!< H_BNAINTRMSK4                                                             */
            uint32_t            : 1;
      __IOM uint32_t H_DESC_LST_ROLLINTRMSK4 : 1;/*!< H_DESC_LST_ROLLINTRMSK4                                                  */
            uint32_t            : 18;
    } bit;
  } HCINTMSK4;
  
  union {
    __IOM uint32_t reg;                         /*!< HCTSIZ4                                                                   */
    
    struct {
      __IOM uint32_t H_XFERSIZE4 : 19;          /*!< H_XFERSIZE4                                                               */
      __IOM uint32_t H_PKTCNT4  : 10;           /*!< H_PKTCNT4                                                                 */
      __IOM uint32_t H_PID4     : 2;            /*!< H_PID4                                                                    */
      __IOM uint32_t H_DOPNG4   : 1;            /*!< H_DOPNG4                                                                  */
    } bit;
  } HCTSIZ4;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMA4                                                                    */
    
    struct {
      __IOM uint32_t H_DMAADDR4 : 32;           /*!< H_DMAADDR4                                                                */
    } bit;
  } HCDMA4;
  __IM  uint32_t  RESERVED16;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMAB4                                                                   */
    
    struct {
      __IM  uint32_t H_HCDMAB4  : 32;           /*!< H_HCDMAB4                                                                 */
    } bit;
  } HCDMAB4;
  
  union {
    __IOM uint32_t reg;                         /*!< HCCHAR5                                                                   */
    
    struct {
      __IOM uint32_t H_MPS5     : 11;           /*!< H_MPS5                                                                    */
      __IOM uint32_t H_EPNUM5   : 4;            /*!< H_EPNUM5                                                                  */
      __IOM uint32_t H_EPDIR5   : 1;            /*!< H_EPDIR5                                                                  */
            uint32_t            : 1;
      __IOM uint32_t H_LSPDDEV5 : 1;            /*!< H_LSPDDEV5                                                                */
      __IOM uint32_t H_EPTYPE5  : 2;            /*!< H_EPTYPE5                                                                 */
            uint32_t            : 1;
      __IOM uint32_t H_EC5      : 1;            /*!< H_EC5                                                                     */
      __IOM uint32_t H_DEVADDR5 : 7;            /*!< H_DEVADDR5                                                                */
      __IOM uint32_t H_ODDFRM5  : 1;            /*!< H_ODDFRM5                                                                 */
      __IOM uint32_t H_CHDIS5   : 1;            /*!< H_CHDIS5                                                                  */
      __IOM uint32_t H_CHENA5   : 1;            /*!< H_CHENA5                                                                  */
    } bit;
  } HCCHAR5;
  __IM  uint32_t  RESERVED17;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINT5                                                                    */
    
    struct {
      __IOM uint32_t H_XFERCOMPL5 : 1;          /*!< H_XFERCOMPL5                                                              */
      __IOM uint32_t H_CHHLTD5  : 1;            /*!< H_CHHLTD5                                                                 */
      __IOM uint32_t H_AHBERR5  : 1;            /*!< H_AHBERR5                                                                 */
      __IOM uint32_t H_STALL5   : 1;            /*!< H_STALL5                                                                  */
      __IOM uint32_t H_NACK5    : 1;            /*!< H_NACK5                                                                   */
      __IOM uint32_t H_ACK5     : 1;            /*!< H_ACK5                                                                    */
      __IOM uint32_t H_NYET5    : 1;            /*!< H_NYET5                                                                   */
      __IOM uint32_t H_XACTERR5 : 1;            /*!< H_XACTERR5                                                                */
      __IOM uint32_t H_BBLERR5  : 1;            /*!< H_BBLERR5                                                                 */
      __IOM uint32_t H_FRMOVRUN5 : 1;           /*!< H_FRMOVRUN5                                                               */
      __IOM uint32_t H_DATATGLERR5 : 1;         /*!< H_DATATGLERR5                                                             */
      __IOM uint32_t H_BNAINTR5 : 1;            /*!< H_BNAINTR5                                                                */
      __IOM uint32_t H_XCS_XACT_ERR5 : 1;       /*!< H_XCS_XACT_ERR5                                                           */
      __IOM uint32_t H_DESC_LST_ROLLINTR5 : 1;  /*!< H_DESC_LST_ROLLINTR5                                                      */
            uint32_t            : 18;
    } bit;
  } HCINT5;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINTMSK5                                                                 */
    
    struct {
      __IOM uint32_t H_XFERCOMPLMSK5 : 1;       /*!< H_XFERCOMPLMSK5                                                           */
      __IOM uint32_t H_CHHLTDMSK5 : 1;          /*!< H_CHHLTDMSK5                                                              */
      __IOM uint32_t H_AHBERRMSK5 : 1;          /*!< H_AHBERRMSK5                                                              */
      __IOM uint32_t H_STALLMSK5 : 1;           /*!< H_STALLMSK5                                                               */
      __IOM uint32_t H_NAKMSK5  : 1;            /*!< H_NAKMSK5                                                                 */
      __IOM uint32_t H_ACKMSK5  : 1;            /*!< H_ACKMSK5                                                                 */
      __IOM uint32_t H_NYETMSK5 : 1;            /*!< H_NYETMSK5                                                                */
      __IOM uint32_t H_XACTERRMSK5 : 1;         /*!< H_XACTERRMSK5                                                             */
      __IOM uint32_t H_BBLERRMSK5 : 1;          /*!< H_BBLERRMSK5                                                              */
      __IOM uint32_t H_FRMOVRUNMSK5 : 1;        /*!< H_FRMOVRUNMSK5                                                            */
      __IOM uint32_t H_DATATGLERRMSK5 : 1;      /*!< H_DATATGLERRMSK5                                                          */
      __IOM uint32_t H_BNAINTRMSK5 : 1;         /*!< H_BNAINTRMSK5                                                             */
            uint32_t            : 1;
      __IOM uint32_t H_DESC_LST_ROLLINTRMSK5 : 1;/*!< H_DESC_LST_ROLLINTRMSK5                                                  */
            uint32_t            : 18;
    } bit;
  } HCINTMSK5;
  
  union {
    __IOM uint32_t reg;                         /*!< HCTSIZ5                                                                   */
    
    struct {
      __IOM uint32_t H_XFERSIZE5 : 19;          /*!< H_XFERSIZE5                                                               */
      __IOM uint32_t H_PKTCNT5  : 10;           /*!< H_PKTCNT5                                                                 */
      __IOM uint32_t H_PID5     : 2;            /*!< H_PID5                                                                    */
      __IOM uint32_t H_DOPNG5   : 1;            /*!< H_DOPNG5                                                                  */
    } bit;
  } HCTSIZ5;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMA5                                                                    */
    
    struct {
      __IOM uint32_t H_DMAADDR5 : 32;           /*!< H_DMAADDR5                                                                */
    } bit;
  } HCDMA5;
  __IM  uint32_t  RESERVED18;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMAB5                                                                   */
    
    struct {
      __IM  uint32_t H_HCDMAB5  : 32;           /*!< H_HCDMAB5                                                                 */
    } bit;
  } HCDMAB5;
  
  union {
    __IOM uint32_t reg;                         /*!< HCCHAR6                                                                   */
    
    struct {
      __IOM uint32_t H_MPS6     : 11;           /*!< H_MPS6                                                                    */
      __IOM uint32_t H_EPNUM6   : 4;            /*!< H_EPNUM6                                                                  */
      __IOM uint32_t H_EPDIR6   : 1;            /*!< H_EPDIR6                                                                  */
            uint32_t            : 1;
      __IOM uint32_t H_LSPDDEV6 : 1;            /*!< H_LSPDDEV6                                                                */
      __IOM uint32_t H_EPTYPE6  : 2;            /*!< H_EPTYPE6                                                                 */
            uint32_t            : 1;
      __IOM uint32_t H_EC6      : 1;            /*!< H_EC6                                                                     */
      __IOM uint32_t H_DEVADDR6 : 7;            /*!< H_DEVADDR6                                                                */
      __IOM uint32_t H_ODDFRM6  : 1;            /*!< H_ODDFRM6                                                                 */
      __IOM uint32_t H_CHDIS6   : 1;            /*!< H_CHDIS6                                                                  */
      __IOM uint32_t H_CHENA6   : 1;            /*!< H_CHENA6                                                                  */
    } bit;
  } HCCHAR6;
  __IM  uint32_t  RESERVED19;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINT6                                                                    */
    
    struct {
      __IOM uint32_t H_XFERCOMPL6 : 1;          /*!< H_XFERCOMPL6                                                              */
      __IOM uint32_t H_CHHLTD6  : 1;            /*!< H_CHHLTD6                                                                 */
      __IOM uint32_t H_AHBERR6  : 1;            /*!< H_AHBERR6                                                                 */
      __IOM uint32_t H_STALL6   : 1;            /*!< H_STALL6                                                                  */
      __IOM uint32_t H_NACK6    : 1;            /*!< H_NACK6                                                                   */
      __IOM uint32_t H_ACK6     : 1;            /*!< H_ACK6                                                                    */
      __IOM uint32_t H_NYET6    : 1;            /*!< H_NYET6                                                                   */
      __IOM uint32_t H_XACTERR6 : 1;            /*!< H_XACTERR6                                                                */
      __IOM uint32_t H_BBLERR6  : 1;            /*!< H_BBLERR6                                                                 */
      __IOM uint32_t H_FRMOVRUN6 : 1;           /*!< H_FRMOVRUN6                                                               */
      __IOM uint32_t H_DATATGLERR6 : 1;         /*!< H_DATATGLERR6                                                             */
      __IOM uint32_t H_BNAINTR6 : 1;            /*!< H_BNAINTR6                                                                */
      __IOM uint32_t H_XCS_XACT_ERR6 : 1;       /*!< H_XCS_XACT_ERR6                                                           */
      __IOM uint32_t H_DESC_LST_ROLLINTR6 : 1;  /*!< H_DESC_LST_ROLLINTR6                                                      */
            uint32_t            : 18;
    } bit;
  } HCINT6;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINTMSK6                                                                 */
    
    struct {
      __IOM uint32_t H_XFERCOMPLMSK6 : 1;       /*!< H_XFERCOMPLMSK6                                                           */
      __IOM uint32_t H_CHHLTDMSK6 : 1;          /*!< H_CHHLTDMSK6                                                              */
      __IOM uint32_t H_AHBERRMSK6 : 1;          /*!< H_AHBERRMSK6                                                              */
      __IOM uint32_t H_STALLMSK6 : 1;           /*!< H_STALLMSK6                                                               */
      __IOM uint32_t H_NAKMSK6  : 1;            /*!< H_NAKMSK6                                                                 */
      __IOM uint32_t H_ACKMSK6  : 1;            /*!< H_ACKMSK6                                                                 */
      __IOM uint32_t H_NYETMSK6 : 1;            /*!< H_NYETMSK6                                                                */
      __IOM uint32_t H_XACTERRMSK6 : 1;         /*!< H_XACTERRMSK6                                                             */
      __IOM uint32_t H_BBLERRMSK6 : 1;          /*!< H_BBLERRMSK6                                                              */
      __IOM uint32_t H_FRMOVRUNMSK6 : 1;        /*!< H_FRMOVRUNMSK6                                                            */
      __IOM uint32_t H_DATATGLERRMSK6 : 1;      /*!< H_DATATGLERRMSK6                                                          */
      __IOM uint32_t H_BNAINTRMSK6 : 1;         /*!< H_BNAINTRMSK6                                                             */
            uint32_t            : 1;
      __IOM uint32_t H_DESC_LST_ROLLINTRMSK6 : 1;/*!< H_DESC_LST_ROLLINTRMSK6                                                  */
            uint32_t            : 18;
    } bit;
  } HCINTMSK6;
  
  union {
    __IOM uint32_t reg;                         /*!< HCTSIZ6                                                                   */
    
    struct {
      __IOM uint32_t H_XFERSIZE6 : 19;          /*!< H_XFERSIZE6                                                               */
      __IOM uint32_t H_PKTCNT6  : 10;           /*!< H_PKTCNT6                                                                 */
      __IOM uint32_t H_PID6     : 2;            /*!< H_PID6                                                                    */
      __IOM uint32_t H_DOPNG6   : 1;            /*!< H_DOPNG6                                                                  */
    } bit;
  } HCTSIZ6;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMA6                                                                    */
    
    struct {
      __IOM uint32_t H_DMAADDR6 : 32;           /*!< H_DMAADDR6                                                                */
    } bit;
  } HCDMA6;
  __IM  uint32_t  RESERVED20;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMAB6                                                                   */
    
    struct {
      __IM  uint32_t H_HCDMAB6  : 32;           /*!< H_HCDMAB6                                                                 */
    } bit;
  } HCDMAB6;
  
  union {
    __IOM uint32_t reg;                         /*!< HCCHAR7                                                                   */
    
    struct {
      __IOM uint32_t H_MPS7     : 11;           /*!< H_MPS7                                                                    */
      __IOM uint32_t H_EPNUM7   : 4;            /*!< H_EPNUM7                                                                  */
      __IOM uint32_t H_EPDIR7   : 1;            /*!< H_EPDIR7                                                                  */
            uint32_t            : 1;
      __IOM uint32_t H_LSPDDEV7 : 1;            /*!< H_LSPDDEV7                                                                */
      __IOM uint32_t H_EPTYPE7  : 2;            /*!< H_EPTYPE7                                                                 */
            uint32_t            : 1;
      __IOM uint32_t H_EC7      : 1;            /*!< H_EC7                                                                     */
      __IOM uint32_t H_DEVADDR7 : 7;            /*!< H_DEVADDR7                                                                */
      __IOM uint32_t H_ODDFRM7  : 1;            /*!< H_ODDFRM7                                                                 */
      __IOM uint32_t H_CHDIS7   : 1;            /*!< H_CHDIS7                                                                  */
      __IOM uint32_t H_CHENA7   : 1;            /*!< H_CHENA7                                                                  */
    } bit;
  } HCCHAR7;
  __IM  uint32_t  RESERVED21;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINT7                                                                    */
    
    struct {
      __IOM uint32_t H_XFERCOMPL7 : 1;          /*!< H_XFERCOMPL7                                                              */
      __IOM uint32_t H_CHHLTD7  : 1;            /*!< H_CHHLTD7                                                                 */
      __IOM uint32_t H_AHBERR7  : 1;            /*!< H_AHBERR7                                                                 */
      __IOM uint32_t H_STALL7   : 1;            /*!< H_STALL7                                                                  */
      __IOM uint32_t H_NACK7    : 1;            /*!< H_NACK7                                                                   */
      __IOM uint32_t H_ACK7     : 1;            /*!< H_ACK7                                                                    */
      __IOM uint32_t H_NYET7    : 1;            /*!< H_NYET7                                                                   */
      __IOM uint32_t H_XACTERR7 : 1;            /*!< H_XACTERR7                                                                */
      __IOM uint32_t H_BBLERR7  : 1;            /*!< H_BBLERR7                                                                 */
      __IOM uint32_t H_FRMOVRUN7 : 1;           /*!< H_FRMOVRUN7                                                               */
      __IOM uint32_t H_DATATGLERR7 : 1;         /*!< H_DATATGLERR7                                                             */
      __IOM uint32_t H_BNAINTR7 : 1;            /*!< H_BNAINTR7                                                                */
      __IOM uint32_t H_XCS_XACT_ERR7 : 1;       /*!< H_XCS_XACT_ERR7                                                           */
      __IOM uint32_t H_DESC_LST_ROLLINTR7 : 1;  /*!< H_DESC_LST_ROLLINTR7                                                      */
            uint32_t            : 18;
    } bit;
  } HCINT7;
  
  union {
    __IOM uint32_t reg;                         /*!< HCINTMSK7                                                                 */
    
    struct {
      __IOM uint32_t H_XFERCOMPLMSK7 : 1;       /*!< H_XFERCOMPLMSK7                                                           */
      __IOM uint32_t H_CHHLTDMSK7 : 1;          /*!< H_CHHLTDMSK7                                                              */
      __IOM uint32_t H_AHBERRMSK7 : 1;          /*!< H_AHBERRMSK7                                                              */
      __IOM uint32_t H_STALLMSK7 : 1;           /*!< H_STALLMSK7                                                               */
      __IOM uint32_t H_NAKMSK7  : 1;            /*!< H_NAKMSK7                                                                 */
      __IOM uint32_t H_ACKMSK7  : 1;            /*!< H_ACKMSK7                                                                 */
      __IOM uint32_t H_NYETMSK7 : 1;            /*!< H_NYETMSK7                                                                */
      __IOM uint32_t H_XACTERRMSK7 : 1;         /*!< H_XACTERRMSK7                                                             */
      __IOM uint32_t H_BBLERRMSK7 : 1;          /*!< H_BBLERRMSK7                                                              */
      __IOM uint32_t H_FRMOVRUNMSK7 : 1;        /*!< H_FRMOVRUNMSK7                                                            */
      __IOM uint32_t H_DATATGLERRMSK7 : 1;      /*!< H_DATATGLERRMSK7                                                          */
      __IOM uint32_t H_BNAINTRMSK7 : 1;         /*!< H_BNAINTRMSK7                                                             */
            uint32_t            : 1;
      __IOM uint32_t H_DESC_LST_ROLLINTRMSK7 : 1;/*!< H_DESC_LST_ROLLINTRMSK7                                                  */
            uint32_t            : 18;
    } bit;
  } HCINTMSK7;
  
  union {
    __IOM uint32_t reg;                         /*!< HCTSIZ7                                                                   */
    
    struct {
      __IOM uint32_t H_XFERSIZE7 : 19;          /*!< H_XFERSIZE7                                                               */
      __IOM uint32_t H_PKTCNT7  : 10;           /*!< H_PKTCNT7                                                                 */
      __IOM uint32_t H_PID7     : 2;            /*!< H_PID7                                                                    */
      __IOM uint32_t H_DOPNG7   : 1;            /*!< H_DOPNG7                                                                  */
    } bit;
  } HCTSIZ7;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMA7                                                                    */
    
    struct {
      __IOM uint32_t H_DMAADDR7 : 32;           /*!< H_DMAADDR7                                                                */
    } bit;
  } HCDMA7;
  __IM  uint32_t  RESERVED22;
  
  union {
    __IOM uint32_t reg;                         /*!< HCDMAB7                                                                   */
    
    struct {
      __IM  uint32_t H_HCDMAB7  : 32;           /*!< H_HCDMAB7                                                                 */
    } bit;
  } HCDMAB7;
  __IM  uint32_t  RESERVED23[128];
  
  union {
    __IOM uint32_t reg;                         /*!< DCFG                                                                      */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t NZSTSOUTHSHK : 1;          /*!< NZSTSOUTHSHK                                                              */
      __IOM uint32_t ENA32KHZSUSP : 1;          /*!< ENA32KHZSUSP                                                              */
      __IOM uint32_t DEVADDR    : 7;            /*!< DEVADDR                                                                   */
      __IOM uint32_t PERFRLINT  : 2;            /*!< PERFRLINT                                                                 */
      __IOM uint32_t ENDEVOUTNAK : 1;           /*!< ENDEVOUTNAK                                                               */
      __IOM uint32_t XCVRDLY    : 1;            /*!< XCVRDLY                                                                   */
      __IOM uint32_t ERRATICINTMSK : 1;         /*!< ERRATICINTMSK                                                             */
            uint32_t            : 2;
      __IOM uint32_t EPMISCNT   : 5;            /*!< EPMISCNT                                                                  */
      __IOM uint32_t DESCDMA    : 1;            /*!< DESCDMA                                                                   */
      __IOM uint32_t PERSCHINTVL : 2;           /*!< PERSCHINTVL                                                               */
      __IOM uint32_t RESVALID   : 6;            /*!< RESVALID                                                                  */
    } bit;
  } DCFG;
  
  union {
    __IOM uint32_t reg;                         /*!< DCTL                                                                      */
    
    struct {
      __IOM uint32_t RMTWKUPSIG : 1;            /*!< RMTWKUPSIG                                                                */
      __IOM uint32_t SFTDISCON  : 1;            /*!< SFTDISCON                                                                 */
      __IM  uint32_t GNPINNAKSTS : 1;           /*!< GNPINNAKSTS                                                               */
      __IM  uint32_t GOUTNAKSTS : 1;            /*!< GOUTNAKSTS                                                                */
      __IOM uint32_t TSTCTL     : 3;            /*!< TSTCTL                                                                    */
      __OM  uint32_t SGNPINNAK  : 1;            /*!< SGNPINNAK                                                                 */
      __OM  uint32_t CGNPINNAK  : 1;            /*!< CGNPINNAK                                                                 */
      __OM  uint32_t SGOUTNAK   : 1;            /*!< SGOUTNAK                                                                  */
      __OM  uint32_t CGOUTNAK   : 1;            /*!< CGOUTNAK                                                                  */
      __IOM uint32_t PWRONPRGDONE : 1;          /*!< PWRONPRGDONE                                                              */
            uint32_t            : 1;
      __IOM uint32_t GMC        : 2;            /*!< GMC                                                                       */
      __IOM uint32_t IGNRFRMNUM : 1;            /*!< IGNRFRMNUM                                                                */
      __IOM uint32_t NAKONBBLE  : 1;            /*!< NAKONBBLE                                                                 */
      __IOM uint32_t ENCOUNTONBNA : 1;          /*!< ENCOUNTONBNA                                                              */
      __IOM uint32_t DEEPSLEEPBESLREJECT : 1;   /*!< DEEPSLEEPBESLREJECT                                                       */
            uint32_t            : 13;
    } bit;
  } DCTL;
  
  union {
    __IOM uint32_t reg;                         /*!< DSTS                                                                      */
    
    struct {
      __IM  uint32_t SUSPSTS    : 1;            /*!< SUSPSTS                                                                   */
      __IM  uint32_t ENUMSPD    : 2;            /*!< ENUMSPD                                                                   */
      __IM  uint32_t ERRTICERR  : 1;            /*!< ERRTICERR                                                                 */
            uint32_t            : 4;
      __IM  uint32_t SOFFN      : 14;           /*!< SOFFN                                                                     */
      __IM  uint32_t DEVLNSTS   : 2;            /*!< DEVLNSTS                                                                  */
            uint32_t            : 8;
    } bit;
  } DSTS;
  __IM  uint32_t  RESERVED24;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPMSK                                                                   */
    
    struct {
      __IOM uint32_t DI_XFERCOMPLMSK : 1;       /*!< DI_XFERCOMPLMSK                                                           */
      __IOM uint32_t DI_EPDISBLDMSK : 1;        /*!< DI_EPDISBLDMSK                                                            */
      __IOM uint32_t DI_AHBERMSK : 1;           /*!< DI_AHBERMSK                                                               */
      __IOM uint32_t TIMEOUTMSK : 1;            /*!< TIMEOUTMSK                                                                */
      __IOM uint32_t INTKNTXFEMPMSK : 1;        /*!< INTKNTXFEMPMSK                                                            */
      __IOM uint32_t INTKNEPMISMSK : 1;         /*!< INTKNEPMISMSK                                                             */
      __IOM uint32_t INEPNAKEFFMSK : 1;         /*!< INEPNAKEFFMSK                                                             */
            uint32_t            : 1;
      __IOM uint32_t TXFIFOUNDRNMSK : 1;        /*!< TXFIFOUNDRNMSK                                                            */
      __IOM uint32_t BNAININTRMSK : 1;          /*!< BNAININTRMSK                                                              */
            uint32_t            : 3;
      __IOM uint32_t DI_NAKMSK  : 1;            /*!< DI_NAKMSK                                                                 */
            uint32_t            : 18;
    } bit;
  } DIEPMSK;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPMSK                                                                   */
    
    struct {
      __IOM uint32_t XFERCOMPLMSK : 1;          /*!< XFERCOMPLMSK                                                              */
      __IOM uint32_t EPDISBLDMSK : 1;           /*!< EPDISBLDMSK                                                               */
      __IOM uint32_t AHBERMSK   : 1;            /*!< AHBERMSK                                                                  */
      __IOM uint32_t SETUPMSK   : 1;            /*!< SETUPMSK                                                                  */
      __IOM uint32_t OUTTKNEPDISMSK : 1;        /*!< OUTTKNEPDISMSK                                                            */
      __IOM uint32_t STSPHSERCVDMSK : 1;        /*!< STSPHSERCVDMSK                                                            */
      __IOM uint32_t BACK2BACKSETUP : 1;        /*!< BACK2BACKSETUP                                                            */
            uint32_t            : 1;
      __IOM uint32_t OUTPKTERRMSK : 1;          /*!< OUTPKTERRMSK                                                              */
      __IOM uint32_t BNAOUTINTRMSK : 1;         /*!< BNAOUTINTRMSK                                                             */
            uint32_t            : 2;
      __IOM uint32_t BBLEERRMSK : 1;            /*!< BBLEERRMSK                                                                */
      __IOM uint32_t NAKMSK     : 1;            /*!< NAKMSK                                                                    */
      __IOM uint32_t NYETMSK    : 1;            /*!< NYETMSK                                                                   */
            uint32_t            : 17;
    } bit;
  } DOEPMSK;
  
  union {
    __IOM uint32_t reg;                         /*!< DAINT                                                                     */
    
    struct {
      __IM  uint32_t INEPINT0   : 1;            /*!< INEPINT0                                                                  */
      __IM  uint32_t INEPINT1   : 1;            /*!< INEPINT1                                                                  */
      __IM  uint32_t INEPINT2   : 1;            /*!< INEPINT2                                                                  */
      __IM  uint32_t INEPINT3   : 1;            /*!< INEPINT3                                                                  */
      __IM  uint32_t INEPINT4   : 1;            /*!< INEPINT4                                                                  */
      __IM  uint32_t INEPINT5   : 1;            /*!< INEPINT5                                                                  */
      __IM  uint32_t INEPINT6   : 1;            /*!< INEPINT6                                                                  */
            uint32_t            : 9;
      __IM  uint32_t OUTEPINT0  : 1;            /*!< OUTEPINT0                                                                 */
      __IM  uint32_t OUTEPINT1  : 1;            /*!< OUTEPINT1                                                                 */
      __IM  uint32_t OUTEPINT2  : 1;            /*!< OUTEPINT2                                                                 */
      __IM  uint32_t OUTEPINT3  : 1;            /*!< OUTEPINT3                                                                 */
      __IM  uint32_t OUTEPINT4  : 1;            /*!< OUTEPINT4                                                                 */
      __IM  uint32_t OUTEPINT5  : 1;            /*!< OUTEPINT5                                                                 */
      __IM  uint32_t OUTEPINT6  : 1;            /*!< OUTEPINT6                                                                 */
            uint32_t            : 9;
    } bit;
  } DAINT;
  
  union {
    __IOM uint32_t reg;                         /*!< DAINTMSK                                                                  */
    
    struct {
      __IOM uint32_t INEPMSK0   : 1;            /*!< INEPMSK0                                                                  */
      __IOM uint32_t INEPMSK1   : 1;            /*!< INEPMSK1                                                                  */
      __IOM uint32_t INEPMSK2   : 1;            /*!< INEPMSK2                                                                  */
      __IOM uint32_t INEPMSK3   : 1;            /*!< INEPMSK3                                                                  */
      __IOM uint32_t INEPMSK4   : 1;            /*!< INEPMSK4                                                                  */
      __IOM uint32_t INEPMSK5   : 1;            /*!< INEPMSK5                                                                  */
      __IOM uint32_t INEPMSK6   : 1;            /*!< INEPMSK6                                                                  */
            uint32_t            : 9;
      __IOM uint32_t OUTEPMSK0  : 1;            /*!< OUTEPMSK0                                                                 */
      __IOM uint32_t OUTEPMSK1  : 1;            /*!< OUTEPMSK1                                                                 */
      __IOM uint32_t OUTEPMSK2  : 1;            /*!< OUTEPMSK2                                                                 */
      __IOM uint32_t OUTEPMSK3  : 1;            /*!< OUTEPMSK3                                                                 */
      __IOM uint32_t OUTEPMSK4  : 1;            /*!< OUTEPMSK4                                                                 */
      __IOM uint32_t OUTEPMSK5  : 1;            /*!< OUTEPMSK5                                                                 */
      __IOM uint32_t OUTEPMSK6  : 1;            /*!< OUTEPMSK6                                                                 */
            uint32_t            : 9;
    } bit;
  } DAINTMSK;
  __IM  uint32_t  RESERVED25[2];
  
  union {
    __IOM uint32_t reg;                         /*!< DVBUSDIS                                                                  */
    
    struct {
      __IOM uint32_t DVBUSDIS   : 16;           /*!< DVBUSDIS                                                                  */
            uint32_t            : 16;
    } bit;
  } DVBUSDIS;
  
  union {
    __IOM uint32_t reg;                         /*!< DVBUSPULSE                                                                */
    
    struct {
      __IOM uint32_t DVBUSPULSE : 12;           /*!< DVBUSPULSE                                                                */
            uint32_t            : 20;
    } bit;
  } DVBUSPULSE;
  
  union {
    __IOM uint32_t reg;                         /*!< DTHRCTL                                                                   */
    
    struct {
      __IOM uint32_t NONISOTHREN : 1;           /*!< NONISOTHREN                                                               */
      __IOM uint32_t ISOTHREN   : 1;            /*!< ISOTHREN                                                                  */
      __IOM uint32_t TXTHRLEN   : 9;            /*!< TXTHRLEN                                                                  */
      __IOM uint32_t AHBTHRRATIO : 2;           /*!< AHBTHRRATIO                                                               */
            uint32_t            : 3;
      __IOM uint32_t RXTHREN    : 1;            /*!< RXTHREN                                                                   */
      __IOM uint32_t RXTHRLEN   : 9;            /*!< RXTHRLEN                                                                  */
            uint32_t            : 1;
      __IOM uint32_t ARBPRKEN   : 1;            /*!< ARBPRKEN                                                                  */
            uint32_t            : 4;
    } bit;
  } DTHRCTL;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPEMPMSK                                                                */
    
    struct {
      __IOM uint32_t D_INEPTXFEMPMSK : 16;      /*!< D_INEPTXFEMPMSK                                                           */
            uint32_t            : 16;
    } bit;
  } DIEPEMPMSK;
  __IM  uint32_t  RESERVED26[50];
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPCTL0                                                                  */
    
    struct {
      __IOM uint32_t D_MPS0     : 2;            /*!< D_MPS0                                                                    */
            uint32_t            : 13;
      __IM  uint32_t D_USBACTEP0 : 1;           /*!< D_USBACTEP0                                                               */
            uint32_t            : 1;
      __IM  uint32_t D_NAKSTS0  : 1;            /*!< D_NAKSTS0                                                                 */
      __IM  uint32_t D_EPTYPE0  : 2;            /*!< D_EPTYPE0                                                                 */
            uint32_t            : 1;
      __IOM uint32_t D_STALL0   : 1;            /*!< D_STALL0                                                                  */
      __IOM uint32_t D_TXFNUM0  : 4;            /*!< D_TXFNUM0                                                                 */
      __OM  uint32_t D_CNAK0    : 1;            /*!< D_CNAK0                                                                   */
      __OM  uint32_t DI_SNAK0   : 1;            /*!< DI_SNAK0                                                                  */
            uint32_t            : 2;
      __IOM uint32_t D_EPDIS0   : 1;            /*!< D_EPDIS0                                                                  */
      __IOM uint32_t D_EPENA0   : 1;            /*!< D_EPENA0                                                                  */
    } bit;
  } DIEPCTL0;
  __IM  uint32_t  RESERVED27;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPINT0                                                                  */
    
    struct {
      __IOM uint32_t D_XFERCOMPL0 : 1;          /*!< D_XFERCOMPL0                                                              */
      __IOM uint32_t D_EPDISBLD0 : 1;           /*!< D_EPDISBLD0                                                               */
      __IOM uint32_t D_AHBERR0  : 1;            /*!< D_AHBERR0                                                                 */
      __IOM uint32_t D_TIMEOUT0 : 1;            /*!< D_TIMEOUT0                                                                */
      __IOM uint32_t D_INTKNTXFEMP0 : 1;        /*!< D_INTKNTXFEMP0                                                            */
      __IOM uint32_t D_INTKNEPMIS0 : 1;         /*!< D_INTKNEPMIS0                                                             */
      __IOM uint32_t D_INEPNAKEFF0 : 1;         /*!< D_INEPNAKEFF0                                                             */
      __IM  uint32_t D_TXFEMP0  : 1;            /*!< D_TXFEMP0                                                                 */
      __IOM uint32_t D_TXFIFOUNDRN0 : 1;        /*!< D_TXFIFOUNDRN0                                                            */
      __IOM uint32_t D_BNAINTR0 : 1;            /*!< D_BNAINTR0                                                                */
            uint32_t            : 1;
      __IOM uint32_t D_PKTDRPSTS0 : 1;          /*!< D_PKTDRPSTS0                                                              */
      __IOM uint32_t D_BBLEERR0 : 1;            /*!< D_BBLEERR0                                                                */
      __IOM uint32_t D_NAKINTRPT0 : 1;          /*!< D_NAKINTRPT0                                                              */
      __IOM uint32_t D_NYETINTRPT0 : 1;         /*!< D_NYETINTRPT0                                                             */
            uint32_t            : 17;
    } bit;
  } DIEPINT0;
  __IM  uint32_t  RESERVED28;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTSIZ0                                                                 */
    
    struct {
      __IOM uint32_t D_XFERSIZE0 : 7;           /*!< D_XFERSIZE0                                                               */
            uint32_t            : 12;
      __IOM uint32_t D_PKTCNT0  : 2;            /*!< D_PKTCNT0                                                                 */
            uint32_t            : 11;
    } bit;
  } DIEPTSIZ0;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMA0                                                                  */
    
    struct {
      __IOM uint32_t D_DMAADDR0 : 32;           /*!< D_DMAADDR0                                                                */
    } bit;
  } DIEPDMA0;
  
  union {
    __IOM uint32_t reg;                         /*!< DTXFSTS0                                                                  */
    
    struct {
      __IM  uint32_t D_INEPTXFSPCAVAIL0 : 16;   /*!< D_INEPTXFSPCAVAIL0                                                        */
            uint32_t            : 16;
    } bit;
  } DTXFSTS0;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMAB0                                                                 */
    
    struct {
      __IM  uint32_t D_DMABUFFERADDR0 : 32;     /*!< D_DMABUFFERADDR0                                                          */
    } bit;
  } DIEPDMAB0;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPCTL1                                                                  */
    
    struct {
      __IOM uint32_t D_MPS1     : 2;            /*!< D_MPS1                                                                    */
            uint32_t            : 13;
      __IM  uint32_t D_USBACTEP1 : 1;           /*!< D_USBACTEP1                                                               */
            uint32_t            : 1;
      __IM  uint32_t D_NAKSTS1  : 1;            /*!< D_NAKSTS1                                                                 */
      __IM  uint32_t D_EPTYPE1  : 2;            /*!< D_EPTYPE1                                                                 */
            uint32_t            : 1;
      __IOM uint32_t D_STALL1   : 1;            /*!< D_STALL1                                                                  */
      __IOM uint32_t D_TXFNUM1  : 4;            /*!< D_TXFNUM1                                                                 */
      __OM  uint32_t D_CNAK1    : 1;            /*!< D_CNAK1                                                                   */
      __OM  uint32_t DI_SNAK1   : 1;            /*!< DI_SNAK1                                                                  */
      __OM  uint32_t DI_SETD0PID1 : 1;          /*!< DI_SETD0PID1                                                              */
      __OM  uint32_t DI_SETD1PID1 : 1;          /*!< DI_SETD1PID1                                                              */
      __IOM uint32_t D_EPDIS1   : 1;            /*!< D_EPDIS1                                                                  */
      __IOM uint32_t D_EPENA1   : 1;            /*!< D_EPENA1                                                                  */
    } bit;
  } DIEPCTL1;
  __IM  uint32_t  RESERVED29;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPINT1                                                                  */
    
    struct {
      __IOM uint32_t D_XFERCOMPL1 : 1;          /*!< D_XFERCOMPL1                                                              */
      __IOM uint32_t D_EPDISBLD1 : 1;           /*!< D_EPDISBLD1                                                               */
      __IOM uint32_t D_AHBERR1  : 1;            /*!< D_AHBERR1                                                                 */
      __IOM uint32_t D_TIMEOUT1 : 1;            /*!< D_TIMEOUT1                                                                */
      __IOM uint32_t D_INTKNTXFEMP1 : 1;        /*!< D_INTKNTXFEMP1                                                            */
      __IOM uint32_t D_INTKNEPMIS1 : 1;         /*!< D_INTKNEPMIS1                                                             */
      __IOM uint32_t D_INEPNAKEFF1 : 1;         /*!< D_INEPNAKEFF1                                                             */
      __IM  uint32_t D_TXFEMP1  : 1;            /*!< D_TXFEMP1                                                                 */
      __IOM uint32_t D_TXFIFOUNDRN1 : 1;        /*!< D_TXFIFOUNDRN1                                                            */
      __IOM uint32_t D_BNAINTR1 : 1;            /*!< D_BNAINTR1                                                                */
            uint32_t            : 1;
      __IOM uint32_t D_PKTDRPSTS1 : 1;          /*!< D_PKTDRPSTS1                                                              */
      __IOM uint32_t D_BBLEERR1 : 1;            /*!< D_BBLEERR1                                                                */
      __IOM uint32_t D_NAKINTRPT1 : 1;          /*!< D_NAKINTRPT1                                                              */
      __IOM uint32_t D_NYETINTRPT1 : 1;         /*!< D_NYETINTRPT1                                                             */
            uint32_t            : 17;
    } bit;
  } DIEPINT1;
  __IM  uint32_t  RESERVED30;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTSIZ1                                                                 */
    
    struct {
      __IOM uint32_t D_XFERSIZE1 : 7;           /*!< D_XFERSIZE1                                                               */
            uint32_t            : 12;
      __IOM uint32_t D_PKTCNT1  : 2;            /*!< D_PKTCNT1                                                                 */
            uint32_t            : 11;
    } bit;
  } DIEPTSIZ1;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMA1                                                                  */
    
    struct {
      __IOM uint32_t D_DMAADDR1 : 32;           /*!< D_DMAADDR1                                                                */
    } bit;
  } DIEPDMA1;
  
  union {
    __IOM uint32_t reg;                         /*!< DTXFSTS1                                                                  */
    
    struct {
      __IM  uint32_t D_INEPTXFSPCAVAIL1 : 16;   /*!< D_INEPTXFSPCAVAIL1                                                        */
            uint32_t            : 16;
    } bit;
  } DTXFSTS1;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMAB1                                                                 */
    
    struct {
      __IM  uint32_t D_DMABUFFERADDR1 : 32;     /*!< D_DMABUFFERADDR1                                                          */
    } bit;
  } DIEPDMAB1;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPCTL2                                                                  */
    
    struct {
      __IOM uint32_t D_MPS2     : 2;            /*!< D_MPS2                                                                    */
            uint32_t            : 13;
      __IM  uint32_t D_USBACTEP2 : 1;           /*!< D_USBACTEP2                                                               */
            uint32_t            : 1;
      __IM  uint32_t D_NAKSTS2  : 1;            /*!< D_NAKSTS2                                                                 */
      __IM  uint32_t D_EPTYPE2  : 2;            /*!< D_EPTYPE2                                                                 */
            uint32_t            : 1;
      __IOM uint32_t D_STALL2   : 1;            /*!< D_STALL2                                                                  */
      __IOM uint32_t D_TXFNUM2  : 4;            /*!< D_TXFNUM2                                                                 */
      __OM  uint32_t D_CNAK2    : 1;            /*!< D_CNAK2                                                                   */
      __OM  uint32_t DI_SNAK2   : 1;            /*!< DI_SNAK2                                                                  */
      __OM  uint32_t DI_SETD0PID2 : 1;          /*!< DI_SETD0PID2                                                              */
      __OM  uint32_t DI_SETD1PID2 : 1;          /*!< DI_SETD1PID2                                                              */
      __IOM uint32_t D_EPDIS2   : 1;            /*!< D_EPDIS2                                                                  */
      __IOM uint32_t D_EPENA2   : 1;            /*!< D_EPENA2                                                                  */
    } bit;
  } DIEPCTL2;
  __IM  uint32_t  RESERVED31;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPINT2                                                                  */
    
    struct {
      __IOM uint32_t D_XFERCOMPL2 : 1;          /*!< D_XFERCOMPL2                                                              */
      __IOM uint32_t D_EPDISBLD2 : 1;           /*!< D_EPDISBLD2                                                               */
      __IOM uint32_t D_AHBERR2  : 1;            /*!< D_AHBERR2                                                                 */
      __IOM uint32_t D_TIMEOUT2 : 1;            /*!< D_TIMEOUT2                                                                */
      __IOM uint32_t D_INTKNTXFEMP2 : 1;        /*!< D_INTKNTXFEMP2                                                            */
      __IOM uint32_t D_INTKNEPMIS2 : 1;         /*!< D_INTKNEPMIS2                                                             */
      __IOM uint32_t D_INEPNAKEFF2 : 1;         /*!< D_INEPNAKEFF2                                                             */
      __IM  uint32_t D_TXFEMP2  : 1;            /*!< D_TXFEMP2                                                                 */
      __IOM uint32_t D_TXFIFOUNDRN2 : 1;        /*!< D_TXFIFOUNDRN2                                                            */
      __IOM uint32_t D_BNAINTR2 : 1;            /*!< D_BNAINTR2                                                                */
            uint32_t            : 1;
      __IOM uint32_t D_PKTDRPSTS2 : 1;          /*!< D_PKTDRPSTS2                                                              */
      __IOM uint32_t D_BBLEERR2 : 1;            /*!< D_BBLEERR2                                                                */
      __IOM uint32_t D_NAKINTRPT2 : 1;          /*!< D_NAKINTRPT2                                                              */
      __IOM uint32_t D_NYETINTRPT2 : 1;         /*!< D_NYETINTRPT2                                                             */
            uint32_t            : 17;
    } bit;
  } DIEPINT2;
  __IM  uint32_t  RESERVED32;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTSIZ2                                                                 */
    
    struct {
      __IOM uint32_t D_XFERSIZE2 : 7;           /*!< D_XFERSIZE2                                                               */
            uint32_t            : 12;
      __IOM uint32_t D_PKTCNT2  : 2;            /*!< D_PKTCNT2                                                                 */
            uint32_t            : 11;
    } bit;
  } DIEPTSIZ2;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMA2                                                                  */
    
    struct {
      __IOM uint32_t D_DMAADDR2 : 32;           /*!< D_DMAADDR2                                                                */
    } bit;
  } DIEPDMA2;
  
  union {
    __IOM uint32_t reg;                         /*!< DTXFSTS2                                                                  */
    
    struct {
      __IM  uint32_t D_INEPTXFSPCAVAIL2 : 16;   /*!< D_INEPTXFSPCAVAIL2                                                        */
            uint32_t            : 16;
    } bit;
  } DTXFSTS2;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMAB2                                                                 */
    
    struct {
      __IM  uint32_t D_DMABUFFERADDR2 : 32;     /*!< D_DMABUFFERADDR2                                                          */
    } bit;
  } DIEPDMAB2;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPCTL3                                                                  */
    
    struct {
      __IOM uint32_t DI_MPS3    : 2;            /*!< DI_MPS3                                                                   */
            uint32_t            : 13;
      __IM  uint32_t DI_USBACTEP3 : 1;          /*!< DI_USBACTEP3                                                              */
            uint32_t            : 1;
      __IM  uint32_t DI_NAKSTS3 : 1;            /*!< DI_NAKSTS3                                                                */
      __IM  uint32_t DI_EPTYPE3 : 2;            /*!< DI_EPTYPE3                                                                */
            uint32_t            : 1;
      __IOM uint32_t DI_STALL3  : 1;            /*!< DI_STALL3                                                                 */
      __IOM uint32_t DI_TXFNUM3 : 4;            /*!< DI_TXFNUM3                                                                */
      __OM  uint32_t DI_CNAK3   : 1;            /*!< DI_CNAK3                                                                  */
      __OM  uint32_t DI_SNAK3   : 1;            /*!< DI_SNAK3                                                                  */
      __OM  uint32_t DI_SETD0PID3 : 1;          /*!< DI_SETD0PID3                                                              */
      __OM  uint32_t DI_SETD1PID3 : 1;          /*!< DI_SETD1PID3                                                              */
      __IOM uint32_t DI_EPDIS3  : 1;            /*!< DI_EPDIS3                                                                 */
      __IOM uint32_t DI_EPENA3  : 1;            /*!< DI_EPENA3                                                                 */
    } bit;
  } DIEPCTL3;
  __IM  uint32_t  RESERVED33;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPINT3                                                                  */
    
    struct {
      __IOM uint32_t D_XFERCOMPL3 : 1;          /*!< D_XFERCOMPL3                                                              */
      __IOM uint32_t D_EPDISBLD3 : 1;           /*!< D_EPDISBLD3                                                               */
      __IOM uint32_t D_AHBERR3  : 1;            /*!< D_AHBERR3                                                                 */
      __IOM uint32_t D_TIMEOUT3 : 1;            /*!< D_TIMEOUT3                                                                */
      __IOM uint32_t D_INTKNTXFEMP3 : 1;        /*!< D_INTKNTXFEMP3                                                            */
      __IOM uint32_t D_INTKNEPMIS3 : 1;         /*!< D_INTKNEPMIS3                                                             */
      __IOM uint32_t D_INEPNAKEFF3 : 1;         /*!< D_INEPNAKEFF3                                                             */
      __IM  uint32_t D_TXFEMP3  : 1;            /*!< D_TXFEMP3                                                                 */
      __IOM uint32_t D_TXFIFOUNDRN3 : 1;        /*!< D_TXFIFOUNDRN3                                                            */
      __IOM uint32_t D_BNAINTR3 : 1;            /*!< D_BNAINTR3                                                                */
            uint32_t            : 1;
      __IOM uint32_t D_PKTDRPSTS3 : 1;          /*!< D_PKTDRPSTS3                                                              */
      __IOM uint32_t D_BBLEERR3 : 1;            /*!< D_BBLEERR3                                                                */
      __IOM uint32_t D_NAKINTRPT3 : 1;          /*!< D_NAKINTRPT3                                                              */
      __IOM uint32_t D_NYETINTRPT3 : 1;         /*!< D_NYETINTRPT3                                                             */
            uint32_t            : 17;
    } bit;
  } DIEPINT3;
  __IM  uint32_t  RESERVED34;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTSIZ3                                                                 */
    
    struct {
      __IOM uint32_t D_XFERSIZE3 : 7;           /*!< D_XFERSIZE3                                                               */
            uint32_t            : 12;
      __IOM uint32_t D_PKTCNT3  : 2;            /*!< D_PKTCNT3                                                                 */
            uint32_t            : 11;
    } bit;
  } DIEPTSIZ3;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMA3                                                                  */
    
    struct {
      __IOM uint32_t D_DMAADDR3 : 32;           /*!< D_DMAADDR3                                                                */
    } bit;
  } DIEPDMA3;
  
  union {
    __IOM uint32_t reg;                         /*!< DTXFSTS3                                                                  */
    
    struct {
      __IM  uint32_t D_INEPTXFSPCAVAIL3 : 16;   /*!< D_INEPTXFSPCAVAIL3                                                        */
            uint32_t            : 16;
    } bit;
  } DTXFSTS3;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMAB3                                                                 */
    
    struct {
      __IM  uint32_t D_DMABUFFERADDR3 : 32;     /*!< D_DMABUFFERADDR3                                                          */
    } bit;
  } DIEPDMAB3;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPCTL4                                                                  */
    
    struct {
      __IOM uint32_t D_MPS4     : 2;            /*!< D_MPS4                                                                    */
            uint32_t            : 13;
      __IM  uint32_t D_USBACTEP4 : 1;           /*!< D_USBACTEP4                                                               */
            uint32_t            : 1;
      __IM  uint32_t D_NAKSTS4  : 1;            /*!< D_NAKSTS4                                                                 */
      __IM  uint32_t D_EPTYPE4  : 2;            /*!< D_EPTYPE4                                                                 */
            uint32_t            : 1;
      __IOM uint32_t D_STALL4   : 1;            /*!< D_STALL4                                                                  */
      __IOM uint32_t D_TXFNUM4  : 4;            /*!< D_TXFNUM4                                                                 */
      __OM  uint32_t D_CNAK4    : 1;            /*!< D_CNAK4                                                                   */
      __OM  uint32_t DI_SNAK4   : 1;            /*!< DI_SNAK4                                                                  */
      __OM  uint32_t DI_SETD0PID4 : 1;          /*!< DI_SETD0PID4                                                              */
      __OM  uint32_t DI_SETD1PID4 : 1;          /*!< DI_SETD1PID4                                                              */
      __IOM uint32_t D_EPDIS4   : 1;            /*!< D_EPDIS4                                                                  */
      __IOM uint32_t D_EPENA4   : 1;            /*!< D_EPENA4                                                                  */
    } bit;
  } DIEPCTL4;
  __IM  uint32_t  RESERVED35;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPINT4                                                                  */
    
    struct {
      __IOM uint32_t D_XFERCOMPL4 : 1;          /*!< D_XFERCOMPL4                                                              */
      __IOM uint32_t D_EPDISBLD4 : 1;           /*!< D_EPDISBLD4                                                               */
      __IOM uint32_t D_AHBERR4  : 1;            /*!< D_AHBERR4                                                                 */
      __IOM uint32_t D_TIMEOUT4 : 1;            /*!< D_TIMEOUT4                                                                */
      __IOM uint32_t D_INTKNTXFEMP4 : 1;        /*!< D_INTKNTXFEMP4                                                            */
      __IOM uint32_t D_INTKNEPMIS4 : 1;         /*!< D_INTKNEPMIS4                                                             */
      __IOM uint32_t D_INEPNAKEFF4 : 1;         /*!< D_INEPNAKEFF4                                                             */
      __IM  uint32_t D_TXFEMP4  : 1;            /*!< D_TXFEMP4                                                                 */
      __IOM uint32_t D_TXFIFOUNDRN4 : 1;        /*!< D_TXFIFOUNDRN4                                                            */
      __IOM uint32_t D_BNAINTR4 : 1;            /*!< D_BNAINTR4                                                                */
            uint32_t            : 1;
      __IOM uint32_t D_PKTDRPSTS4 : 1;          /*!< D_PKTDRPSTS4                                                              */
      __IOM uint32_t D_BBLEERR4 : 1;            /*!< D_BBLEERR4                                                                */
      __IOM uint32_t D_NAKINTRPT4 : 1;          /*!< D_NAKINTRPT4                                                              */
      __IOM uint32_t D_NYETINTRPT4 : 1;         /*!< D_NYETINTRPT4                                                             */
            uint32_t            : 17;
    } bit;
  } DIEPINT4;
  __IM  uint32_t  RESERVED36;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTSIZ4                                                                 */
    
    struct {
      __IOM uint32_t D_XFERSIZE4 : 7;           /*!< D_XFERSIZE4                                                               */
            uint32_t            : 12;
      __IOM uint32_t D_PKTCNT4  : 2;            /*!< D_PKTCNT4                                                                 */
            uint32_t            : 11;
    } bit;
  } DIEPTSIZ4;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMA4                                                                  */
    
    struct {
      __IOM uint32_t D_DMAADDR4 : 32;           /*!< D_DMAADDR4                                                                */
    } bit;
  } DIEPDMA4;
  
  union {
    __IOM uint32_t reg;                         /*!< DTXFSTS4                                                                  */
    
    struct {
      __IM  uint32_t D_INEPTXFSPCAVAIL4 : 16;   /*!< D_INEPTXFSPCAVAIL4                                                        */
            uint32_t            : 16;
    } bit;
  } DTXFSTS4;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMAB4                                                                 */
    
    struct {
      __IM  uint32_t D_DMABUFFERADDR4 : 32;     /*!< D_DMABUFFERADDR4                                                          */
    } bit;
  } DIEPDMAB4;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPCTL5                                                                  */
    
    struct {
      __IOM uint32_t DI_MPS5    : 2;            /*!< DI_MPS5                                                                   */
            uint32_t            : 13;
      __IM  uint32_t DI_USBACTEP5 : 1;          /*!< DI_USBACTEP5                                                              */
            uint32_t            : 1;
      __IM  uint32_t DI_NAKSTS5 : 1;            /*!< DI_NAKSTS5                                                                */
      __IM  uint32_t DI_EPTYPE5 : 2;            /*!< DI_EPTYPE5                                                                */
            uint32_t            : 1;
      __IOM uint32_t DI_STALL5  : 1;            /*!< DI_STALL5                                                                 */
      __IOM uint32_t DI_TXFNUM5 : 4;            /*!< DI_TXFNUM5                                                                */
      __OM  uint32_t DI_CNAK5   : 1;            /*!< DI_CNAK5                                                                  */
      __OM  uint32_t DI_SNAK5   : 1;            /*!< DI_SNAK5                                                                  */
      __OM  uint32_t DI_SETD0PID5 : 1;          /*!< DI_SETD0PID5                                                              */
      __OM  uint32_t DI_SETD1PID5 : 1;          /*!< DI_SETD1PID5                                                              */
      __IOM uint32_t DI_EPDIS5  : 1;            /*!< DI_EPDIS5                                                                 */
      __IOM uint32_t DI_EPENA5  : 1;            /*!< DI_EPENA5                                                                 */
    } bit;
  } DIEPCTL5;
  __IM  uint32_t  RESERVED37;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPINT5                                                                  */
    
    struct {
      __IOM uint32_t D_XFERCOMPL5 : 1;          /*!< D_XFERCOMPL5                                                              */
      __IOM uint32_t D_EPDISBLD5 : 1;           /*!< D_EPDISBLD5                                                               */
      __IOM uint32_t D_AHBERR5  : 1;            /*!< D_AHBERR5                                                                 */
      __IOM uint32_t D_TIMEOUT5 : 1;            /*!< D_TIMEOUT5                                                                */
      __IOM uint32_t D_INTKNTXFEMP5 : 1;        /*!< D_INTKNTXFEMP5                                                            */
      __IOM uint32_t D_INTKNEPMIS5 : 1;         /*!< D_INTKNEPMIS5                                                             */
      __IOM uint32_t D_INEPNAKEFF5 : 1;         /*!< D_INEPNAKEFF5                                                             */
      __IM  uint32_t D_TXFEMP5  : 1;            /*!< D_TXFEMP5                                                                 */
      __IOM uint32_t D_TXFIFOUNDRN5 : 1;        /*!< D_TXFIFOUNDRN5                                                            */
      __IOM uint32_t D_BNAINTR5 : 1;            /*!< D_BNAINTR5                                                                */
            uint32_t            : 1;
      __IOM uint32_t D_PKTDRPSTS5 : 1;          /*!< D_PKTDRPSTS5                                                              */
      __IOM uint32_t D_BBLEERR5 : 1;            /*!< D_BBLEERR5                                                                */
      __IOM uint32_t D_NAKINTRPT5 : 1;          /*!< D_NAKINTRPT5                                                              */
      __IOM uint32_t D_NYETINTRPT5 : 1;         /*!< D_NYETINTRPT5                                                             */
            uint32_t            : 17;
    } bit;
  } DIEPINT5;
  __IM  uint32_t  RESERVED38;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTSIZ5                                                                 */
    
    struct {
      __IOM uint32_t D_XFERSIZE5 : 7;           /*!< D_XFERSIZE5                                                               */
            uint32_t            : 12;
      __IOM uint32_t D_PKTCNT5  : 2;            /*!< D_PKTCNT5                                                                 */
            uint32_t            : 11;
    } bit;
  } DIEPTSIZ5;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMA5                                                                  */
    
    struct {
      __IOM uint32_t D_DMAADDR5 : 32;           /*!< D_DMAADDR5                                                                */
    } bit;
  } DIEPDMA5;
  
  union {
    __IOM uint32_t reg;                         /*!< DTXFSTS5                                                                  */
    
    struct {
      __IM  uint32_t D_INEPTXFSPCAVAIL5 : 16;   /*!< D_INEPTXFSPCAVAIL5                                                        */
            uint32_t            : 16;
    } bit;
  } DTXFSTS5;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMAB5                                                                 */
    
    struct {
      __IM  uint32_t D_DMABUFFERADDR5 : 32;     /*!< D_DMABUFFERADDR5                                                          */
    } bit;
  } DIEPDMAB5;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPCTL6                                                                  */
    
    struct {
      __IOM uint32_t D_MPS6     : 2;            /*!< D_MPS6                                                                    */
            uint32_t            : 13;
      __IM  uint32_t D_USBACTEP6 : 1;           /*!< D_USBACTEP6                                                               */
            uint32_t            : 1;
      __IM  uint32_t D_NAKSTS6  : 1;            /*!< D_NAKSTS6                                                                 */
      __IM  uint32_t D_EPTYPE6  : 2;            /*!< D_EPTYPE6                                                                 */
            uint32_t            : 1;
      __IOM uint32_t D_STALL6   : 1;            /*!< D_STALL6                                                                  */
      __IOM uint32_t D_TXFNUM6  : 4;            /*!< D_TXFNUM6                                                                 */
      __OM  uint32_t D_CNAK6    : 1;            /*!< D_CNAK6                                                                   */
      __OM  uint32_t DI_SNAK6   : 1;            /*!< DI_SNAK6                                                                  */
      __OM  uint32_t DI_SETD0PID6 : 1;          /*!< DI_SETD0PID6                                                              */
      __OM  uint32_t DI_SETD1PID6 : 1;          /*!< DI_SETD1PID6                                                              */
      __IOM uint32_t D_EPDIS6   : 1;            /*!< D_EPDIS6                                                                  */
      __IOM uint32_t D_EPENA6   : 1;            /*!< D_EPENA6                                                                  */
    } bit;
  } DIEPCTL6;
  __IM  uint32_t  RESERVED39;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPINT6                                                                  */
    
    struct {
      __IOM uint32_t D_XFERCOMPL6 : 1;          /*!< D_XFERCOMPL6                                                              */
      __IOM uint32_t D_EPDISBLD6 : 1;           /*!< D_EPDISBLD6                                                               */
      __IOM uint32_t D_AHBERR6  : 1;            /*!< D_AHBERR6                                                                 */
      __IOM uint32_t D_TIMEOUT6 : 1;            /*!< D_TIMEOUT6                                                                */
      __IOM uint32_t D_INTKNTXFEMP6 : 1;        /*!< D_INTKNTXFEMP6                                                            */
      __IOM uint32_t D_INTKNEPMIS6 : 1;         /*!< D_INTKNEPMIS6                                                             */
      __IOM uint32_t D_INEPNAKEFF6 : 1;         /*!< D_INEPNAKEFF6                                                             */
      __IM  uint32_t D_TXFEMP6  : 1;            /*!< D_TXFEMP6                                                                 */
      __IOM uint32_t D_TXFIFOUNDRN6 : 1;        /*!< D_TXFIFOUNDRN6                                                            */
      __IOM uint32_t D_BNAINTR6 : 1;            /*!< D_BNAINTR6                                                                */
            uint32_t            : 1;
      __IOM uint32_t D_PKTDRPSTS6 : 1;          /*!< D_PKTDRPSTS6                                                              */
      __IOM uint32_t D_BBLEERR6 : 1;            /*!< D_BBLEERR6                                                                */
      __IOM uint32_t D_NAKINTRPT6 : 1;          /*!< D_NAKINTRPT6                                                              */
      __IOM uint32_t D_NYETINTRPT6 : 1;         /*!< D_NYETINTRPT6                                                             */
            uint32_t            : 17;
    } bit;
  } DIEPINT6;
  __IM  uint32_t  RESERVED40;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPTSIZ6                                                                 */
    
    struct {
      __IOM uint32_t D_XFERSIZE6 : 7;           /*!< D_XFERSIZE6                                                               */
            uint32_t            : 12;
      __IOM uint32_t D_PKTCNT6  : 2;            /*!< D_PKTCNT6                                                                 */
            uint32_t            : 11;
    } bit;
  } DIEPTSIZ6;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMA6                                                                  */
    
    struct {
      __IOM uint32_t D_DMAADDR6 : 32;           /*!< D_DMAADDR6                                                                */
    } bit;
  } DIEPDMA6;
  
  union {
    __IOM uint32_t reg;                         /*!< DTXFSTS6                                                                  */
    
    struct {
      __IM  uint32_t D_INEPTXFSPCAVAIL6 : 16;   /*!< D_INEPTXFSPCAVAIL6                                                        */
            uint32_t            : 16;
    } bit;
  } DTXFSTS6;
  
  union {
    __IOM uint32_t reg;                         /*!< DIEPDMAB6                                                                 */
    
    struct {
      __IM  uint32_t D_DMABUFFERADDR6 : 32;     /*!< D_DMABUFFERADDR6                                                          */
    } bit;
  } DIEPDMAB6;
  __IM  uint32_t  RESERVED41[72];
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPCTL0                                                                  */
    
    struct {
      __IM  uint32_t MPS0       : 2;            /*!< MPS0                                                                      */
            uint32_t            : 13;
      __IM  uint32_t USBACTEP0  : 1;            /*!< USBACTEP0                                                                 */
            uint32_t            : 1;
      __IM  uint32_t NAKSTS0    : 1;            /*!< NAKSTS0                                                                   */
      __IM  uint32_t EPTYPE0    : 2;            /*!< EPTYPE0                                                                   */
      __IOM uint32_t SNP0       : 1;            /*!< SNP0                                                                      */
      __IOM uint32_t STALL0     : 1;            /*!< STALL0                                                                    */
            uint32_t            : 4;
      __OM  uint32_t CNAK0      : 1;            /*!< CNAK0                                                                     */
      __OM  uint32_t DO_SNAK0   : 1;            /*!< DO_SNAK0                                                                  */
            uint32_t            : 2;
      __IM  uint32_t EPDIS0     : 1;            /*!< EPDIS0                                                                    */
      __IOM uint32_t EPENA0     : 1;            /*!< EPENA0                                                                    */
    } bit;
  } DOEPCTL0;
  __IM  uint32_t  RESERVED42;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPINT0                                                                  */
    
    struct {
      __IOM uint32_t XFERCOMPL0 : 1;            /*!< XFERCOMPL0                                                                */
      __IOM uint32_t EPDISBLD0  : 1;            /*!< EPDISBLD0                                                                 */
      __IOM uint32_t AHBERR0    : 1;            /*!< AHBERR0                                                                   */
      __IOM uint32_t SETUP0     : 1;            /*!< SETUP0                                                                    */
      __IOM uint32_t OUTTKNEPDIS0 : 1;          /*!< OUTTKNEPDIS0                                                              */
      __IOM uint32_t STSPHSERCVD0 : 1;          /*!< STSPHSERCVD0                                                              */
      __IOM uint32_t BACK2BACKSETUP0 : 1;       /*!< BACK2BACKSETUP0                                                           */
            uint32_t            : 1;
      __IOM uint32_t OUTPKTERR0 : 1;            /*!< OUTPKTERR0                                                                */
      __IOM uint32_t BNAINTR0   : 1;            /*!< BNAINTR0                                                                  */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS0 : 1;            /*!< PKTDRPSTS0                                                                */
      __IOM uint32_t BBLEERR0   : 1;            /*!< BBLEERR0                                                                  */
      __IOM uint32_t NAKINTRPT0 : 1;            /*!< NAKINTRPT0                                                                */
      __IOM uint32_t NYEPINTRPT0 : 1;           /*!< NYEPINTRPT0                                                               */
      __IOM uint32_t STUPPKTRCVD0 : 1;          /*!< STUPPKTRCVD0                                                              */
            uint32_t            : 16;
    } bit;
  } DOEPINT0;
  __IM  uint32_t  RESERVED43;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPTSIZ0                                                                 */
    
    struct {
      __IOM uint32_t XFERSIZE0  : 7;            /*!< XFERSIZE0                                                                 */
            uint32_t            : 12;
      __IOM uint32_t PKTCNT0    : 1;            /*!< PKTCNT0                                                                   */
            uint32_t            : 9;
      __IOM uint32_t SUPCNT0    : 2;            /*!< SUPCNT0                                                                   */
            uint32_t            : 1;
    } bit;
  } DOEPTSIZ0;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMA0                                                                  */
    
    struct {
      __IOM uint32_t DMAADDR0   : 32;           /*!< DMAADDR0                                                                  */
    } bit;
  } DOEPDMA0;
  __IM  uint32_t  RESERVED44;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMAB0                                                                 */
    
    struct {
      __IOM uint32_t DMABUFFERADDR0 : 32;       /*!< DMABUFFERADDR0                                                            */
    } bit;
  } DOEPDMAB0;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPCTL1                                                                  */
    
    struct {
      __IM  uint32_t MPS1       : 11;           /*!< MPS1                                                                      */
            uint32_t            : 4;
      __IM  uint32_t USBACTEP1  : 1;            /*!< USBACTEP1                                                                 */
            uint32_t            : 1;
      __IM  uint32_t NAKSTS1    : 1;            /*!< NAKSTS1                                                                   */
      __IM  uint32_t EPTYPE1    : 2;            /*!< EPTYPE1                                                                   */
      __IOM uint32_t SNP1       : 1;            /*!< SNP1                                                                      */
      __IOM uint32_t STALL1     : 1;            /*!< STALL1                                                                    */
            uint32_t            : 4;
      __OM  uint32_t CNAK1      : 1;            /*!< CNAK1                                                                     */
      __OM  uint32_t DO_SNAK1   : 1;            /*!< DO_SNAK1                                                                  */
      __OM  uint32_t DO_SETD0PID1 : 1;          /*!< DO_SETD0PID1                                                              */
      __OM  uint32_t DO_SETD1PID1 : 1;          /*!< DO_SETD1PID1                                                              */
      __IM  uint32_t EPDIS1     : 1;            /*!< EPDIS1                                                                    */
      __IOM uint32_t EPENA1     : 1;            /*!< EPENA1                                                                    */
    } bit;
  } DOEPCTL1;
  __IM  uint32_t  RESERVED45;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPINT1                                                                  */
    
    struct {
      __IOM uint32_t XFERCOMPL1 : 1;            /*!< XFERCOMPL1                                                                */
      __IOM uint32_t EPDISBLD1  : 1;            /*!< EPDISBLD1                                                                 */
      __IOM uint32_t AHBERR1    : 1;            /*!< AHBERR1                                                                   */
      __IOM uint32_t SETUP1     : 1;            /*!< SETUP1                                                                    */
      __IOM uint32_t OUTTKNEPDIS1 : 1;          /*!< OUTTKNEPDIS1                                                              */
      __IOM uint32_t STSPHSERCVD1 : 1;          /*!< STSPHSERCVD1                                                              */
      __IOM uint32_t BACK2BACKSETUP1 : 1;       /*!< BACK2BACKSETUP1                                                           */
            uint32_t            : 1;
      __IOM uint32_t OUTPKTERR1 : 1;            /*!< OUTPKTERR1                                                                */
      __IOM uint32_t BNAINTR1   : 1;            /*!< BNAINTR1                                                                  */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS1 : 1;            /*!< PKTDRPSTS1                                                                */
      __IOM uint32_t BBLEERR1   : 1;            /*!< BBLEERR1                                                                  */
      __IOM uint32_t NAKINTRPT1 : 1;            /*!< NAKINTRPT1                                                                */
      __IOM uint32_t NYEPINTRPT1 : 1;           /*!< NYEPINTRPT1                                                               */
      __IOM uint32_t STUPPKTRCVD1 : 1;          /*!< STUPPKTRCVD1                                                              */
            uint32_t            : 16;
    } bit;
  } DOEPINT1;
  __IM  uint32_t  RESERVED46;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPTSIZ1                                                                 */
    
    struct {
      __IOM uint32_t XFERSIZE1  : 7;            /*!< XFERSIZE1                                                                 */
            uint32_t            : 12;
      __IOM uint32_t PKTCNT1    : 1;            /*!< PKTCNT1                                                                   */
            uint32_t            : 9;
      __IOM uint32_t SUPCNT1    : 2;            /*!< SUPCNT1                                                                   */
            uint32_t            : 1;
    } bit;
  } DOEPTSIZ1;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMA1                                                                  */
    
    struct {
      __IOM uint32_t DMAADDR1   : 32;           /*!< DMAADDR1                                                                  */
    } bit;
  } DOEPDMA1;
  __IM  uint32_t  RESERVED47;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMAB1                                                                 */
    
    struct {
      __IOM uint32_t DMABUFFERADDR1 : 32;       /*!< DMABUFFERADDR1                                                            */
    } bit;
  } DOEPDMAB1;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPCTL2                                                                  */
    
    struct {
      __IM  uint32_t MPS2       : 11;           /*!< MPS2                                                                      */
            uint32_t            : 4;
      __IM  uint32_t USBACTEP2  : 1;            /*!< USBACTEP2                                                                 */
            uint32_t            : 1;
      __IM  uint32_t NAKSTS2    : 1;            /*!< NAKSTS2                                                                   */
      __IM  uint32_t EPTYPE2    : 2;            /*!< EPTYPE2                                                                   */
      __IOM uint32_t SNP2       : 1;            /*!< SNP2                                                                      */
      __IOM uint32_t STALL2     : 1;            /*!< STALL2                                                                    */
            uint32_t            : 4;
      __OM  uint32_t CNAK2      : 1;            /*!< CNAK2                                                                     */
      __OM  uint32_t DO_SNAK2   : 1;            /*!< DO_SNAK2                                                                  */
      __OM  uint32_t DO_SETD0PID2 : 1;          /*!< DO_SETD0PID2                                                              */
      __OM  uint32_t DO_SETD1PID2 : 1;          /*!< DO_SETD1PID2                                                              */
      __IM  uint32_t EPDIS2     : 1;            /*!< EPDIS2                                                                    */
      __IOM uint32_t EPENA2     : 1;            /*!< EPENA2                                                                    */
    } bit;
  } DOEPCTL2;
  __IM  uint32_t  RESERVED48;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPINT2                                                                  */
    
    struct {
      __IOM uint32_t XFERCOMPL2 : 1;            /*!< XFERCOMPL2                                                                */
      __IOM uint32_t EPDISBLD2  : 1;            /*!< EPDISBLD2                                                                 */
      __IOM uint32_t AHBERR2    : 1;            /*!< AHBERR2                                                                   */
      __IOM uint32_t SETUP2     : 1;            /*!< SETUP2                                                                    */
      __IOM uint32_t OUTTKNEPDIS2 : 1;          /*!< OUTTKNEPDIS2                                                              */
      __IOM uint32_t STSPHSERCVD2 : 1;          /*!< STSPHSERCVD2                                                              */
      __IOM uint32_t BACK2BACKSETUP2 : 1;       /*!< BACK2BACKSETUP2                                                           */
            uint32_t            : 1;
      __IOM uint32_t OUTPKTERR2 : 1;            /*!< OUTPKTERR2                                                                */
      __IOM uint32_t BNAINTR2   : 1;            /*!< BNAINTR2                                                                  */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS2 : 1;            /*!< PKTDRPSTS2                                                                */
      __IOM uint32_t BBLEERR2   : 1;            /*!< BBLEERR2                                                                  */
      __IOM uint32_t NAKINTRPT2 : 1;            /*!< NAKINTRPT2                                                                */
      __IOM uint32_t NYEPINTRPT2 : 1;           /*!< NYEPINTRPT2                                                               */
      __IOM uint32_t STUPPKTRCVD2 : 1;          /*!< STUPPKTRCVD2                                                              */
            uint32_t            : 16;
    } bit;
  } DOEPINT2;
  __IM  uint32_t  RESERVED49;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPTSIZ2                                                                 */
    
    struct {
      __IOM uint32_t XFERSIZE2  : 7;            /*!< XFERSIZE2                                                                 */
            uint32_t            : 12;
      __IOM uint32_t PKTCNT2    : 1;            /*!< PKTCNT2                                                                   */
            uint32_t            : 9;
      __IOM uint32_t SUPCNT2    : 2;            /*!< SUPCNT2                                                                   */
            uint32_t            : 1;
    } bit;
  } DOEPTSIZ2;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMA2                                                                  */
    
    struct {
      __IOM uint32_t DMAADDR2   : 32;           /*!< DMAADDR2                                                                  */
    } bit;
  } DOEPDMA2;
  __IM  uint32_t  RESERVED50;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMAB2                                                                 */
    
    struct {
      __IOM uint32_t DMABUFFERADDR2 : 32;       /*!< DMABUFFERADDR2                                                            */
    } bit;
  } DOEPDMAB2;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPCTL3                                                                  */
    
    struct {
      __IM  uint32_t MPS3       : 11;           /*!< MPS3                                                                      */
            uint32_t            : 4;
      __IM  uint32_t USBACTEP3  : 1;            /*!< USBACTEP3                                                                 */
            uint32_t            : 1;
      __IM  uint32_t NAKSTS3    : 1;            /*!< NAKSTS3                                                                   */
      __IM  uint32_t EPTYPE3    : 2;            /*!< EPTYPE3                                                                   */
      __IOM uint32_t SNP3       : 1;            /*!< SNP3                                                                      */
      __IOM uint32_t STALL3     : 1;            /*!< STALL3                                                                    */
            uint32_t            : 4;
      __OM  uint32_t CNAK3      : 1;            /*!< CNAK3                                                                     */
      __OM  uint32_t DO_SNAK3   : 1;            /*!< DO_SNAK3                                                                  */
      __OM  uint32_t DO_SETD0PID3 : 1;          /*!< DO_SETD0PID3                                                              */
      __OM  uint32_t DO_SETD1PID3 : 1;          /*!< DO_SETD1PID3                                                              */
      __IM  uint32_t EPDIS3     : 1;            /*!< EPDIS3                                                                    */
      __IOM uint32_t EPENA3     : 1;            /*!< EPENA3                                                                    */
    } bit;
  } DOEPCTL3;
  __IM  uint32_t  RESERVED51;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPINT3                                                                  */
    
    struct {
      __IOM uint32_t XFERCOMPL3 : 1;            /*!< XFERCOMPL3                                                                */
      __IOM uint32_t EPDISBLD3  : 1;            /*!< EPDISBLD3                                                                 */
      __IOM uint32_t AHBERR3    : 1;            /*!< AHBERR3                                                                   */
      __IOM uint32_t SETUP3     : 1;            /*!< SETUP3                                                                    */
      __IOM uint32_t OUTTKNEPDIS3 : 1;          /*!< OUTTKNEPDIS3                                                              */
      __IOM uint32_t STSPHSERCVD3 : 1;          /*!< STSPHSERCVD3                                                              */
      __IOM uint32_t BACK2BACKSETUP3 : 1;       /*!< BACK2BACKSETUP3                                                           */
            uint32_t            : 1;
      __IOM uint32_t OUTPKTERR3 : 1;            /*!< OUTPKTERR3                                                                */
      __IOM uint32_t BNAINTR3   : 1;            /*!< BNAINTR3                                                                  */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS3 : 1;            /*!< PKTDRPSTS3                                                                */
      __IOM uint32_t BBLEERR3   : 1;            /*!< BBLEERR3                                                                  */
      __IOM uint32_t NAKINTRPT3 : 1;            /*!< NAKINTRPT3                                                                */
      __IOM uint32_t NYEPINTRPT3 : 1;           /*!< NYEPINTRPT3                                                               */
      __IOM uint32_t STUPPKTRCVD3 : 1;          /*!< STUPPKTRCVD3                                                              */
            uint32_t            : 16;
    } bit;
  } DOEPINT3;
  __IM  uint32_t  RESERVED52;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPTSIZ3                                                                 */
    
    struct {
      __IOM uint32_t XFERSIZE3  : 7;            /*!< XFERSIZE3                                                                 */
            uint32_t            : 12;
      __IOM uint32_t PKTCNT3    : 1;            /*!< PKTCNT3                                                                   */
            uint32_t            : 9;
      __IOM uint32_t SUPCNT3    : 2;            /*!< SUPCNT3                                                                   */
            uint32_t            : 1;
    } bit;
  } DOEPTSIZ3;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMA3                                                                  */
    
    struct {
      __IOM uint32_t DMAADDR3   : 32;           /*!< DMAADDR3                                                                  */
    } bit;
  } DOEPDMA3;
  __IM  uint32_t  RESERVED53;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMAB3                                                                 */
    
    struct {
      __IOM uint32_t DMABUFFERADDR3 : 32;       /*!< DMABUFFERADDR3                                                            */
    } bit;
  } DOEPDMAB3;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPCTL4                                                                  */
    
    struct {
      __IM  uint32_t MPS4       : 11;           /*!< MPS4                                                                      */
            uint32_t            : 4;
      __IM  uint32_t USBACTEP4  : 1;            /*!< USBACTEP4                                                                 */
            uint32_t            : 1;
      __IM  uint32_t NAKSTS4    : 1;            /*!< NAKSTS4                                                                   */
      __IM  uint32_t EPTYPE4    : 2;            /*!< EPTYPE4                                                                   */
      __IOM uint32_t SNP4       : 1;            /*!< SNP4                                                                      */
      __IOM uint32_t STALL4     : 1;            /*!< STALL4                                                                    */
            uint32_t            : 4;
      __OM  uint32_t CNAK4      : 1;            /*!< CNAK4                                                                     */
      __OM  uint32_t DO_SNAK4   : 1;            /*!< DO_SNAK4                                                                  */
      __OM  uint32_t DO_SETD0PID4 : 1;          /*!< DO_SETD0PID4                                                              */
      __OM  uint32_t DO_SETD1PID4 : 1;          /*!< DO_SETD1PID4                                                              */
      __IM  uint32_t EPDIS4     : 1;            /*!< EPDIS4                                                                    */
      __IOM uint32_t EPENA4     : 1;            /*!< EPENA4                                                                    */
    } bit;
  } DOEPCTL4;
  __IM  uint32_t  RESERVED54;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPINT4                                                                  */
    
    struct {
      __IOM uint32_t XFERCOMPL4 : 1;            /*!< XFERCOMPL4                                                                */
      __IOM uint32_t EPDISBLD4  : 1;            /*!< EPDISBLD4                                                                 */
      __IOM uint32_t AHBERR4    : 1;            /*!< AHBERR4                                                                   */
      __IOM uint32_t SETUP4     : 1;            /*!< SETUP4                                                                    */
      __IOM uint32_t OUTTKNEPDIS4 : 1;          /*!< OUTTKNEPDIS4                                                              */
      __IOM uint32_t STSPHSERCVD4 : 1;          /*!< STSPHSERCVD4                                                              */
      __IOM uint32_t BACK2BACKSETUP4 : 1;       /*!< BACK2BACKSETUP4                                                           */
            uint32_t            : 1;
      __IOM uint32_t OUTPKTERR4 : 1;            /*!< OUTPKTERR4                                                                */
      __IOM uint32_t BNAINTR4   : 1;            /*!< BNAINTR4                                                                  */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS4 : 1;            /*!< PKTDRPSTS4                                                                */
      __IOM uint32_t BBLEERR4   : 1;            /*!< BBLEERR4                                                                  */
      __IOM uint32_t NAKINTRPT4 : 1;            /*!< NAKINTRPT4                                                                */
      __IOM uint32_t NYEPINTRPT4 : 1;           /*!< NYEPINTRPT4                                                               */
      __IOM uint32_t STUPPKTRCVD4 : 1;          /*!< STUPPKTRCVD4                                                              */
            uint32_t            : 16;
    } bit;
  } DOEPINT4;
  __IM  uint32_t  RESERVED55;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPTSIZ4                                                                 */
    
    struct {
      __IOM uint32_t XFERSIZE4  : 7;            /*!< XFERSIZE4                                                                 */
            uint32_t            : 12;
      __IOM uint32_t PKTCNT4    : 1;            /*!< PKTCNT4                                                                   */
            uint32_t            : 9;
      __IOM uint32_t SUPCNT4    : 2;            /*!< SUPCNT4                                                                   */
            uint32_t            : 1;
    } bit;
  } DOEPTSIZ4;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMA4                                                                  */
    
    struct {
      __IOM uint32_t DMAADDR4   : 32;           /*!< DMAADDR4                                                                  */
    } bit;
  } DOEPDMA4;
  __IM  uint32_t  RESERVED56;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMAB4                                                                 */
    
    struct {
      __IOM uint32_t DMABUFFERADDR4 : 32;       /*!< DMABUFFERADDR4                                                            */
    } bit;
  } DOEPDMAB4;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPCTL5                                                                  */
    
    struct {
      __IM  uint32_t MPS5       : 11;           /*!< MPS5                                                                      */
            uint32_t            : 4;
      __IM  uint32_t USBACTEP5  : 1;            /*!< USBACTEP5                                                                 */
            uint32_t            : 1;
      __IM  uint32_t NAKSTS5    : 1;            /*!< NAKSTS5                                                                   */
      __IM  uint32_t EPTYPE5    : 2;            /*!< EPTYPE5                                                                   */
      __IOM uint32_t SNP5       : 1;            /*!< SNP5                                                                      */
      __IOM uint32_t STALL5     : 1;            /*!< STALL5                                                                    */
            uint32_t            : 4;
      __OM  uint32_t CNAK5      : 1;            /*!< CNAK5                                                                     */
      __OM  uint32_t DO_SNAK5   : 1;            /*!< DO_SNAK5                                                                  */
      __OM  uint32_t DO_SETD0PID5 : 1;          /*!< DO_SETD0PID5                                                              */
      __OM  uint32_t DO_SETD1PID5 : 1;          /*!< DO_SETD1PID5                                                              */
      __IM  uint32_t EPDIS5     : 1;            /*!< EPDIS5                                                                    */
      __IOM uint32_t EPENA5     : 1;            /*!< EPENA5                                                                    */
    } bit;
  } DOEPCTL5;
  __IM  uint32_t  RESERVED57;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPINT5                                                                  */
    
    struct {
      __IOM uint32_t XFERCOMPL5 : 1;            /*!< XFERCOMPL5                                                                */
      __IOM uint32_t EPDISBLD5  : 1;            /*!< EPDISBLD5                                                                 */
      __IOM uint32_t AHBERR5    : 1;            /*!< AHBERR5                                                                   */
      __IOM uint32_t SETUP5     : 1;            /*!< SETUP5                                                                    */
      __IOM uint32_t OUTTKNEPDIS5 : 1;          /*!< OUTTKNEPDIS5                                                              */
      __IOM uint32_t STSPHSERCVD5 : 1;          /*!< STSPHSERCVD5                                                              */
      __IOM uint32_t BACK2BACKSETUP5 : 1;       /*!< BACK2BACKSETUP5                                                           */
            uint32_t            : 1;
      __IOM uint32_t OUTPKTERR5 : 1;            /*!< OUTPKTERR5                                                                */
      __IOM uint32_t BNAINTR5   : 1;            /*!< BNAINTR5                                                                  */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS5 : 1;            /*!< PKTDRPSTS5                                                                */
      __IOM uint32_t BBLEERR5   : 1;            /*!< BBLEERR5                                                                  */
      __IOM uint32_t NAKINTRPT5 : 1;            /*!< NAKINTRPT5                                                                */
      __IOM uint32_t NYEPINTRPT5 : 1;           /*!< NYEPINTRPT5                                                               */
      __IOM uint32_t STUPPKTRCVD5 : 1;          /*!< STUPPKTRCVD5                                                              */
            uint32_t            : 16;
    } bit;
  } DOEPINT5;
  __IM  uint32_t  RESERVED58;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPTSIZ5                                                                 */
    
    struct {
      __IOM uint32_t XFERSIZE5  : 7;            /*!< XFERSIZE5                                                                 */
            uint32_t            : 12;
      __IOM uint32_t PKTCNT5    : 1;            /*!< PKTCNT5                                                                   */
            uint32_t            : 9;
      __IOM uint32_t SUPCNT5    : 2;            /*!< SUPCNT5                                                                   */
            uint32_t            : 1;
    } bit;
  } DOEPTSIZ5;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMA5                                                                  */
    
    struct {
      __IOM uint32_t DMAADDR5   : 32;           /*!< DMAADDR5                                                                  */
    } bit;
  } DOEPDMA5;
  __IM  uint32_t  RESERVED59;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMAB5                                                                 */
    
    struct {
      __IOM uint32_t DMABUFFERADDR5 : 32;       /*!< DMABUFFERADDR5                                                            */
    } bit;
  } DOEPDMAB5;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPCTL6                                                                  */
    
    struct {
      __IM  uint32_t MPS6       : 11;           /*!< MPS6                                                                      */
            uint32_t            : 4;
      __IM  uint32_t USBACTEP6  : 1;            /*!< USBACTEP6                                                                 */
            uint32_t            : 1;
      __IM  uint32_t NAKSTS6    : 1;            /*!< NAKSTS6                                                                   */
      __IM  uint32_t EPTYPE6    : 2;            /*!< EPTYPE6                                                                   */
      __IOM uint32_t SNP6       : 1;            /*!< SNP6                                                                      */
      __IOM uint32_t STALL6     : 1;            /*!< STALL6                                                                    */
            uint32_t            : 4;
      __OM  uint32_t CNAK6      : 1;            /*!< CNAK6                                                                     */
      __OM  uint32_t DO_SNAK6   : 1;            /*!< DO_SNAK6                                                                  */
      __OM  uint32_t DO_SETD0PID6 : 1;          /*!< DO_SETD0PID6                                                              */
      __OM  uint32_t DO_SETD1PID6 : 1;          /*!< DO_SETD1PID6                                                              */
      __IM  uint32_t EPDIS6     : 1;            /*!< EPDIS6                                                                    */
      __IOM uint32_t EPENA6     : 1;            /*!< EPENA6                                                                    */
    } bit;
  } DOEPCTL6;
  __IM  uint32_t  RESERVED60;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPINT6                                                                  */
    
    struct {
      __IOM uint32_t XFERCOMPL6 : 1;            /*!< XFERCOMPL6                                                                */
      __IOM uint32_t EPDISBLD6  : 1;            /*!< EPDISBLD6                                                                 */
      __IOM uint32_t AHBERR6    : 1;            /*!< AHBERR6                                                                   */
      __IOM uint32_t SETUP6     : 1;            /*!< SETUP6                                                                    */
      __IOM uint32_t OUTTKNEPDIS6 : 1;          /*!< OUTTKNEPDIS6                                                              */
      __IOM uint32_t STSPHSERCVD6 : 1;          /*!< STSPHSERCVD6                                                              */
      __IOM uint32_t BACK2BACKSETUP6 : 1;       /*!< BACK2BACKSETUP6                                                           */
            uint32_t            : 1;
      __IOM uint32_t OUTPKTERR6 : 1;            /*!< OUTPKTERR6                                                                */
      __IOM uint32_t BNAINTR6   : 1;            /*!< BNAINTR6                                                                  */
            uint32_t            : 1;
      __IOM uint32_t PKTDRPSTS6 : 1;            /*!< PKTDRPSTS6                                                                */
      __IOM uint32_t BBLEERR6   : 1;            /*!< BBLEERR6                                                                  */
      __IOM uint32_t NAKINTRPT6 : 1;            /*!< NAKINTRPT6                                                                */
      __IOM uint32_t NYEPINTRPT6 : 1;           /*!< NYEPINTRPT6                                                               */
      __IOM uint32_t STUPPKTRCVD6 : 1;          /*!< STUPPKTRCVD6                                                              */
            uint32_t            : 16;
    } bit;
  } DOEPINT6;
  __IM  uint32_t  RESERVED61;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPTSIZ6                                                                 */
    
    struct {
      __IOM uint32_t XFERSIZE6  : 7;            /*!< XFERSIZE6                                                                 */
            uint32_t            : 12;
      __IOM uint32_t PKTCNT6    : 1;            /*!< PKTCNT6                                                                   */
            uint32_t            : 9;
      __IOM uint32_t SUPCNT6    : 2;            /*!< SUPCNT6                                                                   */
            uint32_t            : 1;
    } bit;
  } DOEPTSIZ6;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMA6                                                                  */
    
    struct {
      __IOM uint32_t DMAADDR6   : 32;           /*!< DMAADDR6                                                                  */
    } bit;
  } DOEPDMA6;
  __IM  uint32_t  RESERVED62;
  
  union {
    __IOM uint32_t reg;                         /*!< DOEPDMAB6                                                                 */
    
    struct {
      __IOM uint32_t DMABUFFERADDR6 : 32;       /*!< DMABUFFERADDR6                                                            */
    } bit;
  } DOEPDMAB6;
  __IM  uint32_t  RESERVED63[136];
  
  union {
    __IOM uint32_t reg;                         /*!< PCGCCTL                                                                   */
    
    struct {
      __IOM uint32_t STOPPCLK   : 1;            /*!< STOPPCLK                                                                  */
      __IOM uint32_t GATEHCLK   : 1;            /*!< GATEHCLK                                                                  */
      __IOM uint32_t PWRCLMP    : 1;            /*!< PWRCLMP                                                                   */
      __IOM uint32_t RSTPDWNMODULE : 1;         /*!< RSTPDWNMODULE                                                             */
            uint32_t            : 2;
      __IM  uint32_t PHYSLEEP   : 1;            /*!< PHYSLEEP                                                                  */
      __IM  uint32_t L1SUSPENDED : 1;           /*!< L1SUSPENDED                                                               */
      __IOM uint32_t RESETAFTERSUSP : 1;        /*!< RESETAFTERSUSP                                                            */
            uint32_t            : 23;
    } bit;
  } PCGCCTL;
} USB0_Type;                                    /*!< Size = 3588 (0xe04)                                                       */



/* =========================================================================================================================== */
/* ================                                        USB_DEVICE                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Full-speed USB Serial/JTAG Controller (USB_DEVICE)
  */

typedef struct {                                /*!< USB_DEVICE Structure                                                      */
  
  union {
    __IOM uint32_t reg;                         /*!< Endpoint 1 FIFO register                                                  */
    
    struct {
      __IOM uint32_t RDWR_BYTE  : 8;            /*!< Write and read byte data to/from UART Tx/Rx FIFO through this
                                                     field. When USB_DEVICE_SERIAL_IN_EMPTY_INT is set, then
                                                     user can write data (up to 64 bytes) into UART Tx FIFO.
                                                     When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT is set, user can
                                                     check USB_DEVICE_OUT_EP1_WR_ADDR USB_DEVICE_OUT_EP0_RD_ADDR
                                                     to know how many data is received, then read data from
                                                     UART Rx FIFO.                                                             */
            uint32_t            : 24;
    } bit;
  } EP1;
  
  union {
    __IOM uint32_t reg;                         /*!< Endpoint 1 configure and status register                                  */
    
    struct {
      __OM  uint32_t WR_DONE    : 1;            /*!< Set this bit to indicate writing byte data to UART Tx FIFO is
                                                     done.                                                                     */
      __IM  uint32_t SERIAL_IN_EP_DATA_FREE : 1;/*!< 1'b1: Indicate UART Tx FIFO is not full and can write data into
                                                     in. After writing USB_DEVICE_WR_DONE, this bit would be
                                                     0 until data in UART Tx FIFO is read by USB Host.                         */
      __IM  uint32_t SERIAL_OUT_EP_DATA_AVAIL : 1;/*!< 1'b1: Indicate there is data in UART Rx FIFO.                           */
            uint32_t            : 29;
    } bit;
  } EP1_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Raw status interrupt                                                      */
    
    struct {
      __IOM uint32_t JTAG_IN_FLUSH_INT_RAW : 1; /*!< The raw interrupt bit turns to high level when flush cmd is
                                                     received for IN endpoint 2 of JTAG.                                       */
      __IOM uint32_t SOF_INT_RAW : 1;           /*!< The raw interrupt bit turns to high level when SOF frame is
                                                     received.                                                                 */
      __IOM uint32_t SERIAL_OUT_RECV_PKT_INT_RAW : 1;/*!< The raw interrupt bit turns to high level when Serial Port OUT
                                                     Endpoint received one packet.                                             */
      __IOM uint32_t SERIAL_IN_EMPTY_INT_RAW : 1;/*!< The raw interrupt bit turns to high level when Serial Port IN
                                                     Endpoint is empty.                                                        */
      __IOM uint32_t PID_ERR_INT_RAW : 1;       /*!< The raw interrupt bit turns to high level when pid error is
                                                     detected.                                                                 */
      __IOM uint32_t CRC5_ERR_INT_RAW : 1;      /*!< The raw interrupt bit turns to high level when CRC5 error is
                                                     detected.                                                                 */
      __IOM uint32_t CRC16_ERR_INT_RAW : 1;     /*!< The raw interrupt bit turns to high level when CRC16 error is
                                                     detected.                                                                 */
      __IOM uint32_t STUFF_ERR_INT_RAW : 1;     /*!< The raw interrupt bit turns to high level when stuff error is
                                                     detected.                                                                 */
      __IOM uint32_t IN_TOKEN_REC_IN_EP1_INT_RAW : 1;/*!< The raw interrupt bit turns to high level when IN token for
                                                     IN endpoint 1 is received.                                                */
      __IOM uint32_t USB_BUS_RESET_INT_RAW : 1; /*!< The raw interrupt bit turns to high level when usb bus reset
                                                     is detected.                                                              */
      __IOM uint32_t OUT_EP1_ZERO_PAYLOAD_INT_RAW : 1;/*!< The raw interrupt bit turns to high level when OUT endpoint
                                                     1 received packet with zero palyload.                                     */
      __IOM uint32_t OUT_EP2_ZERO_PAYLOAD_INT_RAW : 1;/*!< The raw interrupt bit turns to high level when OUT endpoint
                                                     2 received packet with zero palyload.                                     */
            uint32_t            : 20;
    } bit;
  } INT_RAW;
  
  union {
    __IOM uint32_t reg;                         /*!< Masked interrupt                                                          */
    
    struct {
      __IM  uint32_t JTAG_IN_FLUSH_INT_ST : 1;  /*!< The raw interrupt status bit for the USB_DEVICE_JTAG_IN_FLUSH_INT
                                                     interrupt.                                                                */
      __IM  uint32_t SOF_INT_ST : 1;            /*!< The raw interrupt status bit for the USB_DEVICE_SOF_INT interrupt.        */
      __IM  uint32_t SERIAL_OUT_RECV_PKT_INT_ST : 1;/*!< The raw interrupt status bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT
                                                     interrupt.                                                                */
      __IM  uint32_t SERIAL_IN_EMPTY_INT_ST : 1;/*!< The raw interrupt status bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT
                                                     interrupt.                                                                */
      __IM  uint32_t PID_ERR_INT_ST : 1;        /*!< The raw interrupt status bit for the USB_DEVICE_PID_ERR_INT
                                                     interrupt.                                                                */
      __IM  uint32_t CRC5_ERR_INT_ST : 1;       /*!< The raw interrupt status bit for the USB_DEVICE_CRC5_ERR_INT
                                                     interrupt.                                                                */
      __IM  uint32_t CRC16_ERR_INT_ST : 1;      /*!< The raw interrupt status bit for the USB_DEVICE_CRC16_ERR_INT
                                                     interrupt.                                                                */
      __IM  uint32_t STUFF_ERR_INT_ST : 1;      /*!< The raw interrupt status bit for the USB_DEVICE_STUFF_ERR_INT
                                                     interrupt.                                                                */
      __IM  uint32_t IN_TOKEN_REC_IN_EP1_INT_ST : 1;/*!< The raw interrupt status bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT
                                                     interrupt.                                                                */
      __IM  uint32_t USB_BUS_RESET_INT_ST : 1;  /*!< The raw interrupt status bit for the USB_DEVICE_USB_BUS_RESET_INT
                                                     interrupt.                                                                */
      __IM  uint32_t OUT_EP1_ZERO_PAYLOAD_INT_ST : 1;/*!< The raw interrupt status bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT
                                                     interrupt.                                                                */
      __IM  uint32_t OUT_EP2_ZERO_PAYLOAD_INT_ST : 1;/*!< The raw interrupt status bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT
                                                     interrupt.                                                                */
            uint32_t            : 20;
    } bit;
  } INT_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt enable bits                                                     */
    
    struct {
      __IOM uint32_t JTAG_IN_FLUSH_INT_ENA : 1; /*!< The interrupt enable bit for the USB_DEVICE_JTAG_IN_FLUSH_INT
                                                     interrupt.                                                                */
      __IOM uint32_t SOF_INT_ENA : 1;           /*!< The interrupt enable bit for the USB_DEVICE_SOF_INT interrupt.            */
      __IOM uint32_t SERIAL_OUT_RECV_PKT_INT_ENA : 1;/*!< The interrupt enable bit for the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT
                                                     interrupt.                                                                */
      __IOM uint32_t SERIAL_IN_EMPTY_INT_ENA : 1;/*!< The interrupt enable bit for the USB_DEVICE_SERIAL_IN_EMPTY_INT
                                                     interrupt.                                                                */
      __IOM uint32_t PID_ERR_INT_ENA : 1;       /*!< The interrupt enable bit for the USB_DEVICE_PID_ERR_INT interrupt.        */
      __IOM uint32_t CRC5_ERR_INT_ENA : 1;      /*!< The interrupt enable bit for the USB_DEVICE_CRC5_ERR_INT interrupt.       */
      __IOM uint32_t CRC16_ERR_INT_ENA : 1;     /*!< The interrupt enable bit for the USB_DEVICE_CRC16_ERR_INT interrupt.      */
      __IOM uint32_t STUFF_ERR_INT_ENA : 1;     /*!< The interrupt enable bit for the USB_DEVICE_STUFF_ERR_INT interrupt.      */
      __IOM uint32_t IN_TOKEN_REC_IN_EP1_INT_ENA : 1;/*!< The interrupt enable bit for the USB_DEVICE_IN_TOKEN_REC_IN_EP1_INT
                                                     interrupt.                                                                */
      __IOM uint32_t USB_BUS_RESET_INT_ENA : 1; /*!< The interrupt enable bit for the USB_DEVICE_USB_BUS_RESET_INT
                                                     interrupt.                                                                */
      __IOM uint32_t OUT_EP1_ZERO_PAYLOAD_INT_ENA : 1;/*!< The interrupt enable bit for the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT
                                                     interrupt.                                                                */
      __IOM uint32_t OUT_EP2_ZERO_PAYLOAD_INT_ENA : 1;/*!< The interrupt enable bit for the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT
                                                     interrupt.                                                                */
            uint32_t            : 20;
    } bit;
  } INT_ENA;
  
  union {
    __IOM uint32_t reg;                         /*!< Interrupt clear bits                                                      */
    
    struct {
      __OM  uint32_t JTAG_IN_FLUSH_INT_CLR : 1; /*!< Set this bit to clear the USB_DEVICE_JTAG_IN_FLUSH_INT interrupt.         */
      __OM  uint32_t SOF_INT_CLR : 1;           /*!< Set this bit to clear the USB_DEVICE_JTAG_SOF_INT interrupt.              */
      __OM  uint32_t SERIAL_OUT_RECV_PKT_INT_CLR : 1;/*!< Set this bit to clear the USB_DEVICE_SERIAL_OUT_RECV_PKT_INT
                                                     interrupt.                                                                */
      __OM  uint32_t SERIAL_IN_EMPTY_INT_CLR : 1;/*!< Set this bit to clear the USB_DEVICE_SERIAL_IN_EMPTY_INT interrupt.      */
      __OM  uint32_t PID_ERR_INT_CLR : 1;       /*!< Set this bit to clear the USB_DEVICE_PID_ERR_INT interrupt.               */
      __OM  uint32_t CRC5_ERR_INT_CLR : 1;      /*!< Set this bit to clear the USB_DEVICE_CRC5_ERR_INT interrupt.              */
      __OM  uint32_t CRC16_ERR_INT_CLR : 1;     /*!< Set this bit to clear the USB_DEVICE_CRC16_ERR_INT interrupt.             */
      __OM  uint32_t STUFF_ERR_INT_CLR : 1;     /*!< Set this bit to clear the USB_DEVICE_STUFF_ERR_INT interrupt.             */
      __OM  uint32_t IN_TOKEN_REC_IN_EP1_INT_CLR : 1;/*!< Set this bit to clear the USB_DEVICE_IN_TOKEN_IN_EP1_INT interrupt.  */
      __OM  uint32_t USB_BUS_RESET_INT_CLR : 1; /*!< Set this bit to clear the USB_DEVICE_USB_BUS_RESET_INT interrupt.         */
      __OM  uint32_t OUT_EP1_ZERO_PAYLOAD_INT_CLR : 1;/*!< Set this bit to clear the USB_DEVICE_OUT_EP1_ZERO_PAYLOAD_INT
                                                     interrupt.                                                                */
      __OM  uint32_t OUT_EP2_ZERO_PAYLOAD_INT_CLR : 1;/*!< Set this bit to clear the USB_DEVICE_OUT_EP2_ZERO_PAYLOAD_INT
                                                     interrupt.                                                                */
            uint32_t            : 20;
    } bit;
  } INT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< Configure 0 register                                                      */
    
    struct {
      __IOM uint32_t PHY_SEL    : 1;            /*!< Select internal/external PHY                                              */
      __IOM uint32_t EXCHG_PINS_OVERRIDE : 1;   /*!< Enable software control USB D+ D- exchange                                */
      __IOM uint32_t EXCHG_PINS : 1;            /*!< USB D+ D- exchange                                                        */
      __IOM uint32_t VREFH      : 2;            /*!< Control single-end input high threshold,1.76V to 2V, step 80mV            */
      __IOM uint32_t VREFL      : 2;            /*!< Control single-end input low threshold,0.8V to 1.04V, step 80mV           */
      __IOM uint32_t VREF_OVERRIDE : 1;         /*!< Enable software control input threshold                                   */
      __IOM uint32_t PAD_PULL_OVERRIDE : 1;     /*!< Enable software control USB D+ D- pullup pulldown                         */
      __IOM uint32_t DP_PULLUP  : 1;            /*!< Control USB D+ pull up.                                                   */
      __IOM uint32_t DP_PULLDOWN : 1;           /*!< Control USB D+ pull down.                                                 */
      __IOM uint32_t DM_PULLUP  : 1;            /*!< Control USB D- pull up.                                                   */
      __IOM uint32_t DM_PULLDOWN : 1;           /*!< Control USB D- pull down.                                                 */
      __IOM uint32_t PULLUP_VALUE : 1;          /*!< Control pull up value.                                                    */
      __IOM uint32_t USB_PAD_ENABLE : 1;        /*!< Enable USB pad function.                                                  */
      __IOM uint32_t PHY_TX_EDGE_SEL : 1;       /*!< 0: TX output at clock negedge. 1: Tx output at clock posedge.             */
      __IOM uint32_t USB_JTAG_BRIDGE_EN : 1;    /*!< Set this bit usb_jtag, the connection between usb_jtag and internal
                                                     JTAG is disconnected, and MTMS, MTDI, MTCK are output through
                                                     GPIO Matrix, MTDO is input through GPIO Matrix.                           */
            uint32_t            : 15;
    } bit;
  } CONF0;
  
  union {
    __IOM uint32_t reg;                         /*!< USB Internal PHY test register                                            */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< Enable test of the USB pad                                                */
      __IOM uint32_t USB_OE     : 1;            /*!< USB pad oen in test                                                       */
      __IOM uint32_t TX_DP      : 1;            /*!< USB D+ tx value in test                                                   */
      __IOM uint32_t TX_DM      : 1;            /*!< USB D- tx value in test                                                   */
      __IM  uint32_t RX_RCV     : 1;            /*!< USB differential rx value in test                                         */
      __IM  uint32_t RX_DP      : 1;            /*!< USB D+ rx value in test                                                   */
      __IM  uint32_t RX_DM      : 1;            /*!< USB D- rx value in test                                                   */
            uint32_t            : 25;
    } bit;
  } TEST;
  
  union {
    __IOM uint32_t reg;                         /*!< USB-JTAG FIFO status                                                      */
    
    struct {
      __IM  uint32_t IN_FIFO_CNT : 2;           /*!< JTAT in fifo counter.                                                     */
      __IM  uint32_t IN_FIFO_EMPTY : 1;         /*!< 1: JTAG in fifo is empty.                                                 */
      __IM  uint32_t IN_FIFO_FULL : 1;          /*!< 1: JTAG in fifo is full.                                                  */
      __IM  uint32_t OUT_FIFO_CNT : 2;          /*!< JTAT out fifo counter.                                                    */
      __IM  uint32_t OUT_FIFO_EMPTY : 1;        /*!< 1: JTAG out fifo is empty.                                                */
      __IM  uint32_t OUT_FIFO_FULL : 1;         /*!< 1: JTAG out fifo is full.                                                 */
      __IOM uint32_t IN_FIFO_RESET : 1;         /*!< Write 1 to reset JTAG in fifo.                                            */
      __IOM uint32_t OUT_FIFO_RESET : 1;        /*!< Write 1 to reset JTAG out fifo.                                           */
            uint32_t            : 22;
    } bit;
  } JFIFO_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< SOF frame number                                                          */
    
    struct {
      __IM  uint32_t SOF_FRAME_INDEX : 11;      /*!< Frame index of received SOF frame.                                        */
            uint32_t            : 21;
    } bit;
  } FRAM_NUM;
  
  union {
    __IOM uint32_t reg;                         /*!< IN Endpoint 0 status                                                      */
    
    struct {
      __IM  uint32_t IN_EP0_STATE : 2;          /*!< State of IN Endpoint 0.                                                   */
      __IM  uint32_t IN_EP0_WR_ADDR : 7;        /*!< Write data address of IN endpoint 0.                                      */
      __IM  uint32_t IN_EP0_RD_ADDR : 7;        /*!< Read data address of IN endpoint 0.                                       */
            uint32_t            : 16;
    } bit;
  } IN_EP0_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< IN Endpoint 1 status                                                      */
    
    struct {
      __IM  uint32_t IN_EP1_STATE : 2;          /*!< State of IN Endpoint 1.                                                   */
      __IM  uint32_t IN_EP1_WR_ADDR : 7;        /*!< Write data address of IN endpoint 1.                                      */
      __IM  uint32_t IN_EP1_RD_ADDR : 7;        /*!< Read data address of IN endpoint 1.                                       */
            uint32_t            : 16;
    } bit;
  } IN_EP1_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< IN Endpoint 2 status                                                      */
    
    struct {
      __IM  uint32_t IN_EP2_STATE : 2;          /*!< State of IN Endpoint 2.                                                   */
      __IM  uint32_t IN_EP2_WR_ADDR : 7;        /*!< Write data address of IN endpoint 2.                                      */
      __IM  uint32_t IN_EP2_RD_ADDR : 7;        /*!< Read data address of IN endpoint 2.                                       */
            uint32_t            : 16;
    } bit;
  } IN_EP2_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< IN Endpoint 3 status                                                      */
    
    struct {
      __IM  uint32_t IN_EP3_STATE : 2;          /*!< State of IN Endpoint 3.                                                   */
      __IM  uint32_t IN_EP3_WR_ADDR : 7;        /*!< Write data address of IN endpoint 3.                                      */
      __IM  uint32_t IN_EP3_RD_ADDR : 7;        /*!< Read data address of IN endpoint 3.                                       */
            uint32_t            : 16;
    } bit;
  } IN_EP3_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< OUT Endpoint 0 status                                                     */
    
    struct {
      __IM  uint32_t OUT_EP0_STATE : 2;         /*!< State of OUT Endpoint 0.                                                  */
      __IM  uint32_t OUT_EP0_WR_ADDR : 7;       /*!< Write data address of OUT endpoint 0. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT
                                                     is detected, there are USB_DEVICE_OUT_EP0_WR_ADDR-2 bytes
                                                     data in OUT EP0.                                                          */
      __IM  uint32_t OUT_EP0_RD_ADDR : 7;       /*!< Read data address of OUT endpoint 0.                                      */
            uint32_t            : 16;
    } bit;
  } OUT_EP0_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< OUT Endpoint 1 status                                                     */
    
    struct {
      __IM  uint32_t OUT_EP1_STATE : 2;         /*!< State of OUT Endpoint 1.                                                  */
      __IM  uint32_t OUT_EP1_WR_ADDR : 7;       /*!< Write data address of OUT endpoint 1. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT
                                                     is detected, there are USB_DEVICE_OUT_EP1_WR_ADDR-2 bytes
                                                     data in OUT EP1.                                                          */
      __IM  uint32_t OUT_EP1_RD_ADDR : 7;       /*!< Read data address of OUT endpoint 1.                                      */
      __IM  uint32_t OUT_EP1_REC_DATA_CNT : 7;  /*!< Data count in OUT endpoint 1 when one packet is received.                 */
            uint32_t            : 9;
    } bit;
  } OUT_EP1_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< OUT Endpoint 2 status                                                     */
    
    struct {
      __IM  uint32_t OUT_EP2_STATE : 2;         /*!< State of OUT Endpoint 2.                                                  */
      __IM  uint32_t OUT_EP2_WR_ADDR : 7;       /*!< Write data address of OUT endpoint 2. When USB_DEVICE_SERIAL_OUT_RECV_PKT_INT
                                                     is detected, there are USB_DEVICE_OUT_EP2_WR_ADDR-2 bytes
                                                     data in OUT EP2.                                                          */
      __IM  uint32_t OUT_EP2_RD_ADDR : 7;       /*!< Read data address of OUT endpoint 2.                                      */
            uint32_t            : 16;
    } bit;
  } OUT_EP2_ST;
  
  union {
    __IOM uint32_t reg;                         /*!< MISC register                                                             */
    
    struct {
      __IOM uint32_t CLK_EN     : 1;            /*!< 1'h1: Force clock on for register. 1'h0: Support clock only
                                                     when application writes registers.                                        */
            uint32_t            : 31;
    } bit;
  } MISC_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< Power control                                                             */
    
    struct {
      __IOM uint32_t USB_MEM_PD : 1;            /*!< 1: power down usb memory.                                                 */
      __IOM uint32_t USB_MEM_CLK_EN : 1;        /*!< 1: Force clock on for usb memory.                                         */
            uint32_t            : 30;
    } bit;
  } MEM_CONF;
  __IM  uint32_t  RESERVED[13];
  
  union {
    __IOM uint32_t reg;                         /*!< Version control register                                                  */
    
    struct {
      __IOM uint32_t DATE       : 32;           /*!< register version.                                                         */
    } bit;
  } DATE;
} USB_DEVICE_Type;                              /*!< Size = 132 (0x84)                                                         */



/* =========================================================================================================================== */
/* ================                                         USB_WRAP                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief USB_WRAP Peripheral (USB_WRAP)
  */

typedef struct {                                /*!< USB_WRAP Structure                                                        */
  
  union {
    __IOM uint32_t reg;                         /*!< USB OTG Wrapper Configure Register                                        */
    
    struct {
      __IOM uint32_t SRP_SESSEND_OVERRIDE : 1;  /*!< This bit is used to enable the software over-ride of srp session
                                                     end signal. 1'b0: the signal is controlled by the chip
                                                     input. 1'b1: the signal is controlled by the software.                    */
      __IOM uint32_t SRP_SESSEND_VALUE : 1;     /*!< Software over-ride value of srp session end signal.                       */
      __IOM uint32_t PHY_SEL    : 1;            /*!< Select internal external PHY. 1'b0: Select internal PHY. 1'b1:
                                                     Select external PHY.                                                      */
      __IOM uint32_t DFIFO_FORCE_PD : 1;        /*!< Force the dfifo to go into low power mode. The data in dfifo
                                                     will not lost.                                                            */
      __IOM uint32_t DBNCE_FLTR_BYPASS : 1;     /*!< Bypass Debounce filters for avalid,bvalid,vbusvalid,session
                                                     end, id signals                                                           */
      __IOM uint32_t EXCHG_PINS_OVERRIDE : 1;   /*!< Enable software controlle USB D+ D- exchange                              */
      __IOM uint32_t EXCHG_PINS : 1;            /*!< USB D+ D- exchange. 1'b0: don't change. 1'b1: exchange D+ D-              */
      __IOM uint32_t VREFH      : 2;            /*!< Control single-end input high threshold,1.76V to 2V, step 80mV            */
      __IOM uint32_t VREFL      : 2;            /*!< Control single-end input low threshold,0.8V to 1.04V, step 80mV           */
      __IOM uint32_t VREF_OVERRIDE : 1;         /*!< Enable software controlle input threshold                                 */
      __IOM uint32_t PAD_PULL_OVERRIDE : 1;     /*!< Enable software controlle USB D+ D- pullup pulldown                       */
      __IOM uint32_t DP_PULLUP  : 1;            /*!< Controlle USB D+ pullup                                                   */
      __IOM uint32_t DP_PULLDOWN : 1;           /*!< Controlle USB D+ pulldown                                                 */
      __IOM uint32_t DM_PULLUP  : 1;            /*!< Controlle USB D+ pullup                                                   */
      __IOM uint32_t DM_PULLDOWN : 1;           /*!< Controlle USB D+ pulldown                                                 */
      __IOM uint32_t PULLUP_VALUE : 1;          /*!< Controlle pullup value. 1'b0: typical value is 2.4K. 1'b1: typical
                                                     value is 1.2K.                                                            */
      __IOM uint32_t USB_PAD_ENABLE : 1;        /*!< Enable USB pad function                                                   */
      __IOM uint32_t AHB_CLK_FORCE_ON : 1;      /*!< Force ahb clock always on                                                 */
      __IOM uint32_t PHY_CLK_FORCE_ON : 1;      /*!< Force phy clock always on                                                 */
      __IOM uint32_t PHY_TX_EDGE_SEL : 1;       /*!< Select phy tx signal output clock edge. 1'b0: negedge. 1'b1:
                                                     posedge.                                                                  */
      __IOM uint32_t DFIFO_FORCE_PU : 1;        /*!< Disable the dfifo to go into low power mode. The data in dfifo
                                                     will not lost.                                                            */
            uint32_t            : 8;
      __IOM uint32_t CLK_EN     : 1;            /*!< Disable auto clock gating of CSR registers                                */
    } bit;
  } OTG_CONF;
  
  union {
    __IOM uint32_t reg;                         /*!< USB Internal PHY Testing Register                                         */
    
    struct {
      __IOM uint32_t TEST_ENABLE : 1;           /*!< Enable test of the USB pad                                                */
      __IOM uint32_t TEST_USB_OE : 1;           /*!< USB pad oen in test                                                       */
      __IOM uint32_t TEST_TX_DP : 1;            /*!< USB D+ tx value in test                                                   */
      __IOM uint32_t TEST_TX_DM : 1;            /*!< USB D- tx value in test                                                   */
      __IM  uint32_t TEST_RX_RCV : 1;           /*!< USB differential rx value in test                                         */
      __IM  uint32_t TEST_RX_DP : 1;            /*!< USB D+ rx value in test                                                   */
      __IM  uint32_t TEST_RX_DM : 1;            /*!< USB D- rx value in test                                                   */
            uint32_t            : 25;
    } bit;
  } TEST_CONF;
  __IM  uint32_t  RESERVED[253];
  
  union {
    __IOM uint32_t reg;                         /*!< Version Control Register                                                  */
    
    struct {
      __IOM uint32_t USB_WRAP_DATE : 32;        /*!< Date register                                                             */
    } bit;
  } DATE;
} USB_WRAP_Type;                                /*!< Size = 1024 (0x400)                                                       */



/* =========================================================================================================================== */
/* ================                                            WCL                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief WCL Peripheral (WCL)
  */

typedef struct {                                /*!< WCL Structure                                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 1 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_1_ADDR : 32;  /*!< Core_0 Entry 1 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_0_ENTRY_1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 2 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_2_ADDR : 32;  /*!< Core_0 Entry 2 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_0_ENTRY_2_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 3 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_3_ADDR : 32;  /*!< Core_0 Entry 3 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_0_ENTRY_3_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 4 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_4_ADDR : 32;  /*!< Core_0 Entry 4 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_0_ENTRY_4_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 5 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_5_ADDR : 32;  /*!< Core_0 Entry 5 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_0_ENTRY_5_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 6 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_6_ADDR : 32;  /*!< Core_0 Entry 6 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_0_ENTRY_6_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 7 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_7_ADDR : 32;  /*!< Core_0 Entry 7 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_0_ENTRY_7_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 8 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_8_ADDR : 32;  /*!< Core_0 Entry 8 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_0_ENTRY_8_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 9 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_9_ADDR : 32;  /*!< Core_0 Entry 9 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_0_ENTRY_9_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 10 address configuration Register                            */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_10_ADDR : 32; /*!< Core_0 Entry 10 address from WORLD1 to WORLD0                             */
    } bit;
  } Core_0_ENTRY_10_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 11 address configuration Register                            */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_11_ADDR : 32; /*!< Core_0 Entry 11 address from WORLD1 to WORLD0                             */
    } bit;
  } Core_0_ENTRY_11_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 12 address configuration Register                            */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_12_ADDR : 32; /*!< Core_0 Entry 12 address from WORLD1 to WORLD0                             */
    } bit;
  } Core_0_ENTRY_12_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry 13 address configuration Register                            */
    
    struct {
      __IOM uint32_t CORE_0_ENTRY_13_ADDR : 32; /*!< Core_0 Entry 13 address from WORLD1 to WORLD0                             */
    } bit;
  } Core_0_ENTRY_13_ADDR;
  __IM  uint32_t  RESERVED[18];
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Entry check configuration Register                                 */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CORE_0_ENTRY_CHECK : 13;   /*!< This filed is used to enable entry address check                          */
            uint32_t            : 18;
    } bit;
  } Core_0_ENTRY_CHECK;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 1                                */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_1 : 1;   /*!< This bit is used to confirm world before enter entry 1                    */
      __IOM uint32_t CORE_0_FROM_ENTRY_1 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     1                                                                         */
      __IOM uint32_t CORE_0_CURRENT_1 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 1                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 2                                */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_2 : 1;   /*!< This bit is used to confirm world before enter entry 2                    */
      __IOM uint32_t CORE_0_FROM_ENTRY_2 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     2                                                                         */
      __IOM uint32_t CORE_0_CURRENT_2 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 2                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE2;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 3                                */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_3 : 1;   /*!< This bit is used to confirm world before enter entry 3                    */
      __IOM uint32_t CORE_0_FROM_ENTRY_3 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     3                                                                         */
      __IOM uint32_t CORE_0_CURRENT_3 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 3                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE3;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 4                                */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_4 : 1;   /*!< This bit is used to confirm world before enter entry 4                    */
      __IOM uint32_t CORE_0_FROM_ENTRY_4 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     4                                                                         */
      __IOM uint32_t CORE_0_CURRENT_4 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 4                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE4;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 5                                */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_5 : 1;   /*!< This bit is used to confirm world before enter entry 5                    */
      __IOM uint32_t CORE_0_FROM_ENTRY_5 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     5                                                                         */
      __IOM uint32_t CORE_0_CURRENT_5 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 5                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE5;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 6                                */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_6 : 1;   /*!< This bit is used to confirm world before enter entry 6                    */
      __IOM uint32_t CORE_0_FROM_ENTRY_6 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     6                                                                         */
      __IOM uint32_t CORE_0_CURRENT_6 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 6                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE6;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 7                                */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_7 : 1;   /*!< This bit is used to confirm world before enter entry 7                    */
      __IOM uint32_t CORE_0_FROM_ENTRY_7 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     7                                                                         */
      __IOM uint32_t CORE_0_CURRENT_7 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 7                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE7;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 8                                */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_8 : 1;   /*!< This bit is used to confirm world before enter entry 8                    */
      __IOM uint32_t CORE_0_FROM_ENTRY_8 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     8                                                                         */
      __IOM uint32_t CORE_0_CURRENT_8 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 8                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE8;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 9                                */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_9 : 1;   /*!< This bit is used to confirm world before enter entry 9                    */
      __IOM uint32_t CORE_0_FROM_ENTRY_9 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     9                                                                         */
      __IOM uint32_t CORE_0_CURRENT_9 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 9                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE9;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 10                               */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_10 : 1;  /*!< This bit is used to confirm world before enter entry 10                   */
      __IOM uint32_t CORE_0_FROM_ENTRY_10 : 4;  /*!< This filed is used to confirm in which entry before enter entry
                                                     10                                                                        */
      __IOM uint32_t CORE_0_CURRENT_10 : 1;     /*!< This bit is used to confirm whether the current state is in
                                                     entry 10                                                                  */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE10;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 11                               */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_11 : 1;  /*!< This bit is used to confirm world before enter entry 11                   */
      __IOM uint32_t CORE_0_FROM_ENTRY_11 : 4;  /*!< This filed is used to confirm in which entry before enter entry
                                                     11                                                                        */
      __IOM uint32_t CORE_0_CURRENT_11 : 1;     /*!< This bit is used to confirm whether the current state is in
                                                     entry 11                                                                  */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE11;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 12                               */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_12 : 1;  /*!< This bit is used to confirm world before enter entry 12                   */
      __IOM uint32_t CORE_0_FROM_ENTRY_12 : 4;  /*!< This filed is used to confirm in which entry before enter entry
                                                     12                                                                        */
      __IOM uint32_t CORE_0_CURRENT_12 : 1;     /*!< This bit is used to confirm whether the current state is in
                                                     entry 12                                                                  */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE12;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 13                               */
    
    struct {
      __IOM uint32_t CORE_0_FROM_WORLD_13 : 1;  /*!< This bit is used to confirm world before enter entry 13                   */
      __IOM uint32_t CORE_0_FROM_ENTRY_13 : 4;  /*!< This filed is used to confirm in which entry before enter entry
                                                     13                                                                        */
      __IOM uint32_t CORE_0_CURRENT_13 : 1;     /*!< This bit is used to confirm whether the current state is in
                                                     entry 13                                                                  */
            uint32_t            : 26;
    } bit;
  } Core_0_STATUSTABLE13;
  __IM  uint32_t  RESERVED1[18];
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of statustable current                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CORE_0_STATUSTABLE_CURRENT : 13;/*!< This field is used to quickly read and rewrite the current field
                                                     of all STATUSTABLE registers,for example,bit 1 represents
                                                     the current field of STATUSTABLE1,bit2 represents the current
                                                     field of STATUSTABLE2                                                     */
            uint32_t            : 18;
    } bit;
  } Core_0_STATUSTABLE_CURRENT;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear writer_buffer write address configuration register                  */
    
    struct {
      __IOM uint32_t CORE_0_MESSAGE_ADDR : 32;  /*!< This field is used to set address that need to write when enter
                                                     WORLD0                                                                    */
    } bit;
  } Core_0_MESSAGE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear writer_buffer write number configuration register                   */
    
    struct {
      __IOM uint32_t CORE_0_MESSAGE_MAX : 4;    /*!< This filed is used to set the max value of clear write_buffer             */
            uint32_t            : 28;
    } bit;
  } Core_0_MESSAGE_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear writer_buffer status register                                       */
    
    struct {
      __IM  uint32_t CORE_0_MESSAGE_MATCH : 1;  /*!< This bit indicates whether the check is successful                        */
      __IM  uint32_t CORE_0_MESSAGE_EXPECT : 4; /*!< This field indicates the data to be written next time                     */
      __IM  uint32_t CORE_0_MESSAGE_DATAPHASE : 1;/*!< If this bit is 1, it means that is checking clear write_buffer
                                                     operation,and is checking data                                            */
      __IM  uint32_t CORE_0_MESSAGE_ADDRESSPHASE : 1;/*!< If this bit is 1, it means that is checking clear write_buffer
                                                     operation,and is checking address.                                        */
            uint32_t            : 25;
    } bit;
  } Core_0_MESSAGE_PHASE;
  __IM  uint32_t  RESERVED2[13];
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 trigger address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_0_WORLD_TRIGGER_ADDR : 32;/*!< This field is used to configure the entry address from WORLD0
                                                     to WORLD1,when the CPU executes to this address,switch
                                                     to WORLD1                                                                 */
    } bit;
  } Core_0_World_TRIGGER_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 prepare world configuration Register                               */
    
    struct {
      __IOM uint32_t CORE_0_WORLD_PREPARE : 2;  /*!< This field to used to set world to enter, 2'b01 means WORLD0,
                                                     2'b10 means WORLD1                                                        */
            uint32_t            : 30;
    } bit;
  } Core_0_World_PREPARE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 configuration update register                                      */
    
    struct {
      __OM  uint32_t CORE_0_UPDATE : 32;        /*!< This field is used to update configuration completed, can write
                                                     any value,the hardware only checks the write operation
                                                     of this register and does not case about its value                        */
    } bit;
  } Core_0_World_UPDATE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 configuration cancel register                                      */
    
    struct {
      __OM  uint32_t CORE_0_WORLD_CANCEL : 32;  /*!< This field is used to cancel switch world configuration,if the
                                                     trigger address and update configuration complete,use this
                                                     register to cancel world switch, jujst need write any value,the
                                                     hardware only checks the write operation of this register
                                                     and does not case about its value                                         */
    } bit;
  } Core_0_World_Cancel;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 Iram0 world register                                               */
    
    struct {
      __IOM uint32_t CORE_0_WORLD_IRAM0 : 2;    /*!< this field is used to read current world of Iram0 bus                     */
            uint32_t            : 30;
    } bit;
  } Core_0_World_IRam0;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 dram0 and PIF world register                                       */
    
    struct {
      __IOM uint32_t CORE_0_WORLD_DRAM0_PIF : 2;/*!< this field is used to read current world of Dram0 bus and PIF
                                                     bus                                                                       */
            uint32_t            : 30;
    } bit;
  } Core_0_World_DRam0_PIF;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 world status register                                              */
    
    struct {
      __IM  uint32_t CORE_0_WORLD_PHASE : 1;    /*!< This bit indicates whether is preparing to switch to WORLD1,
                                                     1 means value.                                                            */
            uint32_t            : 31;
    } bit;
  } Core_0_World_Phase;
  __IM  uint32_t  RESERVED3[9];
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 NMI mask enable register                                           */
    
    struct {
      __OM  uint32_t CORE_0_NMI_MASK_ENABLE : 32;/*!< this field is used to set NMI mask,it can write any value,when
                                                     write this register,the hardware start masking NMI interrupt              */
    } bit;
  } Core_0_NMI_MASK_ENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 NMI mask trigger address register                                  */
    
    struct {
      __IOM uint32_t CORE_0_NMI_MASK_TRIGGER_ADDR : 32;/*!< this field to used to set trigger address, when CPU executes
                                                     to this address,NMI mask automatically fails                              */
    } bit;
  } Core_0_NMI_MASK_TRIGGER_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 NMI mask disable register                                          */
    
    struct {
      __OM  uint32_t CORE_0_NMI_MASK_DISABLE : 32;/*!< this field is used to disable NMI mask,it will not take effect
                                                     immediately,only when the CPU executes to the trigger address
                                                     will it start to cancel NMI mask                                          */
    } bit;
  } Core_0_NMI_MASK_DISABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 NMI mask disable register                                          */
    
    struct {
      __OM  uint32_t CORE_0_NMI_MASK_CANCEL : 32;/*!< this field is used to cancel NMI mask disable function.                  */
    } bit;
  } Core_0_NMI_MASK_CANCLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 NMI mask register                                                  */
    
    struct {
      __IOM uint32_t CORE_0_NMI_MASK : 1;       /*!< this bit is used to mask NMI interrupt,it can directly mask
                                                     NMI interrupt                                                             */
            uint32_t            : 31;
    } bit;
  } Core_0_NMI_MASK;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 NMI mask phase register                                            */
    
    struct {
      __IM  uint32_t CORE_0_NMI_MASK_PHASE : 1; /*!< this bit is used to indicates whether the NMI interrupt is being
                                                     masked, 1 means NMI interrupt is being masked                             */
            uint32_t            : 31;
    } bit;
  } Core_0_NMI_MASK_PHASE;
  __IM  uint32_t  RESERVED4[154];
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 1 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_1_ADDR : 32;  /*!< Core_1 Entry 1 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_1_ENTRY_1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 2 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_2_ADDR : 32;  /*!< Core_1 Entry 2 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_1_ENTRY_2_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 3 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_3_ADDR : 32;  /*!< Core_1 Entry 3 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_1_ENTRY_3_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 4 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_4_ADDR : 32;  /*!< Core_1 Entry 4 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_1_ENTRY_4_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 5 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_5_ADDR : 32;  /*!< Core_1 Entry 5 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_1_ENTRY_5_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 6 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_6_ADDR : 32;  /*!< Core_1 Entry 6 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_1_ENTRY_6_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 7 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_7_ADDR : 32;  /*!< Core_1 Entry 7 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_1_ENTRY_7_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 8 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_8_ADDR : 32;  /*!< Core_1 Entry 8 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_1_ENTRY_8_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 9 address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_9_ADDR : 32;  /*!< Core_1 Entry 9 address from WORLD1 to WORLD0                              */
    } bit;
  } Core_1_ENTRY_9_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 10 address configuration Register                            */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_10_ADDR : 32; /*!< Core_1 Entry 10 address from WORLD1 to WORLD0                             */
    } bit;
  } Core_1_ENTRY_10_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 11 address configuration Register                            */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_11_ADDR : 32; /*!< Core_1 Entry 11 address from WORLD1 to WORLD0                             */
    } bit;
  } Core_1_ENTRY_11_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 12 address configuration Register                            */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_12_ADDR : 32; /*!< Core_1 Entry 12 address from WORLD1 to WORLD0                             */
    } bit;
  } Core_1_ENTRY_12_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry 13 address configuration Register                            */
    
    struct {
      __IOM uint32_t CORE_1_ENTRY_13_ADDR : 32; /*!< Core_1 Entry 13 address from WORLD1 to WORLD0                             */
    } bit;
  } Core_1_ENTRY_13_ADDR;
  __IM  uint32_t  RESERVED5[18];
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Entry check configuration Register                                 */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CORE_1_ENTRY_CHECK : 13;   /*!< This filed is used to enable entry address check                          */
            uint32_t            : 18;
    } bit;
  } Core_1_ENTRY_CHECK;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 1                                */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_1 : 1;   /*!< This bit is used to confirm world before enter entry 1                    */
      __IOM uint32_t CORE_1_FROM_ENTRY_1 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     1                                                                         */
      __IOM uint32_t CORE_1_CURRENT_1 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 1                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE1;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 2                                */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_2 : 1;   /*!< This bit is used to confirm world before enter entry 2                    */
      __IOM uint32_t CORE_1_FROM_ENTRY_2 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     2                                                                         */
      __IOM uint32_t CORE_1_CURRENT_2 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 2                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE2;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 3                                */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_3 : 1;   /*!< This bit is used to confirm world before enter entry 3                    */
      __IOM uint32_t CORE_1_FROM_ENTRY_3 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     3                                                                         */
      __IOM uint32_t CORE_1_CURRENT_3 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 3                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE3;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 4                                */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_4 : 1;   /*!< This bit is used to confirm world before enter entry 4                    */
      __IOM uint32_t CORE_1_FROM_ENTRY_4 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     4                                                                         */
      __IOM uint32_t CORE_1_CURRENT_4 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 4                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE4;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 5                                */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_5 : 1;   /*!< This bit is used to confirm world before enter entry 5                    */
      __IOM uint32_t CORE_1_FROM_ENTRY_5 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     5                                                                         */
      __IOM uint32_t CORE_1_CURRENT_5 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 5                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE5;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 6                                */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_6 : 1;   /*!< This bit is used to confirm world before enter entry 6                    */
      __IOM uint32_t CORE_1_FROM_ENTRY_6 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     6                                                                         */
      __IOM uint32_t CORE_1_CURRENT_6 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 6                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE6;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 7                                */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_7 : 1;   /*!< This bit is used to confirm world before enter entry 7                    */
      __IOM uint32_t CORE_1_FROM_ENTRY_7 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     7                                                                         */
      __IOM uint32_t CORE_1_CURRENT_7 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 7                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE7;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 8                                */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_8 : 1;   /*!< This bit is used to confirm world before enter entry 8                    */
      __IOM uint32_t CORE_1_FROM_ENTRY_8 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     8                                                                         */
      __IOM uint32_t CORE_1_CURRENT_8 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 8                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE8;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 9                                */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_9 : 1;   /*!< This bit is used to confirm world before enter entry 9                    */
      __IOM uint32_t CORE_1_FROM_ENTRY_9 : 4;   /*!< This filed is used to confirm in which entry before enter entry
                                                     9                                                                         */
      __IOM uint32_t CORE_1_CURRENT_9 : 1;      /*!< This bit is used to confirm whether the current state is in
                                                     entry 9                                                                   */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE9;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 10                               */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_10 : 1;  /*!< This bit is used to confirm world before enter entry 10                   */
      __IOM uint32_t CORE_1_FROM_ENTRY_10 : 4;  /*!< This filed is used to confirm in which entry before enter entry
                                                     10                                                                        */
      __IOM uint32_t CORE_1_CURRENT_10 : 1;     /*!< This bit is used to confirm whether the current state is in
                                                     entry 10                                                                  */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE10;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 11                               */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_11 : 1;  /*!< This bit is used to confirm world before enter entry 11                   */
      __IOM uint32_t CORE_1_FROM_ENTRY_11 : 4;  /*!< This filed is used to confirm in which entry before enter entry
                                                     11                                                                        */
      __IOM uint32_t CORE_1_CURRENT_11 : 1;     /*!< This bit is used to confirm whether the current state is in
                                                     entry 11                                                                  */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE11;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 12                               */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_12 : 1;  /*!< This bit is used to confirm world before enter entry 12                   */
      __IOM uint32_t CORE_1_FROM_ENTRY_12 : 4;  /*!< This filed is used to confirm in which entry before enter entry
                                                     12                                                                        */
      __IOM uint32_t CORE_1_CURRENT_12 : 1;     /*!< This bit is used to confirm whether the current state is in
                                                     entry 12                                                                  */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE12;
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of world switch of entry 13                               */
    
    struct {
      __IOM uint32_t CORE_1_FROM_WORLD_13 : 1;  /*!< This bit is used to confirm world before enter entry 13                   */
      __IOM uint32_t CORE_1_FROM_ENTRY_13 : 4;  /*!< This filed is used to confirm in which entry before enter entry
                                                     13                                                                        */
      __IOM uint32_t CORE_1_CURRENT_13 : 1;     /*!< This bit is used to confirm whether the current state is in
                                                     entry 13                                                                  */
            uint32_t            : 26;
    } bit;
  } Core_1_STATUSTABLE13;
  __IM  uint32_t  RESERVED6[18];
  
  union {
    __IOM uint32_t reg;                         /*!< Status register of statustable current                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t CORE_1_STATUSTABLE_CURRENT : 13;/*!< This field is used to quickly read and rewrite the current field
                                                     of all STATUSTABLE registers,for example,bit 1 represents
                                                     the current field of STATUSTABLE1                                         */
            uint32_t            : 18;
    } bit;
  } Core_1_STATUSTABLE_CURRENT;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear writer_buffer write address configuration register                  */
    
    struct {
      __IOM uint32_t CORE_1_MESSAGE_ADDR : 32;  /*!< This field is used to set address that need to write when enter
                                                     WORLD0                                                                    */
    } bit;
  } Core_1_MESSAGE_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear writer_buffer write number configuration register                   */
    
    struct {
      __IOM uint32_t CORE_1_MESSAGE_MAX : 4;    /*!< This filed is used to set the max value of clear write_buffer             */
            uint32_t            : 28;
    } bit;
  } Core_1_MESSAGE_MAX;
  
  union {
    __IOM uint32_t reg;                         /*!< Clear writer_buffer status register                                       */
    
    struct {
      __IM  uint32_t CORE_1_MESSAGE_MATCH : 1;  /*!< This bit indicates whether the check is successful                        */
      __IM  uint32_t CORE_1_MESSAGE_EXPECT : 4; /*!< This field indicates the data to be written next time                     */
      __IM  uint32_t CORE_1_MESSAGE_DATAPHASE : 1;/*!< If this bit is 1, it means that is checking clear write_buffer
                                                     operation, and is checking data                                           */
      __IM  uint32_t CORE_1_MESSAGE_ADDRESSPHASE : 1;/*!< If this bit is 1, it means that is checking clear write_buffer
                                                     operation, and is checking address.                                       */
            uint32_t            : 25;
    } bit;
  } Core_1_MESSAGE_PHASE;
  __IM  uint32_t  RESERVED7[13];
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 trigger address configuration Register                             */
    
    struct {
      __IOM uint32_t CORE_1_WORLD_TRIGGER_ADDR : 32;/*!< This field is used to configure the entry address from WORLD0
                                                     to WORLD1,when the CPU executes to this address,switch
                                                     to WORLD1                                                                 */
    } bit;
  } Core_1_World_TRIGGER_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 prepare world configuration Register                               */
    
    struct {
      __IOM uint32_t CORE_1_WORLD_PREPARE : 2;  /*!< This field to used to set world to enter,2'b01 means WORLD0,
                                                     2'b10 means WORLD1                                                        */
            uint32_t            : 30;
    } bit;
  } Core_1_World_PREPARE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 configuration update register                                      */
    
    struct {
      __OM  uint32_t CORE_1_UPDATE : 32;        /*!< This field is used to update configuration completed, can write
                                                     any value,the hardware only checks the write operation
                                                     of this register and does not case about its value                        */
    } bit;
  } Core_1_World_UPDATE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 configuration cancel register                                      */
    
    struct {
      __OM  uint32_t CORE_1_WORLD_CANCEL : 32;  /*!< This field is used to cancel switch world configuration,if the
                                                     trigger address and update configuration complete,can use
                                                     this register to cancel world switch. can write any value,
                                                     the hardware only checks the write operation of this register
                                                     and does not case about its value                                         */
    } bit;
  } Core_1_World_Cancel;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 Iram0 world register                                               */
    
    struct {
      __IOM uint32_t CORE_1_WORLD_IRAM0 : 2;    /*!< this field is used to read current world of Iram0 bus                     */
            uint32_t            : 30;
    } bit;
  } Core_1_World_IRam0;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 dram0 and PIF world register                                       */
    
    struct {
      __IOM uint32_t CORE_1_WORLD_DRAM0_PIF : 2;/*!< this field is used to read current world of Dram0 bus and PIF
                                                     bus                                                                       */
            uint32_t            : 30;
    } bit;
  } Core_1_World_DRam0_PIF;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_0 world status register                                              */
    
    struct {
      __IM  uint32_t CORE_1_WORLD_PHASE : 1;    /*!< This bit indicates whether is preparing to switch to WORLD1,1
                                                     means value.                                                              */
            uint32_t            : 31;
    } bit;
  } Core_1_World_Phase;
  __IM  uint32_t  RESERVED8[9];
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 NMI mask enable register                                           */
    
    struct {
      __OM  uint32_t CORE_1_NMI_MASK_ENABLE : 32;/*!< this field is used to set NMI mask, it can write any value,
                                                     when write this register,the hardware start masking NMI
                                                     interrupt                                                                 */
    } bit;
  } Core_1_NMI_MASK_ENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 NMI mask trigger addr register                                     */
    
    struct {
      __IOM uint32_t CORE_1_NMI_MASK_TRIGGER_ADDR : 32;/*!< this field to used to set trigger address                          */
    } bit;
  } Core_1_NMI_MASK_TRIGGER_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 NMI mask disable register                                          */
    
    struct {
      __OM  uint32_t CORE_1_NMI_MASK_DISABLE : 32;/*!< this field is used to disable NMI mask, it will not take effect
                                                     immediately,only when the CPU executes to the trigger address
                                                     will it start to cancel NMI mask                                          */
    } bit;
  } Core_1_NMI_MASK_DISABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 NMI mask disable register                                          */
    
    struct {
      __OM  uint32_t CORE_1_NMI_MASK_CANCEL : 32;/*!< this field is used to cancel NMI mask disable function.                  */
    } bit;
  } Core_1_NMI_MASK_CANCLE;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 NMI mask register                                                  */
    
    struct {
      __IOM uint32_t CORE_1_NMI_MASK : 1;       /*!< this bit is used to mask NMI interrupt,it can directly mask
                                                     NMI interrupt                                                             */
            uint32_t            : 31;
    } bit;
  } Core_1_NMI_MASK;
  
  union {
    __IOM uint32_t reg;                         /*!< Core_1 NMI mask phase register                                            */
    
    struct {
      __IM  uint32_t CORE_1_NMI_MASK_PHASE : 1; /*!< this bit is used to indicates whether the NMI interrupt is being
                                                     masked, 1 means NMI interrupt is being masked                             */
            uint32_t            : 31;
    } bit;
  } Core_1_NMI_MASK_PHASE;
} WCL_Type;                                     /*!< Size = 1432 (0x598)                                                       */



/* =========================================================================================================================== */
/* ================                                          XTS_AES                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief XTS-AES-128 Flash Encryption (XTS_AES)
  */

typedef struct {                                /*!< XTS_AES Structure                                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 0                                                      */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_0;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 1                                                      */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_1;
  __IM  uint32_t  RESERVED1[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 2                                                      */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_2;
  __IM  uint32_t  RESERVED2[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 3                                                      */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_3;
  __IM  uint32_t  RESERVED3[3];
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Plaintext register 4                                                      */
      
      struct {
        __IOM uint32_t PLAIN    : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
      } bit;
    } PLAIN_4;
    
    union {
      __IOM uint32_t reg;                       /*!< XTS-AES line-size register                                                */
      
      struct {
        __IOM uint32_t LINESIZE : 1;            /*!< Configures the data size of one encryption.                               */
              uint32_t          : 31;
      } bit;
    } LINESIZE;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< XTS-AES destination register                                              */
    
    struct {
      __IOM uint32_t DESTINATION : 1;           /*!< Configures the type of the external memory. Currently, it must
                                                     be set to 0, as the Manual Encryption block only supports
                                                     flash encryption. Errors may occurs if users write 1. 0:flash.
                                                     1: external RAM.                                                          */
            uint32_t            : 31;
    } bit;
  } DESTINATION;
  
  union {
    __IOM uint32_t reg;                         /*!< physical address                                                          */
    
    struct {
      __IOM uint32_t PHYSICAL_ADDRESS : 30;     /*!< Those bits stores the physical address. If linesize is 16-byte,
                                                     the physical address should be aligned of 16 bytes. If
                                                     linesize is 32-byte, the physical address should be aligned
                                                     of 32 bytes. If linesize is 64-byte, the physical address
                                                     should be aligned of 64 bytes.                                            */
            uint32_t            : 2;
    } bit;
  } PHYSICAL_ADDRESS;
  
  union {
    __IOM uint32_t reg;                         /*!< XTS-AES trigger register                                                  */
    
    struct {
      __OM  uint32_t TRIGGER    : 1;            /*!< Write 1 to activate manual encryption.                                    */
            uint32_t            : 31;
    } bit;
  } TRIGGER;
  
  union {
    union {
      __IOM uint32_t reg;                       /*!< Plaintext register 5                                                      */
      
      struct {
        __IOM uint32_t PLAIN    : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
      } bit;
    } PLAIN_5;
    
    union {
      __IOM uint32_t reg;                       /*!< XTS-AES release control register                                          */
      
      struct {
        __OM  uint32_t RELEASE  : 1;            /*!< Write 1 to grant SPI1 access to encrypted result.                         */
              uint32_t          : 31;
      } bit;
    } RELEASE;
  };
  
  union {
    __IOM uint32_t reg;                         /*!< XTS-AES destroy control register                                          */
    
    struct {
      __OM  uint32_t DESTROY    : 1;            /*!< Write 1 to destroy encrypted result.                                      */
            uint32_t            : 31;
    } bit;
  } DESTROY;
  
  union {
    __IOM uint32_t reg;                         /*!< XTS-AES status register                                                   */
    
    struct {
      __IM  uint32_t STATE      : 2;            /*!< Those bits indicates the status of the Manual Encryption block.
                                                     0X0 (XTS_AES_IDLE): idle. 0X1 (XTS_AES_BUSY): busy with
                                                     encryption. 0X2 (XTS_AES_DONE): encryption is completed,
                                                     but the encrypted result is not accessible to SPI. 0X3
                                                     (XTS_AES_AVAILABLE) encrypted result is accessible and
                                                     available to SPI.                                                         */
            uint32_t            : 30;
    } bit;
  } STATE;
  
  union {
    __IOM uint32_t reg;                         /*!< XTS-AES version control register                                          */
    
    struct {
      __IOM uint32_t DATE       : 30;           /*!< Manual Encryption block version information.                              */
            uint32_t            : 2;
    } bit;
  } DATE;
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 6                                                      */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_6;
  __IM  uint32_t  RESERVED4[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 7                                                      */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_7;
  __IM  uint32_t  RESERVED5[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 8                                                      */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_8;
  __IM  uint32_t  RESERVED6[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 9                                                      */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_9;
  __IM  uint32_t  RESERVED7[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 10                                                     */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_10;
  __IM  uint32_t  RESERVED8[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 11                                                     */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_11;
  __IM  uint32_t  RESERVED9[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 12                                                     */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_12;
  __IM  uint32_t  RESERVED10[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 13                                                     */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_13;
  __IM  uint32_t  RESERVED11[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 14                                                     */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_14;
  __IM  uint32_t  RESERVED12[3];
  
  union {
    __IOM uint32_t reg;                         /*!< Plaintext register 15                                                     */
    
    struct {
      __IOM uint32_t PLAIN      : 32;           /*!< Stores the nth 32-bit piece of plaintext.                                 */
    } bit;
  } PLAIN_15;
} XTS_AES_Type;                                 /*!< Size = 244 (0xf4)                                                         */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define AES_BASE                    0x6003A000UL
#define APB_CTRL_BASE               0x60026000UL
#define APB_SARADC_BASE             0x60040000UL
#define BB_BASE                     0x6001D000UL
#define ASSIST_DEBUG_BASE           0x600CE000UL
#define DMA_BASE                    0x6003F000UL
#define DS_BASE                     0x6003D000UL
#define EFUSE_BASE                  0x60007000UL
#define EXTMEM_BASE                 0x600C4000UL
#define GPIO_BASE                   0x60004000UL
#define GPIO_SD_BASE                0x60004F00UL
#define HMAC_BASE                   0x6003E000UL
#define I2C0_BASE                   0x60013000UL
#define I2C1_BASE                   0x60027000UL
#define I2S0_BASE                   0x6000F000UL
#define I2S1_BASE                   0x6002D000UL
#define INTERRUPT_CORE0_BASE        0x600C2000UL
#define INTERRUPT_CORE1_BASE        0x600C2000UL
#define IO_MUX_BASE                 0x60009000UL
#define LCD_CAM_BASE                0x60041000UL
#define LEDC_BASE                   0x60019000UL
#define PCNT_BASE                   0x60017000UL
#define PERI_BACKUP_BASE            0x6002A000UL
#define MCPWM0_BASE                 0x6001E000UL
#define MCPWM1_BASE                 0x6002C000UL
#define RMT_BASE                    0x60016000UL
#define RNG_BASE                    0x60034F6CUL
#define RSA_BASE                    0x6003C000UL
#define RTC_CNTL_BASE               0x60008000UL
#define RTC_I2C_BASE                0x60008C00UL
#define RTC_IO_BASE                 0x60008400UL
#define SDHOST_BASE                 0x60028000UL
#define SENS_BASE                   0x60008800UL
#define SENSITIVE_BASE              0x600C1000UL
#define SHA_BASE                    0x6003B000UL
#define SPI0_BASE                   0x60003000UL
#define SPI1_BASE                   0x60002000UL
#define SPI2_BASE                   0x60024000UL
#define SPI3_BASE                   0x60025000UL
#define SYSTEM_BASE                 0x600C0000UL
#define SYSTIMER_BASE               0x60023000UL
#define TIMG0_BASE                  0x6001F000UL
#define TIMG1_BASE                  0x60020000UL
#define TWAI0_BASE                  0x6002B000UL
#define UART0_BASE                  0x60000000UL
#define UART1_BASE                  0x60010000UL
#define UART2_BASE                  0x6002E000UL
#define UHCI0_BASE                  0x60014000UL
#define UHCI1_BASE                  0x6000C000UL
#define USB0_BASE                   0x60080000UL
#define USB_DEVICE_BASE             0x60038000UL
#define USB_WRAP_BASE               0x60039000UL
#define WCL_BASE                    0x600D0000UL
#define XTS_AES_BASE                0x600CC000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define AES                         ((AES_Type*)               AES_BASE)
#define APB_CTRL                    ((APB_CTRL_Type*)          APB_CTRL_BASE)
#define APB_SARADC                  ((APB_SARADC_Type*)        APB_SARADC_BASE)
#define BB                          ((BB_Type*)                BB_BASE)
#define ASSIST_DEBUG                ((ASSIST_DEBUG_Type*)      ASSIST_DEBUG_BASE)
#define DMA                         ((DMA_Type*)               DMA_BASE)
#define DS                          ((DS_Type*)                DS_BASE)
#define EFUSE                       ((EFUSE_Type*)             EFUSE_BASE)
#define EXTMEM                      ((EXTMEM_Type*)            EXTMEM_BASE)
#define GPIO                        ((GPIO_Type*)              GPIO_BASE)
#define GPIO_SD                     ((GPIO_SD_Type*)           GPIO_SD_BASE)
#define HMAC                        ((HMAC_Type*)              HMAC_BASE)
#define I2C0                        ((I2C0_Type*)              I2C0_BASE)
#define I2C1                        ((I2C0_Type*)              I2C1_BASE)
#define I2S0                        ((I2S0_Type*)              I2S0_BASE)
#define I2S1                        ((I2S1_Type*)              I2S1_BASE)
#define INTERRUPT_CORE0             ((INTERRUPT_CORE0_Type*)   INTERRUPT_CORE0_BASE)
#define INTERRUPT_CORE1             ((INTERRUPT_CORE1_Type*)   INTERRUPT_CORE1_BASE)
#define IO_MUX                      ((IO_MUX_Type*)            IO_MUX_BASE)
#define LCD_CAM                     ((LCD_CAM_Type*)           LCD_CAM_BASE)
#define LEDC                        ((LEDC_Type*)              LEDC_BASE)
#define PCNT                        ((PCNT_Type*)              PCNT_BASE)
#define PERI_BACKUP                 ((PERI_BACKUP_Type*)       PERI_BACKUP_BASE)
#define MCPWM0                      ((MCPWM0_Type*)            MCPWM0_BASE)
#define MCPWM1                      ((MCPWM0_Type*)            MCPWM1_BASE)
#define RMT                         ((RMT_Type*)               RMT_BASE)
#define RNG                         ((RNG_Type*)               RNG_BASE)
#define RSA                         ((RSA_Type*)               RSA_BASE)
#define RTC_CNTL                    ((RTC_CNTL_Type*)          RTC_CNTL_BASE)
#define RTC_I2C                     ((RTC_I2C_Type*)           RTC_I2C_BASE)
#define RTC_IO                      ((RTC_IO_Type*)            RTC_IO_BASE)
#define SDHOST                      ((SDHOST_Type*)            SDHOST_BASE)
#define SENS                        ((SENS_Type*)              SENS_BASE)
#define SENSITIVE                   ((SENSITIVE_Type*)         SENSITIVE_BASE)
#define SHA                         ((SHA_Type*)               SHA_BASE)
#define SPI0                        ((SPI0_Type*)              SPI0_BASE)
#define SPI1                        ((SPI1_Type*)              SPI1_BASE)
#define SPI2                        ((SPI2_Type*)              SPI2_BASE)
#define SPI3                        ((SPI2_Type*)              SPI3_BASE)
#define SYSTEM                      ((SYSTEM_Type*)            SYSTEM_BASE)
#define SYSTIMER                    ((SYSTIMER_Type*)          SYSTIMER_BASE)
#define TIMG0                       ((TIMG0_Type*)             TIMG0_BASE)
#define TIMG1                       ((TIMG0_Type*)             TIMG1_BASE)
#define TWAI0                       ((TWAI0_Type*)             TWAI0_BASE)
#define UART0                       ((UART0_Type*)             UART0_BASE)
#define UART1                       ((UART0_Type*)             UART1_BASE)
#define UART2                       ((UART0_Type*)             UART2_BASE)
#define UHCI0                       ((UHCI0_Type*)             UHCI0_BASE)
#define UHCI1                       ((UHCI0_Type*)             UHCI1_BASE)
#define USB0                        ((USB0_Type*)              USB0_BASE)
#define USB_DEVICE                  ((USB_DEVICE_Type*)        USB_DEVICE_BASE)
#define USB_WRAP                    ((USB_WRAP_Type*)          USB_WRAP_BASE)
#define WCL                         ((WCL_Type*)               WCL_BASE)
#define XTS_AES                     ((XTS_AES_Type*)           XTS_AES_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */

#ifdef __cplusplus
}
#endif

#endif /* ESP32_S3_H */
